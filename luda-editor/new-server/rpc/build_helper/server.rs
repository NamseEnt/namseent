use crate::*;
use build_helper::*;
use quote::quote;

pub fn generate_code(rpc: &Rpc) {
    generate_api_files(rpc);
    generate_api_wire_up_file(rpc);
}

fn server_src_path() -> &'static std::path::Path {
    std::path::Path::new("../server/src")
}

fn generate_api_files(rpc: &Rpc) {
    let api_path = server_src_path().join("api");
    let mut api_mod_rs_lines = rpc
        .services
        .iter()
        .map(|service| format!("pub mod {};\n", service.snake_case_name,))
        .collect::<Vec<String>>();
    api_mod_rs_lines.sort();
    write_if_changed(
        api_path.join("mod.rs"),
        "//! This is Generated by rpc build.rs\n\n".to_string() + &api_mod_rs_lines.join(""),
    );

    for service in &rpc.services {
        let service_snake_name = &service.snake_case_name;
        let service_path = api_path.join(service_snake_name.to_string());
        if !service_path.exists() {
            std::fs::create_dir_all(&service_path).unwrap();
        }

        let service_mod_rs_lines = {
            let mut modules = service
                .apis
                .iter()
                .map(|api| format!("{}", api.name))
                .chain(["common".to_string()])
                .collect::<Vec<String>>();
            modules.sort();

            modules
                .into_iter()
                .map(|x| {
                    if x == "common" {
                        "mod common;\n".to_string()
                    } else {
                        format!("pub mod {};\n", x)
                    }
                })
                .collect::<Vec<String>>()
                .join("")
                + "\n#[allow(unused_imports)]\npub use common::*;\n"
        };
        write_if_changed(
            service_path.join("mod.rs"),
            "//! This is Generated by rpc build.rs\n\n".to_string() + &service_mod_rs_lines,
        );

        let common_dir = service_path.join("common");
        if !common_dir.exists() {
            std::fs::create_dir_all(&common_dir).unwrap();
            std::fs::write(common_dir.join("mod.rs"), "").unwrap();
        }

        for api in &service.apis {
            let api_rs = service_path
                .join(format!("{}", api.name))
                .with_extension("rs");
            if api_rs.exists() || api_rs.with_extension("").exists() {
                continue;
            }
            let api_name = &api.name;
            write_if_changed(
                &api_rs,
                format!(
                    "use crate::*;
use database::schema::*;
use luda_rpc::{service_snake_name}::{api_name}::*;

pub async fn {api_name}(
    &ArchivedRequest {{ }}: &ArchivedRequest,
    db: &Database,
    session: Session,
) -> Result<Response> {{
    todo!()
}}
"
                ),
            );
        }
    }
}

fn generate_api_wire_up_file(rpc: &Rpc) {
    let handle_file_path = server_src_path().join("ws_handler/handle.rs");

    let mut api_index: u16 = 0;
    let api_matches = rpc.services.iter().map(|service| {
        let service_name = &service.snake_case_name;
        let apis = service.apis.iter().map(|api| {
            let api_name = &api.name;
            let this_api_index = api_index;
            api_index += 1;
            quote! {
                #this_api_index => {
                    let Ok(request) = rkyv::validation::validators::check_archived_root::<
                        luda_rpc::#service_name::#api_name::Request,
                    >(in_payload) else {
                        return Err(anyhow::anyhow!("Failed to validate packet"));
                    };
                    match api::#service_name::#api_name::#api_name(request, db, session)
                        .await
                    {
                        Ok(response) => Ok(HandleResult::Response(
                            serializer::serialize(&response)?
                        )),
                        Err(error) => {
                            Ok(HandleResult::Error(match error
                                .downcast_ref::<luda_rpc::#service_name::#api_name::Error>(
                            ) {
                                Some(error) => serializer::serialize(error),
                                None => serializer::serialize(
                                    &luda_rpc::#service_name::#api_name::Error::InternalServerError {
                                        err: error.to_string(),
                                    },
                                ),
                            }?))
                        }
                    }
                }
            }
        });
        quote! {
            #(#apis)*
        }
    });

    let handle_fn = quote! {
        use crate::*;
        use database::Database;

        pub enum HandleResult {
            Response(Vec<u8>),
            Error(Vec<u8>),
        }

        pub async fn handle(
            api_index: u16,
            in_payload: &[u8],
            db: &Database,
            session: Session,
        ) -> Result<HandleResult> {
            match api_index {
                #(#api_matches)*
                _ => Err(anyhow::anyhow!("Unknown packet type: {}", api_index)),
            }
        }
    };

    write_fmt(handle_file_path, handle_fn);
}
