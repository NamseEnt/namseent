use crate::*;
use build_helper::{write_fmt, write_if_changed};
use quote::quote;
use syn::spanned::Spanned;

pub fn generate_code(rpc: &Rpc) {
    generate_rpc_files(rpc);
}

fn client_src_path() -> &'static std::path::Path {
    std::path::Path::new("../../new-client/src")
}

fn generate_rpc_files(rpc: &Rpc) {
    let mut generated_file_paths = vec![];

    let rpc_path = client_src_path().join("rpc");
    std::fs::create_dir_all(&rpc_path).unwrap();

    let mut rpc_mod_rs_lines = rpc
        .services
        .iter()
        .map(|service| format!("pub mod {};\n", service.snake_case_name,))
        .collect::<Vec<String>>();
    rpc_mod_rs_lines.sort();

    write_if_changed(
        rpc_path.join("mod.rs"),
        "#![allow(warnings, unused)]
//! This is Generated by rpc build.rs\n\n"
            .to_string()
            + &rpc_mod_rs_lines.join(""),
    );
    generated_file_paths.push(rpc_path.join("mod.rs"));

    let mut api_index: u16 = 0;

    for service in &rpc.services {
        let service_snake_name = &service.snake_case_name;
        let service_path = rpc_path.join(service_snake_name.to_string());

        std::fs::create_dir_all(&service_path).unwrap();

        let mut service_mod_rs_lines = service
            .apis
            .iter()
            .map(|api| format!("pub mod {};\n", api.name))
            .collect::<Vec<String>>();
        service_mod_rs_lines.sort();
        write_if_changed(
            service_path.join("mod.rs"),
            "//! This is Generated by rpc build.rs\n\n".to_string()
                + &service_mod_rs_lines.join(""),
        );
        generated_file_paths.push(service_path.join("mod.rs"));

        for api in &service.apis {
            let api_path = service_path.join(format!("{}.rs", api.name));
            generated_file_paths.push(api_path.clone());

            let api_name = &api.name;
            let api_name_render = syn::Ident::new(&format!("{api_name}_render"), api.name.span());

            let item_struct = match &api.request {
                syn::Item::Enum(_item_enum) => {
                    todo!()
                }
                syn::Item::Struct(item_struct) => item_struct,
                _ => panic!("Request must be a struct or enum"),
            };

            let make_fn_name = syn::Ident::new(&format!("make_{}_fn", api.name), api.name.span());

            let RefFielder {
                generics,
                generics_without_bounds,
                ..
            } = RefFielder::new(&item_struct.fields);

            let ref_request_name = quote! { RefRequest #generics_without_bounds };

            let api_generic = {
                let mut generics = generics.clone();
                add_lifetime_a_if_not_exists(&mut generics);

                for type_name in ["Deps", "Artifacts", "RequestFn"] {
                    generics
                        .params
                        .push(syn::GenericParam::Type(syn::TypeParam::from(
                            syn::Ident::new(type_name, api_name.span()),
                        )));
                }
                generics
            };

            let api_render_generic = api_generic.clone();

            let server_connection_api_generic = {
                let mut generics = generics.clone();
                add_lifetime_a_if_not_exists(&mut generics);
                generics
            };

            let make_fn_generic = {
                let mut generics = generics.clone();
                add_lifetime_a_if_not_exists(&mut generics);
                for type_name in ["MakeRequestFn", "ResponseFn", "Artifacts"] {
                    generics
                        .params
                        .push(syn::GenericParam::Type(syn::TypeParam::from(
                            syn::Ident::new(type_name, api_name.span()),
                        )));
                }
                generics
            };

            let content = quote! {
                //! This is Generated by rpc build.rs
                use crate::{*, network::*};
                pub use luda_rpc::#service_snake_name::#api_name::*;
                use std::sync::{
                    atomic::{AtomicBool, Ordering},
                    Arc,
                };

                pub fn #api_name #api_generic (
                    ctx: &'a RenderCtx,
                    request: RequestFn,
                    dependencies: Deps,
                ) -> Sig<'a, Option<Result<(Response, <Artifacts as Dependencies>::Owned), Error>>>
                where
                    Deps: TrackEqTuple,
                    Artifacts: Dependencies,
                    <Artifacts as Dependencies>::Owned: 'static + Send,
                    RequestFn: FnOnce(Deps) -> Option<(#ref_request_name, Artifacts)>,
                {
                    server_rpc(ctx, request, dependencies, #api_index)
                }

                pub fn #api_name_render #api_render_generic (
                    ctx: &'a RenderCtx,
                    request: RequestFn,
                    dependencies: Deps,
                    on_loading: impl FnOnce(),
                    on_err: impl FnOnce(&Error),
                    on_res: impl FnOnce(&(Response, <Artifacts as Dependencies>::Owned)),
                )
                where
                    Deps: TrackEqTuple,
                    Artifacts: Dependencies,
                    <Artifacts as Dependencies>::Owned: 'static + Send,
                    RequestFn: FnOnce(Deps) -> Option<(#ref_request_name, Artifacts)>,
                {
                    match #api_name(ctx, request, dependencies).as_ref() {
                        Some(result) => match result {
                            Ok(res) => on_res(res),
                            Err(err) => on_err(err),
                        },
                        None => on_loading(),
                    }
                }

                impl ServerConnection {
                    pub async fn #api_name #server_connection_api_generic (
                        &'a self,
                        request: #ref_request_name,
                    ) -> Result<Response, Error> {
                        self.request(
                            #api_index,
                            luda_rpc::rkyv::to_bytes::<_, 1024>(&request)
                                .unwrap()
                                .to_vec()
                        )
                        .await
                    }
                }

                pub fn #make_fn_name #make_fn_generic (
                    ctx: &'a RenderCtx,
                    make_request: MakeRequestFn,
                    response_fn: ResponseFn,
                ) -> (impl FnOnce() + 'a, bool)
                where
                    MakeRequestFn: FnOnce() -> Option<(#ref_request_name, Artifacts)> + 'a,
                    ResponseFn: FnOnce(Result<(Response, <Artifacts as Dependencies>::Owned), Error>) + 'static + Send,
                    Artifacts: Dependencies,
                    <Artifacts as Dependencies>::Owned: 'static + Send,
                {
                    let on_progress = ctx.memo(|| Arc::new(AtomicBool::new(false)));
                    let ret_on_progress = on_progress.load(Ordering::Relaxed);

                    (
                        move || {
                            if on_progress.swap(true, Ordering::Relaxed) {
                                return;
                            }
                            let Some((request, artifacts)) = make_request() else {
                                on_progress.store(false, Ordering::Relaxed);
                                return;
                            };

                            let bytes = luda_rpc::rkyv::to_bytes::<_, 1024>(&request)
                                .unwrap()
                                .to_vec();

                            let owned_artifacts = artifacts.to_owned();

                            let on_progress = on_progress.clone_inner();
                            tokio::spawn(async move {
                                let result = server_connection().request(#api_index, bytes).await;

                                on_progress.store(false, Ordering::Relaxed);

                                response_fn(match result {
                                    Ok(res) => Ok((res, owned_artifacts)),
                                    Err(err) => Err(err),
                                });
                            });
                        },
                        ret_on_progress,
                    )
                }
            };
            write_fmt(api_path, content);

            api_index += 1;
        }
    }

    for entry in walkdir::WalkDir::new(&rpc_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
    {
        let path = entry.path();
        if !generated_file_paths.contains(&path.to_path_buf()) {
            std::fs::remove_file(path).unwrap();
        }
    }

    for entry in walkdir::WalkDir::new(&rpc_path)
        .contents_first(true)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_dir())
    {
        let has_child = walkdir::WalkDir::new(entry.path())
            .into_iter()
            .any(|_| true);

        if !has_child {
            std::fs::remove_dir(entry.path()).unwrap();
        }
    }
}

fn add_lifetime_a_if_not_exists(generics: &mut syn::Generics) {
    if !generics.lifetimes().any(|l| l.lifetime.ident == "a") {
        generics
            .params
            .push(syn::GenericParam::Lifetime(syn::LifetimeParam::new(
                syn::Lifetime::new("'a", generics.span()),
            )));
    }
}
