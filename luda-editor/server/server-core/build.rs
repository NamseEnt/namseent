use convert_case::{Case, Casing};
use rpc_parser::Rpc;
use std::{fs, path::PathBuf};

fn main() {
    let rpc_libe_file_path = "../../rpc/src/lib.rs";
    println!("cargo:rerun-if-changed={rpc_libe_file_path}");

    let rpc_lib_file = std::fs::read_to_string(rpc_libe_file_path).unwrap();

    let define_rpc_content = {
        let define_rpc_start = "define_rpc! {";
        let define_rpc_start_index =
            rpc_lib_file.find("define_rpc! {").unwrap() + define_rpc_start.len();

        let define_rpc_end = "}";
        let define_rpc_end_index = rpc_lib_file.rfind(define_rpc_end).unwrap();

        &rpc_lib_file[define_rpc_start_index..define_rpc_end_index]
    };

    let dont_edit_manually_warning =
        "// NOTE: Don't edit this file manually. It is generated by build.rs.\n\n";

    let rpc: Rpc = syn::parse_str(define_rpc_content).unwrap();

    let mut snake_cased_service_names = vec![];

    for service in rpc.services.iter() {
        let snake_cased_service_name = service.name.to_string().to_case(Case::Snake);
        snake_cased_service_names.push(snake_cased_service_name.clone());

        let api_dir_path = format!("src/apis/{snake_cased_service_name}");
        fs::create_dir_all(&api_dir_path).unwrap();

        let mut snake_cased_api_names = vec![];

        for api in service.apis.iter() {
            let snake_cased_api_name = api.name.to_string().to_case(Case::Snake);
            snake_cased_api_names.push(snake_cased_api_name.clone());

            let api_file_path = PathBuf::from(format!("{api_dir_path}/{snake_cased_api_name}.rs"));
            if !api_file_path.exists() {
                let api_file_content = format!(
                    "use crate::documents::*;
                    use super::common::*;
                    
                    pub async fn {snake_cased_api_name}(
                        session: Option<SessionDocument>,
                        req: rpc::{snake_cased_api_name}::Request,
                    ) -> rpc::{snake_cased_api_name}::Result {{
                        todo!()
                    }}"
                );

                fs::write(api_file_path, api_file_content).unwrap();
            }
        }

        let api_mod_file_path = format!("{api_dir_path}/mod.rs");
        let mod_file_content = dont_edit_manually_warning.to_string()
            + "mod shared;\n"
            + &snake_cased_api_names
                .iter()
                .map(|snake_cased_api_name| format!("mod {snake_cased_api_name};\n"))
                .collect::<Vec<_>>()
                .join("")
            + "\n"
            + &snake_cased_api_names
                .iter()
                .map(|snake_cased_api_name| {
                    format!("pub use {snake_cased_api_name}::{snake_cased_api_name};\n")
                })
                .collect::<Vec<_>>()
                .join("");
        fs::write(api_mod_file_path, mod_file_content).unwrap();

        let api_shared_dir_path = format!("{api_dir_path}/shared");
        let api_shared_file_path = format!("{api_shared_dir_path}/mod.rs");
        fs::create_dir_all(api_shared_dir_path).unwrap();
        fs::write(api_shared_file_path, "").unwrap();
    }

    let apis_mod_file_path = format!("src/apis/mod.rs");
    let mod_file_content = dont_edit_manually_warning.to_string()
        + &snake_cased_service_names
            .into_iter()
            .map(|snake_cased_service_name| format!("pub mod {snake_cased_service_name};\n"))
            .collect::<Vec<_>>()
            .join("")
        + &format!(
            "
            pub async fn handle_api(
                api_name: &str,
                session: Option<crate::documents::SessionDocument>,
                body: &[u8],
            ) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>> {{
                match api_name {{
                    {handle_api_matches}
                    _ => Err(\"Unknown api name\".into()),
                }}
            }}
        ",
            handle_api_matches = handle_api_matches(&rpc)
        );
    fs::write(apis_mod_file_path, mod_file_content).unwrap();

    std::process::Command::new("cargo")
        .arg("fmt")
        .output()
        .unwrap();
}

fn handle_api_matches(rpc: &Rpc) -> String {
    rpc.services.iter().flat_map(|service| {
        service.apis.iter().map(|api| {
            let snake_cased_service_name = service.name.to_string().to_case(Case::Snake);
            let snake_cased_api_name = api.name.to_string().to_case(Case::Snake);
            format!("\"{snake_cased_api_name}\" => {{
                let Ok(api_request) = serde_json::from_slice::<rpc::{snake_cased_api_name}::Request>(body)
                else {{
                    return Err(\"Fail to parse body\".into());
                }};
                let response = {snake_cased_service_name}::{snake_cased_api_name}(session, api_request).await;
                Ok(serde_json::to_vec(&response).unwrap())
            }},")
        })
    }).collect::<Vec<_>>().join("\n")
}
