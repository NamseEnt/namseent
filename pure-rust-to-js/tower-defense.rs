#![feature(prelude_import)]
#[macro_use]
extern crate std;
#[prelude_import]
use std::prelude::rust_2024::*;
mod camera_controller {
    use crate::game_state::mutate_game_state;
    use crate::*;
    struct KeyboardNav {
        up: bool,
        down: bool,
        left: bool,
        right: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for KeyboardNav {
        #[inline]
        fn clone(&self) -> KeyboardNav {
            let _: ::core::clone::AssertParamIsClone<bool>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for KeyboardNav {}
    #[automatically_derived]
    impl ::core::default::Default for KeyboardNav {
        #[inline]
        fn default() -> KeyboardNav {
            KeyboardNav {
                up: ::core::default::Default::default(),
                down: ::core::default::Default::default(),
                left: ::core::default::Default::default(),
                right: ::core::default::Default::default(),
            }
        }
    }
    impl bincode::Encode for KeyboardNav {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            bincode::Encode::encode(&self.up, encoder)?;
            bincode::Encode::encode(&self.down, encoder)?;
            bincode::Encode::encode(&self.left, encoder)?;
            bincode::Encode::encode(&self.right, encoder)?;
            Ok(())
        }
    }
    impl bincode::Decode<()> for KeyboardNav {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            Ok(Self {
                up: bincode::Decode::decode(decoder)?,
                down: bincode::Decode::decode(decoder)?,
                left: bincode::Decode::decode(decoder)?,
                right: bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl Serialize for KeyboardNav {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            buf.write_string("up");
            self.up.serialize_without_name(buf);
            buf.write_string("down");
            self.down.serialize_without_name(buf);
            buf.write_string("left");
            self.left.serialize_without_name(buf);
            buf.write_string("right");
            self.right.serialize_without_name(buf);
        }
    }
    impl Deserialize for KeyboardNav {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let field_name = buf.read_name("up")?;
            let up = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("down")?;
            let down = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("left")?;
            let left = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("right")?;
            let right = Deserialize::deserialize_without_name(buf)?;
            Ok(Self { up, down, left, right })
        }
    }
    pub struct CameraController;
    impl Component for CameraController {
        fn render(self, ctx: &RenderCtx) {
            let (keyboard_nav, set_keyboard_nav) = ctx.state(KeyboardNav::default);
            ctx.attach_event(move |event| match event {
                Event::KeyDown { event } => {
                    match event.code {
                        Code::KeyW => set_keyboard_nav.mutate(|nav| nav.up = true),
                        Code::KeyS => set_keyboard_nav.mutate(|nav| nav.down = true),
                        Code::KeyA => set_keyboard_nav.mutate(|nav| nav.left = true),
                        Code::KeyD => set_keyboard_nav.mutate(|nav| nav.right = true),
                        _ => {}
                    }
                }
                Event::KeyUp { event } => {
                    match event.code {
                        Code::KeyW => set_keyboard_nav.mutate(|nav| nav.up = false),
                        Code::KeyS => set_keyboard_nav.mutate(|nav| nav.down = false),
                        Code::KeyA => set_keyboard_nav.mutate(|nav| nav.left = false),
                        Code::KeyD => set_keyboard_nav.mutate(|nav| nav.right = false),
                        _ => {}
                    }
                }
                _ => {}
            });
            ctx.interval(
                "camera move",
                Duration::from_millis(16),
                move |real_dt| {
                    let nav = *keyboard_nav;
                    if nav.up || nav.down || nav.left || nav.right {
                        let speed_px_per_sec: f32 = 1024.0;
                        let dt_secs = real_dt.as_millis() as f32 / 1000.0;
                        let step = (speed_px_per_sec * dt_secs).max(0.0);
                        let mut dir_x: f32 = 0.0;
                        let mut dir_y: f32 = 0.0;
                        if nav.left {
                            dir_x -= 1.0;
                        }
                        if nav.right {
                            dir_x += 1.0;
                        }
                        if nav.up {
                            dir_y -= 1.0;
                        }
                        if nav.down {
                            dir_y += 1.0;
                        }
                        let len = (dir_x * dir_x + dir_y * dir_y).sqrt();
                        if len > 0.0 {
                            let nx = dir_x / len;
                            let ny = dir_y / len;
                            let dx = (nx * step).px();
                            let dy = (ny * step).px();
                            mutate_game_state(move |game_state| {
                                game_state.camera.move_by(Xy::new(dx, dy));
                            });
                        }
                    }
                },
            );
        }
    }
}
mod card {
    use crate::*;
    use rand::Rng;
    use std::fmt::Display;
    pub enum Suit {
        Spades,
        Hearts,
        Diamonds,
        Clubs,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Suit {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Suit::Spades => "Spades",
                    Suit::Hearts => "Hearts",
                    Suit::Diamonds => "Diamonds",
                    Suit::Clubs => "Clubs",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Suit {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Suit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Suit {
        #[inline]
        fn eq(&self, other: &Suit) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Suit {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Suit {
        #[inline]
        fn clone(&self) -> Suit {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Suit {}
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Suit {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Suit,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Suit {
        #[inline]
        fn cmp(&self, other: &Suit) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    impl bincode::Encode for Suit {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            match self {
                Self::Spades => {
                    bincode::Encode::encode(&0u32, encoder)?;
                }
                Self::Hearts => {
                    bincode::Encode::encode(&1u32, encoder)?;
                }
                Self::Diamonds => {
                    bincode::Encode::encode(&2u32, encoder)?;
                }
                Self::Clubs => {
                    bincode::Encode::encode(&3u32, encoder)?;
                }
            }
            Ok(())
        }
    }
    impl bincode::Decode<()> for Suit {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            let discriminant: u32 = bincode::Decode::decode(decoder)?;
            match discriminant {
                0u32 => Ok(Self::Spades),
                1u32 => Ok(Self::Hearts),
                2u32 => Ok(Self::Diamonds),
                3u32 => Ok(Self::Clubs),
                _ => {
                    Err(bincode::error::DecodeError::UnexpectedVariant {
                        type_name: core::any::type_name::<Self>(),
                        allowed: &bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 3u32,
                        },
                        found: discriminant,
                    })
                }
            }
        }
    }
    impl Serialize for Suit {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            match self {
                Self::Spades => {
                    buf.write_string("Spades");
                }
                Self::Hearts => {
                    buf.write_string("Hearts");
                }
                Self::Diamonds => {
                    buf.write_string("Diamonds");
                }
                Self::Clubs => {
                    buf.write_string("Clubs");
                }
            }
        }
    }
    impl Deserialize for Suit {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let variant_name = buf.read_string();
            match variant_name.as_ref() {
                "Spades" => Ok(Self::Spades),
                "Hearts" => Ok(Self::Hearts),
                "Diamonds" => Ok(Self::Diamonds),
                "Clubs" => Ok(Self::Clubs),
                _ => {
                    Err(DeserializeError::InvalidEnumVariant {
                        expected: std::any::type_name::<Self>().to_string(),
                        actual: variant_name,
                    })
                }
            }
        }
    }
    impl Display for Suit {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = match self {
                Suit::Spades => "♠",
                Suit::Hearts => "♥",
                Suit::Diamonds => "◆",
                Suit::Clubs => "♣",
            };
            f.write_fmt(format_args!("{0}", s))
        }
    }
    pub const SUITS: [Suit; 4] = [
        Suit::Spades,
        Suit::Hearts,
        Suit::Diamonds,
        Suit::Clubs,
    ];
    pub enum Rank {
        Seven,
        Eight,
        Nine,
        Ten,
        Jack,
        Queen,
        King,
        Ace,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Rank {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Rank::Seven => "Seven",
                    Rank::Eight => "Eight",
                    Rank::Nine => "Nine",
                    Rank::Ten => "Ten",
                    Rank::Jack => "Jack",
                    Rank::Queen => "Queen",
                    Rank::King => "King",
                    Rank::Ace => "Ace",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Rank {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Rank {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Rank {
        #[inline]
        fn eq(&self, other: &Rank) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Rank {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Rank {
        #[inline]
        fn clone(&self) -> Rank {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Rank {}
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Rank {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Rank,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Rank {
        #[inline]
        fn cmp(&self, other: &Rank) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    impl bincode::Encode for Rank {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            match self {
                Self::Seven => {
                    bincode::Encode::encode(&0u32, encoder)?;
                }
                Self::Eight => {
                    bincode::Encode::encode(&1u32, encoder)?;
                }
                Self::Nine => {
                    bincode::Encode::encode(&2u32, encoder)?;
                }
                Self::Ten => {
                    bincode::Encode::encode(&3u32, encoder)?;
                }
                Self::Jack => {
                    bincode::Encode::encode(&4u32, encoder)?;
                }
                Self::Queen => {
                    bincode::Encode::encode(&5u32, encoder)?;
                }
                Self::King => {
                    bincode::Encode::encode(&6u32, encoder)?;
                }
                Self::Ace => {
                    bincode::Encode::encode(&7u32, encoder)?;
                }
            }
            Ok(())
        }
    }
    impl bincode::Decode<()> for Rank {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            let discriminant: u32 = bincode::Decode::decode(decoder)?;
            match discriminant {
                0u32 => Ok(Self::Seven),
                1u32 => Ok(Self::Eight),
                2u32 => Ok(Self::Nine),
                3u32 => Ok(Self::Ten),
                4u32 => Ok(Self::Jack),
                5u32 => Ok(Self::Queen),
                6u32 => Ok(Self::King),
                7u32 => Ok(Self::Ace),
                _ => {
                    Err(bincode::error::DecodeError::UnexpectedVariant {
                        type_name: core::any::type_name::<Self>(),
                        allowed: &bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 7u32,
                        },
                        found: discriminant,
                    })
                }
            }
        }
    }
    impl Serialize for Rank {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            match self {
                Self::Seven => {
                    buf.write_string("Seven");
                }
                Self::Eight => {
                    buf.write_string("Eight");
                }
                Self::Nine => {
                    buf.write_string("Nine");
                }
                Self::Ten => {
                    buf.write_string("Ten");
                }
                Self::Jack => {
                    buf.write_string("Jack");
                }
                Self::Queen => {
                    buf.write_string("Queen");
                }
                Self::King => {
                    buf.write_string("King");
                }
                Self::Ace => {
                    buf.write_string("Ace");
                }
            }
        }
    }
    impl Deserialize for Rank {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let variant_name = buf.read_string();
            match variant_name.as_ref() {
                "Seven" => Ok(Self::Seven),
                "Eight" => Ok(Self::Eight),
                "Nine" => Ok(Self::Nine),
                "Ten" => Ok(Self::Ten),
                "Jack" => Ok(Self::Jack),
                "Queen" => Ok(Self::Queen),
                "King" => Ok(Self::King),
                "Ace" => Ok(Self::Ace),
                _ => {
                    Err(DeserializeError::InvalidEnumVariant {
                        expected: std::any::type_name::<Self>().to_string(),
                        actual: variant_name,
                    })
                }
            }
        }
    }
    impl Rank {
        pub fn bonus_damage(&self) -> usize {
            match self {
                Rank::Seven => 1,
                Rank::Eight => 2,
                Rank::Nine => 3,
                Rank::Ten => 4,
                Rank::Jack => 6,
                Rank::Queen => 8,
                Rank::King => 10,
                Rank::Ace => 15,
            }
        }
        pub fn is_even(&self) -> bool {
            match self {
                Rank::Ace | Rank::Seven | Rank::Nine | Rank::Jack | Rank::King => false,
                Rank::Eight | Rank::Ten | Rank::Queen => true,
            }
        }
        pub fn is_face(&self) -> bool {
            #[allow(non_exhaustive_omitted_patterns)]
            match self {
                Rank::Jack | Rank::Queen | Rank::King => true,
                _ => false,
            }
        }
    }
    impl Display for Rank {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = match self {
                Rank::Ace => "A",
                Rank::Seven => "7",
                Rank::Eight => "8",
                Rank::Nine => "9",
                Rank::Ten => "10",
                Rank::Jack => "J",
                Rank::Queen => "Q",
                Rank::King => "K",
            };
            f.write_fmt(format_args!("{0}", s))
        }
    }
    pub const REVERSED_RANKS: [Rank; 8] = [
        Rank::Ace,
        Rank::King,
        Rank::Queen,
        Rank::Jack,
        Rank::Ten,
        Rank::Nine,
        Rank::Eight,
        Rank::Seven,
    ];
    pub struct Card {
        pub suit: Suit,
        pub rank: Rank,
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Card {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Suit>;
            let _: ::core::cmp::AssertParamIsEq<Rank>;
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Card {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Card",
                "suit",
                &self.suit,
                "rank",
                &&self.rank,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Card {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Card {
        #[inline]
        fn eq(&self, other: &Card) -> bool {
            self.suit == other.suit && self.rank == other.rank
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Card {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.suit, state);
            ::core::hash::Hash::hash(&self.rank, state)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Card {
        #[inline]
        fn clone(&self) -> Card {
            let _: ::core::clone::AssertParamIsClone<Suit>;
            let _: ::core::clone::AssertParamIsClone<Rank>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Card {}
    impl bincode::Encode for Card {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            bincode::Encode::encode(&self.suit, encoder)?;
            bincode::Encode::encode(&self.rank, encoder)?;
            Ok(())
        }
    }
    impl bincode::Decode<()> for Card {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            Ok(Self {
                suit: bincode::Decode::decode(decoder)?,
                rank: bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl Serialize for Card {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            buf.write_string("suit");
            self.suit.serialize_without_name(buf);
            buf.write_string("rank");
            self.rank.serialize_without_name(buf);
        }
    }
    impl Deserialize for Card {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let field_name = buf.read_name("suit")?;
            let suit = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("rank")?;
            let rank = Deserialize::deserialize_without_name(buf)?;
            Ok(Self { suit, rank })
        }
    }
    impl Ord for Card {
        fn cmp(&self, other: &Self) -> std::cmp::Ordering {
            let rank_cmp = (self.rank as usize).cmp(&(other.rank as usize));
            if let std::cmp::Ordering::Equal = rank_cmp {
                return (self.suit as usize).cmp(&(other.suit as usize));
            }
            rank_cmp
        }
    }
    impl PartialOrd for Card {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            Some(self.cmp(other))
        }
    }
    impl Card {
        pub fn new_random() -> Self {
            let card = rand::thread_rng().gen_range(0..32usize);
            let suit = match card / 8 {
                0 => Suit::Spades,
                1 => Suit::Hearts,
                2 => Suit::Diamonds,
                3 => Suit::Clubs,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            };
            let rank = match card % 8 {
                0 => Rank::Ace,
                1 => Rank::Seven,
                2 => Rank::Eight,
                3 => Rank::Nine,
                4 => Rank::Ten,
                5 => Rank::Jack,
                6 => Rank::Queen,
                7 => Rank::King,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            };
            Self { suit, rank }
        }
        pub fn face_image(&self) -> Image {
            (self.rank, self.suit).image()
        }
    }
    pub trait FaceCardImage {
        fn image(self) -> Image;
    }
    impl FaceCardImage for (Rank, Suit) {
        fn image(self) -> Image {
            let (rank, suit) = self;
            match (rank, suit) {
                (Rank::Jack, Suit::Spades) => crate::asset::image::face::spades::JACK,
                (Rank::Jack, Suit::Hearts) => crate::asset::image::face::hearts::JACK,
                (Rank::Jack, Suit::Diamonds) => crate::asset::image::face::diamonds::JACK,
                (Rank::Jack, Suit::Clubs) => crate::asset::image::face::clubs::JACK,
                (Rank::Queen, Suit::Spades) => crate::asset::image::face::spades::QUEEN,
                (Rank::Queen, Suit::Hearts) => crate::asset::image::face::hearts::QUEEN,
                (Rank::Queen, Suit::Diamonds) => {
                    crate::asset::image::face::diamonds::QUEEN
                }
                (Rank::Queen, Suit::Clubs) => crate::asset::image::face::clubs::QUEEN,
                (Rank::King, Suit::Spades) => crate::asset::image::face::spades::KING,
                (Rank::King, Suit::Hearts) => crate::asset::image::face::hearts::KING,
                (Rank::King, Suit::Diamonds) => crate::asset::image::face::diamonds::KING,
                (Rank::King, Suit::Clubs) => crate::asset::image::face::clubs::KING,
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("Not a face card: {0:?} {1:?}", rank, suit),
                    );
                }
            }
        }
    }
}
mod contracts {
    mod contract_item {
        use crate::{
            game_state::contract::{Contract, ContractId},
            hand::xy_with_spring, icon::{Icon, IconKind, IconSize},
            l10n::{TextManager, contract::ContractText},
            palette,
            theme::typography::{
                FontSize, HEADLINE_FONT_SIZE_LARGE, TextAlign, headline, paragraph,
            },
        };
        use namui::*;
        use namui_prebuilt::table;
        const PADDING: Px = px(4.);
        pub struct ContractItemContent<'a> {
            pub contract: &'a Contract,
            pub text_manager: TextManager,
            pub content_width: Px,
            pub evaluating_contract_id: Option<ContractId>,
        }
        impl Component for ContractItemContent<'_> {
            fn render(self, ctx: &RenderCtx) {
                let Self {
                    contract,
                    text_manager,
                    content_width,
                    evaluating_contract_id,
                } = self;
                let eval_offset_x = if Some(contract.id) == evaluating_contract_id {
                    px(32.0)
                } else {
                    0.px()
                };
                let target_xy = Xy::new(eval_offset_x, 0.px());
                let animated_xy = xy_with_spring(ctx, target_xy, Xy::zero());
                let content = ctx
                    .ghost_compose(
                        "inner",
                        |ctx| {
                            table::vertical([
                                table::fixed(
                                    HEADLINE_FONT_SIZE_LARGE.into_px(),
                                    table::horizontal([
                                        table::fixed(
                                            HEADLINE_FONT_SIZE_LARGE.into_px(),
                                            |wh, ctx| {
                                                ctx.add(
                                                    Icon::new(IconKind::Rarity {
                                                            rarity: contract.rarity,
                                                        })
                                                        .size(IconSize::Custom { size: wh.width })
                                                        .wh(wh),
                                                );
                                            },
                                        ),
                                        table::ratio(
                                            1,
                                            move |wh, ctx| {
                                                ctx.add(
                                                    headline("thumbnail".to_string())
                                                        .size(FontSize::Small)
                                                        .align(TextAlign::LeftCenter {
                                                            height: wh.height,
                                                        })
                                                        .max_width(wh.width)
                                                        .build(),
                                                );
                                            },
                                        ),
                                        table::fixed(
                                            HEADLINE_FONT_SIZE_LARGE.into_px() * 2.0,
                                            |wh, ctx| {
                                                ctx.add(
                                                    headline(contract.status.to_string())
                                                        .size(FontSize::Small)
                                                        .align(TextAlign::Center { wh })
                                                        .build(),
                                                );
                                            },
                                        ),
                                    ]),
                                ),
                                table::fixed(PADDING * 2.0, |_, _| {}),
                                table::fit(
                                    table::FitAlign::LeftTop,
                                    move |compose_ctx| {
                                        let text = text_manager
                                            .contract(ContractText::Risk(&contract.risk));
                                        compose_ctx
                                            .add(
                                                paragraph(text)
                                                    .size(FontSize::Medium)
                                                    .align(TextAlign::LeftTop)
                                                    .max_width(content_width)
                                                    .build_rich(),
                                            );
                                    },
                                ),
                                table::fixed(PADDING, |_, _| {}),
                                table::fit(
                                    table::FitAlign::LeftTop,
                                    move |compose_ctx| {
                                        let text = text_manager
                                            .contract(ContractText::Reward(&contract.reward));
                                        compose_ctx
                                            .add(
                                                paragraph(text)
                                                    .size(FontSize::Medium)
                                                    .align(TextAlign::LeftTop)
                                                    .max_width(content_width)
                                                    .build_rich(),
                                            );
                                    },
                                ),
                            ])(Wh::new(content_width, f32::MAX.px()), ctx);
                        },
                    );
                let Some(content_wh) = content.bounding_box().map(|rect| rect.wh()) else {
                    return;
                };
                let container_wh = content_wh + Wh::single(PADDING * 2.);
                ctx.translate(animated_xy + Xy::single(PADDING)).add(content);
                ctx.translate(animated_xy)
                    .add(
                        rect(RectParam {
                            rect: container_wh.to_rect(),
                            style: RectStyle {
                                stroke: Some(RectStroke {
                                    color: palette::OUTLINE,
                                    width: 1.px(),
                                    border_position: BorderPosition::Inside,
                                }),
                                fill: Some(RectFill {
                                    color: palette::SURFACE_CONTAINER,
                                }),
                                round: Some(RectRound {
                                    radius: palette::ROUND,
                                }),
                            },
                        }),
                    );
            }
        }
    }
    use crate::{
        game_state::{
            GameState, contract::ContractId,
            flow::{GameFlow, contract::ContractFlowState},
            use_game_state,
        },
        icon::{Icon, IconKind, IconSize},
        l10n::TextManager, palette,
    };
    use contract_item::ContractItemContent;
    use namui::*;
    use namui_prebuilt::{scroll_view::AutoScrollViewWithCtx, table};
    const PANEL_WIDTH: Px = px(260.);
    const PADDING: Px = px(4.);
    const TITLE_HEIGHT: Px = px(36.);
    pub struct ContractsPanel {
        pub screen_wh: Wh<Px>,
    }
    impl Component for ContractsPanel {
        fn render(self, render_ctx: &RenderCtx) {
            let game_state = use_game_state(render_ctx);
            let text_manager: TextManager = game_state.text();
            let evaluating_contract_id = get_evaluating_contract_id(&game_state);
            let scroll_view = |wh: Wh<Px>, ctx: ComposeCtx| {
                ctx.clip(Path::new().add_rect(wh.to_rect()), ClipOp::Intersect)
                    .add(AutoScrollViewWithCtx {
                        wh,
                        scroll_bar_width: PADDING,
                        content: |ctx| {
                            let content_width = wh.width;
                            let mut current_y = 0.px();
                            for contract in game_state.contracts.iter() {
                                let item = ctx
                                    .ghost_compose(
                                        "ContractItemContent",
                                        |ctx| {
                                            ctx.add(ContractItemContent {
                                                contract,
                                                text_manager,
                                                content_width,
                                                evaluating_contract_id,
                                            });
                                        },
                                    );
                                let Some(container_wh) = item
                                    .bounding_box()
                                    .map(|rect| rect.wh()) else {
                                    return;
                                };
                                ctx.translate((0.px(), current_y)).add(item);
                                current_y += container_wh.height;
                            }
                        },
                    });
            };
            render_ctx
                .compose(|ctx| {
                    table::horizontal([
                        table::fixed_no_clip(
                            PANEL_WIDTH,
                            table::padding(
                                PADDING,
                                table::vertical([
                                    table::fixed(
                                        TITLE_HEIGHT,
                                        |wh, ctx| {
                                            ctx.add(
                                                Icon::new(IconKind::Quest)
                                                    .size(IconSize::Medium)
                                                    .wh(Wh {
                                                        width: 32.px(),
                                                        height: wh.height,
                                                    }),
                                            );
                                            ctx.add(
                                                rect(RectParam {
                                                    rect: wh.to_rect(),
                                                    style: RectStyle {
                                                        stroke: Some(RectStroke {
                                                            color: palette::OUTLINE,
                                                            width: 1.px(),
                                                            border_position: BorderPosition::Inside,
                                                        }),
                                                        fill: Some(RectFill {
                                                            color: palette::SURFACE_CONTAINER,
                                                        }),
                                                        round: Some(RectRound {
                                                            radius: palette::ROUND,
                                                        }),
                                                    },
                                                }),
                                            );
                                        },
                                    ),
                                    table::fixed_no_clip(PADDING, |_, _| {}),
                                    table::ratio(1, scroll_view),
                                ]),
                            ),
                        ),
                        table::ratio_no_clip(1, |_, _| {}),
                    ])(self.screen_wh, ctx);
                });
        }
    }
    pub struct Contracts {
        pub screen_wh: Wh<Px>,
    }
    impl Component for Contracts {
        fn render(self, ctx: &RenderCtx) {
            ctx.add(ContractsPanel {
                screen_wh: self.screen_wh,
            });
        }
    }
    fn get_evaluating_contract_id(game_state: &GameState) -> Option<ContractId> {
        let GameFlow::Contract(contract_flow) = &game_state.flow else {
            return None;
        };
        match &contract_flow.state {
            ContractFlowState::Active { event, .. }
            | ContractFlowState::Standby { event, .. } => Some(event.contract_id),
            _ => None,
        }
    }
}
mod flow_ui {
    mod placing_tower {
        mod tower_placing_hand {
            use crate::{
                game_state::{
                    Modal, force_start, mutate_game_state, set_modal, use_game_state,
                },
                hand::{HAND_WH, HandComponent, HandSlotId},
                theme::{
                    button::{Button, ButtonColor, ButtonVariant},
                    typography::{TextAlign, headline},
                },
            };
            use namui::*;
            use namui_prebuilt::table;
            pub struct TowerPlacingHand;
            impl Component for TowerPlacingHand {
                fn render(self, ctx: &RenderCtx) {
                    let screen_wh = screen::size().into_type::<Px>();
                    let game_state = use_game_state(ctx);
                    let (hand, selected_hand_slot_ids) = match &game_state.flow {
                        crate::game_state::flow::GameFlow::PlacingTower { hand } => {
                            let selected_hand_slot_ids = ctx
                                .track_eq(&hand.selected_slot_ids());
                            (hand, selected_hand_slot_ids)
                        }
                        _ => return,
                    };
                    let select_tower = |slot_id: HandSlotId| {
                        if !selected_hand_slot_ids.is_empty() {
                            return;
                        }
                        let Some(_tower_template) = hand.get_item(slot_id) else {
                            return;
                        };
                        mutate_game_state(move |game_state| {
                            if let crate::game_state::flow::GameFlow::PlacingTower {
                                hand,
                            } = &mut game_state.flow
                            {
                                hand.select_slot(slot_id);
                            }
                        });
                    };
                    let handle_start_button_click = || {
                        if hand.is_empty() {
                            force_start();
                        } else {
                            set_modal(Some(Modal::StartConfirm));
                        }
                    };
                    ctx.compose(|ctx| {
                        table::vertical([
                            table::ratio_no_clip(1, |_, _| {}),
                            table::fixed_no_clip(
                                HAND_WH.height,
                                table::horizontal([
                                    table::ratio_no_clip(1, |_, _| {}),
                                    table::fixed_no_clip(
                                        HAND_WH.width,
                                        |_wh, ctx| {
                                            ctx.add(HandComponent {
                                                hand,
                                                on_click: &select_tower,
                                            });
                                        },
                                    ),
                                    table::fixed_no_clip(
                                        120.px(),
                                        |wh, ctx| {
                                            ctx.compose(|ctx| {
                                                table::vertical([
                                                    table::ratio(1, |_, _| {}),
                                                    table::fixed(
                                                        48.px(),
                                                        |wh, ctx| {
                                                            let padding = px(8.0);
                                                            table::padding(
                                                                padding,
                                                                |wh, ctx| {
                                                                    ctx.add(
                                                                        Button::new(
                                                                                wh,
                                                                                &|| {
                                                                                    handle_start_button_click();
                                                                                },
                                                                                &|wh, text_color, ctx| {
                                                                                    ctx.add(
                                                                                        headline("START")
                                                                                            .color(text_color)
                                                                                            .align(TextAlign::Center { wh })
                                                                                            .build(),
                                                                                    );
                                                                                },
                                                                            )
                                                                            .variant(ButtonVariant::Contained)
                                                                            .color(ButtonColor::Primary),
                                                                    );
                                                                },
                                                            )(wh, ctx);
                                                        },
                                                    ),
                                                    table::ratio(1, |_, _| {}),
                                                ])(wh, ctx);
                                            });
                                        },
                                    ),
                                    table::ratio_no_clip(1, |_, _| {}),
                                ]),
                            ),
                        ])(screen_wh, ctx);
                    });
                }
            }
        }
        use namui::*;
        use tower_placing_hand::TowerPlacingHand;
        pub struct PlacingTowerUi;
        impl Component for PlacingTowerUi {
            fn render(self, ctx: &RenderCtx) {
                ctx.add(TowerPlacingHand);
            }
        }
    }
    mod selecting_tower {
        mod shop_modal {
            mod constants {
                use namui::*;
                pub const PADDING: Px = px(4.0);
                pub const SHOP_WH: Wh<Px> = Wh {
                    width: px(960.0),
                    height: px(480.0),
                };
                pub const SHOP_BUTTON_WH: Wh<Px> = Wh {
                    width: px(128.0),
                    height: px(48.0),
                };
                pub const SHOP_REFRESH_BUTTON_WH: Wh<Px> = Wh {
                    width: px(192.0),
                    height: px(48.0),
                };
                pub const SOLD_OUT_HEIGHT: Px = px(36.0);
            }
            mod items {
                use super::constants::{PADDING, SOLD_OUT_HEIGHT};
                use crate::game_state::contract::Contract;
                use crate::game_state::item::{Effect, Item};
                use crate::game_state::upgrade::{Upgrade, UpgradeKind};
                use crate::game_state::use_game_state;
                use crate::icon::{Icon, IconKind, IconSize};
                use crate::l10n::ui::TopBarText;
                use crate::palette;
                use crate::shop::ShopSlot;
                use crate::theme::button::{Button, ButtonColor};
                use crate::theme::typography::{FontSize, TextAlign, headline, paragraph};
                use namui::*;
                use namui_prebuilt::{simple_rect, table};
                pub struct ShopItem<'a> {
                    pub wh: Wh<Px>,
                    pub shop_slot: &'a ShopSlot,
                    pub shop_slot_index: usize,
                    pub purchase_item: &'a dyn Fn(usize),
                    pub can_purchase_item: bool,
                }
                impl Component for ShopItem<'_> {
                    fn render(self, ctx: &RenderCtx) {
                        let Self {
                            wh,
                            shop_slot,
                            shop_slot_index,
                            purchase_item,
                            can_purchase_item,
                        } = self;
                        let purchase_item = || purchase_item(shop_slot_index);
                        ctx.compose(|ctx| {
                            table::padding_no_clip(
                                PADDING,
                                |wh, ctx| {
                                    match shop_slot {
                                        ShopSlot::Locked => {
                                            ctx.add(ShopItemLocked { wh });
                                        }
                                        ShopSlot::Item { item, cost, purchased } => {
                                            ctx.add(ShopItemContent {
                                                wh,
                                                item,
                                                purchase_item: &purchase_item,
                                                cost: *cost,
                                                purchased: *purchased,
                                                disabled: !can_purchase_item,
                                            });
                                        }
                                        ShopSlot::Upgrade { upgrade, cost, purchased } => {
                                            ctx.add(ShopUpgradeContent {
                                                wh,
                                                upgrade,
                                                purchase_upgrade: &purchase_item,
                                                cost: *cost,
                                                purchased: *purchased,
                                                disabled: !can_purchase_item,
                                            });
                                        }
                                        ShopSlot::Contract { contract, cost, purchased } => {
                                            ctx.add(ShopContractContent {
                                                wh,
                                                contract,
                                                purchase_contract: &purchase_item,
                                                cost: *cost,
                                                purchased: *purchased,
                                                disabled: !can_purchase_item,
                                            });
                                        }
                                    }
                                    ctx.add(
                                        rect(RectParam {
                                            rect: wh.to_rect(),
                                            style: RectStyle {
                                                stroke: Some(RectStroke {
                                                    color: palette::OUTLINE,
                                                    width: 1.px(),
                                                    border_position: BorderPosition::Inside,
                                                }),
                                                fill: Some(RectFill {
                                                    color: palette::SURFACE_CONTAINER,
                                                }),
                                                round: Some(RectRound {
                                                    radius: palette::ROUND,
                                                }),
                                            },
                                        }),
                                    );
                                },
                            )(wh, ctx);
                        });
                    }
                }
                pub struct ShopItemLocked {
                    pub wh: Wh<Px>,
                }
                impl Component for ShopItemLocked {
                    fn render(self, ctx: &RenderCtx) {
                        let Self { wh } = self;
                        ctx.compose(|ctx| {
                            table::vertical([
                                table::ratio(1, |_, _| {}),
                                table::fixed(
                                    36.px(),
                                    |wh, ctx| {
                                        ctx.add(
                                            Icon::new(IconKind::Lock).size(IconSize::Large).wh(wh),
                                        );
                                    },
                                ),
                                table::ratio(1, |_, _| {}),
                            ])(wh, ctx);
                        });
                    }
                }
                pub struct ShopItemContent<'a> {
                    pub wh: Wh<Px>,
                    pub item: &'a Item,
                    pub purchase_item: &'a dyn Fn(),
                    pub cost: usize,
                    pub purchased: bool,
                    pub disabled: bool,
                }
                struct ShopItemLayoutParams<'a> {
                    wh: Wh<Px>,
                    name: String,
                    description: String,
                    cost: usize,
                    purchased: bool,
                    available: bool,
                    purchase_action: &'a dyn Fn(),
                    item_kind: Option<&'a Effect>,
                    upgrade_kind: Option<&'a UpgradeKind>,
                    contract_kind: Option<&'a Contract>,
                    rarity: crate::rarity::Rarity,
                }
                fn render_shop_item_layout(
                    params: ShopItemLayoutParams,
                    ctx: &RenderCtx,
                ) {
                    let ShopItemLayoutParams {
                        wh,
                        name,
                        description,
                        cost,
                        purchased,
                        available,
                        purchase_action,
                        item_kind,
                        upgrade_kind,
                        contract_kind,
                        rarity,
                    } = params;
                    ctx.compose(|ctx| {
                        if !purchased {
                            return;
                        }
                        ctx.add(ShopItemSoldOut { wh });
                    });
                    ctx.compose(|ctx| {
                        table::vertical([
                            table::fixed_no_clip(
                                wh.width,
                                table::padding_no_clip(
                                    PADDING,
                                    |wh, ctx| {
                                        ctx.translate((
                                                (wh.width - IconSize::Large.px()) * 0.5,
                                                -PADDING,
                                            ))
                                            .add(
                                                Icon::new(IconKind::Rarity { rarity })
                                                    .size(IconSize::Large)
                                                    .wh(Wh::new(IconSize::Large.px(), PADDING)),
                                            );
                                        ctx.compose(|ctx| {
                                            table::padding(
                                                PADDING,
                                                |wh, ctx| {
                                                    if let Some(kind) = item_kind {
                                                        ctx.add(kind.thumbnail(wh));
                                                    } else if let Some(upgrade) = upgrade_kind {
                                                        ctx.add(upgrade.thumbnail(wh));
                                                    } else if contract_kind.is_some() {
                                                        ctx.add(
                                                            Icon::new(IconKind::Quest).size(IconSize::Large).wh(wh),
                                                        );
                                                    } else {
                                                        ctx.add(
                                                            Icon::new(IconKind::Config).size(IconSize::Large).wh(wh),
                                                        );
                                                    }
                                                },
                                            )(wh, ctx);
                                        });
                                        ctx.add(
                                            rect(RectParam {
                                                rect: wh.to_rect(),
                                                style: RectStyle {
                                                    stroke: Some(RectStroke {
                                                        color: palette::OUTLINE,
                                                        width: 1.px(),
                                                        border_position: BorderPosition::Inside,
                                                    }),
                                                    fill: Some(RectFill {
                                                        color: palette::SURFACE_CONTAINER_LOWEST,
                                                    }),
                                                    round: Some(RectRound {
                                                        radius: palette::ROUND,
                                                    }),
                                                },
                                            }),
                                        );
                                    },
                                ),
                            ),
                            table::ratio(
                                1,
                                table::padding(
                                    PADDING,
                                    table::vertical([
                                        table::fixed(PADDING, |_, _| {}),
                                        table::fit(
                                            table::FitAlign::LeftTop,
                                            move |ctx| {
                                                ctx.add(
                                                    headline(name)
                                                        .size(FontSize::Small)
                                                        .align(TextAlign::LeftTop)
                                                        .max_width(wh.width)
                                                        .build_rich(),
                                                );
                                            },
                                        ),
                                        table::fixed(PADDING, |_, _| {}),
                                        table::ratio(
                                            1,
                                            move |wh, ctx| {
                                                ctx.add(
                                                    paragraph(description.clone())
                                                        .size(FontSize::Medium)
                                                        .align(TextAlign::LeftTop)
                                                        .max_width(wh.width)
                                                        .build_rich(),
                                                );
                                            },
                                        ),
                                        table::fixed(PADDING, |_, _| {}),
                                        table::fixed(
                                            48.px(),
                                            |wh, ctx| {
                                                ctx.add(
                                                    Button::new(
                                                            wh,
                                                            &|| {
                                                                if !available {
                                                                    return;
                                                                }
                                                                purchase_action();
                                                            },
                                                            &|wh, color, ctx| {
                                                                ctx.add(
                                                                    headline(
                                                                            ::alloc::__export::must_use({
                                                                                ::alloc::fmt::format(
                                                                                    format_args!(
                                                                                        "{0} {1}",
                                                                                        Icon::new(IconKind::Gold)
                                                                                            .size(IconSize::Large)
                                                                                            .wh(Wh::single(wh.height))
                                                                                            .as_tag(),
                                                                                        cost,
                                                                                    ),
                                                                                )
                                                                            }),
                                                                        )
                                                                        .color(color)
                                                                        .build_rich(),
                                                                );
                                                            },
                                                        )
                                                        .color(
                                                            if available {
                                                                ButtonColor::Primary
                                                            } else {
                                                                ButtonColor::Secondary
                                                            },
                                                        )
                                                        .disabled(!available),
                                                );
                                            },
                                        ),
                                    ]),
                                ),
                            ),
                        ])(wh, ctx);
                    });
                }
                impl Component for ShopItemContent<'_> {
                    fn render(self, ctx: &RenderCtx) {
                        let Self {
                            wh,
                            item,
                            purchase_item,
                            cost,
                            purchased,
                            disabled,
                        } = self;
                        let game_state = use_game_state(ctx);
                        let available = !purchased && !disabled;
                        let name = item.name(&game_state.text());
                        let description = item.description(&game_state.text());
                        render_shop_item_layout(
                            ShopItemLayoutParams {
                                wh,
                                name,
                                description,
                                cost,
                                purchased,
                                available,
                                purchase_action: purchase_item,
                                item_kind: Some(&item.effect),
                                upgrade_kind: None,
                                contract_kind: None,
                                rarity: item.rarity,
                            },
                            ctx,
                        );
                    }
                }
                struct ShopUpgradeContent<'a> {
                    wh: Wh<Px>,
                    upgrade: &'a Upgrade,
                    purchase_upgrade: &'a dyn Fn(),
                    cost: usize,
                    purchased: bool,
                    disabled: bool,
                }
                impl Component for ShopUpgradeContent<'_> {
                    fn render(self, ctx: &RenderCtx) {
                        let Self {
                            wh,
                            upgrade,
                            purchase_upgrade,
                            cost,
                            purchased,
                            disabled,
                        } = self;
                        let game_state = use_game_state(ctx);
                        let available = !purchased && !disabled;
                        let name = upgrade.kind.name(&game_state.text());
                        let description = upgrade.kind.description(&game_state.text());
                        render_shop_item_layout(
                            ShopItemLayoutParams {
                                wh,
                                name,
                                description,
                                cost,
                                purchased,
                                available,
                                purchase_action: purchase_upgrade,
                                item_kind: None,
                                upgrade_kind: Some(&upgrade.kind),
                                contract_kind: None,
                                rarity: upgrade.rarity,
                            },
                            ctx,
                        );
                    }
                }
                struct ShopContractContent<'a> {
                    wh: Wh<Px>,
                    contract: &'a Contract,
                    purchase_contract: &'a dyn Fn(),
                    cost: usize,
                    purchased: bool,
                    disabled: bool,
                }
                impl Component for ShopContractContent<'_> {
                    fn render(self, ctx: &RenderCtx) {
                        let Self {
                            wh,
                            contract,
                            purchase_contract,
                            cost,
                            purchased,
                            disabled,
                        } = self;
                        let available = !purchased && !disabled;
                        let name = match contract.rarity {
                            crate::rarity::Rarity::Common => "Common Contract",
                            crate::rarity::Rarity::Rare => "Rare Contract",
                            crate::rarity::Rarity::Epic => "Epic Contract",
                            crate::rarity::Rarity::Legendary => "Legendary Contract",
                        }
                            .to_string();
                        let description = ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}\n{1}",
                                    crate::l10n::contract::ContractText::Risk(&contract.risk)
                                        .to_korean(),
                                    crate::l10n::contract::ContractText::Reward(
                                            &contract.reward,
                                        )
                                        .to_korean(),
                                ),
                            )
                        });
                        render_shop_item_layout(
                            ShopItemLayoutParams {
                                wh,
                                name,
                                description,
                                cost,
                                purchased,
                                available,
                                purchase_action: purchase_contract,
                                item_kind: None,
                                upgrade_kind: None,
                                contract_kind: Some(contract),
                                rarity: contract.rarity,
                            },
                            ctx,
                        );
                    }
                }
                struct ShopItemSoldOut {
                    wh: Wh<Px>,
                }
                impl Component for ShopItemSoldOut {
                    fn render(self, ctx: &RenderCtx) {
                        let Self { wh } = self;
                        let game_state = use_game_state(ctx);
                        ctx.compose(|ctx| {
                            table::vertical([
                                table::ratio(1, |_, _| {}),
                                table::fixed(
                                    SOLD_OUT_HEIGHT,
                                    |wh, ctx| {
                                        ctx.add(
                                            headline(
                                                    game_state.text().ui(TopBarText::SoldOut).to_string(),
                                                )
                                                .size(FontSize::Medium)
                                                .align(TextAlign::Center { wh })
                                                .build(),
                                        );
                                        ctx.add(
                                            simple_rect(
                                                wh,
                                                Color::TRANSPARENT,
                                                0.px(),
                                                palette::SECONDARY,
                                            ),
                                        );
                                    },
                                ),
                                table::ratio(1, |_, _| {}),
                            ])(wh, ctx);
                        });
                    }
                }
            }
            mod layout {
                use super::constants::{PADDING, SHOP_REFRESH_BUTTON_WH, SHOP_WH};
                use super::items::ShopItem;
                use crate::game_state::{mutate_game_state, use_game_state};
                use crate::icon::{Icon, IconKind, IconSize};
                use crate::shop::Shop;
                use crate::shop::refresh_shop;
                use crate::theme::button::{Button, ButtonVariant};
                use crate::theme::typography::{TextAlign, headline};
                use namui::*;
                use namui_prebuilt::table::{self, ratio, ratio_no_clip};
                pub struct ShopLayout<'a> {
                    pub shop: &'a Shop,
                    pub purchase_item: &'a dyn Fn(usize),
                    pub can_purchase_items: &'a [bool],
                }
                impl Component for ShopLayout<'_> {
                    fn render(self, ctx: &RenderCtx) {
                        let Self { shop, purchase_item, can_purchase_items } = self;
                        let game_state = use_game_state(ctx);
                        let disabled = game_state.left_shop_refresh_chance == 0
                            || {
                                let health_cost = game_state
                                    .stage_modifiers
                                    .get_shop_reroll_health_cost();
                                (game_state.hp - health_cost as f32) < 1.0
                            };
                        let refresh_shop = || {
                            mutate_game_state(|game_state| {
                                let health_cost = game_state
                                    .stage_modifiers
                                    .get_shop_reroll_health_cost();
                                if (game_state.hp - health_cost as f32) < 1.0 {
                                    return;
                                }
                                game_state.left_shop_refresh_chance -= 1;
                                game_state.take_damage(health_cost as f32);
                                refresh_shop(game_state);
                            });
                        };
                        ctx.compose(|ctx| {
                            table::padding_no_clip(
                                PADDING,
                                table::vertical([
                                    table::ratio_no_clip(
                                        1,
                                        table::horizontal(
                                            shop
                                                .slots
                                                .iter()
                                                .enumerate()
                                                .map(|(shop_slot_index, shop_slot)| {
                                                    ratio_no_clip(
                                                        1,
                                                        move |wh, ctx| {
                                                            ctx.add(ShopItem {
                                                                wh,
                                                                shop_slot,
                                                                shop_slot_index,
                                                                purchase_item,
                                                                can_purchase_item: can_purchase_items[shop_slot_index],
                                                            });
                                                        },
                                                    )
                                                }),
                                        ),
                                    ),
                                    table::fixed(
                                        SHOP_REFRESH_BUTTON_WH.height,
                                        table::horizontal([
                                            ratio(1, |_, _| {}),
                                            table::fixed(
                                                SHOP_REFRESH_BUTTON_WH.width,
                                                |wh, ctx| {
                                                    ctx.add(
                                                        Button::new(
                                                                wh,
                                                                &|| {
                                                                    refresh_shop();
                                                                },
                                                                &|wh, color, ctx| {
                                                                    let health_cost = game_state
                                                                        .stage_modifiers
                                                                        .get_shop_reroll_health_cost();
                                                                    let mut text = ::alloc::__export::must_use({
                                                                        ::alloc::fmt::format(
                                                                            format_args!(
                                                                                "{0}-{1}",
                                                                                Icon::new(IconKind::Refresh)
                                                                                    .size(IconSize::Large)
                                                                                    .wh(Wh::single(wh.height))
                                                                                    .as_tag(),
                                                                                game_state.left_shop_refresh_chance,
                                                                            ),
                                                                        )
                                                                    });
                                                                    if health_cost > 0 {
                                                                        text.push_str(
                                                                            &::alloc::__export::must_use({
                                                                                ::alloc::fmt::format(
                                                                                    format_args!(
                                                                                        " {0}",
                                                                                        Icon::new(IconKind::Health)
                                                                                            .size(IconSize::Small)
                                                                                            .wh(Wh::single(wh.height * 0.5))
                                                                                            .as_tag(),
                                                                                    ),
                                                                                )
                                                                            }),
                                                                        );
                                                                    }
                                                                    ctx.add(
                                                                        headline(text)
                                                                            .color(color)
                                                                            .align(TextAlign::Center { wh })
                                                                            .build_rich(),
                                                                    );
                                                                },
                                                            )
                                                            .variant(ButtonVariant::Fab)
                                                            .disabled(disabled),
                                                    );
                                                },
                                            ),
                                            ratio(1, |_, _| {}),
                                        ]),
                                    ),
                                ]),
                            )(SHOP_WH, ctx);
                        });
                    }
                }
            }
            mod open_button {
                use super::constants::SHOP_BUTTON_WH;
                use crate::icon::{Icon, IconKind, IconSize};
                use crate::theme::button::{Button, ButtonColor, ButtonVariant};
                use namui::*;
                pub struct ShopOpenButton<'a> {
                    pub opened: bool,
                    pub toggle_open: &'a dyn Fn(),
                }
                impl Component for ShopOpenButton<'_> {
                    fn render(self, ctx: &RenderCtx) {
                        let Self { opened, toggle_open } = self;
                        ctx.compose(|ctx| {
                            ctx.translate((0.px(), -SHOP_BUTTON_WH.height))
                                .add(
                                    Button::new(
                                            SHOP_BUTTON_WH,
                                            &|| {
                                                toggle_open();
                                            },
                                            &|wh, _text_color, ctx| {
                                                ctx.add(
                                                    Icon::new(IconKind::Shop).size(IconSize::Large).wh(wh),
                                                );
                                            },
                                        )
                                        .variant(ButtonVariant::Fab)
                                        .color(
                                            match opened {
                                                true => ButtonColor::Primary,
                                                false => ButtonColor::Secondary,
                                            },
                                        ),
                                );
                        });
                    }
                }
            }
            use crate::game_state::{mutate_game_state, use_game_state};
            use crate::shop::Shop;
            use constants::SHOP_WH;
            use layout::ShopLayout;
            use namui::*;
            use open_button::ShopOpenButton;
            pub struct ShopModal<'a> {
                pub shop: &'a Shop,
            }
            impl Component for ShopModal<'_> {
                fn render(self, ctx: &RenderCtx) {
                    let Self { shop } = self;
                    let screen_wh = screen::size().into_type::<Px>();
                    let (opened, set_opened) = ctx.state(|| true);
                    let toggle_open = || {
                        set_opened.mutate(|opened| *opened = !*opened);
                    };
                    let purchase_item = |slot_index: usize| {
                        mutate_game_state(move |game_state| {
                            game_state.purchase_shop_item(slot_index);
                        });
                    };
                    let game_state = use_game_state(ctx);
                    let can_purchase_items: Vec<bool> = shop
                        .slots
                        .iter()
                        .enumerate()
                        .map(|(index, _)| game_state.can_purchase_shop_item(index))
                        .collect();
                    let offset = ((screen_wh - SHOP_WH) * 0.5).to_xy();
                    ctx.compose(|ctx| {
                        ctx.translate(offset)
                            .add(ShopOpenButton {
                                opened: *opened,
                                toggle_open: &toggle_open,
                            });
                    });
                    ctx.compose(|ctx| {
                        if !*opened {
                            return;
                        }
                        ctx.translate(offset)
                            .add(ShopLayout {
                                shop,
                                purchase_item: &purchase_item,
                                can_purchase_items: &can_purchase_items,
                            });
                    });
                }
            }
        }
        mod tower_selecting_hand {
            mod get_highest_tower {
                mod tower_hand_ranking {
                    use crate::card::{Card, Rank, Suit};
                    use crate::game_state::upgrade::UpgradeState;
                    use std::collections::HashMap;
                    pub struct StraightResult {
                        pub royal: bool,
                        pub top: Card,
                    }
                    pub struct FlushResult {
                        pub suit: Suit,
                    }
                    pub fn check_straight(
                        cards: &[Card],
                        upgrade_state: &UpgradeState,
                    ) -> Option<StraightResult> {
                        let straight_card_count = match upgrade_state
                            .shorten_straight_flush_to_4_cards
                        {
                            true => 4,
                            false => 5,
                        };
                        let skip_rank_for_straight = upgrade_state
                            .skip_rank_for_straight;
                        if cards.len() < straight_card_count {
                            return None;
                        }
                        let mut cards_ace_as_high = cards
                            .iter()
                            .map(|card| {
                                let mut rank = card.rank as usize;
                                if rank == 0 {
                                    rank = Rank::King as usize + 1;
                                }
                                (rank, card)
                            })
                            .collect::<Vec<_>>();
                        cards_ace_as_high.sort_by(|a, b| a.0.cmp(&b.0));
                        if let Some((start_idx, end_idx, _)) = check_rank(
                            &cards_ace_as_high,
                            straight_card_count,
                            skip_rank_for_straight,
                        ) {
                            let straight_slice = &cards_ace_as_high[start_idx..=end_idx];
                            let ranks: Vec<usize> = straight_slice
                                .iter()
                                .map(|(r, _)| *r)
                                .collect();
                            let is_royal = if straight_card_count == 5 {
                                [
                                    Rank::Ten as usize,
                                    Rank::Jack as usize,
                                    Rank::Queen as usize,
                                    Rank::King as usize,
                                    Rank::Ace as usize,
                                ]
                                    .iter()
                                    .all(|r| ranks.contains(r))
                            } else if straight_card_count == 4 {
                                if skip_rank_for_straight {
                                    let has_10 = ranks.contains(&(Rank::Ten as usize));
                                    let has_j = ranks.contains(&(Rank::Jack as usize));
                                    let has_q = ranks.contains(&(Rank::Queen as usize));
                                    let has_k = ranks.contains(&(Rank::King as usize));
                                    let has_a = ranks.contains(&(Rank::Ace as usize));
                                    has_a && has_q && (has_10 || has_j) && (has_j || has_k)
                                } else {
                                    let royal_sequences = [
                                        [
                                            Rank::Ten as usize,
                                            Rank::Jack as usize,
                                            Rank::Queen as usize,
                                            Rank::King as usize,
                                        ],
                                        [
                                            Rank::Jack as usize,
                                            Rank::Queen as usize,
                                            Rank::King as usize,
                                            Rank::Ace as usize,
                                        ],
                                    ];
                                    royal_sequences
                                        .iter()
                                        .any(|sequence| sequence.iter().all(|r| ranks.contains(r)))
                                }
                            } else {
                                false
                            };
                            return Some(StraightResult {
                                royal: is_royal,
                                top: *straight_slice.last().unwrap().1,
                            });
                        }
                        let mut cards_ace_as_low = cards
                            .iter()
                            .map(|card| (card.rank as usize, card))
                            .collect::<Vec<_>>();
                        cards_ace_as_low.sort_by(|a, b| a.0.cmp(&b.0));
                        if let Some((start_idx, end_idx, _)) = check_rank(
                            &cards_ace_as_low,
                            straight_card_count,
                            skip_rank_for_straight,
                        ) {
                            let straight_slice = &cards_ace_as_low[start_idx..=end_idx];
                            return Some(StraightResult {
                                royal: false,
                                top: *straight_slice.last().unwrap().1,
                            });
                        }
                        return None;
                        fn check_rank(
                            cards: &[(usize, &Card)],
                            straight_card_count: usize,
                            skip_rank: bool,
                        ) -> Option<(usize, usize, usize)> {
                            let mut count = 1;
                            let mut skips = 0;
                            let mut start = 0;
                            for i in 1..cards.len() {
                                if cards[i].0 == cards[i - 1].0 + 1 {
                                    count += 1;
                                } else if skip_rank && cards[i].0 == cards[i - 1].0 + 2
                                    && skips == 0
                                {
                                    count += 1;
                                    skips += 1;
                                } else {
                                    count = 1;
                                    skips = 0;
                                    start = i;
                                }
                                if count == straight_card_count {
                                    return Some((start, i, skips));
                                }
                            }
                            None
                        }
                    }
                    pub fn check_flush(
                        cards: &[Card],
                        upgrade_state: &UpgradeState,
                    ) -> Option<FlushResult> {
                        let flush_card_count = match upgrade_state
                            .shorten_straight_flush_to_4_cards
                        {
                            true => 4,
                            false => 5,
                        };
                        let treat_suits_as_same = upgrade_state.treat_suits_as_same;
                        if cards.len() < flush_card_count {
                            return None;
                        }
                        let mut suit_map = HashMap::new();
                        for card in cards {
                            let suit = if treat_suits_as_same {
                                match card.suit {
                                    Suit::Clubs | Suit::Spades => Suit::Spades,
                                    Suit::Hearts | Suit::Diamonds => Suit::Hearts,
                                }
                            } else {
                                card.suit
                            };
                            suit_map.entry(suit).or_insert_with(Vec::new).push(card);
                        }
                        for (suit, cards) in suit_map {
                            if cards.len() >= flush_card_count {
                                return Some(FlushResult { suit });
                            }
                        }
                        None
                    }
                    pub fn count_rank(cards: &[Card]) -> HashMap<Rank, Vec<Card>> {
                        let mut map = HashMap::new();
                        for card in cards {
                            map.entry(card.rank).or_insert_with(Vec::new).push(*card);
                        }
                        map
                    }
                }
                mod tower_skill_injector {
                    use crate::game_state::tower::{
                        TowerKind, TowerSkillKind, TowerSkillTemplate, TowerTemplate,
                    };
                    use namui::DurationExt;
                    pub fn inject_skills(tower: &mut TowerTemplate) {
                        let hand_ranking_skill = match tower.kind {
                            TowerKind::Barricade => None,
                            TowerKind::High => None,
                            TowerKind::OnePair => {
                                Some(TowerSkillTemplate {
                                    kind: TowerSkillKind::MoneyIncomeAdd {
                                        add: 1,
                                    },
                                    cooldown: 1.sec(),
                                    duration: 1.sec(),
                                })
                            }
                            TowerKind::TwoPair => {
                                Some(TowerSkillTemplate {
                                    kind: TowerSkillKind::MoneyIncomeAdd {
                                        add: 2,
                                    },
                                    cooldown: 1.sec(),
                                    duration: 1.sec(),
                                })
                            }
                            TowerKind::ThreeOfAKind => {
                                Some(TowerSkillTemplate {
                                    kind: TowerSkillKind::NearbyMonsterSpeedMul {
                                        mul: 0.9,
                                        range_radius: 4.0,
                                    },
                                    cooldown: 1.sec(),
                                    duration: 1.sec(),
                                })
                            }
                            TowerKind::Straight => None,
                            TowerKind::Flush => None,
                            TowerKind::FullHouse => {
                                Some(TowerSkillTemplate {
                                    kind: TowerSkillKind::NearbyTowerAttackSpeedMul {
                                        mul: 2.0,
                                        range_radius: 2.0,
                                    },
                                    cooldown: 1.sec(),
                                    duration: 1.sec(),
                                })
                            }
                            TowerKind::FourOfAKind => {
                                Some(TowerSkillTemplate {
                                    kind: TowerSkillKind::NearbyMonsterSpeedMul {
                                        mul: 0.75,
                                        range_radius: 4.0,
                                    },
                                    cooldown: 1.sec(),
                                    duration: 1.sec(),
                                })
                            }
                            TowerKind::StraightFlush => None,
                            TowerKind::RoyalFlush => {
                                Some(TowerSkillTemplate {
                                    kind: TowerSkillKind::NearbyTowerDamageMul {
                                        mul: 2.0,
                                        range_radius: 6.0,
                                    },
                                    cooldown: 1.sec(),
                                    duration: 1.sec(),
                                })
                            }
                        };
                        if let Some(skill) = hand_ranking_skill {
                            tower.skill_templates.push(skill);
                        }
                        let top_card_effect = TowerSkillTemplate {
                            kind: TowerSkillKind::TopCardBonus {
                                rank: tower.rank,
                                bonus_damage: tower.rank.bonus_damage(),
                            },
                            cooldown: 1.sec(),
                            duration: 1.sec(),
                        };
                        tower.skill_templates.push(top_card_effect);
                    }
                }
                mod tower_status_effect_injector {
                    use crate::game_state::tower::{
                        TowerStatusEffect, TowerStatusEffectEnd, TowerStatusEffectKind,
                        TowerTemplate,
                    };
                    use crate::game_state::upgrade::{
                        TowerSelectUpgradeTarget, TowerUpgradeState, UpgradeState,
                    };
                    pub fn inject_status_effects(
                        tower: &mut TowerTemplate,
                        upgrade_state: &UpgradeState,
                        rerolled_count: usize,
                    ) {
                        let mut inject_tower_upgrades = |upgrade: &TowerUpgradeState| {
                            if upgrade.damage_plus > 0.0 {
                                let upgrade_effect = TowerStatusEffect {
                                    kind: TowerStatusEffectKind::DamageAdd {
                                        add: upgrade.damage_plus,
                                    },
                                    end_at: TowerStatusEffectEnd::NeverEnd,
                                };
                                tower.default_status_effects.push(upgrade_effect);
                            }
                            if upgrade.damage_multiplier > 1.0 {
                                let upgrade_effect = TowerStatusEffect {
                                    kind: TowerStatusEffectKind::DamageMul {
                                        mul: upgrade.damage_multiplier,
                                    },
                                    end_at: TowerStatusEffectEnd::NeverEnd,
                                };
                                tower.default_status_effects.push(upgrade_effect);
                            }
                            if upgrade.speed_plus > 0.0 {
                                let upgrade_effect = TowerStatusEffect {
                                    kind: TowerStatusEffectKind::AttackSpeedAdd {
                                        add: upgrade.speed_plus,
                                    },
                                    end_at: TowerStatusEffectEnd::NeverEnd,
                                };
                                tower.default_status_effects.push(upgrade_effect);
                            }
                            if upgrade.speed_multiplier > 1.0 {
                                let upgrade_effect = TowerStatusEffect {
                                    kind: TowerStatusEffectKind::AttackSpeedMul {
                                        mul: upgrade.speed_multiplier,
                                    },
                                    end_at: TowerStatusEffectEnd::NeverEnd,
                                };
                                tower.default_status_effects.push(upgrade_effect);
                            }
                            if upgrade.range_plus > 0.0 {
                                let upgrade_effect = TowerStatusEffect {
                                    kind: TowerStatusEffectKind::AttackRangeAdd {
                                        add: upgrade.range_plus,
                                    },
                                    end_at: TowerStatusEffectEnd::NeverEnd,
                                };
                                tower.default_status_effects.push(upgrade_effect);
                            }
                        };
                        if tower.kind.is_low_card_tower()
                            && let Some(upgrade) = upgrade_state
                                .tower_select_upgrade_states
                                .get(&TowerSelectUpgradeTarget::LowCard)
                        {
                            inject_tower_upgrades(upgrade);
                        }
                        if rerolled_count == 0 {
                            if let Some(upgrade) = upgrade_state
                                .tower_select_upgrade_states
                                .get(&TowerSelectUpgradeTarget::NoReroll)
                            {
                                inject_tower_upgrades(upgrade);
                            }
                        } else if rerolled_count > 0 {
                            for _ in 0..rerolled_count {
                                if let Some(upgrade) = upgrade_state
                                    .tower_select_upgrade_states
                                    .get(&TowerSelectUpgradeTarget::Reroll)
                                {
                                    inject_tower_upgrades(upgrade);
                                }
                            }
                        }
                    }
                }
                mod tower_template_factory {
                    use crate::card::{Rank, Suit};
                    use crate::game_state::projectile::ProjectileKind;
                    use crate::game_state::tower::TowerKind;
                    use crate::game_state::tower::TowerTemplate;
                    use namui::{DurationExt, Per};
                    pub fn create_tower_template(
                        kind: TowerKind,
                        suit: Suit,
                        rank: Rank,
                    ) -> TowerTemplate {
                        let shoot_interval = match kind {
                            TowerKind::Barricade => 8192.0,
                            TowerKind::High => 1.0,
                            TowerKind::OnePair => 1.0,
                            TowerKind::TwoPair => 1.0,
                            TowerKind::ThreeOfAKind => 1.0,
                            TowerKind::Straight => 1.0,
                            TowerKind::Flush => 0.5,
                            TowerKind::FullHouse => 1.0,
                            TowerKind::FourOfAKind => 1.0,
                            TowerKind::StraightFlush => 0.5,
                            TowerKind::RoyalFlush => 1.0 / 3.0,
                        }
                            .sec();
                        let default_attack_range_radius = match kind {
                            TowerKind::Barricade => 0.0,
                            TowerKind::High => 5.0,
                            TowerKind::OnePair => 5.0,
                            TowerKind::TwoPair => 5.0,
                            TowerKind::ThreeOfAKind => 5.0,
                            TowerKind::Straight => 10.0,
                            TowerKind::Flush => 5.0,
                            TowerKind::FullHouse => 5.0,
                            TowerKind::FourOfAKind => 5.0,
                            TowerKind::StraightFlush => 10.0,
                            TowerKind::RoyalFlush => 15.0,
                        };
                        let default_damage = match kind {
                            TowerKind::Barricade => 0.0,
                            TowerKind::High => 1.0,
                            TowerKind::OnePair => 5.0,
                            TowerKind::TwoPair => 10.0,
                            TowerKind::ThreeOfAKind => 25.0,
                            TowerKind::Straight => 50.0,
                            TowerKind::Flush => 75.0,
                            TowerKind::FullHouse => 200.0,
                            TowerKind::FourOfAKind => 250.0,
                            TowerKind::StraightFlush => 1500.0,
                            TowerKind::RoyalFlush => 3000.0,
                        };
                        TowerTemplate {
                            kind,
                            shoot_interval,
                            default_attack_range_radius,
                            projectile_kind: ProjectileKind::Ball,
                            projectile_speed: Per::new(16.0, 1.sec()),
                            default_damage,
                            suit,
                            rank,
                            skill_templates: ::alloc::vec::Vec::new(),
                            default_status_effects: ::alloc::vec::Vec::new(),
                        }
                    }
                }
                use self::tower_hand_ranking::{check_flush, check_straight, count_rank};
                use self::tower_skill_injector::inject_skills;
                use self::tower_status_effect_injector::inject_status_effects;
                use self::tower_template_factory::create_tower_template;
                use crate::card::Card;
                use crate::card::REVERSED_RANKS;
                use crate::game_state::tower::TowerKind;
                use crate::game_state::tower::TowerTemplate;
                use crate::game_state::upgrade::UpgradeState;
                pub fn get_highest_tower_template(
                    cards: &[Card],
                    upgrade_state: &UpgradeState,
                    rerolled_count: usize,
                ) -> TowerTemplate {
                    let straight_result = check_straight(cards, upgrade_state);
                    let flush_result = check_flush(cards, upgrade_state);
                    if let (Some(straight_result), Some(flush_result)) = (
                        &straight_result,
                        &flush_result,
                    ) {
                        if straight_result.royal
                            && straight_result.top.rank == crate::card::Rank::Ace
                        {
                            let mut template = create_tower_template(
                                TowerKind::RoyalFlush,
                                flush_result.suit,
                                crate::card::Rank::Ace,
                            );
                            inject_skills(&mut template);
                            inject_status_effects(
                                &mut template,
                                upgrade_state,
                                rerolled_count,
                            );
                            return template;
                        }
                        let mut template = create_tower_template(
                            TowerKind::StraightFlush,
                            flush_result.suit,
                            straight_result.top.rank,
                        );
                        inject_skills(&mut template);
                        inject_status_effects(
                            &mut template,
                            upgrade_state,
                            rerolled_count,
                        );
                        return template;
                    }
                    let rank_map = count_rank(cards);
                    let mut triple_cards = None;
                    let mut pair_high_cards = None;
                    let mut pair_low_cards = None;
                    for rank in REVERSED_RANKS {
                        let Some(cards_of_rank) = rank_map.get(&rank) else {
                            continue;
                        };
                        if cards_of_rank.len() == 4 {
                            let mut sorted_cards = cards_of_rank.clone();
                            sorted_cards.sort();
                            let top_card = sorted_cards.last().unwrap();
                            let mut template = create_tower_template(
                                TowerKind::FourOfAKind,
                                top_card.suit,
                                top_card.rank,
                            );
                            inject_skills(&mut template);
                            inject_status_effects(
                                &mut template,
                                upgrade_state,
                                rerolled_count,
                            );
                            return template;
                        }
                        if cards_of_rank.len() == 3 && triple_cards.is_none() {
                            triple_cards = Some(cards_of_rank.clone());
                        } else if cards_of_rank.len() == 2 {
                            if pair_high_cards.is_none() {
                                pair_high_cards = Some(cards_of_rank.clone());
                            } else if pair_low_cards.is_none() {
                                pair_low_cards = Some(cards_of_rank.clone());
                            }
                        }
                    }
                    if let (Some(triple_cards_vec), Some(pair_high_cards_vec)) = (
                        &triple_cards,
                        &pair_high_cards,
                    ) {
                        let mut combined_cards = triple_cards_vec
                            .iter()
                            .chain(pair_high_cards_vec)
                            .collect::<Vec<_>>();
                        combined_cards.sort();
                        let top_card = combined_cards.last().unwrap();
                        let mut template = create_tower_template(
                            TowerKind::FullHouse,
                            top_card.suit,
                            top_card.rank,
                        );
                        inject_skills(&mut template);
                        inject_status_effects(
                            &mut template,
                            upgrade_state,
                            rerolled_count,
                        );
                        return template;
                    }
                    if let Some(flush_result) = flush_result {
                        let mut sorted_cards = cards.to_vec();
                        sorted_cards.sort();
                        let top_card = sorted_cards.last().unwrap();
                        let mut template = create_tower_template(
                            TowerKind::Flush,
                            flush_result.suit,
                            top_card.rank,
                        );
                        inject_skills(&mut template);
                        inject_status_effects(
                            &mut template,
                            upgrade_state,
                            rerolled_count,
                        );
                        return template;
                    }
                    if let Some(straight_result) = straight_result {
                        let mut template = create_tower_template(
                            TowerKind::Straight,
                            straight_result.top.suit,
                            straight_result.top.rank,
                        );
                        inject_skills(&mut template);
                        inject_status_effects(
                            &mut template,
                            upgrade_state,
                            rerolled_count,
                        );
                        return template;
                    }
                    if let Some(mut triple_cards_vec) = triple_cards {
                        triple_cards_vec.sort();
                        let top_card = triple_cards_vec.last().unwrap();
                        let mut template = create_tower_template(
                            TowerKind::ThreeOfAKind,
                            top_card.suit,
                            top_card.rank,
                        );
                        inject_skills(&mut template);
                        inject_status_effects(
                            &mut template,
                            upgrade_state,
                            rerolled_count,
                        );
                        return template;
                    }
                    if let (Some(pair_high_cards_vec), Some(pair_low_cards_vec)) = (
                        &pair_high_cards,
                        &pair_low_cards,
                    ) {
                        let mut combined_cards = pair_high_cards_vec
                            .iter()
                            .chain(pair_low_cards_vec)
                            .collect::<Vec<_>>();
                        combined_cards.sort();
                        let top_card = combined_cards.last().unwrap();
                        let mut template = create_tower_template(
                            TowerKind::TwoPair,
                            top_card.suit,
                            top_card.rank,
                        );
                        inject_skills(&mut template);
                        inject_status_effects(
                            &mut template,
                            upgrade_state,
                            rerolled_count,
                        );
                        return template;
                    }
                    if let Some(mut pair_high_cards_vec) = pair_high_cards {
                        pair_high_cards_vec.sort();
                        let top_card = pair_high_cards_vec.last().unwrap();
                        let mut template = create_tower_template(
                            TowerKind::OnePair,
                            top_card.suit,
                            top_card.rank,
                        );
                        inject_skills(&mut template);
                        inject_status_effects(
                            &mut template,
                            upgrade_state,
                            rerolled_count,
                        );
                        return template;
                    }
                    let mut sorted_cards = cards.to_vec();
                    sorted_cards.sort();
                    let top_card = sorted_cards.last().unwrap();
                    let mut template = create_tower_template(
                        TowerKind::High,
                        top_card.suit,
                        top_card.rank,
                    );
                    inject_skills(&mut template);
                    inject_status_effects(&mut template, upgrade_state, rerolled_count);
                    template
                }
            }
            mod tower_preview {
                mod stat {
                    use crate::l10n::rich_text_helpers::{
                        additive_value, multiplier_value,
                    };
                    use crate::{
                        icon::{Icon, IconKind, IconSize},
                        theme::{palette, typography::{FontSize, TextAlign, paragraph}},
                    };
                    use namui::*;
                    use namui_prebuilt::simple_rect;
                    use std::fmt;
                    const TOOLTIP_MAX_WIDTH: Px = px(256.);
                    const PADDING: Px = px(8.);
                    pub(super) struct StatPreview<'a> {
                        pub stat_icon_kind: IconKind,
                        pub default_stat: f32,
                        pub plus_stat: f32,
                        pub multiplier: f32,
                        pub wh: Wh<Px>,
                        pub upgrade_texts: &'a [String],
                    }
                    #[automatically_derived]
                    impl<'a> ::core::clone::Clone for StatPreview<'a> {
                        #[inline]
                        fn clone(&self) -> StatPreview<'a> {
                            StatPreview {
                                stat_icon_kind: ::core::clone::Clone::clone(
                                    &self.stat_icon_kind,
                                ),
                                default_stat: ::core::clone::Clone::clone(
                                    &self.default_stat,
                                ),
                                plus_stat: ::core::clone::Clone::clone(&self.plus_stat),
                                multiplier: ::core::clone::Clone::clone(&self.multiplier),
                                wh: ::core::clone::Clone::clone(&self.wh),
                                upgrade_texts: ::core::clone::Clone::clone(
                                    &self.upgrade_texts,
                                ),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'a> ::core::marker::StructuralPartialEq for StatPreview<'a> {}
                    #[automatically_derived]
                    impl<'a> ::core::cmp::PartialEq for StatPreview<'a> {
                        #[inline]
                        fn eq(&self, other: &StatPreview<'a>) -> bool {
                            self.default_stat == other.default_stat
                                && self.plus_stat == other.plus_stat
                                && self.multiplier == other.multiplier
                                && self.stat_icon_kind == other.stat_icon_kind
                                && self.wh == other.wh
                                && self.upgrade_texts == other.upgrade_texts
                        }
                    }
                    impl Component for StatPreview<'_> {
                        fn render(self, ctx: &RenderCtx) {
                            let Self {
                                stat_icon_kind,
                                default_stat,
                                plus_stat,
                                multiplier,
                                wh,
                                upgrade_texts,
                            } = self;
                            let (mouse_hovering, set_mouse_hovering) = ctx
                                .state::<bool>(|| false);
                            ctx.compose(|ctx| {
                                if !*mouse_hovering {
                                    return;
                                }
                                let tooltip = ctx
                                    .ghost_add(
                                        "tooltip",
                                        Tooltip {
                                            stat_detail: format_stat_detail(
                                                default_stat,
                                                plus_stat,
                                                multiplier,
                                            ),
                                            upgrade_texts,
                                            max_width: TOOLTIP_MAX_WIDTH,
                                        },
                                    );
                                let Some(tooltip_wh) = tooltip
                                    .bounding_box()
                                    .map(|rect| rect.wh()) else {
                                    return;
                                };
                                if tooltip_wh.height == 0.px() {
                                    return;
                                }
                                ctx.translate((wh.width, wh.height - tooltip_wh.height))
                                    .on_top()
                                    .add(tooltip);
                            });
                            ctx.add(
                                Icon::new(stat_icon_kind)
                                    .size(IconSize::Small)
                                    .wh(Wh::new(16.px(), wh.height)),
                            );
                            ctx.add(
                                paragraph(
                                        format_stat_final(default_stat, plus_stat, multiplier),
                                    )
                                    .size(FontSize::Medium)
                                    .align(TextAlign::RightTop {
                                        width: wh.width,
                                    })
                                    .build_rich(),
                            );
                            ctx.add(
                                simple_rect(
                                        wh,
                                        Color::TRANSPARENT,
                                        0.px(),
                                        Color::TRANSPARENT,
                                    )
                                    .attach_event(|event| {
                                        let Event::MouseMove { event } = event else {
                                            return;
                                        };
                                        if event.is_local_xy_in() {
                                            set_mouse_hovering.set(true);
                                        } else {
                                            set_mouse_hovering.set(false);
                                        }
                                    }),
                            );
                        }
                    }
                    fn format_stat_final(
                        base: f32,
                        plus: f32,
                        multiplier: f32,
                    ) -> String {
                        let final_value = calculate_final_stat(base, plus, multiplier);
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0:.1}", final_value))
                        })
                    }
                    fn format_stat_detail(
                        base: f32,
                        plus: f32,
                        multiplier: f32,
                    ) -> String {
                        let has_plus = plus != 0.0;
                        let has_multiplier = multiplier != 1.0;
                        match (has_plus, has_multiplier) {
                            (true, true) => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "({0:.1} {1}) {2} = {3:.1}",
                                            base,
                                            additive_value(OneDecimal(plus)),
                                            multiplier_value(OneDecimal(multiplier)),
                                            calculate_final_stat(base, plus, multiplier),
                                        ),
                                    )
                                })
                            }
                            (true, false) => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0:.1} {1} = {2:.1}",
                                            base,
                                            additive_value(OneDecimal(plus)),
                                            base + plus,
                                        ),
                                    )
                                })
                            }
                            (false, true) => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0:.1} {1} = {2:.1}",
                                            base,
                                            multiplier_value(OneDecimal(multiplier)),
                                            base * multiplier,
                                        ),
                                    )
                                })
                            }
                            (false, false) => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(format_args!("{0:.1}", base))
                                })
                            }
                        }
                    }
                    struct OneDecimal(f32);
                    impl fmt::Display for OneDecimal {
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            f.write_fmt(format_args!("{0:.1}", self.0))
                        }
                    }
                    fn calculate_final_stat(
                        base: f32,
                        plus: f32,
                        multiplier: f32,
                    ) -> f32 {
                        (base + plus) * multiplier
                    }
                    struct Tooltip<'a> {
                        stat_detail: String,
                        upgrade_texts: &'a [String],
                        max_width: Px,
                    }
                    impl Component for Tooltip<'_> {
                        fn render(self, ctx: &RenderCtx) {
                            let Tooltip { stat_detail, upgrade_texts, max_width } = self;
                            let text_max_width = max_width - (PADDING * 2.0);
                            let content = ctx
                                .ghost_compose(
                                    "tooltip-contents",
                                    |mut ctx| {
                                        let stat_text = ctx
                                            .ghost_add(
                                                "stat-detail",
                                                paragraph(stat_detail)
                                                    .size(FontSize::Medium)
                                                    .align(TextAlign::LeftTop)
                                                    .max_width(text_max_width)
                                                    .build_rich(),
                                            );
                                        let stat_text_height = stat_text
                                            .bounding_box()
                                            .map(|rect| rect.height())
                                            .unwrap_or_default();
                                        ctx.add(stat_text);
                                        ctx = ctx.translate((0.px(), PADDING + stat_text_height));
                                        if !upgrade_texts.is_empty() {
                                            ctx = ctx.translate((0.px(), PADDING));
                                        }
                                        for (index, upgrade_text) in upgrade_texts
                                            .iter()
                                            .enumerate()
                                        {
                                            let rendered_text = ctx
                                                .ghost_add(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(
                                                            format_args!("tooltip-content-{0}", index),
                                                        )
                                                    }),
                                                    paragraph(upgrade_text.clone())
                                                        .size(FontSize::Medium)
                                                        .align(TextAlign::LeftTop)
                                                        .max_width(text_max_width)
                                                        .build_rich(),
                                                );
                                            let text_height = rendered_text
                                                .bounding_box()
                                                .map(|rect| rect.height())
                                                .unwrap_or_default();
                                            ctx.add(rendered_text);
                                            ctx = ctx.translate((0.px(), PADDING + text_height));
                                        }
                                    },
                                );
                            let Some(content_wh) = content
                                .bounding_box()
                                .map(|rect| rect.wh()) else {
                                return;
                            };
                            if content_wh.height == 0.px() {
                                return;
                            }
                            let container_wh = Wh::new(
                                content_wh.width + (PADDING * 2.0),
                                content_wh.height + (PADDING * 2.0),
                            );
                            ctx.translate((PADDING, PADDING)).add(content);
                            ctx.add(
                                rect(RectParam {
                                    rect: container_wh.to_rect(),
                                    style: RectStyle {
                                        stroke: Some(RectStroke {
                                            color: palette::OUTLINE,
                                            width: 1.px(),
                                            border_position: BorderPosition::Inside,
                                        }),
                                        fill: Some(RectFill {
                                            color: palette::SURFACE,
                                        }),
                                        round: Some(RectRound {
                                            radius: palette::ROUND,
                                        }),
                                    },
                                }),
                            );
                        }
                    }
                }
                mod tower_preview_component {
                    use super::{
                        stat::StatPreview,
                        tower_skill::{TowerEffectDescription, TowerSkillTemplateIcon},
                        upgrade_helpers::*,
                    };
                    use crate::{
                        game_state::{
                            self, GameState, tower::{TowerSkillTemplate, TowerTemplate},
                            upgrade::{
                                TowerSelectUpgradeTarget, TowerUpgradeState,
                                TowerUpgradeTarget,
                            },
                        },
                        icon::{Icon, IconKind},
                        l10n::upgrade::UpgradeKindText, palette,
                        theme::typography::{FontSize, TextAlign, headline},
                    };
                    use namui::*;
                    use namui_prebuilt::table;
                    const PADDING: Px = px(4.0);
                    const HEADLINE_FONT_SIZE_SMALL: Px = px(16.0);
                    const PARAGRAPH_FONT_SIZE_LARGE: Px = px(16.0);
                    const PREVIEW_ICON_SIZE: Px = px(40.0);
                    struct MouseHoveringSkill {
                        skill: TowerSkillTemplate,
                        offset: Xy<Px>,
                    }
                    impl bincode::Encode for MouseHoveringSkill {
                        fn encode<__E: bincode::enc::Encoder>(
                            &self,
                            encoder: &mut __E,
                        ) -> core::result::Result<(), bincode::error::EncodeError> {
                            bincode::Encode::encode(&self.skill, encoder)?;
                            bincode::Encode::encode(&self.offset, encoder)?;
                            Ok(())
                        }
                    }
                    impl bincode::Decode<()> for MouseHoveringSkill {
                        fn decode<__D: bincode::de::Decoder<Context = ()>>(
                            decoder: &mut __D,
                        ) -> core::result::Result<Self, bincode::error::DecodeError> {
                            Ok(Self {
                                skill: bincode::Decode::decode(decoder)?,
                                offset: bincode::Decode::decode(decoder)?,
                            })
                        }
                    }
                    impl Serialize for MouseHoveringSkill {
                        fn serialize(&self, buf: &mut Vec<u8>) {
                            buf.write_string(std::any::type_name::<Self>());
                            self.serialize_without_name(buf);
                        }
                        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                            buf.write_string("skill");
                            self.skill.serialize_without_name(buf);
                            buf.write_string("offset");
                            self.offset.serialize_without_name(buf);
                        }
                    }
                    impl Deserialize for MouseHoveringSkill {
                        fn deserialize(
                            buf: &mut &[u8],
                        ) -> Result<Self, DeserializeError> {
                            buf.read_name(std::any::type_name::<Self>())?;
                            Self::deserialize_without_name(buf)
                        }
                        fn deserialize_without_name(
                            buf: &mut &[u8],
                        ) -> Result<Self, DeserializeError> {
                            let field_name = buf.read_name("skill")?;
                            let skill = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("offset")?;
                            let offset = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self { skill, offset })
                        }
                    }
                    pub struct TowerPreviewContent<'a> {
                        pub wh: Wh<Px>,
                        pub tower_template: &'a TowerTemplate,
                    }
                    impl Component for TowerPreviewContent<'_> {
                        fn render(self, ctx: &RenderCtx) {
                            let Self { wh, tower_template } = self;
                            let (mouse_hovering_effect, set_mouse_hovering_effect) = ctx
                                .state::<Option<MouseHoveringSkill>>(|| None);
                            let game_state = game_state::use_game_state(ctx);
                            let upgrade_state_and_texts = ctx
                                .memo(|| calculate_upgrade_state_and_texts(
                                    game_state.as_ref(),
                                    tower_template,
                                ));
                            let (upgrade_state, texts) = upgrade_state_and_texts
                                .as_ref();
                            let on_mouse_move_in_effect_icon = |
                                effect: &TowerSkillTemplate,
                                offset|
                            {
                                set_mouse_hovering_effect
                                    .set(
                                        Some(MouseHoveringSkill {
                                            skill: *effect,
                                            offset,
                                        }),
                                    );
                            };
                            let on_mouse_move_out_effect_icon = |
                                effect: &TowerSkillTemplate|
                            {
                                let Some(mouse_hovering_effect) = mouse_hovering_effect
                                    .as_ref() else {
                                    return;
                                };
                                if &mouse_hovering_effect.skill != effect {
                                    return;
                                }
                                set_mouse_hovering_effect.set(None);
                            };
                            ctx.compose(|ctx| {
                                let Some(MouseHoveringSkill { skill: effect, offset }) = mouse_hovering_effect
                                    .as_ref() else {
                                    return;
                                };
                                ctx.absolute(*offset)
                                    .add(TowerEffectDescription {
                                        skill: effect,
                                    });
                            });
                            ctx.compose(|ctx| {
                                table::padding_no_clip(
                                    PADDING,
                                    |wh, ctx| {
                                        table::vertical([
                                            table::fixed_no_clip(
                                                HEADLINE_FONT_SIZE_SMALL,
                                                |wh, ctx| {
                                                    let mut tower_name = String::new();
                                                    tower_name
                                                        .push_str(
                                                            &Icon::new(IconKind::Suit {
                                                                    suit: tower_template.suit,
                                                                })
                                                                .size(crate::icon::IconSize::Small)
                                                                .wh(Wh::single(crate::icon::IconSize::Small.px()))
                                                                .as_tag(),
                                                        );
                                                    tower_name.push_str(&tower_template.rank.to_string());
                                                    tower_name.push(' ');
                                                    tower_name
                                                        .push_str(
                                                            game_state.text().tower(tower_template.kind.to_text()),
                                                        );
                                                    ctx.add(
                                                        headline(tower_name)
                                                            .size(FontSize::Small)
                                                            .align(TextAlign::LeftCenter {
                                                                height: wh.height,
                                                            })
                                                            .max_width(wh.width)
                                                            .build_rich(),
                                                    );
                                                },
                                            ),
                                            table::fixed_no_clip(
                                                PARAGRAPH_FONT_SIZE_LARGE,
                                                |wh, ctx| {
                                                    let damage = tower_template.kind.default_damage();
                                                    let damage_plus = upgrade_state.damage_plus
                                                        + tower_template.rank.bonus_damage() as f32;
                                                    let damage_multiplier = upgrade_state.damage_multiplier;
                                                    ctx.add(StatPreview {
                                                        stat_icon_kind: IconKind::AttackDamage,
                                                        default_stat: damage as f32,
                                                        plus_stat: damage_plus,
                                                        multiplier: damage_multiplier,
                                                        wh,
                                                        upgrade_texts: &texts.damage,
                                                    });
                                                },
                                            ),
                                            table::fixed_no_clip(
                                                PARAGRAPH_FONT_SIZE_LARGE,
                                                |wh, ctx| {
                                                    let range = tower_template.default_attack_range_radius;
                                                    let range_plus = upgrade_state.range_plus;
                                                    ctx.add(StatPreview {
                                                        stat_icon_kind: IconKind::AttackRange,
                                                        default_stat: range,
                                                        plus_stat: range_plus,
                                                        multiplier: 1.0,
                                                        wh,
                                                        upgrade_texts: &texts.range,
                                                    });
                                                },
                                            ),
                                            table::fixed_no_clip(
                                                PARAGRAPH_FONT_SIZE_LARGE,
                                                |wh, ctx| {
                                                    let attack_speed = 1.0
                                                        / tower_template.kind.shoot_interval().as_secs_f32();
                                                    let speed_plus = upgrade_state.speed_plus;
                                                    let speed_multiplier = upgrade_state.speed_multiplier;
                                                    ctx.add(StatPreview {
                                                        stat_icon_kind: IconKind::AttackSpeed,
                                                        default_stat: attack_speed,
                                                        plus_stat: speed_plus,
                                                        multiplier: speed_multiplier,
                                                        wh,
                                                        upgrade_texts: &texts.speed,
                                                    });
                                                },
                                            ),
                                            table::fixed_no_clip(
                                                PREVIEW_ICON_SIZE,
                                                table::horizontal(
                                                    tower_template
                                                        .skill_templates
                                                        .iter()
                                                        .map(|effect| {
                                                            table::fixed_no_clip(
                                                                PREVIEW_ICON_SIZE,
                                                                table::padding_no_clip(
                                                                    PADDING,
                                                                    |wh, ctx| {
                                                                        ctx.add(TowerSkillTemplateIcon {
                                                                            skill: effect,
                                                                            wh,
                                                                            on_mouse_move_in_effect_icon: &on_mouse_move_in_effect_icon,
                                                                            on_mouse_move_out_effect_icon: &on_mouse_move_out_effect_icon,
                                                                        });
                                                                    },
                                                                ),
                                                            )
                                                        }),
                                                ),
                                            ),
                                        ])(wh, ctx);
                                    },
                                )(wh, ctx);
                            });
                        }
                    }
                    pub struct TowerPreview<'a> {
                        pub wh: Wh<Px>,
                        pub tower_template: &'a TowerTemplate,
                    }
                    impl Component for TowerPreview<'_> {
                        fn render(self, ctx: &RenderCtx) {
                            let Self { wh, tower_template } = self;
                            ctx.add(TowerPreviewContent {
                                wh,
                                tower_template,
                            });
                            ctx.add(
                                rect(RectParam {
                                    rect: wh.to_rect(),
                                    style: RectStyle {
                                        stroke: Some(RectStroke {
                                            color: palette::OUTLINE,
                                            width: 1.px(),
                                            border_position: BorderPosition::Inside,
                                        }),
                                        fill: Some(RectFill {
                                            color: palette::SURFACE,
                                        }),
                                        round: Some(RectRound {
                                            radius: palette::ROUND,
                                        }),
                                    },
                                }),
                            );
                        }
                    }
                    struct UpgradeTexts {
                        damage: Vec<String>,
                        speed: Vec<String>,
                        range: Vec<String>,
                    }
                    impl bincode::Encode for UpgradeTexts {
                        fn encode<__E: bincode::enc::Encoder>(
                            &self,
                            encoder: &mut __E,
                        ) -> core::result::Result<(), bincode::error::EncodeError> {
                            bincode::Encode::encode(&self.damage, encoder)?;
                            bincode::Encode::encode(&self.speed, encoder)?;
                            bincode::Encode::encode(&self.range, encoder)?;
                            Ok(())
                        }
                    }
                    impl bincode::Decode<()> for UpgradeTexts {
                        fn decode<__D: bincode::de::Decoder<Context = ()>>(
                            decoder: &mut __D,
                        ) -> core::result::Result<Self, bincode::error::DecodeError> {
                            Ok(Self {
                                damage: bincode::Decode::decode(decoder)?,
                                speed: bincode::Decode::decode(decoder)?,
                                range: bincode::Decode::decode(decoder)?,
                            })
                        }
                    }
                    impl Serialize for UpgradeTexts {
                        fn serialize(&self, buf: &mut Vec<u8>) {
                            buf.write_string(std::any::type_name::<Self>());
                            self.serialize_without_name(buf);
                        }
                        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                            buf.write_string("damage");
                            self.damage.serialize_without_name(buf);
                            buf.write_string("speed");
                            self.speed.serialize_without_name(buf);
                            buf.write_string("range");
                            self.range.serialize_without_name(buf);
                        }
                    }
                    impl Deserialize for UpgradeTexts {
                        fn deserialize(
                            buf: &mut &[u8],
                        ) -> Result<Self, DeserializeError> {
                            buf.read_name(std::any::type_name::<Self>())?;
                            Self::deserialize_without_name(buf)
                        }
                        fn deserialize_without_name(
                            buf: &mut &[u8],
                        ) -> Result<Self, DeserializeError> {
                            let field_name = buf.read_name("damage")?;
                            let damage = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("speed")?;
                            let speed = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("range")?;
                            let range = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self { damage, speed, range })
                        }
                    }
                    fn calculate_upgrade_state_and_texts(
                        game_state: &GameState,
                        tower_template: &TowerTemplate,
                    ) -> (TowerUpgradeState, UpgradeTexts) {
                        let mut state = TowerUpgradeState::default();
                        let mut texts = UpgradeTexts {
                            damage: ::alloc::vec::Vec::new(),
                            speed: ::alloc::vec::Vec::new(),
                            range: ::alloc::vec::Vec::new(),
                        };
                        let mut apply_upgrade = |
                            upgrade_state: &TowerUpgradeState,
                            target: &UpgradeTargetType|
                        {
                            state.damage_plus += upgrade_state.damage_plus;
                            state.damage_multiplier *= upgrade_state.damage_multiplier;
                            state.speed_plus += upgrade_state.speed_plus;
                            state.speed_multiplier *= upgrade_state.speed_multiplier;
                            state.range_plus += upgrade_state.range_plus;
                            if upgrade_state.damage_plus > 0.0 {
                                let upgrade_kind = match target {
                                    UpgradeTargetType::Tower(tower_target) => {
                                        create_upgrade_kind_for_target(
                                            tower_target,
                                            UpgradeStatType::Damage,
                                            true,
                                            upgrade_state.damage_plus,
                                        )
                                    }
                                    UpgradeTargetType::TowerSelect(tower_select_target) => {
                                        create_tower_select_upgrade_kind(
                                            tower_select_target,
                                            UpgradeStatType::Damage,
                                            true,
                                            upgrade_state.damage_plus,
                                        )
                                    }
                                };
                                texts
                                    .damage
                                    .push(
                                        game_state
                                            .text()
                                            .upgrade_kind(UpgradeKindText::Description(&upgrade_kind)),
                                    );
                            }
                            if upgrade_state.damage_multiplier > 1.0 {
                                let upgrade_kind = match target {
                                    UpgradeTargetType::Tower(tower_target) => {
                                        create_upgrade_kind_for_target(
                                            tower_target,
                                            UpgradeStatType::Damage,
                                            false,
                                            upgrade_state.damage_multiplier,
                                        )
                                    }
                                    UpgradeTargetType::TowerSelect(tower_select_target) => {
                                        create_tower_select_upgrade_kind(
                                            tower_select_target,
                                            UpgradeStatType::Damage,
                                            false,
                                            upgrade_state.damage_multiplier,
                                        )
                                    }
                                };
                                texts
                                    .damage
                                    .push(
                                        game_state
                                            .text()
                                            .upgrade_kind(UpgradeKindText::Description(&upgrade_kind)),
                                    );
                            }
                            if upgrade_state.speed_plus > 0.0 {
                                let upgrade_kind = match target {
                                    UpgradeTargetType::Tower(tower_target) => {
                                        create_upgrade_kind_for_target(
                                            tower_target,
                                            UpgradeStatType::Speed,
                                            true,
                                            upgrade_state.speed_plus,
                                        )
                                    }
                                    UpgradeTargetType::TowerSelect(tower_select_target) => {
                                        create_tower_select_upgrade_kind(
                                            tower_select_target,
                                            UpgradeStatType::Speed,
                                            true,
                                            upgrade_state.speed_plus,
                                        )
                                    }
                                };
                                texts
                                    .speed
                                    .push(
                                        game_state
                                            .text()
                                            .upgrade_kind(UpgradeKindText::Description(&upgrade_kind)),
                                    );
                            }
                            if upgrade_state.speed_multiplier > 1.0 {
                                let upgrade_kind = match target {
                                    UpgradeTargetType::Tower(tower_target) => {
                                        create_upgrade_kind_for_target(
                                            tower_target,
                                            UpgradeStatType::Speed,
                                            false,
                                            upgrade_state.speed_multiplier,
                                        )
                                    }
                                    UpgradeTargetType::TowerSelect(tower_select_target) => {
                                        create_tower_select_upgrade_kind(
                                            tower_select_target,
                                            UpgradeStatType::Speed,
                                            false,
                                            upgrade_state.speed_multiplier,
                                        )
                                    }
                                };
                                texts
                                    .speed
                                    .push(
                                        game_state
                                            .text()
                                            .upgrade_kind(UpgradeKindText::Description(&upgrade_kind)),
                                    );
                            }
                            if upgrade_state.range_plus > 0.0 {
                                let upgrade_kind = match target {
                                    UpgradeTargetType::Tower(tower_target) => {
                                        create_upgrade_kind_for_target(
                                            tower_target,
                                            UpgradeStatType::Range,
                                            true,
                                            upgrade_state.range_plus,
                                        )
                                    }
                                    UpgradeTargetType::TowerSelect(tower_select_target) => {
                                        create_tower_select_upgrade_kind(
                                            tower_select_target,
                                            UpgradeStatType::Range,
                                            true,
                                            upgrade_state.range_plus,
                                        )
                                    }
                                };
                                texts
                                    .range
                                    .push(
                                        game_state
                                            .text()
                                            .upgrade_kind(UpgradeKindText::Description(&upgrade_kind)),
                                    );
                            }
                        };
                        let apply_tower_upgrade_target = |target| {
                            let Some(upgrade_state) = game_state
                                .upgrade_state
                                .tower_upgrade_states
                                .get(&target) else {
                                return;
                            };
                            apply_upgrade(
                                upgrade_state,
                                &UpgradeTargetType::Tower(target),
                            );
                        };
                        let targets = [
                            TowerUpgradeTarget::Rank {
                                rank: tower_template.rank,
                            },
                            TowerUpgradeTarget::Suit {
                                suit: tower_template.suit,
                            },
                            TowerUpgradeTarget::TowerKind {
                                tower_kind: tower_template.kind,
                            },
                            TowerUpgradeTarget::EvenOdd {
                                even: tower_template.rank.is_even(),
                            },
                            TowerUpgradeTarget::FaceNumber {
                                face: tower_template.rank.is_face(),
                            },
                        ];
                        targets.into_iter().for_each(apply_tower_upgrade_target);
                        let mut apply_tower_select_upgrade_target = |target| {
                            let Some(upgrade_state) = game_state
                                .upgrade_state
                                .tower_select_upgrade_states
                                .get(&target) else {
                                return;
                            };
                            apply_upgrade(
                                upgrade_state,
                                &UpgradeTargetType::TowerSelect(target),
                            );
                        };
                        if tower_template.kind.is_low_card_tower() {
                            apply_tower_select_upgrade_target(
                                TowerSelectUpgradeTarget::LowCard,
                            );
                        }
                        let rerolled_count = game_state.rerolled_count;
                        if rerolled_count == 0 {
                            apply_tower_select_upgrade_target(
                                TowerSelectUpgradeTarget::NoReroll,
                            );
                        } else if let Some(upgrade_state) = game_state
                            .upgrade_state
                            .tower_select_upgrade_states
                            .get(&TowerSelectUpgradeTarget::Reroll)
                        {
                            for _ in 0..rerolled_count {
                                apply_upgrade(
                                    upgrade_state,
                                    &UpgradeTargetType::TowerSelect(
                                        TowerSelectUpgradeTarget::Reroll,
                                    ),
                                );
                            }
                        }
                        (state, texts)
                    }
                }
                mod tower_skill {
                    use crate::flow_ui::selecting_tower::tower_selecting_hand::PADDING;
                    use crate::icon::IconKind;
                    use crate::thumbnail::ThumbnailComposer;
                    use crate::thumbnail::constants::OVERLAY_SIZE_RATIO;
                    use crate::thumbnail::overlay_rendering::OverlayPosition;
                    use crate::{
                        game_state::tower::{TowerSkillKind, TowerSkillTemplate},
                        game_state::use_game_state, l10n::tower_skill::TowerSkillText,
                        theme::{
                            palette,
                            typography::{FontSize, TextAlign, headline, paragraph},
                        },
                    };
                    use namui::*;
                    use namui_prebuilt::{simple_rect, table};
                    const TOWER_EFFECT_DESCRIPTION_MAXWIDTH: Px = px(192.);
                    pub struct TowerSkillTemplateIcon<'a> {
                        pub wh: Wh<Px>,
                        pub skill: &'a TowerSkillTemplate,
                        pub on_mouse_move_in_effect_icon: &'a dyn Fn(
                            &TowerSkillTemplate,
                            Xy<Px>,
                        ),
                        pub on_mouse_move_out_effect_icon: &'a dyn Fn(
                            &TowerSkillTemplate,
                        ),
                    }
                    impl Component for TowerSkillTemplateIcon<'_> {
                        fn render(self, ctx: &RenderCtx) {
                            let Self {
                                wh,
                                skill,
                                on_mouse_move_in_effect_icon,
                                on_mouse_move_out_effect_icon,
                            } = self;
                            let thumbnail = compose_skill_thumbnail(wh, &skill.kind);
                            let bg = simple_rect(
                                wh,
                                palette::OUTLINE,
                                1.px(),
                                palette::SURFACE_CONTAINER_HIGH,
                            );
                            let composed = namui::render(
                                <[_]>::into_vec(::alloc::boxed::box_new([thumbnail, bg])),
                            );
                            ctx.add(composed)
                                .attach_event(|event| {
                                    match event {
                                        Event::MouseMove { event } => {
                                            match event.is_local_xy_in() {
                                                true => on_mouse_move_in_effect_icon(skill, event.global_xy),
                                                false => on_mouse_move_out_effect_icon(skill),
                                            };
                                        }
                                        Event::VisibilityChange => {
                                            on_mouse_move_out_effect_icon(skill);
                                        }
                                        _ => {}
                                    };
                                });
                        }
                    }
                    fn compose_skill_thumbnail(
                        wh: Wh<Px>,
                        kind: &TowerSkillKind,
                    ) -> RenderingTree {
                        match *kind {
                            TowerSkillKind::NearbyTowerDamageMul { .. } => {
                                ThumbnailComposer::new(wh)
                                    .with_icon_base(IconKind::AttackDamage)
                                    .add_icon_overlay(
                                        IconKind::Multiply,
                                        OverlayPosition::BottomRight,
                                        OVERLAY_SIZE_RATIO,
                                    )
                                    .build()
                            }
                            TowerSkillKind::NearbyTowerDamageAdd { .. } => {
                                ThumbnailComposer::new(wh)
                                    .with_icon_base(IconKind::AttackDamage)
                                    .add_plus_overlay()
                                    .build()
                            }
                            TowerSkillKind::NearbyTowerAttackSpeedAdd { .. } => {
                                ThumbnailComposer::new(wh)
                                    .with_icon_base(IconKind::AttackSpeed)
                                    .add_plus_overlay()
                                    .build()
                            }
                            TowerSkillKind::NearbyTowerAttackSpeedMul { .. } => {
                                ThumbnailComposer::new(wh)
                                    .with_icon_base(IconKind::AttackSpeed)
                                    .add_icon_overlay(
                                        IconKind::Multiply,
                                        OverlayPosition::BottomRight,
                                        OVERLAY_SIZE_RATIO,
                                    )
                                    .build()
                            }
                            TowerSkillKind::NearbyTowerAttackRangeAdd { .. } => {
                                ThumbnailComposer::new(wh)
                                    .with_icon_base(IconKind::AttackRange)
                                    .add_plus_overlay()
                                    .build()
                            }
                            TowerSkillKind::NearbyMonsterSpeedMul { mul, .. } => {
                                let dir_icon = if mul < 1.0 {
                                    IconKind::Down
                                } else {
                                    IconKind::Up
                                };
                                ThumbnailComposer::new(wh)
                                    .with_icon_base(IconKind::MoveSpeed)
                                    .add_icon_overlay(
                                        dir_icon,
                                        OverlayPosition::BottomRight,
                                        OVERLAY_SIZE_RATIO,
                                    )
                                    .build()
                            }
                            TowerSkillKind::MoneyIncomeAdd { .. } => {
                                ThumbnailComposer::new(wh)
                                    .with_icon_base(IconKind::Gold)
                                    .add_plus_overlay()
                                    .build()
                            }
                            TowerSkillKind::TopCardBonus { rank, .. } => {
                                ThumbnailComposer::new(wh)
                                    .with_icon_base(IconKind::AttackDamage)
                                    .add_rank_overlay(rank)
                                    .add_plus_overlay()
                                    .build()
                            }
                        }
                    }
                    pub(super) struct TowerEffectDescription<'a> {
                        pub skill: &'a TowerSkillTemplate,
                    }
                    impl Component for TowerEffectDescription<'_> {
                        fn render(self, ctx: &RenderCtx) {
                            let Self { skill } = self;
                            let game_state = use_game_state(ctx);
                            let title = match skill.kind {
                                TowerSkillKind::NearbyTowerDamageMul { .. } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerDamageMulTitle)
                                }
                                TowerSkillKind::NearbyTowerDamageAdd { .. } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerDamageAddTitle)
                                }
                                TowerSkillKind::NearbyTowerAttackSpeedAdd { .. } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerAttackSpeedAddTitle)
                                }
                                TowerSkillKind::NearbyTowerAttackSpeedMul { .. } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerAttackSpeedMulTitle)
                                }
                                TowerSkillKind::NearbyTowerAttackRangeAdd { .. } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerAttackRangeAddTitle)
                                }
                                TowerSkillKind::NearbyMonsterSpeedMul { .. } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyMonsterSpeedMulTitle)
                                }
                                TowerSkillKind::MoneyIncomeAdd { .. } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::MoneyIncomeAddTitle)
                                }
                                TowerSkillKind::TopCardBonus { .. } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::TopCardBonusTitle)
                                }
                            };
                            let description = match skill.kind {
                                TowerSkillKind::NearbyTowerDamageMul {
                                    mul,
                                    range_radius,
                                } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerDamageMulDesc {
                                            mul,
                                            range_radius: range_radius as usize,
                                        })
                                }
                                TowerSkillKind::NearbyTowerDamageAdd {
                                    add,
                                    range_radius,
                                } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerDamageAddDesc {
                                            add,
                                            range_radius: range_radius as usize,
                                        })
                                }
                                TowerSkillKind::NearbyTowerAttackSpeedAdd {
                                    add,
                                    range_radius,
                                } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerAttackSpeedAddDesc {
                                            add,
                                            range_radius: range_radius as usize,
                                        })
                                }
                                TowerSkillKind::NearbyTowerAttackSpeedMul {
                                    mul,
                                    range_radius,
                                } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerAttackSpeedMulDesc {
                                            mul,
                                            range_radius: range_radius as usize,
                                        })
                                }
                                TowerSkillKind::NearbyTowerAttackRangeAdd {
                                    add,
                                    range_radius,
                                } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyTowerAttackRangeAddDesc {
                                            add,
                                            range_radius: range_radius as usize,
                                        })
                                }
                                TowerSkillKind::NearbyMonsterSpeedMul {
                                    mul,
                                    range_radius,
                                } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::NearbyMonsterSpeedMulDesc {
                                            mul,
                                            range_radius: range_radius as usize,
                                        })
                                }
                                TowerSkillKind::MoneyIncomeAdd { add } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::MoneyIncomeAddDesc {
                                            add,
                                        })
                                }
                                TowerSkillKind::TopCardBonus { rank, bonus_damage } => {
                                    game_state
                                        .text()
                                        .tower_skill(TowerSkillText::TopCardBonusDesc {
                                            rank: ::alloc::__export::must_use({
                                                ::alloc::fmt::format(format_args!("{0:?}", rank))
                                            }),
                                            bonus_damage,
                                        })
                                }
                            };
                            ctx.compose(|ctx| {
                                let text_content = ctx
                                    .ghost_compose(
                                        "TowerEffect description tooltip",
                                        |ctx| {
                                            table::vertical([
                                                table::fit(
                                                    table::FitAlign::LeftTop,
                                                    |ctx| {
                                                        ctx.add(
                                                            headline(title)
                                                                .size(FontSize::Small)
                                                                .align(TextAlign::LeftTop)
                                                                .max_width(TOWER_EFFECT_DESCRIPTION_MAXWIDTH)
                                                                .build_rich(),
                                                        );
                                                    },
                                                ),
                                                table::fixed(PADDING, |_, _| {}),
                                                table::fit(
                                                    table::FitAlign::LeftTop,
                                                    |ctx| {
                                                        ctx.add(
                                                            paragraph(description)
                                                                .size(FontSize::Medium)
                                                                .align(TextAlign::LeftTop)
                                                                .max_width(TOWER_EFFECT_DESCRIPTION_MAXWIDTH)
                                                                .build_rich(),
                                                        );
                                                    },
                                                ),
                                            ])(
                                                Wh {
                                                    width: TOWER_EFFECT_DESCRIPTION_MAXWIDTH,
                                                    height: f32::MAX.px(),
                                                },
                                                ctx,
                                            );
                                        },
                                    );
                                let Some(text_content_wh) = text_content
                                    .bounding_box()
                                    .map(|rect| rect.wh()) else {
                                    return;
                                };
                                let ctx = ctx
                                    .translate((
                                        0.px(),
                                        -text_content_wh.height - PADDING * 2.0,
                                    ));
                                ctx.translate(Xy::single(PADDING)).add(text_content);
                                ctx.add(
                                    simple_rect(
                                        text_content_wh + Wh::single(PADDING * 2.0),
                                        palette::OUTLINE,
                                        1.px(),
                                        palette::SURFACE_CONTAINER_HIGH,
                                    ),
                                );
                            });
                        }
                    }
                }
                mod upgrade_helpers {
                    use crate::{
                        game_state::upgrade::{
                            TowerSelectUpgradeTarget, TowerUpgradeTarget, UpgradeKind,
                        },
                        *,
                    };
                    pub enum UpgradeStatType {
                        Damage,
                        Speed,
                        Range,
                    }
                    #[automatically_derived]
                    impl ::core::fmt::Debug for UpgradeStatType {
                        #[inline]
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            ::core::fmt::Formatter::write_str(
                                f,
                                match self {
                                    UpgradeStatType::Damage => "Damage",
                                    UpgradeStatType::Speed => "Speed",
                                    UpgradeStatType::Range => "Range",
                                },
                            )
                        }
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for UpgradeStatType {
                        #[inline]
                        fn clone(&self) -> UpgradeStatType {
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for UpgradeStatType {}
                    impl bincode::Encode for UpgradeStatType {
                        fn encode<__E: bincode::enc::Encoder>(
                            &self,
                            encoder: &mut __E,
                        ) -> core::result::Result<(), bincode::error::EncodeError> {
                            match self {
                                Self::Damage => {
                                    bincode::Encode::encode(&0u32, encoder)?;
                                }
                                Self::Speed => {
                                    bincode::Encode::encode(&1u32, encoder)?;
                                }
                                Self::Range => {
                                    bincode::Encode::encode(&2u32, encoder)?;
                                }
                            }
                            Ok(())
                        }
                    }
                    impl bincode::Decode<()> for UpgradeStatType {
                        fn decode<__D: bincode::de::Decoder<Context = ()>>(
                            decoder: &mut __D,
                        ) -> core::result::Result<Self, bincode::error::DecodeError> {
                            let discriminant: u32 = bincode::Decode::decode(decoder)?;
                            match discriminant {
                                0u32 => Ok(Self::Damage),
                                1u32 => Ok(Self::Speed),
                                2u32 => Ok(Self::Range),
                                _ => {
                                    Err(bincode::error::DecodeError::UnexpectedVariant {
                                        type_name: core::any::type_name::<Self>(),
                                        allowed: &bincode::error::AllowedEnumVariants::Range {
                                            min: 0,
                                            max: 2u32,
                                        },
                                        found: discriminant,
                                    })
                                }
                            }
                        }
                    }
                    impl Serialize for UpgradeStatType {
                        fn serialize(&self, buf: &mut Vec<u8>) {
                            buf.write_string(std::any::type_name::<Self>());
                            self.serialize_without_name(buf);
                        }
                        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                            match self {
                                Self::Damage => {
                                    buf.write_string("Damage");
                                }
                                Self::Speed => {
                                    buf.write_string("Speed");
                                }
                                Self::Range => {
                                    buf.write_string("Range");
                                }
                            }
                        }
                    }
                    impl Deserialize for UpgradeStatType {
                        fn deserialize(
                            buf: &mut &[u8],
                        ) -> Result<Self, DeserializeError> {
                            buf.read_name(std::any::type_name::<Self>())?;
                            Self::deserialize_without_name(buf)
                        }
                        fn deserialize_without_name(
                            buf: &mut &[u8],
                        ) -> Result<Self, DeserializeError> {
                            let variant_name = buf.read_string();
                            match variant_name.as_ref() {
                                "Damage" => Ok(Self::Damage),
                                "Speed" => Ok(Self::Speed),
                                "Range" => Ok(Self::Range),
                                _ => {
                                    Err(DeserializeError::InvalidEnumVariant {
                                        expected: std::any::type_name::<Self>().to_string(),
                                        actual: variant_name,
                                    })
                                }
                            }
                        }
                    }
                    pub enum UpgradeTargetType {
                        Tower(TowerUpgradeTarget),
                        TowerSelect(TowerSelectUpgradeTarget),
                    }
                    #[automatically_derived]
                    impl ::core::fmt::Debug for UpgradeTargetType {
                        #[inline]
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            match self {
                                UpgradeTargetType::Tower(__self_0) => {
                                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                                        f,
                                        "Tower",
                                        &__self_0,
                                    )
                                }
                                UpgradeTargetType::TowerSelect(__self_0) => {
                                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                                        f,
                                        "TowerSelect",
                                        &__self_0,
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for UpgradeTargetType {
                        #[inline]
                        fn clone(&self) -> UpgradeTargetType {
                            match self {
                                UpgradeTargetType::Tower(__self_0) => {
                                    UpgradeTargetType::Tower(
                                        ::core::clone::Clone::clone(__self_0),
                                    )
                                }
                                UpgradeTargetType::TowerSelect(__self_0) => {
                                    UpgradeTargetType::TowerSelect(
                                        ::core::clone::Clone::clone(__self_0),
                                    )
                                }
                            }
                        }
                    }
                    impl bincode::Encode for UpgradeTargetType {
                        fn encode<__E: bincode::enc::Encoder>(
                            &self,
                            encoder: &mut __E,
                        ) -> core::result::Result<(), bincode::error::EncodeError> {
                            match self {
                                Self::Tower(field0) => {
                                    bincode::Encode::encode(&0u32, encoder)?;
                                    bincode::Encode::encode(field0, encoder)?;
                                }
                                Self::TowerSelect(field0) => {
                                    bincode::Encode::encode(&1u32, encoder)?;
                                    bincode::Encode::encode(field0, encoder)?;
                                }
                            }
                            Ok(())
                        }
                    }
                    impl bincode::Decode<()> for UpgradeTargetType {
                        fn decode<__D: bincode::de::Decoder<Context = ()>>(
                            decoder: &mut __D,
                        ) -> core::result::Result<Self, bincode::error::DecodeError> {
                            let discriminant: u32 = bincode::Decode::decode(decoder)?;
                            match discriminant {
                                0u32 => Ok(Self::Tower(bincode::Decode::decode(decoder)?)),
                                1u32 => {
                                    Ok(Self::TowerSelect(bincode::Decode::decode(decoder)?))
                                }
                                _ => {
                                    Err(bincode::error::DecodeError::UnexpectedVariant {
                                        type_name: core::any::type_name::<Self>(),
                                        allowed: &bincode::error::AllowedEnumVariants::Range {
                                            min: 0,
                                            max: 1u32,
                                        },
                                        found: discriminant,
                                    })
                                }
                            }
                        }
                    }
                    impl Serialize for UpgradeTargetType {
                        fn serialize(&self, buf: &mut Vec<u8>) {
                            buf.write_string(std::any::type_name::<Self>());
                            self.serialize_without_name(buf);
                        }
                        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                            match self {
                                Self::Tower(field0) => {
                                    buf.write_string("Tower");
                                    field0.serialize_without_name(buf);
                                }
                                Self::TowerSelect(field0) => {
                                    buf.write_string("TowerSelect");
                                    field0.serialize_without_name(buf);
                                }
                            }
                        }
                    }
                    impl Deserialize for UpgradeTargetType {
                        fn deserialize(
                            buf: &mut &[u8],
                        ) -> Result<Self, DeserializeError> {
                            buf.read_name(std::any::type_name::<Self>())?;
                            Self::deserialize_without_name(buf)
                        }
                        fn deserialize_without_name(
                            buf: &mut &[u8],
                        ) -> Result<Self, DeserializeError> {
                            let variant_name = buf.read_string();
                            match variant_name.as_ref() {
                                "Tower" => {
                                    let field0 = {
                                        Deserialize::deserialize_without_name(buf)?
                                    };
                                    Ok(Self::Tower(field0))
                                }
                                "TowerSelect" => {
                                    let field0 = {
                                        Deserialize::deserialize_without_name(buf)?
                                    };
                                    Ok(Self::TowerSelect(field0))
                                }
                                _ => {
                                    Err(DeserializeError::InvalidEnumVariant {
                                        expected: std::any::type_name::<Self>().to_string(),
                                        actual: variant_name,
                                    })
                                }
                            }
                        }
                    }
                    /// TowerUpgradeTarget에서 적절한 UpgradeKind를 생성하는 함수
                    pub fn create_upgrade_kind_for_target(
                        target: &TowerUpgradeTarget,
                        stat_type: UpgradeStatType,
                        is_additive: bool,
                        value: f32,
                    ) -> UpgradeKind {
                        match (target, stat_type, is_additive) {
                            (
                                TowerUpgradeTarget::Rank { rank },
                                UpgradeStatType::Damage,
                                true,
                            ) => {
                                UpgradeKind::RankAttackDamagePlus {
                                    rank: *rank,
                                    damage_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::Rank { rank },
                                UpgradeStatType::Damage,
                                false,
                            ) => {
                                UpgradeKind::RankAttackDamageMultiply {
                                    rank: *rank,
                                    damage_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::Rank { rank },
                                UpgradeStatType::Speed,
                                true,
                            ) => {
                                UpgradeKind::RankAttackSpeedPlus {
                                    rank: *rank,
                                    speed_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::Rank { rank },
                                UpgradeStatType::Speed,
                                false,
                            ) => {
                                UpgradeKind::RankAttackSpeedMultiply {
                                    rank: *rank,
                                    speed_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::Rank { rank },
                                UpgradeStatType::Range,
                                true,
                            ) => {
                                UpgradeKind::RankAttackRangePlus {
                                    rank: *rank,
                                    range_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::Suit { suit },
                                UpgradeStatType::Damage,
                                true,
                            ) => {
                                UpgradeKind::SuitAttackDamagePlus {
                                    suit: *suit,
                                    damage_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::Suit { suit },
                                UpgradeStatType::Damage,
                                false,
                            ) => {
                                UpgradeKind::SuitAttackDamageMultiply {
                                    suit: *suit,
                                    damage_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::Suit { suit },
                                UpgradeStatType::Speed,
                                true,
                            ) => {
                                UpgradeKind::SuitAttackSpeedPlus {
                                    suit: *suit,
                                    speed_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::Suit { suit },
                                UpgradeStatType::Speed,
                                false,
                            ) => {
                                UpgradeKind::SuitAttackSpeedMultiply {
                                    suit: *suit,
                                    speed_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::Suit { suit },
                                UpgradeStatType::Range,
                                true,
                            ) => {
                                UpgradeKind::SuitAttackRangePlus {
                                    suit: *suit,
                                    range_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::TowerKind { tower_kind },
                                UpgradeStatType::Damage,
                                true,
                            ) => {
                                UpgradeKind::HandAttackDamagePlus {
                                    tower_kind: *tower_kind,
                                    damage_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::TowerKind { tower_kind },
                                UpgradeStatType::Damage,
                                false,
                            ) => {
                                UpgradeKind::HandAttackDamageMultiply {
                                    tower_kind: *tower_kind,
                                    damage_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::TowerKind { tower_kind },
                                UpgradeStatType::Speed,
                                true,
                            ) => {
                                UpgradeKind::HandAttackSpeedPlus {
                                    tower_kind: *tower_kind,
                                    speed_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::TowerKind { tower_kind },
                                UpgradeStatType::Speed,
                                false,
                            ) => {
                                UpgradeKind::HandAttackSpeedMultiply {
                                    tower_kind: *tower_kind,
                                    speed_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::TowerKind { tower_kind },
                                UpgradeStatType::Range,
                                true,
                            ) => {
                                UpgradeKind::HandAttackRangePlus {
                                    tower_kind: *tower_kind,
                                    range_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::EvenOdd { even },
                                UpgradeStatType::Damage,
                                true,
                            ) => {
                                UpgradeKind::EvenOddTowerAttackDamagePlus {
                                    even: *even,
                                    damage_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::EvenOdd { even },
                                UpgradeStatType::Damage,
                                false,
                            ) => {
                                UpgradeKind::EvenOddTowerAttackDamageMultiply {
                                    even: *even,
                                    damage_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::EvenOdd { even },
                                UpgradeStatType::Speed,
                                true,
                            ) => {
                                UpgradeKind::EvenOddTowerAttackSpeedPlus {
                                    even: *even,
                                    speed_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::EvenOdd { even },
                                UpgradeStatType::Speed,
                                false,
                            ) => {
                                UpgradeKind::EvenOddTowerAttackSpeedMultiply {
                                    even: *even,
                                    speed_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::EvenOdd { even },
                                UpgradeStatType::Range,
                                true,
                            ) => {
                                UpgradeKind::EvenOddTowerAttackRangePlus {
                                    even: *even,
                                    range_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::FaceNumber { face },
                                UpgradeStatType::Damage,
                                true,
                            ) => {
                                UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                                    face: *face,
                                    damage_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::FaceNumber { face },
                                UpgradeStatType::Damage,
                                false,
                            ) => {
                                UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                                    face: *face,
                                    damage_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::FaceNumber { face },
                                UpgradeStatType::Speed,
                                true,
                            ) => {
                                UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                                    face: *face,
                                    speed_plus: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::FaceNumber { face },
                                UpgradeStatType::Speed,
                                false,
                            ) => {
                                UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                                    face: *face,
                                    speed_multiplier: value,
                                }
                            }
                            (
                                TowerUpgradeTarget::FaceNumber { face },
                                UpgradeStatType::Range,
                                true,
                            ) => {
                                UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                                    face: *face,
                                    range_plus: value,
                                }
                            }
                            _ => UpgradeKind::GoldEarnPlus,
                        }
                    }
                    /// TowerSelectUpgradeTarget에서 적절한 UpgradeKind를 생성하는 함수
                    pub fn create_tower_select_upgrade_kind(
                        target: &TowerSelectUpgradeTarget,
                        stat_type: UpgradeStatType,
                        is_additive: bool,
                        value: f32,
                    ) -> UpgradeKind {
                        match (target, stat_type, is_additive) {
                            (
                                TowerSelectUpgradeTarget::LowCard,
                                UpgradeStatType::Damage,
                                true,
                            ) => {
                                UpgradeKind::LowCardTowerDamagePlus {
                                    damage_plus: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::LowCard,
                                UpgradeStatType::Damage,
                                false,
                            ) => {
                                UpgradeKind::LowCardTowerDamageMultiply {
                                    damage_multiplier: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::LowCard,
                                UpgradeStatType::Speed,
                                true,
                            ) => {
                                UpgradeKind::LowCardTowerAttackSpeedPlus {
                                    speed_plus: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::LowCard,
                                UpgradeStatType::Speed,
                                false,
                            ) => {
                                UpgradeKind::LowCardTowerAttackSpeedMultiply {
                                    speed_multiplier: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::LowCard,
                                UpgradeStatType::Range,
                                true,
                            ) => {
                                UpgradeKind::LowCardTowerAttackRangePlus {
                                    range_plus: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::NoReroll,
                                UpgradeStatType::Damage,
                                true,
                            ) => {
                                UpgradeKind::NoRerollTowerAttackDamagePlus {
                                    damage_plus: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::NoReroll,
                                UpgradeStatType::Damage,
                                false,
                            ) => {
                                UpgradeKind::NoRerollTowerAttackDamageMultiply {
                                    damage_multiplier: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::NoReroll,
                                UpgradeStatType::Speed,
                                true,
                            ) => {
                                UpgradeKind::NoRerollTowerAttackSpeedPlus {
                                    speed_plus: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::NoReroll,
                                UpgradeStatType::Speed,
                                false,
                            ) => {
                                UpgradeKind::NoRerollTowerAttackSpeedMultiply {
                                    speed_multiplier: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::NoReroll,
                                UpgradeStatType::Range,
                                true,
                            ) => {
                                UpgradeKind::NoRerollTowerAttackRangePlus {
                                    range_plus: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::Reroll,
                                UpgradeStatType::Damage,
                                true,
                            ) => {
                                UpgradeKind::RerollTowerAttackDamagePlus {
                                    damage_plus: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::Reroll,
                                UpgradeStatType::Damage,
                                false,
                            ) => {
                                UpgradeKind::RerollTowerAttackDamageMultiply {
                                    damage_multiplier: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::Reroll,
                                UpgradeStatType::Speed,
                                true,
                            ) => {
                                UpgradeKind::RerollTowerAttackSpeedPlus {
                                    speed_plus: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::Reroll,
                                UpgradeStatType::Speed,
                                false,
                            ) => {
                                UpgradeKind::RerollTowerAttackSpeedMultiply {
                                    speed_multiplier: value,
                                }
                            }
                            (
                                TowerSelectUpgradeTarget::Reroll,
                                UpgradeStatType::Range,
                                true,
                            ) => {
                                UpgradeKind::RerollTowerAttackRangePlus {
                                    range_plus: value,
                                }
                            }
                            _ => UpgradeKind::GoldEarnPlus,
                        }
                    }
                }
                pub use tower_preview_component::{TowerPreview, TowerPreviewContent};
            }
            pub use tower_preview::{TowerPreview, TowerPreviewContent};
            use crate::card::Card;
            use crate::game_state::flow::GameFlow;
            use crate::game_state::mutate_game_state;
            use crate::hand::{HAND_WH, Hand, HandComponent, HandSlotId};
            use crate::icon::{Icon, IconKind, IconSize};
            use crate::palette;
            use crate::theme::button::Button;
            use crate::theme::typography::{TextAlign, headline};
            use get_highest_tower::get_highest_tower_template;
            use namui::*;
            use namui_prebuilt::table;
            const PADDING: Px = px(4.);
            pub struct TowerSelectingHand<'a> {
                pub hand: &'a Hand<Card>,
            }
            impl<'a> Component for TowerSelectingHand<'a> {
                fn render(self, ctx: &RenderCtx) {
                    let Self { hand } = self;
                    let screen_wh = screen::size().into_type::<Px>();
                    let game_state = crate::game_state::use_game_state(ctx);
                    let selected_hand_slot_ids = ctx.track_eq(&hand.selected_slot_ids());
                    let some_selected = ctx.memo(|| !selected_hand_slot_ids.is_empty());
                    let using_cards = ctx
                        .memo(|| {
                            let slot_ids = {
                                let selected_slot_ids = hand.selected_slot_ids();
                                if !selected_slot_ids.is_empty() {
                                    selected_slot_ids
                                } else {
                                    hand.active_slot_ids()
                                }
                            };
                            hand.get_items(&slot_ids).cloned().collect::<Vec<Card>>()
                        });
                    let tower_template = ctx
                        .memo(|| {
                            get_highest_tower_template(
                                &using_cards,
                                &game_state.upgrade_state,
                                game_state.rerolled_count,
                            )
                        });
                    let reroll_selected = || {
                        if game_state.left_reroll_chance == 0
                            || selected_hand_slot_ids.is_empty()
                        {
                            return;
                        }
                        let selected_hand_slot_ids = selected_hand_slot_ids
                            .clone_inner();
                        mutate_game_state(move |game_state| {
                            if game_state.left_reroll_chance == 0
                                || selected_hand_slot_ids.is_empty()
                            {
                                return;
                            }
                            let health_cost = game_state
                                .stage_modifiers
                                .get_card_selection_hand_reroll_health_cost();
                            if (game_state.hp - health_cost as f32) < 1.0 {
                                return;
                            }
                            {
                                let GameFlow::SelectingTower(flow) = &mut game_state.flow
                                else {
                                    ::core::panicking::panic(
                                        "internal error: entered unreachable code",
                                    )
                                };
                                let select_count = selected_hand_slot_ids.len();
                                flow.hand.delete_slots(&selected_hand_slot_ids);
                                (0..select_count)
                                    .for_each(|_| {
                                        flow.hand.push(Card::new_random());
                                    });
                            }
                            game_state.left_reroll_chance -= 1;
                            game_state.rerolled_count += 1;
                            game_state.take_damage(health_cost as f32);
                        });
                    };
                    let on_card_click = |id: HandSlotId| {
                        mutate_game_state(move |game_state| {
                            let GameFlow::SelectingTower(flow) = &mut game_state.flow
                            else {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            };
                            if flow.hand.selected_slot_ids().contains(&id) {
                                flow.hand.deselect_slot(id);
                            } else {
                                flow.hand.select_slot(id);
                            }
                        });
                    };
                    let use_tower = || {
                        let tower_template = tower_template.clone_inner();
                        mutate_game_state(move |state| {
                            state.goto_placing_tower(tower_template);
                        });
                    };
                    ctx.compose(|ctx| {
                        table::vertical([
                            table::ratio_no_clip(1, |_, _| {}),
                            table::fixed_no_clip(
                                HAND_WH.height,
                                table::horizontal([
                                    table::ratio_no_clip(1, |_, _| {}),
                                    table::fixed_no_clip(
                                        HAND_WH.height,
                                        |wh, ctx| {
                                            ctx.add(TowerPreview {
                                                wh,
                                                tower_template: &tower_template,
                                            });
                                        },
                                    ),
                                    table::fixed_no_clip(
                                        HAND_WH.width,
                                        |_wh, ctx| {
                                            ctx.add(HandComponent {
                                                hand,
                                                on_click: &on_card_click,
                                            });
                                        },
                                    ),
                                    table::fixed(
                                        HAND_WH.height,
                                        table::padding(
                                            PADDING,
                                            |wh, ctx| {
                                                ctx.add(InteractionArea {
                                                    wh,
                                                    some_selected: *some_selected,
                                                    reroll_selected: &reroll_selected,
                                                    use_tower: &use_tower,
                                                });
                                            },
                                        ),
                                    ),
                                    table::ratio_no_clip(1, |_, _| {}),
                                ]),
                            ),
                        ])(screen_wh, ctx);
                    });
                }
            }
            struct InteractionArea<'a> {
                wh: Wh<Px>,
                some_selected: bool,
                reroll_selected: &'a dyn Fn(),
                use_tower: &'a dyn Fn(),
            }
            impl Component for InteractionArea<'_> {
                fn render(self, ctx: &RenderCtx) {
                    let Self { wh, some_selected, reroll_selected, use_tower } = self;
                    let game_state = crate::game_state::use_game_state(ctx);
                    ctx.compose(|ctx| {
                        table::padding(
                            PADDING,
                            table::vertical([
                                table::fixed(
                                    48.px(),
                                    |wh, ctx| {
                                        ctx.add(
                                            Button::new(
                                                    wh,
                                                    &|| {
                                                        reroll_selected();
                                                    },
                                                    &|wh, color, ctx| {
                                                        let health_cost = game_state
                                                            .stage_modifiers
                                                            .get_card_selection_hand_reroll_health_cost();
                                                        let mut text = ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!(
                                                                    "{0} {1}/{2}",
                                                                    Icon::new(IconKind::Refresh)
                                                                        .size(IconSize::Large)
                                                                        .wh(Wh::single(wh.height))
                                                                        .as_tag(),
                                                                    game_state.rerolled_count,
                                                                    game_state.rerolled_count + game_state.left_reroll_chance,
                                                                ),
                                                            )
                                                        });
                                                        if health_cost > 0 {
                                                            text.push_str(
                                                                &::alloc::__export::must_use({
                                                                    ::alloc::fmt::format(
                                                                        format_args!(
                                                                            " {0}",
                                                                            Icon::new(IconKind::Health)
                                                                                .size(IconSize::Small)
                                                                                .wh(Wh::single(wh.height * 0.5))
                                                                                .as_tag(),
                                                                        ),
                                                                    )
                                                                }),
                                                            );
                                                        }
                                                        ctx.add(
                                                            headline(text)
                                                                .color(color)
                                                                .align(TextAlign::Center { wh })
                                                                .build_rich(),
                                                        );
                                                    },
                                                )
                                                .disabled(
                                                    !some_selected || game_state.left_reroll_chance == 0
                                                        || {
                                                            let health_cost = game_state
                                                                .stage_modifiers
                                                                .get_card_selection_hand_reroll_health_cost();
                                                            (game_state.hp - health_cost as f32) < 1.0
                                                        },
                                                ),
                                        );
                                    },
                                ),
                                table::ratio(1, |_, _| {}),
                                table::fixed(
                                    48.px(),
                                    |wh, ctx| {
                                        ctx.add(
                                            Button::new(
                                                wh,
                                                &|| {
                                                    use_tower();
                                                },
                                                &|wh, _text_color, ctx| {
                                                    ctx.add(
                                                        Icon::new(IconKind::Accept).size(IconSize::Large).wh(wh),
                                                    );
                                                },
                                            ),
                                        );
                                    },
                                ),
                            ]),
                        )(wh, ctx);
                    });
                    ctx.add(
                        rect(RectParam {
                            rect: wh.to_rect(),
                            style: RectStyle {
                                stroke: Some(RectStroke {
                                    color: palette::OUTLINE,
                                    width: 1.px(),
                                    border_position: BorderPosition::Inside,
                                }),
                                fill: Some(RectFill {
                                    color: palette::SURFACE,
                                }),
                                round: Some(RectRound {
                                    radius: palette::ROUND,
                                }),
                            },
                        }),
                    );
                }
            }
        }
        pub use tower_selecting_hand::TowerPreviewContent;
        use crate::game_state::flow::SelectingTowerFlow;
        use namui::*;
        use shop_modal::ShopModal;
        use tower_selecting_hand::TowerSelectingHand;
        pub struct SelectingTowerUi<'a> {
            pub selecting_tower_flow: &'a SelectingTowerFlow,
        }
        impl Component for SelectingTowerUi<'_> {
            fn render(self, ctx: &RenderCtx) {
                let Self { selecting_tower_flow } = self;
                ctx.add(TowerSelectingHand {
                    hand: &selecting_tower_flow.hand,
                });
                ctx.add(ShopModal {
                    shop: &selecting_tower_flow.shop,
                });
            }
        }
    }
    mod selecting_upgrade {}
    use crate::game_state::{flow::GameFlow, use_game_state};
    use namui::*;
    pub use selecting_tower::TowerPreviewContent;
    pub struct FlowUi;
    impl Component for FlowUi {
        fn render(self, ctx: &RenderCtx) {
            let game_state = use_game_state(ctx);
            match &game_state.flow {
                GameFlow::Initializing => {}
                GameFlow::Contract(..) => {}
                GameFlow::SelectingTower(selecting_tower_flow) => {
                    ctx.add(selecting_tower::SelectingTowerUi {
                        selecting_tower_flow,
                    });
                }
                GameFlow::PlacingTower { hand: _ } => {
                    ctx.add(placing_tower::PlacingTowerUi);
                }
                GameFlow::Defense => {}
                GameFlow::SelectingUpgrade { upgrades: _ } => {}
                GameFlow::Result => {}
            };
        }
    }
}
mod game_speed_indicator {
    use crate::{
        game_state::{
            fast_forward::FastForwardMultiplier, mutate_game_state, use_game_state,
        },
        theme::typography::{TextAlign, paragraph},
        theme::{button::Button, palette},
    };
    use namui::*;
    use namui_prebuilt::table;
    pub struct GameSpeedIndicator;
    impl Component for GameSpeedIndicator {
        fn render(self, ctx: &RenderCtx) {
            let game_state = use_game_state(ctx);
            let current_speed_text = match game_state.fast_forward_multiplier {
                FastForwardMultiplier::X1 => "1x",
                FastForwardMultiplier::X2 => "2x",
                FastForwardMultiplier::X4 => "4x",
                FastForwardMultiplier::X8 => "8x",
                FastForwardMultiplier::X16 => "16x",
            };
            let slower_action = || {
                mutate_game_state(|game_state| {
                    game_state.fast_forward_multiplier = game_state
                        .fast_forward_multiplier
                        .prev();
                });
            };
            let default_action = || {
                mutate_game_state(|game_state| {
                    game_state.fast_forward_multiplier = FastForwardMultiplier::X1;
                });
            };
            let faster_action = || {
                mutate_game_state(|game_state| {
                    game_state.fast_forward_multiplier = game_state
                        .fast_forward_multiplier
                        .next();
                });
            };
            const PADDING: Px = px(8.);
            let content_wh = Wh::new(92.px(), 64.px());
            let container_wh = Wh::new(
                content_wh.width + (PADDING * 2.0),
                content_wh.height + (PADDING * 2.0),
            );
            ctx.translate((PADDING, PADDING))
                .compose(|ctx| {
                    table::vertical([
                        table::fixed(
                            32.px(),
                            |wh, ctx| {
                                ctx.add(
                                    paragraph(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!("Speed: {0}", current_speed_text),
                                                )
                                            }),
                                        )
                                        .align(TextAlign::Center { wh })
                                        .build(),
                                );
                            },
                        ),
                        table::fixed(
                            28.px(),
                            |_wh, ctx| {
                                table::horizontal([
                                    table::fixed(
                                        28.px(),
                                        |wh, ctx| {
                                            ctx.add(
                                                Button::new(
                                                        wh,
                                                        &slower_action,
                                                        &|wh, color, ctx| {
                                                            ctx.add(
                                                                paragraph("<<")
                                                                    .color(color)
                                                                    .align(TextAlign::Center { wh })
                                                                    .build(),
                                                            );
                                                        },
                                                    )
                                                    .disabled(
                                                        game_state.fast_forward_multiplier
                                                            == FastForwardMultiplier::X1,
                                                    ),
                                            );
                                        },
                                    ),
                                    table::fixed(
                                        36.px(),
                                        |wh, ctx| {
                                            ctx.add(
                                                Button::new(
                                                    wh,
                                                    &default_action,
                                                    &|wh, color, ctx| {
                                                        ctx.add(
                                                            paragraph("1x")
                                                                .color(color)
                                                                .align(TextAlign::Center { wh })
                                                                .build(),
                                                        );
                                                    },
                                                ),
                                            );
                                        },
                                    ),
                                    table::fixed(
                                        28.px(),
                                        |wh, ctx| {
                                            ctx.add(
                                                Button::new(
                                                        wh,
                                                        &faster_action,
                                                        &|wh, color, ctx| {
                                                            ctx.add(
                                                                paragraph(">>")
                                                                    .color(color)
                                                                    .align(TextAlign::Center { wh })
                                                                    .build(),
                                                            );
                                                        },
                                                    )
                                                    .disabled(
                                                        game_state.fast_forward_multiplier
                                                            == FastForwardMultiplier::X16,
                                                    ),
                                            );
                                        },
                                    ),
                                ])(Wh::new(92.px(), 28.px()), ctx);
                            },
                        ),
                    ])(content_wh, ctx);
                });
            ctx.add(
                rect(RectParam {
                    rect: container_wh.to_rect(),
                    style: RectStyle {
                        fill: Some(RectFill {
                            color: palette::SURFACE_CONTAINER,
                        }),
                        round: Some(RectRound {
                            radius: palette::ROUND,
                        }),
                        stroke: Some(RectStroke {
                            color: palette::OUTLINE,
                            width: 1.px(),
                            border_position: BorderPosition::Inside,
                        }),
                    },
                }),
            );
        }
    }
}
mod game_state {
    pub mod background {
        use crate::MapCoordF32;
        use namui::*;
        use namui_prebuilt::simple_rect;
        use rand::{Rng, thread_rng};
        pub struct Background {
            pub coord: MapCoordF32,
            kind: BackgroundKind,
            flip_horizontally: bool,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Background {
            #[inline]
            fn clone(&self) -> Background {
                let _: ::core::clone::AssertParamIsClone<MapCoordF32>;
                let _: ::core::clone::AssertParamIsClone<BackgroundKind>;
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Background {}
        impl bincode::Encode for Background {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.coord, encoder)?;
                bincode::Encode::encode(&self.kind, encoder)?;
                bincode::Encode::encode(&self.flip_horizontally, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Background {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    coord: bincode::Decode::decode(decoder)?,
                    kind: bincode::Decode::decode(decoder)?,
                    flip_horizontally: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Background {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("coord");
                self.coord.serialize_without_name(buf);
                buf.write_string("kind");
                self.kind.serialize_without_name(buf);
                buf.write_string("flip_horizontally");
                self.flip_horizontally.serialize_without_name(buf);
            }
        }
        impl Deserialize for Background {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("coord")?;
                let coord = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("kind")?;
                let kind = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("flip_horizontally")?;
                let flip_horizontally = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    coord,
                    kind,
                    flip_horizontally,
                })
            }
        }
        impl Component for &Background {
            fn render(self, ctx: &RenderCtx) {
                let image = self.kind.image();
                let image_wh = image.info().wh();
                ctx.compose(|mut ctx| {
                    if self.flip_horizontally {
                        ctx = ctx
                            .scale(Xy::new(-1.0, 1.0))
                            .translate((-image_wh.width, 0.px()));
                    }
                    ctx.add(
                        namui::image(ImageParam {
                            rect: Rect::from_xy_wh(Xy::zero(), image.info().wh()),
                            image,
                            style: ImageStyle {
                                fit: ImageFit::None,
                                paint: None,
                            },
                        }),
                    );
                });
                ctx.add(
                    simple_rect(image_wh, Color::TRANSPARENT, 0.px(), Color::TRANSPARENT),
                );
            }
        }
        pub enum BackgroundKind {
            Tile0,
            Tile1,
            Tile2,
            Tile3,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BackgroundKind {
            #[inline]
            fn clone(&self) -> BackgroundKind {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for BackgroundKind {}
        impl bincode::Encode for BackgroundKind {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Tile0 => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Tile1 => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::Tile2 => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::Tile3 => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for BackgroundKind {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Tile0),
                    1u32 => Ok(Self::Tile1),
                    2u32 => Ok(Self::Tile2),
                    3u32 => Ok(Self::Tile3),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 3u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for BackgroundKind {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Tile0 => {
                        buf.write_string("Tile0");
                    }
                    Self::Tile1 => {
                        buf.write_string("Tile1");
                    }
                    Self::Tile2 => {
                        buf.write_string("Tile2");
                    }
                    Self::Tile3 => {
                        buf.write_string("Tile3");
                    }
                }
            }
        }
        impl Deserialize for BackgroundKind {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Tile0" => Ok(Self::Tile0),
                    "Tile1" => Ok(Self::Tile1),
                    "Tile2" => Ok(Self::Tile2),
                    "Tile3" => Ok(Self::Tile3),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl BackgroundKind {
            pub fn image(self) -> Image {
                match self {
                    BackgroundKind::Tile0 => crate::asset::image::background::TILE0,
                    BackgroundKind::Tile1 => crate::asset::image::background::TILE1,
                    BackgroundKind::Tile2 => crate::asset::image::background::TILE2,
                    BackgroundKind::Tile3 => crate::asset::image::background::TILE3,
                }
            }
        }
        pub fn generate_backgrounds() -> Vec<Background> {
            let mut rng = thread_rng();
            let mut backgrounds = ::alloc::vec::Vec::new();
            for y in (-6)..12 {
                for x in (-6)..12 {
                    let coord = MapCoordF32::new(x as f32 * 8.0, y as f32 * 8.0);
                    backgrounds
                        .push(Background {
                            coord,
                            kind: match rng.gen_range(0..=3) {
                                0 => BackgroundKind::Tile0,
                                1 => BackgroundKind::Tile1,
                                2 => BackgroundKind::Tile2,
                                _ => BackgroundKind::Tile3,
                            },
                            flip_horizontally: rng.r#gen(),
                        });
                }
            }
            backgrounds
        }
    }
    mod camera {
        use super::*;
        pub struct Camera {
            pub left_top: MapCoordF32,
            pub zoom_level: f32,
        }
        impl bincode::Encode for Camera {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.left_top, encoder)?;
                bincode::Encode::encode(&self.zoom_level, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Camera {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    left_top: bincode::Decode::decode(decoder)?,
                    zoom_level: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Camera {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("left_top");
                self.left_top.serialize_without_name(buf);
                buf.write_string("zoom_level");
                self.zoom_level.serialize_without_name(buf);
            }
        }
        impl Deserialize for Camera {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("left_top")?;
                let left_top = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("zoom_level")?;
                let zoom_level = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { left_top, zoom_level })
            }
        }
        impl Default for Camera {
            fn default() -> Self {
                Self::new()
            }
        }
        impl Camera {
            pub fn new() -> Self {
                Self {
                    left_top: MapCoordF32::new(0.0, 0.0),
                    zoom_level: 1.0,
                }
            }
            pub fn zoom(&mut self, delta: f32, origin_screen_xy: Xy<Px>) {
                let screen_wh = screen::size().into_type::<Px>();
                let prev_zoom_level = self.zoom_level;
                let next_zoom_level = (self.zoom_level + delta)
                    .clamp(max_zoom_out_level(), 1.0);
                let tile_delta = ((screen_wh / TILE_PX_SIZE)
                    * (prev_zoom_level - next_zoom_level)
                    / (prev_zoom_level * next_zoom_level))
                    .to_xy();
                let ratio = origin_screen_xy / screen_wh.to_xy();
                self.left_top -= tile_delta * ratio;
                self.zoom_level = next_zoom_level;
                self.constrain_to_map();
            }
            pub fn move_by(&mut self, screen_px_xy: Xy<Px>) {
                let px_xy_on_1_0 = screen_px_xy / self.zoom_level;
                self.left_top
                    += Xy::new(
                        px_xy_on_1_0.x / TILE_PX_SIZE.width,
                        px_xy_on_1_0.y / TILE_PX_SIZE.height,
                    );
                self.constrain_to_map();
            }
            fn constrain_to_map(&mut self) {
                let screen_wh = screen::size().into_type::<Px>() / self.zoom_level;
                let half_screen_tiles = Xy::new(
                    screen_wh.width.as_f32() / (2.0 * TILE_PX_SIZE.width.as_f32()),
                    screen_wh.height.as_f32() / (2.0 * TILE_PX_SIZE.height.as_f32()),
                );
                self.left_top.x = self
                    .left_top
                    .x
                    .clamp(
                        -half_screen_tiles.x,
                        MAP_SIZE.width as f32 - half_screen_tiles.x,
                    );
                self.left_top.y = self
                    .left_top
                    .y
                    .clamp(
                        -half_screen_tiles.y,
                        MAP_SIZE.height as f32 - half_screen_tiles.y,
                    );
            }
        }
        fn max_zoom_out_level() -> f32 {
            let screen_wh = screen::size().map(|x| x.as_i32() as f32);
            let shorter_side = screen_wh.width.min(screen_wh.height) as f32;
            shorter_side / (MAP_SIZE.width as f32 * TILE_PX_SIZE.width.as_f32())
        }
    }
    pub mod can_place_tower {
        use super::*;
        pub fn can_place_tower(
            tower_left_top: MapCoord,
            tower_size: Wh<usize>,
            travel_points: &[MapCoord],
            placed_tower_coords: &[MapCoord],
            route_coords: &[MapCoord],
            map_wh: Wh<usize>,
        ) -> bool {
            let new_tower_coords = (0..tower_size.width)
                .flat_map(|x| {
                    (0..tower_size.height)
                        .map(move |y| MapCoord::new(x, y) + tower_left_top)
                })
                .collect::<Vec<_>>();
            for new_tower_coord in &new_tower_coords {
                let is_out_of_map = new_tower_coord.x >= map_wh.width
                    || new_tower_coord.y >= map_wh.height;
                let is_collided_to_other_tower = placed_tower_coords
                    .contains(new_tower_coord);
                let is_collided_to_travel_point = travel_points
                    .contains(new_tower_coord);
                if is_out_of_map || is_collided_to_other_tower
                    || is_collided_to_travel_point
                {
                    return false;
                }
            }
            let disrupts = find_all_disrupts(&new_tower_coords, placed_tower_coords);
            let all_tower_coords = {
                let mut coords = new_tower_coords;
                coords.extend_from_slice(placed_tower_coords);
                coords
            };
            let mut route_coords_queue = route_coords;
            for i in 0..travel_points.len() - 1 {
                let start = travel_points[i];
                let end = travel_points[i + 1];
                let section_route_coords = {
                    let index = route_coords_queue
                        .iter()
                        .position(|&coord| coord == end)
                        .unwrap();
                    let left = &route_coords_queue[index..];
                    let right = &route_coords_queue[..index + 1];
                    route_coords_queue = left;
                    right
                };
                if !is_disrupted(section_route_coords, &disrupts) {
                    continue;
                }
                let new_route = crate::route::find_shortest_route(
                    map_wh,
                    start,
                    end,
                    &all_tower_coords,
                );
                if new_route.is_none() {
                    return false;
                }
            }
            true
        }
        enum Disrupt {
            One { coord: MapCoord },
            Path { coord1: MapCoord, coord2: MapCoord },
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Disrupt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Disrupt::One { coord: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "One",
                            "coord",
                            &__self_0,
                        )
                    }
                    Disrupt::Path { coord1: __self_0, coord2: __self_1 } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "Path",
                            "coord1",
                            __self_0,
                            "coord2",
                            &__self_1,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Disrupt {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Disrupt {
            #[inline]
            fn eq(&self, other: &Disrupt) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            Disrupt::One { coord: __self_0 },
                            Disrupt::One { coord: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Disrupt::Path { coord1: __self_0, coord2: __self_1 },
                            Disrupt::Path { coord1: __arg1_0, coord2: __arg1_1 },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl bincode::Encode for Disrupt {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::One { coord } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(coord, encoder)?;
                    }
                    Self::Path { coord1, coord2 } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(coord1, encoder)?;
                        bincode::Encode::encode(coord2, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for Disrupt {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::One {
                            coord: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::Path {
                            coord1: bincode::Decode::decode(decoder)?,
                            coord2: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 1u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for Disrupt {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::One { coord } => {
                        buf.write_string("One");
                        buf.write_string("coord");
                        coord.serialize_without_name(buf);
                    }
                    Self::Path { coord1, coord2 } => {
                        buf.write_string("Path");
                        buf.write_string("coord1");
                        coord1.serialize_without_name(buf);
                        buf.write_string("coord2");
                        coord2.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for Disrupt {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "One" => {
                        let field_name = buf.read_name("coord")?;
                        let coord = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::One { coord })
                    }
                    "Path" => {
                        let field_name = buf.read_name("coord1")?;
                        let coord1 = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("coord2")?;
                        let coord2 = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Path { coord1, coord2 })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        fn find_all_disrupts(
            new_tower_coords: &[MapCoord],
            placed_tower_coords: &[MapCoord],
        ) -> Vec<Disrupt> {
            let mut disrupt = ::alloc::vec::Vec::new();
            for coord in new_tower_coords.iter().cloned() {
                disrupt.push(Disrupt::One { coord });
            }
            for placed_tower_coord in placed_tower_coords {
                for new_tower_coord in new_tower_coords {
                    let is_near_diagonal = {
                        placed_tower_coord.x.abs_diff(new_tower_coord.x) == 1
                            && placed_tower_coord.y.abs_diff(new_tower_coord.y) == 1
                    };
                    if !is_near_diagonal {
                        continue;
                    }
                    let coord1 = MapCoord::new(placed_tower_coord.x, new_tower_coord.y);
                    let coord2 = MapCoord::new(new_tower_coord.x, placed_tower_coord.y);
                    disrupt.push(Disrupt::Path { coord1, coord2 });
                }
            }
            disrupt
        }
        fn is_disrupted(route_coords: &[MapCoord], disrupts: &[Disrupt]) -> bool {
            disrupts
                .iter()
                .any(|disrupt| match disrupt {
                    Disrupt::One { coord } => route_coords.contains(coord),
                    &Disrupt::Path { coord1, coord2 } => {
                        route_coords
                            .windows(2)
                            .any(|window| {
                                window[0] == coord1 && window[1] == coord2
                                    || window[0] == coord2 && window[1] == coord1
                            })
                    }
                })
        }
    }
    pub mod contract {
        mod constants {
            //! Shared numeric balance constants & range tables for contract generation.
            //! Centralizing these makes balancing and tweaking easier.
            /// Stage duration weighted distribution (for stages 2..=10).
            /// Interpreted by `WeightedIndex` in the same order.
            pub const STAGE_DURATION_WEIGHTS: [u32; 9] = [8, 9, 5, 4, 3, 2, 1, 1, 1];
            pub const REWARD_HEAL_ON_SIGN: [(f32, f32); 4] = [
                (10.0, 15.0),
                (20.0, 25.0),
                (30.0, 35.0),
                (40.0, 46.0),
            ];
            pub const REWARD_EARN_GOLD: [(f32, f32); 4] = [
                (225.0, 251.0),
                (500.0, 551.0),
                (1000.0, 1251.0),
                (2000.0, 2501.0),
            ];
            pub const REWARD_INCREASE_TOWER_DAMAGE: [(f32, f32); 4] = [
                (1.01, 1.06),
                (1.05, 1.11),
                (1.10, 1.26),
                (1.25, 1.76),
            ];
            pub const REWARD_INCREASE_TOWER_RANGE: [(f32, f32); 4] = [
                (1.01, 1.06),
                (1.05, 1.11),
                (1.10, 1.26),
                (1.25, 1.51),
            ];
            pub const REWARD_DECREASE_INCOMING_DAMAGE: [(f32, f32); 4] = [
                (0.9, 0.95),
                (0.8, 0.9),
                (0.65, 0.8),
                (0.5, 0.65),
            ];
            pub const REWARD_INCREASE_GOLD_GAIN: [(f32, f32); 4] = [
                (1.25, 1.35),
                (1.35, 1.5),
                (1.5, 1.75),
                (1.75, 2.25),
            ];
            pub const RISK_LOSE_HEALTH: [(f32, f32); 4] = [
                (5.0, 10.0),
                (10.0, 15.0),
                (15.0, 20.0),
                (20.0, 26.0),
            ];
            pub const RISK_LOSE_GOLD: [(f32, f32); 4] = [
                (125.0, 151.0),
                (250.0, 301.0),
                (500.0, 751.0),
                (1000.0, 1501.0),
            ];
            pub const RISK_STAGE_LOSE_GOLD: [(f32, f32); 4] = [
                (10.0, 20.0),
                (20.0, 30.0),
                (30.0, 40.0),
                (40.0, 50.0),
            ];
            pub const RISK_DECREASE_TOWER_DAMAGE: (f32, f32) = (0.75, 0.95);
            pub const RISK_INCREASE_INCOMING_DAMAGE: (f32, f32) = (1.1, 2.0);
            pub const RISK_DECREASE_GOLD_GAIN_PERCENT: (f32, f32) = (0.1, 0.5);
            pub const RISK_REROLL_HEALTH_COST: (u32, u32) = (1, 5);
            pub const RISK_DECREASE_ENEMY_HEALTH_PERCENT: f32 = 10.0;
        }
        pub mod effect_kinds {
            use crate::*;
            pub enum ContractEffectType {
                OnSign,
                WhileActive,
                OnStageStart,
                OnExpire,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ContractEffectType {
                #[inline]
                fn clone(&self) -> ContractEffectType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ContractEffectType {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ContractEffectType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ContractEffectType {
                #[inline]
                fn eq(&self, other: &ContractEffectType) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            impl bincode::Encode for ContractEffectType {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::OnSign => {
                            bincode::Encode::encode(&0u32, encoder)?;
                        }
                        Self::WhileActive => {
                            bincode::Encode::encode(&1u32, encoder)?;
                        }
                        Self::OnStageStart => {
                            bincode::Encode::encode(&2u32, encoder)?;
                        }
                        Self::OnExpire => {
                            bincode::Encode::encode(&3u32, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for ContractEffectType {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => Ok(Self::OnSign),
                        1u32 => Ok(Self::WhileActive),
                        2u32 => Ok(Self::OnStageStart),
                        3u32 => Ok(Self::OnExpire),
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 3u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for ContractEffectType {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::OnSign => {
                            buf.write_string("OnSign");
                        }
                        Self::WhileActive => {
                            buf.write_string("WhileActive");
                        }
                        Self::OnStageStart => {
                            buf.write_string("OnStageStart");
                        }
                        Self::OnExpire => {
                            buf.write_string("OnExpire");
                        }
                    }
                }
            }
            impl Deserialize for ContractEffectType {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "OnSign" => Ok(Self::OnSign),
                        "WhileActive" => Ok(Self::WhileActive),
                        "OnStageStart" => Ok(Self::OnStageStart),
                        "OnExpire" => Ok(Self::OnExpire),
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
        }
        pub mod generation {
            use super::{
                Contract, ContractEffect, constants, effect_kinds::ContractEffectType,
            };
            use crate::{
                game_state::contract::{reward, risk},
                rarity::Rarity,
            };
            use rand::{RngCore, distributions::WeightedIndex, prelude::*, thread_rng};
            pub fn generate_contract(rarity: Rarity) -> Contract {
                let mut rng = thread_rng();
                generate_contract_with_rng(&mut rng, rarity)
            }
            pub fn generate_contract_with_rng(
                rng: &mut dyn RngCore,
                rarity: Rarity,
            ) -> Contract {
                let duration_stages = generate_duration_stages_with_rng(rng);
                let (risk_type, reward_type) = generate_contract_effect_types_with_rng(
                    rng,
                );
                let risk = generate_contract_effect_with_rng(
                    rng,
                    risk_type,
                    true,
                    rarity,
                    duration_stages,
                );
                let reward = generate_contract_effect_with_rng(
                    rng,
                    reward_type,
                    false,
                    rarity,
                    duration_stages,
                );
                Contract::new(rarity, duration_stages, risk, reward)
            }
            fn generate_duration_stages_with_rng(rng: &mut dyn RngCore) -> usize {
                let dist = WeightedIndex::new(constants::STAGE_DURATION_WEIGHTS)
                    .unwrap();
                let index = dist.sample(rng);
                2 + index
            }
            fn generate_contract_effect_types_with_rng(
                rng: &mut dyn RngCore,
            ) -> (ContractEffectType, ContractEffectType) {
                let types = [
                    ContractEffectType::OnSign,
                    ContractEffectType::WhileActive,
                    ContractEffectType::OnStageStart,
                    ContractEffectType::OnExpire,
                ];
                let risk_type = *types.choose(rng).unwrap();
                let available_types: Vec<_> = types
                    .into_iter()
                    .filter(|&t| t != risk_type)
                    .collect();
                let reward_type = *available_types.choose(rng).unwrap();
                (risk_type, reward_type)
            }
            fn generate_contract_effect_with_rng(
                rng: &mut dyn RngCore,
                effect_type: ContractEffectType,
                is_risk: bool,
                rarity: Rarity,
                duration_stages: usize,
            ) -> ContractEffect {
                let effect = if is_risk {
                    risk::generate_risk_effect_with_rng(
                        rng,
                        &effect_type,
                        rarity,
                        duration_stages,
                    )
                } else {
                    reward::generate_reward_effect_with_rng(
                        rng,
                        &effect_type,
                        rarity,
                        duration_stages,
                    )
                };
                match effect_type {
                    ContractEffectType::OnSign => ContractEffect::OnSign { effect },
                    ContractEffectType::WhileActive => {
                        ContractEffect::WhileActive {
                            effect,
                        }
                    }
                    ContractEffectType::OnStageStart => {
                        ContractEffect::OnStageStart {
                            effect,
                        }
                    }
                    ContractEffectType::OnExpire => ContractEffect::OnExpire { effect },
                }
            }
        }
        pub mod reward {
            pub mod on_expire {
                use super::types::RewardGeneratorFn;
                use crate::game_state::contract::{
                    constants::*, util::rarity_table_random,
                };
                use crate::game_state::effect::Effect;
                pub(crate) fn list() -> &'static [RewardGeneratorFn] {
                    const FNS: &[RewardGeneratorFn] = &[
                        |rng, rarity, _| Effect::Heal {
                            amount: rarity_table_random(
                                rng,
                                rarity,
                                &REWARD_HEAL_ON_SIGN,
                            ),
                        },
                        |rng, rarity, _| Effect::EarnGold {
                            amount: rarity_table_random(rng, rarity, &REWARD_EARN_GOLD)
                                as usize,
                        },
                        |_, rarity, _| Effect::GrantUpgrade { rarity },
                        |_, rarity, _| Effect::GrantItem { rarity },
                    ];
                    FNS
                }
            }
            pub mod on_sign {
                use super::types::RewardGeneratorFn;
                use crate::game_state::contract::{
                    constants::*, util::rarity_table_random,
                };
                use crate::game_state::effect::Effect;
                pub(crate) fn list() -> &'static [RewardGeneratorFn] {
                    const FNS: &[RewardGeneratorFn] = &[
                        |rng, rarity, _| Effect::Heal {
                            amount: rarity_table_random(
                                rng,
                                rarity,
                                &REWARD_HEAL_ON_SIGN,
                            ),
                        },
                        |rng, rarity, _| Effect::EarnGold {
                            amount: rarity_table_random(rng, rarity, &REWARD_EARN_GOLD)
                                as usize,
                        },
                        |_, rarity, _| Effect::GrantUpgrade { rarity },
                        |_, rarity, _| Effect::GrantItem { rarity },
                    ];
                    FNS
                }
            }
            pub mod on_stage_start {
                use super::types::RewardGeneratorFn;
                use crate::game_state::contract::{
                    constants::*,
                    util::{
                        distribute_per_stage, rarity_based_amount, rarity_table_random,
                    },
                };
                use crate::{game_state::effect::Effect, rarity::Rarity};
                pub(crate) fn list() -> &'static [RewardGeneratorFn] {
                    const FNS: &[RewardGeneratorFn] = &[
                        |_, rarity, _| Effect::AddBarricadeCardsToTowerPlacementHand {
                            count: rarity_based_amount(rarity, 1.0, 2.0, 3.0, 4.0)
                                as usize,
                        },
                        |_, rarity, _| Effect::GainShield {
                            min_amount: match rarity {
                                Rarity::Common => 1.0,
                                Rarity::Rare => 2.0,
                                Rarity::Epic => 4.0,
                                Rarity::Legendary => 7.0,
                            },
                            max_amount: match rarity {
                                Rarity::Common => 2.0,
                                Rarity::Rare => 3.0,
                                Rarity::Epic => 6.0,
                                Rarity::Legendary => 10.0,
                            },
                        },
                        |_, rarity, _| Effect::HealHealth {
                            min_amount: match rarity {
                                Rarity::Common => 10.0,
                                Rarity::Rare => 20.0,
                                Rarity::Epic => 30.0,
                                Rarity::Legendary => 40.0,
                            },
                            max_amount: match rarity {
                                Rarity::Common => 14.0,
                                Rarity::Rare => 24.0,
                                Rarity::Epic => 34.0,
                                Rarity::Legendary => 45.0,
                            },
                        },
                        |rng, rarity, duration| {
                            let total_gold = rarity_table_random(
                                rng,
                                rarity,
                                &REWARD_EARN_GOLD,
                            );
                            let (min_amount, max_amount) = distribute_per_stage(
                                total_gold,
                                duration,
                            );
                            Effect::GainGold {
                                min_amount,
                                max_amount,
                            }
                        },
                    ];
                    FNS
                }
            }
            pub mod types {
                use crate::{game_state::effect::Effect, rarity::Rarity};
                use rand::RngCore;
                pub type RewardGeneratorFn = fn(
                    rng: &mut dyn RngCore,
                    rarity: Rarity,
                    duration_stages: usize,
                ) -> Effect;
            }
            pub mod while_active {
                use super::types::RewardGeneratorFn;
                use crate::game_state::contract::{
                    constants::*, util::rarity_table_random,
                };
                use crate::game_state::effect::Effect;
                pub(crate) fn list() -> &'static [RewardGeneratorFn] {
                    const FNS: &[RewardGeneratorFn] = &[
                        |rng, rarity, _| Effect::IncreaseAllTowersDamage {
                            multiplier: rarity_table_random(
                                rng,
                                rarity,
                                &REWARD_INCREASE_TOWER_DAMAGE,
                            ),
                        },
                        |rng, rarity, _| Effect::IncreaseAllTowersAttackSpeed {
                            multiplier: rarity_table_random(
                                rng,
                                rarity,
                                &REWARD_INCREASE_TOWER_DAMAGE,
                            ),
                        },
                        |rng, rarity, _| Effect::IncreaseAllTowersRange {
                            multiplier: rarity_table_random(
                                rng,
                                rarity,
                                &REWARD_INCREASE_TOWER_RANGE,
                            ),
                        },
                        |rng, rarity, _| Effect::DecreaseIncomingDamage {
                            multiplier: rarity_table_random(
                                rng,
                                rarity,
                                &REWARD_DECREASE_INCOMING_DAMAGE,
                            ),
                        },
                        |rng, rarity, _| Effect::IncreaseGoldGain {
                            multiplier: rarity_table_random(
                                rng,
                                rarity,
                                &REWARD_INCREASE_GOLD_GAIN,
                            ),
                        },
                        |_, _, _| Effect::IncreaseCardSelectionHandMaxSlots {
                            bonus: 1,
                        },
                        |_, _, _| Effect::IncreaseCardSelectionHandMaxRerolls {
                            bonus: 1,
                        },
                        |_, _, _| Effect::IncreaseShopMaxRerolls {
                            bonus: 1,
                        },
                    ];
                    FNS
                }
            }
            use super::effect_kinds::ContractEffectType;
            use crate::{game_state::effect::Effect, rarity::Rarity};
            use rand::prelude::*;
            use types::RewardGeneratorFn;
            pub(crate) fn generate_reward_effect_with_rng(
                rng: &mut dyn rand::RngCore,
                effect_type: &ContractEffectType,
                rarity: Rarity,
                duration_stages: usize,
            ) -> Effect {
                let list: &[RewardGeneratorFn] = match effect_type {
                    ContractEffectType::OnSign => on_sign::list(),
                    ContractEffectType::WhileActive => while_active::list(),
                    ContractEffectType::OnStageStart => on_stage_start::list(),
                    ContractEffectType::OnExpire => on_expire::list(),
                };
                let generator = list.choose(rng).expect("reward effect list non-empty");
                generator(rng, rarity, duration_stages)
            }
        }
        pub mod risk {
            pub mod on_expire {
                use super::types::RiskGeneratorFn;
                use crate::game_state::contract::util::rarity_based_amount;
                use crate::game_state::effect::Effect;
                pub(crate) fn list() -> &'static [RiskGeneratorFn] {
                    const FNS: &[RiskGeneratorFn] = &[
                        |_, rarity, _| Effect::LoseHealthExpire {
                            min_amount: rarity_based_amount(
                                rarity,
                                5.0,
                                10.0,
                                15.0,
                                20.0,
                            ),
                            max_amount: rarity_based_amount(
                                rarity,
                                9.0,
                                14.0,
                                19.0,
                                25.0,
                            ),
                        },
                        |_, rarity, _| Effect::LoseGoldExpire {
                            min_amount: rarity_based_amount(
                                rarity,
                                125.0,
                                250.0,
                                500.0,
                                1000.0,
                            ),
                            max_amount: rarity_based_amount(
                                rarity,
                                150.0,
                                300.0,
                                750.0,
                                1500.0,
                            ),
                        },
                    ];
                    FNS
                }
            }
            pub mod on_sign {
                use super::types::RiskGeneratorFn;
                use crate::game_state::contract::{
                    constants::*, util::rarity_table_random,
                };
                use crate::game_state::effect::Effect;
                pub(crate) fn list() -> &'static [RiskGeneratorFn] {
                    const FNS: &[RiskGeneratorFn] = &[
                        |rng, rarity, _| Effect::LoseHealth {
                            amount: rarity_table_random(rng, rarity, &RISK_LOSE_HEALTH),
                        },
                        |rng, rarity, _| Effect::LoseGold {
                            amount: rarity_table_random(rng, rarity, &RISK_LOSE_GOLD)
                                as usize,
                        },
                        |_, _, _| Effect::AddChallengeMonster,
                    ];
                    FNS
                }
            }
            pub mod on_stage_start {
                use super::types::RiskGeneratorFn;
                use crate::game_state::contract::{
                    constants::*, util::{distribute_per_stage, rarity_table_random},
                };
                use crate::game_state::effect::Effect;
                pub(crate) fn list() -> &'static [RiskGeneratorFn] {
                    const FNS: &[RiskGeneratorFn] = &[
                        |rng, rarity, duration| {
                            let total = rarity_table_random(
                                rng,
                                rarity,
                                &RISK_LOSE_HEALTH,
                            );
                            let (min_amount, max_amount) = distribute_per_stage(
                                total,
                                duration,
                            );
                            Effect::LoseHealthRange {
                                min_amount,
                                max_amount,
                            }
                        },
                        |rng, rarity, duration| {
                            let total = rarity_table_random(
                                rng,
                                rarity,
                                &RISK_STAGE_LOSE_GOLD,
                            );
                            let (min_amount, max_amount) = distribute_per_stage(
                                total,
                                duration,
                            );
                            Effect::LoseGoldRange {
                                min_amount,
                                max_amount,
                            }
                        },
                    ];
                    FNS
                }
            }
            pub mod types {
                use crate::{game_state::effect::Effect, rarity::Rarity};
                use rand::RngCore;
                pub type RiskGeneratorFn = fn(
                    rng: &mut dyn RngCore,
                    rarity: Rarity,
                    duration_stages: usize,
                ) -> Effect;
            }
            pub mod while_active {
                use super::types::RiskGeneratorFn;
                use crate::game_state::contract::constants::*;
                use crate::{
                    card::{Rank, SUITS},
                    game_state::effect::Effect,
                };
                use rand::prelude::*;
                pub(crate) fn list() -> &'static [RiskGeneratorFn] {
                    const FNS: &[RiskGeneratorFn] = &[
                        |rng, _, _| Effect::DecreaseAllTowersDamage {
                            multiplier: rng
                                .gen_range(
                                    RISK_DECREASE_TOWER_DAMAGE.0..RISK_DECREASE_TOWER_DAMAGE.1,
                                ),
                        },
                        |rng, _, _| Effect::IncreaseIncomingDamage {
                            multiplier: rng
                                .gen_range(
                                    RISK_INCREASE_INCOMING_DAMAGE
                                        .0..RISK_INCREASE_INCOMING_DAMAGE.1,
                                ),
                        },
                        |rng, _, _| Effect::DecreaseGoldGainPercent {
                            reduction_percentage: rng
                                .gen_range(
                                    RISK_DECREASE_GOLD_GAIN_PERCENT
                                        .0..RISK_DECREASE_GOLD_GAIN_PERCENT.1,
                                ),
                        },
                        |_, _, _| Effect::DisableItemAndUpgradePurchases,
                        |_, _, _| Effect::DisableItemUse,
                        |_, _, _| Effect::DecreaseCardSelectionHandMaxSlots {
                            penalty: 1,
                        },
                        |_, _, _| Effect::DecreaseCardSelectionHandMaxRerolls {
                            penalty: 1,
                        },
                        |_, _, _| Effect::DecreaseShopMaxRerolls {
                            penalty: 1,
                        },
                        |rng, _, _| Effect::AddCardSelectionHandRerollHealthCost {
                            cost: rng
                                .gen_range(
                                    RISK_REROLL_HEALTH_COST.0..=RISK_REROLL_HEALTH_COST.1,
                                ) as usize,
                        },
                        |rng, _, _| Effect::AddShopRerollHealthCost {
                            cost: rng
                                .gen_range(
                                    RISK_REROLL_HEALTH_COST.0..=RISK_REROLL_HEALTH_COST.1,
                                ) as usize,
                        },
                        |_, _, _| Effect::DecreaseEnemyHealthPercent {
                            percentage: RISK_DECREASE_ENEMY_HEALTH_PERCENT,
                        },
                        |rng, _, _| {
                            let ranks = [
                                Rank::Seven,
                                Rank::Eight,
                                Rank::Nine,
                                Rank::Ten,
                                Rank::Jack,
                                Rank::Queen,
                                Rank::King,
                                Rank::Ace,
                            ];
                            let rank = ranks.choose(rng).unwrap();
                            Effect::RankTowerDisable {
                                rank: *rank,
                            }
                        },
                        |rng, _, _| {
                            let suit = SUITS.choose(rng).unwrap();
                            Effect::SuitTowerDisable {
                                suit: *suit,
                            }
                        },
                    ];
                    FNS
                }
            }
            use super::effect_kinds::ContractEffectType;
            use crate::{game_state::effect::Effect, rarity::Rarity};
            use rand::prelude::*;
            use types::RiskGeneratorFn;
            pub(crate) fn generate_risk_effect_with_rng(
                rng: &mut dyn rand::RngCore,
                effect_type: &ContractEffectType,
                rarity: Rarity,
                duration_stages: usize,
            ) -> Effect {
                let list: &[RiskGeneratorFn] = match effect_type {
                    ContractEffectType::OnSign => on_sign::list(),
                    ContractEffectType::WhileActive => while_active::list(),
                    ContractEffectType::OnStageStart => on_stage_start::list(),
                    ContractEffectType::OnExpire => on_expire::list(),
                };
                let generator = list.choose(rng).expect("risk effect list non-empty");
                generator(rng, rarity, duration_stages)
            }
        }
        mod util {
            use crate::rarity::Rarity;
            use rand::{Rng, RngCore};
            /// 고정 rarity 값에 따른 숫자 선택
            pub(crate) fn rarity_based_amount(
                rarity: Rarity,
                common: f32,
                rare: f32,
                epic: f32,
                legendary: f32,
            ) -> f32 {
                match rarity {
                    Rarity::Common => common,
                    Rarity::Rare => rare,
                    Rarity::Epic => epic,
                    Rarity::Legendary => legendary,
                }
            }
            /// 간결화를 위한 헬퍼: (f32,f32) 튜플 4개짜리 rarity 테이블에서 해당 rarity 구간을 뽑아 난수.
            /// 기존 `rarity_based_random_amount_with_rng` 가 4개의 Range 를 직접 받는 패턴 중복을 줄이기 위해 추가.
            pub(crate) fn rarity_table_random(
                rng: &mut dyn RngCore,
                rarity: Rarity,
                table: &[(f32, f32); 4],
            ) -> f32 {
                let (lo, hi) = match rarity {
                    Rarity::Common => table[0],
                    Rarity::Rare => table[1],
                    Rarity::Epic => table[2],
                    Rarity::Legendary => table[3],
                };
                rng.gen_range(lo..hi)
            }
            /// Stage 단위로 total 값을 duration 에 나누어 (0.8x, 1.2x) 범위로 정수 경계 보정.
            /// 동일 패턴이 reward / risk stage start 생성 코드에 3회 반복되어 추출.
            /// 분포 범위를 조정하려면 아래 상수만 수정하면 된다.
            pub(crate) const STAGE_DISTRIBUTION_MIN_MULTIPLIER: f32 = 0.8;
            pub(crate) const STAGE_DISTRIBUTION_MAX_MULTIPLIER: f32 = 1.2;
            pub(crate) fn distribute_per_stage(
                total: f32,
                duration_stages: usize,
            ) -> (f32, f32) {
                let base = (total / duration_stages as f32).max(1.0);
                let min_amount = (base * STAGE_DISTRIBUTION_MIN_MULTIPLIER).floor();
                let max_amount = (base * STAGE_DISTRIBUTION_MAX_MULTIPLIER).ceil();
                (min_amount, max_amount)
            }
        }
        use crate::{
            game_state::{GameState, effect::{Effect, run_effect}},
            rarity::Rarity, *,
        };
        use std::fmt::Display;
        use std::sync::atomic::AtomicUsize;
        pub enum ContractEffect {
            OnSign { effect: Effect },
            WhileActive { effect: Effect },
            OnStageStart { effect: Effect },
            OnExpire { effect: Effect },
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ContractEffect {
            #[inline]
            fn clone(&self) -> ContractEffect {
                match self {
                    ContractEffect::OnSign { effect: __self_0 } => {
                        ContractEffect::OnSign {
                            effect: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    ContractEffect::WhileActive { effect: __self_0 } => {
                        ContractEffect::WhileActive {
                            effect: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    ContractEffect::OnStageStart { effect: __self_0 } => {
                        ContractEffect::OnStageStart {
                            effect: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    ContractEffect::OnExpire { effect: __self_0 } => {
                        ContractEffect::OnExpire {
                            effect: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ContractEffect {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ContractEffect::OnSign { effect: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "OnSign",
                            "effect",
                            &__self_0,
                        )
                    }
                    ContractEffect::WhileActive { effect: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "WhileActive",
                            "effect",
                            &__self_0,
                        )
                    }
                    ContractEffect::OnStageStart { effect: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "OnStageStart",
                            "effect",
                            &__self_0,
                        )
                    }
                    ContractEffect::OnExpire { effect: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "OnExpire",
                            "effect",
                            &__self_0,
                        )
                    }
                }
            }
        }
        impl bincode::Encode for ContractEffect {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::OnSign { effect } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(effect, encoder)?;
                    }
                    Self::WhileActive { effect } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(effect, encoder)?;
                    }
                    Self::OnStageStart { effect } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(effect, encoder)?;
                    }
                    Self::OnExpire { effect } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(effect, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for ContractEffect {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::OnSign {
                            effect: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::WhileActive {
                            effect: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => {
                        Ok(Self::OnStageStart {
                            effect: bincode::Decode::decode(decoder)?,
                        })
                    }
                    3u32 => {
                        Ok(Self::OnExpire {
                            effect: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 3u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for ContractEffect {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::OnSign { effect } => {
                        buf.write_string("OnSign");
                        buf.write_string("effect");
                        effect.serialize_without_name(buf);
                    }
                    Self::WhileActive { effect } => {
                        buf.write_string("WhileActive");
                        buf.write_string("effect");
                        effect.serialize_without_name(buf);
                    }
                    Self::OnStageStart { effect } => {
                        buf.write_string("OnStageStart");
                        buf.write_string("effect");
                        effect.serialize_without_name(buf);
                    }
                    Self::OnExpire { effect } => {
                        buf.write_string("OnExpire");
                        buf.write_string("effect");
                        effect.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for ContractEffect {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "OnSign" => {
                        let field_name = buf.read_name("effect")?;
                        let effect = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::OnSign { effect })
                    }
                    "WhileActive" => {
                        let field_name = buf.read_name("effect")?;
                        let effect = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::WhileActive { effect })
                    }
                    "OnStageStart" => {
                        let field_name = buf.read_name("effect")?;
                        let effect = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::OnStageStart { effect })
                    }
                    "OnExpire" => {
                        let field_name = buf.read_name("effect")?;
                        let effect = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::OnExpire { effect })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub enum ContractStatus {
            Pending { duration_stages: usize },
            Active { remaining_stages: usize },
            Expired,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ContractStatus {
            #[inline]
            fn clone(&self) -> ContractStatus {
                let _: ::core::clone::AssertParamIsClone<usize>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ContractStatus {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ContractStatus::Pending { duration_stages: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Pending",
                            "duration_stages",
                            &__self_0,
                        )
                    }
                    ContractStatus::Active { remaining_stages: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Active",
                            "remaining_stages",
                            &__self_0,
                        )
                    }
                    ContractStatus::Expired => {
                        ::core::fmt::Formatter::write_str(f, "Expired")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ContractStatus {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ContractStatus {
            #[inline]
            fn eq(&self, other: &ContractStatus) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            ContractStatus::Pending { duration_stages: __self_0 },
                            ContractStatus::Pending { duration_stages: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            ContractStatus::Active { remaining_stages: __self_0 },
                            ContractStatus::Active { remaining_stages: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ContractStatus {}
        impl bincode::Encode for ContractStatus {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Pending { duration_stages } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(duration_stages, encoder)?;
                    }
                    Self::Active { remaining_stages } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(remaining_stages, encoder)?;
                    }
                    Self::Expired => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for ContractStatus {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::Pending {
                            duration_stages: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::Active {
                            remaining_stages: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => Ok(Self::Expired),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 2u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for ContractStatus {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Pending { duration_stages } => {
                        buf.write_string("Pending");
                        buf.write_string("duration_stages");
                        duration_stages.serialize_without_name(buf);
                    }
                    Self::Active { remaining_stages } => {
                        buf.write_string("Active");
                        buf.write_string("remaining_stages");
                        remaining_stages.serialize_without_name(buf);
                    }
                    Self::Expired => {
                        buf.write_string("Expired");
                    }
                }
            }
        }
        impl Deserialize for ContractStatus {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Pending" => {
                        let field_name = buf.read_name("duration_stages")?;
                        let duration_stages = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::Pending { duration_stages })
                    }
                    "Active" => {
                        let field_name = buf.read_name("remaining_stages")?;
                        let remaining_stages = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::Active { remaining_stages })
                    }
                    "Expired" => Ok(Self::Expired),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl Display for ContractStatus {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let n = match self {
                    ContractStatus::Pending { duration_stages: n }
                    | ContractStatus::Active { remaining_stages: n } => *n,
                    ContractStatus::Expired => 0,
                };
                f.write_fmt(format_args!("S-{0}", n))
            }
        }
        pub type ContractId = usize;
        pub struct Contract {
            pub id: usize,
            pub rarity: Rarity,
            pub status: ContractStatus,
            pub risk: ContractEffect,
            pub reward: ContractEffect,
            /// Events generated by this contract that are pending to be processed
            pending_events: Vec<ContractEvent>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Contract {
            #[inline]
            fn clone(&self) -> Contract {
                Contract {
                    id: ::core::clone::Clone::clone(&self.id),
                    rarity: ::core::clone::Clone::clone(&self.rarity),
                    status: ::core::clone::Clone::clone(&self.status),
                    risk: ::core::clone::Clone::clone(&self.risk),
                    reward: ::core::clone::Clone::clone(&self.reward),
                    pending_events: ::core::clone::Clone::clone(&self.pending_events),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Contract {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "rarity",
                    "status",
                    "risk",
                    "reward",
                    "pending_events",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.rarity,
                    &self.status,
                    &self.risk,
                    &self.reward,
                    &&self.pending_events,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Contract",
                    names,
                    values,
                )
            }
        }
        impl bincode::Encode for Contract {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.id, encoder)?;
                bincode::Encode::encode(&self.rarity, encoder)?;
                bincode::Encode::encode(&self.status, encoder)?;
                bincode::Encode::encode(&self.risk, encoder)?;
                bincode::Encode::encode(&self.reward, encoder)?;
                bincode::Encode::encode(&self.pending_events, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Contract {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    id: bincode::Decode::decode(decoder)?,
                    rarity: bincode::Decode::decode(decoder)?,
                    status: bincode::Decode::decode(decoder)?,
                    risk: bincode::Decode::decode(decoder)?,
                    reward: bincode::Decode::decode(decoder)?,
                    pending_events: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Contract {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("id");
                self.id.serialize_without_name(buf);
                buf.write_string("rarity");
                self.rarity.serialize_without_name(buf);
                buf.write_string("status");
                self.status.serialize_without_name(buf);
                buf.write_string("risk");
                self.risk.serialize_without_name(buf);
                buf.write_string("reward");
                self.reward.serialize_without_name(buf);
                buf.write_string("pending_events");
                self.pending_events.serialize_without_name(buf);
            }
        }
        impl Deserialize for Contract {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("id")?;
                let id = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("rarity")?;
                let rarity = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("status")?;
                let status = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("risk")?;
                let risk = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("reward")?;
                let reward = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("pending_events")?;
                let pending_events = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    id,
                    rarity,
                    status,
                    risk,
                    reward,
                    pending_events,
                })
            }
        }
        impl Contract {
            pub fn new(
                rarity: Rarity,
                duration_stages: usize,
                risk: ContractEffect,
                reward: ContractEffect,
            ) -> Self {
                static ID: AtomicUsize = AtomicUsize::new(1);
                Contract {
                    id: ID.fetch_add(1, std::sync::atomic::Ordering::Relaxed),
                    rarity,
                    status: ContractStatus::Pending {
                        duration_stages,
                    },
                    risk,
                    reward,
                    pending_events: Vec::new(),
                }
            }
            pub fn on_sign_effects(&self) -> Vec<&Effect> {
                [&self.reward, &self.risk]
                    .iter()
                    .filter_map(|contract_effect| {
                        if let ContractEffect::OnSign { effect } = contract_effect {
                            Some(effect)
                        } else {
                            None
                        }
                    })
                    .collect()
            }
            pub fn while_active_effects(&self) -> Vec<&Effect> {
                [&self.reward, &self.risk]
                    .iter()
                    .filter_map(|contract_effect| {
                        if let ContractEffect::WhileActive { effect } = contract_effect {
                            Some(effect)
                        } else {
                            None
                        }
                    })
                    .collect()
            }
            pub fn on_stage_start_effects(&self) -> Vec<&Effect> {
                [&self.reward, &self.risk]
                    .iter()
                    .filter_map(|contract_effect| {
                        if let ContractEffect::OnStageStart { effect } = contract_effect {
                            Some(effect)
                        } else {
                            None
                        }
                    })
                    .collect()
            }
            pub fn on_expire_effects(&self) -> Vec<&Effect> {
                [&self.reward, &self.risk]
                    .iter()
                    .filter_map(|contract_effect| {
                        if let ContractEffect::OnExpire { effect } = contract_effect {
                            Some(effect)
                        } else {
                            None
                        }
                    })
                    .collect()
            }
            /// Advances the contract to the next stage and stores events internally.
            /// This follows Command pattern - only modifies state, doesn't return events.
            /// Use `drain_events()` to retrieve generated events after stepping.
            pub fn step_stage(&mut self) {
                let previous_status = self.status;
                match &mut self.status {
                    ContractStatus::Pending { duration_stages } => {
                        self.status = ContractStatus::Active {
                            remaining_stages: *duration_stages,
                        };
                    }
                    ContractStatus::Active { remaining_stages } => {
                        if *remaining_stages > 0 {
                            *remaining_stages -= 1;
                        }
                        if *remaining_stages == 0 {
                            self.status = ContractStatus::Expired;
                        }
                    }
                    ContractStatus::Expired => {
                        {
                            ::std::io::_eprint(
                                format_args!(
                                    "Warning: Attempting to step expired contract (id: {0})\n",
                                    self.id,
                                ),
                            );
                        };
                        return;
                    }
                }
                let events = self
                    .generate_transition_events(previous_status, self.status);
                self.pending_events.extend(events);
            }
            /// Drains all pending events from this contract.
            /// This follows Query pattern - only returns data, doesn't modify state.
            pub fn drain_events(&mut self) -> Vec<ContractEvent> {
                std::mem::take(&mut self.pending_events)
            }
            /// Generates events based on status transition.
            fn generate_transition_events(
                &self,
                from_status: ContractStatus,
                to_status: ContractStatus,
            ) -> Vec<ContractEvent> {
                match (from_status, to_status) {
                    (ContractStatus::Pending { .. }, ContractStatus::Active { .. }) => {
                        let mut events = self
                            .create_events_from_effects(&self.on_stage_start_effects());
                        events
                            .extend(
                                self
                                    .create_events_from_effects(&self.while_active_effects()),
                            );
                        events
                    }
                    (ContractStatus::Active { .. }, ContractStatus::Expired) => {
                        self.create_events_from_effects(&self.on_expire_effects())
                    }
                    (ContractStatus::Active { .. }, ContractStatus::Active { .. }) => {
                        let mut events = self
                            .create_events_from_effects(&self.on_stage_start_effects());
                        events
                            .extend(
                                self
                                    .create_events_from_effects(&self.while_active_effects()),
                            );
                        events
                    }
                    _ => ::alloc::vec::Vec::new(),
                }
            }
            /// Creates ContractEvents from a list of effects.
            fn create_events_from_effects(
                &self,
                effects: &[&Effect],
            ) -> Vec<ContractEvent> {
                effects
                    .iter()
                    .map(|effect| ContractEvent {
                        contract_id: self.id,
                        effect: (*effect).clone(),
                    })
                    .collect()
            }
            pub fn is_expired(&self) -> bool {
                #[allow(non_exhaustive_omitted_patterns)]
                match self.status {
                    ContractStatus::Expired => true,
                    _ => false,
                }
            }
        }
        #[allow(dead_code)]
        pub fn sign_contract(game_state: &mut GameState, contract: Contract) {
            contract
                .on_sign_effects()
                .iter()
                .for_each(|effect| {
                    run_effect(game_state, effect);
                });
            game_state.contracts.push(contract);
        }
        pub struct ContractEvent {
            pub contract_id: ContractId,
            pub effect: Effect,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ContractEvent {
            #[inline]
            fn clone(&self) -> ContractEvent {
                ContractEvent {
                    contract_id: ::core::clone::Clone::clone(&self.contract_id),
                    effect: ::core::clone::Clone::clone(&self.effect),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ContractEvent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "ContractEvent",
                    "contract_id",
                    &self.contract_id,
                    "effect",
                    &&self.effect,
                )
            }
        }
        impl bincode::Encode for ContractEvent {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.contract_id, encoder)?;
                bincode::Encode::encode(&self.effect, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for ContractEvent {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    contract_id: bincode::Decode::decode(decoder)?,
                    effect: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for ContractEvent {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("contract_id");
                self.contract_id.serialize_without_name(buf);
                buf.write_string("effect");
                self.effect.serialize_without_name(buf);
            }
        }
        impl Deserialize for ContractEvent {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("contract_id")?;
                let contract_id = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("effect")?;
                let effect = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { contract_id, effect })
            }
        }
    }
    pub mod cursor_preview {
        pub mod tower {
            use crate::{
                MapCoordF32,
                game_state::{
                    MAP_SIZE, TILE_PX_SIZE, TRAVEL_POINTS,
                    can_place_tower::can_place_tower, flow::GameFlow, hand::HandSlotId,
                    mutate_game_state, place_tower,
                    tower::{
                        AnimationKind, Tower, TowerTemplate,
                        render::TowerImage as TowerImageTrait,
                    },
                    use_game_state,
                },
                palette,
            };
            use namui::*;
            pub struct TowerCursorPreview<'a> {
                pub tower_template: &'a TowerTemplate,
                pub map_coord: MapCoordF32,
                pub placing_tower_slot_id: HandSlotId,
            }
            impl Component for TowerCursorPreview<'_> {
                fn render(self, ctx: &namui::RenderCtx) {
                    let Self { tower_template, map_coord, placing_tower_slot_id } = self;
                    let game_state = use_game_state(ctx);
                    let rounded_center_xy = ctx
                        .track_eq(&map_coord.map(|f| f.round() as usize));
                    let placed_tower_coords = &game_state.towers.coords();
                    let route_coords = &game_state.route.iter_coords();
                    let can_place_tower = ctx
                        .memo(|| {
                            let out_of_map = rounded_center_xy.x < 1
                                || rounded_center_xy.y < 1
                                || rounded_center_xy.x >= MAP_SIZE.width
                                || rounded_center_xy.y >= MAP_SIZE.height;
                            if out_of_map {
                                return false;
                            }
                            can_place_tower(
                                *rounded_center_xy - Xy::single(1),
                                Wh::single(2),
                                &TRAVEL_POINTS,
                                placed_tower_coords,
                                route_coords,
                                MAP_SIZE,
                            )
                        });
                    let cancel_placing_tower_selection = move || {
                        mutate_game_state(move |game_state| {
                            let GameFlow::PlacingTower { hand } = &mut game_state.flow
                            else {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            };
                            hand.deselect_slot(placing_tower_slot_id);
                        });
                    };
                    let place_tower = || {
                        let left_top = *rounded_center_xy - Xy::single(1);
                        place_tower(
                            Tower::new(tower_template, left_top, game_state.now()),
                            placing_tower_slot_id,
                        );
                    };
                    let ctx = ctx.translate(TILE_PX_SIZE.to_xy() * *rounded_center_xy);
                    ctx.add(TowerImage { tower_template });
                    ctx.add(TowerAttackRange { tower_template });
                    ctx.add(TowerArea {
                        can_place_tower: *can_place_tower,
                    });
                    ctx.attach_event(|event| match event {
                        Event::MouseDown { event } => {
                            match event.button {
                                Some(MouseButton::Left) => {
                                    if *can_place_tower {
                                        place_tower();
                                    }
                                    event.stop_propagation();
                                }
                                Some(MouseButton::Right) => {
                                    cancel_placing_tower_selection();
                                    event.stop_propagation();
                                }
                                _ => {}
                            }
                        }
                        Event::KeyDown { event } => {
                            if event.code == Code::Escape {
                                cancel_placing_tower_selection();
                                event.stop_propagation();
                            }
                        }
                        _ => {}
                    });
                }
            }
            struct TowerImage<'a> {
                tower_template: &'a TowerTemplate,
            }
            impl Component for TowerImage<'_> {
                fn render(self, ctx: &RenderCtx) {
                    let Self { tower_template } = self;
                    let tower_image = (tower_template.kind, AnimationKind::Idle1)
                        .image();
                    let image_wh = tower_image.info().wh();
                    let rect = Rect::from_xy_wh(image_wh.to_xy() / -2.0, image_wh);
                    let paint = Paint::new(Color::grayscale_alpha_f01(0.0, 0.5));
                    ctx.add(
                        namui::image(ImageParam {
                            rect,
                            image: tower_image,
                            style: ImageStyle {
                                fit: ImageFit::None,
                                paint: Some(paint),
                            },
                        }),
                    );
                }
            }
            struct TowerAttackRange<'a> {
                tower_template: &'a TowerTemplate,
            }
            impl Component for TowerAttackRange<'_> {
                fn render(self, ctx: &RenderCtx) {
                    let Self { tower_template } = self;
                    let range_radius_px = TILE_PX_SIZE.width
                        * tower_template.default_attack_range_radius;
                    let paint = Paint::new(palette::OUTLINE)
                        .set_style(PaintStyle::Stroke)
                        .set_stroke_width(2.px());
                    let path = Path::new()
                        .add_oval(Rect::Ltrb {
                            left: -range_radius_px,
                            top: -range_radius_px,
                            right: range_radius_px,
                            bottom: range_radius_px,
                        });
                    ctx.add(namui::path(path, paint));
                }
            }
            struct TowerArea {
                can_place_tower: bool,
            }
            impl Component for TowerArea {
                fn render(self, ctx: &RenderCtx) {
                    let Self { can_place_tower } = self;
                    let color = match can_place_tower {
                        true => palette::PRIMARY,
                        false => palette::SURFACE_CONTAINER_HIGH,
                    }
                        .with_alpha(127);
                    ctx.add(
                        rect(RectParam {
                            rect: Rect::from_xy_wh(
                                Xy::single(-TILE_PX_SIZE.width),
                                TILE_PX_SIZE * 2.0,
                            ),
                            style: RectStyle {
                                stroke: Some(RectStroke {
                                    color,
                                    width: 2.px(),
                                    border_position: BorderPosition::Inside,
                                }),
                                fill: Some(RectFill { color }),
                                round: None,
                            },
                        }),
                    );
                }
            }
        }
        use crate::MapCoordF32;
        use namui::*;
        pub struct CursorPreview {
            pub kind: PreviewKind,
            pub map_coord: MapCoordF32,
        }
        impl bincode::Encode for CursorPreview {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.kind, encoder)?;
                bincode::Encode::encode(&self.map_coord, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for CursorPreview {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    kind: bincode::Decode::decode(decoder)?,
                    map_coord: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for CursorPreview {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("kind");
                self.kind.serialize_without_name(buf);
                buf.write_string("map_coord");
                self.map_coord.serialize_without_name(buf);
            }
        }
        impl Deserialize for CursorPreview {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("kind")?;
                let kind = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("map_coord")?;
                let map_coord = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { kind, map_coord })
            }
        }
        impl CursorPreview {
            pub fn should_update_position(&self) -> bool {
                match self.kind {
                    PreviewKind::None => false,
                }
            }
            pub fn update_position(&mut self, map_coord: MapCoordF32) {
                self.map_coord = map_coord;
            }
            pub fn render(&self) -> impl Component + '_ {
                RenderCursorPreview { inner: self }
            }
        }
        impl Default for CursorPreview {
            fn default() -> Self {
                Self {
                    kind: Default::default(),
                    map_coord: MapCoordF32::new(0., 0.),
                }
            }
        }
        struct RenderCursorPreview<'a> {
            inner: &'a CursorPreview,
        }
        impl Component for RenderCursorPreview<'_> {
            fn render(self, _ctx: &RenderCtx) {
                let CursorPreview { kind, .. } = self.inner;
                match kind {
                    PreviewKind::None => {}
                }
            }
        }
        pub enum PreviewKind {
            #[default]
            None,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PreviewKind {
            #[inline]
            fn clone(&self) -> PreviewKind {
                PreviewKind::None
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for PreviewKind {
            #[inline]
            fn default() -> PreviewKind {
                Self::None
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PreviewKind {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PreviewKind {
            #[inline]
            fn eq(&self, other: &PreviewKind) -> bool {
                true
            }
        }
        impl bincode::Encode for PreviewKind {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::None => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for PreviewKind {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::None),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 0u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for PreviewKind {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::None => {
                        buf.write_string("None");
                    }
                }
            }
        }
        impl Deserialize for PreviewKind {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "None" => Ok(Self::None),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
    }
    pub mod effect {
        use crate::card::{Rank, Suit};
        use crate::game_state::{
            GameState, user_status_effect::{UserStatusEffect, UserStatusEffectKind},
        };
        use crate::rarity::Rarity;
        use namui::*;
        pub enum Effect {
            Heal { amount: f32 },
            Shield { amount: f32 },
            ExtraReroll,
            EarnGold { amount: usize },
            Lottery { amount: f32, probability: f32 },
            DamageReduction { damage_multiply: f32, duration: Duration },
            UserDamageReduction { multiply: f32, duration: Duration },
            LoseHealth { amount: f32 },
            LoseGold { amount: usize },
            GrantUpgrade { rarity: Rarity },
            GrantItem { rarity: Rarity },
            AddChallengeMonster,
            IncreaseAllTowersDamage { multiplier: f32 },
            DecreaseAllTowersDamage { multiplier: f32 },
            IncreaseIncomingDamage { multiplier: f32 },
            IncreaseAllTowersAttackSpeed { multiplier: f32 },
            IncreaseAllTowersRange { multiplier: f32 },
            DecreaseIncomingDamage { multiplier: f32 },
            IncreaseGoldGain { multiplier: f32 },
            DecreaseGoldGainPercent { reduction_percentage: f32 },
            DisableItemAndUpgradePurchases,
            DisableItemUse,
            IncreaseCardSelectionHandMaxSlots { bonus: usize },
            DecreaseCardSelectionHandMaxSlots { penalty: usize },
            IncreaseCardSelectionHandMaxRerolls { bonus: usize },
            DecreaseCardSelectionHandMaxRerolls { penalty: usize },
            IncreaseShopMaxRerolls { bonus: usize },
            DecreaseShopMaxRerolls { penalty: usize },
            AddCardSelectionHandRerollHealthCost { cost: usize },
            AddShopRerollHealthCost { cost: usize },
            DecreaseEnemyHealthPercent { percentage: f32 },
            RankTowerDisable { rank: Rank },
            SuitTowerDisable { suit: Suit },
            AddBarricadeCardsToTowerPlacementHand { count: usize },
            GainShield { min_amount: f32, max_amount: f32 },
            HealHealth { min_amount: f32, max_amount: f32 },
            GainGold { min_amount: f32, max_amount: f32 },
            LoseHealthRange { min_amount: f32, max_amount: f32 },
            LoseGoldRange { min_amount: f32, max_amount: f32 },
            LoseHealthExpire { min_amount: f32, max_amount: f32 },
            LoseGoldExpire { min_amount: f32, max_amount: f32 },
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Effect {
            #[inline]
            fn clone(&self) -> Effect {
                match self {
                    Effect::Heal { amount: __self_0 } => {
                        Effect::Heal {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::Shield { amount: __self_0 } => {
                        Effect::Shield {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::ExtraReroll => Effect::ExtraReroll,
                    Effect::EarnGold { amount: __self_0 } => {
                        Effect::EarnGold {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::Lottery { amount: __self_0, probability: __self_1 } => {
                        Effect::Lottery {
                            amount: ::core::clone::Clone::clone(__self_0),
                            probability: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    Effect::DamageReduction {
                        damage_multiply: __self_0,
                        duration: __self_1,
                    } => {
                        Effect::DamageReduction {
                            damage_multiply: ::core::clone::Clone::clone(__self_0),
                            duration: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    Effect::UserDamageReduction {
                        multiply: __self_0,
                        duration: __self_1,
                    } => {
                        Effect::UserDamageReduction {
                            multiply: ::core::clone::Clone::clone(__self_0),
                            duration: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    Effect::LoseHealth { amount: __self_0 } => {
                        Effect::LoseHealth {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::LoseGold { amount: __self_0 } => {
                        Effect::LoseGold {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::GrantUpgrade { rarity: __self_0 } => {
                        Effect::GrantUpgrade {
                            rarity: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::GrantItem { rarity: __self_0 } => {
                        Effect::GrantItem {
                            rarity: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::AddChallengeMonster => Effect::AddChallengeMonster,
                    Effect::IncreaseAllTowersDamage { multiplier: __self_0 } => {
                        Effect::IncreaseAllTowersDamage {
                            multiplier: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::DecreaseAllTowersDamage { multiplier: __self_0 } => {
                        Effect::DecreaseAllTowersDamage {
                            multiplier: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::IncreaseIncomingDamage { multiplier: __self_0 } => {
                        Effect::IncreaseIncomingDamage {
                            multiplier: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::IncreaseAllTowersAttackSpeed { multiplier: __self_0 } => {
                        Effect::IncreaseAllTowersAttackSpeed {
                            multiplier: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::IncreaseAllTowersRange { multiplier: __self_0 } => {
                        Effect::IncreaseAllTowersRange {
                            multiplier: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::DecreaseIncomingDamage { multiplier: __self_0 } => {
                        Effect::DecreaseIncomingDamage {
                            multiplier: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::IncreaseGoldGain { multiplier: __self_0 } => {
                        Effect::IncreaseGoldGain {
                            multiplier: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::DecreaseGoldGainPercent {
                        reduction_percentage: __self_0,
                    } => {
                        Effect::DecreaseGoldGainPercent {
                            reduction_percentage: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::DisableItemAndUpgradePurchases => {
                        Effect::DisableItemAndUpgradePurchases
                    }
                    Effect::DisableItemUse => Effect::DisableItemUse,
                    Effect::IncreaseCardSelectionHandMaxSlots { bonus: __self_0 } => {
                        Effect::IncreaseCardSelectionHandMaxSlots {
                            bonus: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::DecreaseCardSelectionHandMaxSlots { penalty: __self_0 } => {
                        Effect::DecreaseCardSelectionHandMaxSlots {
                            penalty: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::IncreaseCardSelectionHandMaxRerolls { bonus: __self_0 } => {
                        Effect::IncreaseCardSelectionHandMaxRerolls {
                            bonus: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::DecreaseCardSelectionHandMaxRerolls { penalty: __self_0 } => {
                        Effect::DecreaseCardSelectionHandMaxRerolls {
                            penalty: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::IncreaseShopMaxRerolls { bonus: __self_0 } => {
                        Effect::IncreaseShopMaxRerolls {
                            bonus: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::DecreaseShopMaxRerolls { penalty: __self_0 } => {
                        Effect::DecreaseShopMaxRerolls {
                            penalty: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::AddCardSelectionHandRerollHealthCost { cost: __self_0 } => {
                        Effect::AddCardSelectionHandRerollHealthCost {
                            cost: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::AddShopRerollHealthCost { cost: __self_0 } => {
                        Effect::AddShopRerollHealthCost {
                            cost: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::DecreaseEnemyHealthPercent { percentage: __self_0 } => {
                        Effect::DecreaseEnemyHealthPercent {
                            percentage: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::RankTowerDisable { rank: __self_0 } => {
                        Effect::RankTowerDisable {
                            rank: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::SuitTowerDisable { suit: __self_0 } => {
                        Effect::SuitTowerDisable {
                            suit: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::AddBarricadeCardsToTowerPlacementHand { count: __self_0 } => {
                        Effect::AddBarricadeCardsToTowerPlacementHand {
                            count: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Effect::GainShield { min_amount: __self_0, max_amount: __self_1 } => {
                        Effect::GainShield {
                            min_amount: ::core::clone::Clone::clone(__self_0),
                            max_amount: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    Effect::HealHealth { min_amount: __self_0, max_amount: __self_1 } => {
                        Effect::HealHealth {
                            min_amount: ::core::clone::Clone::clone(__self_0),
                            max_amount: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    Effect::GainGold { min_amount: __self_0, max_amount: __self_1 } => {
                        Effect::GainGold {
                            min_amount: ::core::clone::Clone::clone(__self_0),
                            max_amount: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    Effect::LoseHealthRange {
                        min_amount: __self_0,
                        max_amount: __self_1,
                    } => {
                        Effect::LoseHealthRange {
                            min_amount: ::core::clone::Clone::clone(__self_0),
                            max_amount: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    Effect::LoseGoldRange {
                        min_amount: __self_0,
                        max_amount: __self_1,
                    } => {
                        Effect::LoseGoldRange {
                            min_amount: ::core::clone::Clone::clone(__self_0),
                            max_amount: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    Effect::LoseHealthExpire {
                        min_amount: __self_0,
                        max_amount: __self_1,
                    } => {
                        Effect::LoseHealthExpire {
                            min_amount: ::core::clone::Clone::clone(__self_0),
                            max_amount: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    Effect::LoseGoldExpire {
                        min_amount: __self_0,
                        max_amount: __self_1,
                    } => {
                        Effect::LoseGoldExpire {
                            min_amount: ::core::clone::Clone::clone(__self_0),
                            max_amount: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Effect {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Effect::Heal { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Heal",
                            "amount",
                            &__self_0,
                        )
                    }
                    Effect::Shield { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Shield",
                            "amount",
                            &__self_0,
                        )
                    }
                    Effect::ExtraReroll => {
                        ::core::fmt::Formatter::write_str(f, "ExtraReroll")
                    }
                    Effect::EarnGold { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "EarnGold",
                            "amount",
                            &__self_0,
                        )
                    }
                    Effect::Lottery { amount: __self_0, probability: __self_1 } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "Lottery",
                            "amount",
                            __self_0,
                            "probability",
                            &__self_1,
                        )
                    }
                    Effect::DamageReduction {
                        damage_multiply: __self_0,
                        duration: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "DamageReduction",
                            "damage_multiply",
                            __self_0,
                            "duration",
                            &__self_1,
                        )
                    }
                    Effect::UserDamageReduction {
                        multiply: __self_0,
                        duration: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "UserDamageReduction",
                            "multiply",
                            __self_0,
                            "duration",
                            &__self_1,
                        )
                    }
                    Effect::LoseHealth { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "LoseHealth",
                            "amount",
                            &__self_0,
                        )
                    }
                    Effect::LoseGold { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "LoseGold",
                            "amount",
                            &__self_0,
                        )
                    }
                    Effect::GrantUpgrade { rarity: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "GrantUpgrade",
                            "rarity",
                            &__self_0,
                        )
                    }
                    Effect::GrantItem { rarity: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "GrantItem",
                            "rarity",
                            &__self_0,
                        )
                    }
                    Effect::AddChallengeMonster => {
                        ::core::fmt::Formatter::write_str(f, "AddChallengeMonster")
                    }
                    Effect::IncreaseAllTowersDamage { multiplier: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseAllTowersDamage",
                            "multiplier",
                            &__self_0,
                        )
                    }
                    Effect::DecreaseAllTowersDamage { multiplier: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DecreaseAllTowersDamage",
                            "multiplier",
                            &__self_0,
                        )
                    }
                    Effect::IncreaseIncomingDamage { multiplier: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseIncomingDamage",
                            "multiplier",
                            &__self_0,
                        )
                    }
                    Effect::IncreaseAllTowersAttackSpeed { multiplier: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseAllTowersAttackSpeed",
                            "multiplier",
                            &__self_0,
                        )
                    }
                    Effect::IncreaseAllTowersRange { multiplier: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseAllTowersRange",
                            "multiplier",
                            &__self_0,
                        )
                    }
                    Effect::DecreaseIncomingDamage { multiplier: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DecreaseIncomingDamage",
                            "multiplier",
                            &__self_0,
                        )
                    }
                    Effect::IncreaseGoldGain { multiplier: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseGoldGain",
                            "multiplier",
                            &__self_0,
                        )
                    }
                    Effect::DecreaseGoldGainPercent {
                        reduction_percentage: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DecreaseGoldGainPercent",
                            "reduction_percentage",
                            &__self_0,
                        )
                    }
                    Effect::DisableItemAndUpgradePurchases => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "DisableItemAndUpgradePurchases",
                        )
                    }
                    Effect::DisableItemUse => {
                        ::core::fmt::Formatter::write_str(f, "DisableItemUse")
                    }
                    Effect::IncreaseCardSelectionHandMaxSlots { bonus: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseCardSelectionHandMaxSlots",
                            "bonus",
                            &__self_0,
                        )
                    }
                    Effect::DecreaseCardSelectionHandMaxSlots { penalty: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DecreaseCardSelectionHandMaxSlots",
                            "penalty",
                            &__self_0,
                        )
                    }
                    Effect::IncreaseCardSelectionHandMaxRerolls { bonus: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseCardSelectionHandMaxRerolls",
                            "bonus",
                            &__self_0,
                        )
                    }
                    Effect::DecreaseCardSelectionHandMaxRerolls { penalty: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DecreaseCardSelectionHandMaxRerolls",
                            "penalty",
                            &__self_0,
                        )
                    }
                    Effect::IncreaseShopMaxRerolls { bonus: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseShopMaxRerolls",
                            "bonus",
                            &__self_0,
                        )
                    }
                    Effect::DecreaseShopMaxRerolls { penalty: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DecreaseShopMaxRerolls",
                            "penalty",
                            &__self_0,
                        )
                    }
                    Effect::AddCardSelectionHandRerollHealthCost { cost: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "AddCardSelectionHandRerollHealthCost",
                            "cost",
                            &__self_0,
                        )
                    }
                    Effect::AddShopRerollHealthCost { cost: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "AddShopRerollHealthCost",
                            "cost",
                            &__self_0,
                        )
                    }
                    Effect::DecreaseEnemyHealthPercent { percentage: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DecreaseEnemyHealthPercent",
                            "percentage",
                            &__self_0,
                        )
                    }
                    Effect::RankTowerDisable { rank: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RankTowerDisable",
                            "rank",
                            &__self_0,
                        )
                    }
                    Effect::SuitTowerDisable { suit: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "SuitTowerDisable",
                            "suit",
                            &__self_0,
                        )
                    }
                    Effect::AddBarricadeCardsToTowerPlacementHand { count: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "AddBarricadeCardsToTowerPlacementHand",
                            "count",
                            &__self_0,
                        )
                    }
                    Effect::GainShield { min_amount: __self_0, max_amount: __self_1 } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "GainShield",
                            "min_amount",
                            __self_0,
                            "max_amount",
                            &__self_1,
                        )
                    }
                    Effect::HealHealth { min_amount: __self_0, max_amount: __self_1 } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "HealHealth",
                            "min_amount",
                            __self_0,
                            "max_amount",
                            &__self_1,
                        )
                    }
                    Effect::GainGold { min_amount: __self_0, max_amount: __self_1 } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "GainGold",
                            "min_amount",
                            __self_0,
                            "max_amount",
                            &__self_1,
                        )
                    }
                    Effect::LoseHealthRange {
                        min_amount: __self_0,
                        max_amount: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "LoseHealthRange",
                            "min_amount",
                            __self_0,
                            "max_amount",
                            &__self_1,
                        )
                    }
                    Effect::LoseGoldRange {
                        min_amount: __self_0,
                        max_amount: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "LoseGoldRange",
                            "min_amount",
                            __self_0,
                            "max_amount",
                            &__self_1,
                        )
                    }
                    Effect::LoseHealthExpire {
                        min_amount: __self_0,
                        max_amount: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "LoseHealthExpire",
                            "min_amount",
                            __self_0,
                            "max_amount",
                            &__self_1,
                        )
                    }
                    Effect::LoseGoldExpire {
                        min_amount: __self_0,
                        max_amount: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "LoseGoldExpire",
                            "min_amount",
                            __self_0,
                            "max_amount",
                            &__self_1,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Effect {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Effect {
            #[inline]
            fn eq(&self, other: &Effect) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            Effect::Heal { amount: __self_0 },
                            Effect::Heal { amount: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::Shield { amount: __self_0 },
                            Effect::Shield { amount: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::EarnGold { amount: __self_0 },
                            Effect::EarnGold { amount: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::Lottery { amount: __self_0, probability: __self_1 },
                            Effect::Lottery { amount: __arg1_0, probability: __arg1_1 },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (
                            Effect::DamageReduction {
                                damage_multiply: __self_0,
                                duration: __self_1,
                            },
                            Effect::DamageReduction {
                                damage_multiply: __arg1_0,
                                duration: __arg1_1,
                            },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (
                            Effect::UserDamageReduction {
                                multiply: __self_0,
                                duration: __self_1,
                            },
                            Effect::UserDamageReduction {
                                multiply: __arg1_0,
                                duration: __arg1_1,
                            },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (
                            Effect::LoseHealth { amount: __self_0 },
                            Effect::LoseHealth { amount: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::LoseGold { amount: __self_0 },
                            Effect::LoseGold { amount: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::GrantUpgrade { rarity: __self_0 },
                            Effect::GrantUpgrade { rarity: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::GrantItem { rarity: __self_0 },
                            Effect::GrantItem { rarity: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::IncreaseAllTowersDamage { multiplier: __self_0 },
                            Effect::IncreaseAllTowersDamage { multiplier: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::DecreaseAllTowersDamage { multiplier: __self_0 },
                            Effect::DecreaseAllTowersDamage { multiplier: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::IncreaseIncomingDamage { multiplier: __self_0 },
                            Effect::IncreaseIncomingDamage { multiplier: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::IncreaseAllTowersAttackSpeed {
                                multiplier: __self_0,
                            },
                            Effect::IncreaseAllTowersAttackSpeed { multiplier: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::IncreaseAllTowersRange { multiplier: __self_0 },
                            Effect::IncreaseAllTowersRange { multiplier: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::DecreaseIncomingDamage { multiplier: __self_0 },
                            Effect::DecreaseIncomingDamage { multiplier: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::IncreaseGoldGain { multiplier: __self_0 },
                            Effect::IncreaseGoldGain { multiplier: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::DecreaseGoldGainPercent {
                                reduction_percentage: __self_0,
                            },
                            Effect::DecreaseGoldGainPercent {
                                reduction_percentage: __arg1_0,
                            },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::IncreaseCardSelectionHandMaxSlots {
                                bonus: __self_0,
                            },
                            Effect::IncreaseCardSelectionHandMaxSlots { bonus: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::DecreaseCardSelectionHandMaxSlots {
                                penalty: __self_0,
                            },
                            Effect::DecreaseCardSelectionHandMaxSlots {
                                penalty: __arg1_0,
                            },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::IncreaseCardSelectionHandMaxRerolls {
                                bonus: __self_0,
                            },
                            Effect::IncreaseCardSelectionHandMaxRerolls {
                                bonus: __arg1_0,
                            },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::DecreaseCardSelectionHandMaxRerolls {
                                penalty: __self_0,
                            },
                            Effect::DecreaseCardSelectionHandMaxRerolls {
                                penalty: __arg1_0,
                            },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::IncreaseShopMaxRerolls { bonus: __self_0 },
                            Effect::IncreaseShopMaxRerolls { bonus: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::DecreaseShopMaxRerolls { penalty: __self_0 },
                            Effect::DecreaseShopMaxRerolls { penalty: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::AddCardSelectionHandRerollHealthCost {
                                cost: __self_0,
                            },
                            Effect::AddCardSelectionHandRerollHealthCost {
                                cost: __arg1_0,
                            },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::AddShopRerollHealthCost { cost: __self_0 },
                            Effect::AddShopRerollHealthCost { cost: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::DecreaseEnemyHealthPercent { percentage: __self_0 },
                            Effect::DecreaseEnemyHealthPercent { percentage: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::RankTowerDisable { rank: __self_0 },
                            Effect::RankTowerDisable { rank: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::SuitTowerDisable { suit: __self_0 },
                            Effect::SuitTowerDisable { suit: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::AddBarricadeCardsToTowerPlacementHand {
                                count: __self_0,
                            },
                            Effect::AddBarricadeCardsToTowerPlacementHand {
                                count: __arg1_0,
                            },
                        ) => __self_0 == __arg1_0,
                        (
                            Effect::GainShield {
                                min_amount: __self_0,
                                max_amount: __self_1,
                            },
                            Effect::GainShield {
                                min_amount: __arg1_0,
                                max_amount: __arg1_1,
                            },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (
                            Effect::HealHealth {
                                min_amount: __self_0,
                                max_amount: __self_1,
                            },
                            Effect::HealHealth {
                                min_amount: __arg1_0,
                                max_amount: __arg1_1,
                            },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (
                            Effect::GainGold {
                                min_amount: __self_0,
                                max_amount: __self_1,
                            },
                            Effect::GainGold {
                                min_amount: __arg1_0,
                                max_amount: __arg1_1,
                            },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (
                            Effect::LoseHealthRange {
                                min_amount: __self_0,
                                max_amount: __self_1,
                            },
                            Effect::LoseHealthRange {
                                min_amount: __arg1_0,
                                max_amount: __arg1_1,
                            },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (
                            Effect::LoseGoldRange {
                                min_amount: __self_0,
                                max_amount: __self_1,
                            },
                            Effect::LoseGoldRange {
                                min_amount: __arg1_0,
                                max_amount: __arg1_1,
                            },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (
                            Effect::LoseHealthExpire {
                                min_amount: __self_0,
                                max_amount: __self_1,
                            },
                            Effect::LoseHealthExpire {
                                min_amount: __arg1_0,
                                max_amount: __arg1_1,
                            },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (
                            Effect::LoseGoldExpire {
                                min_amount: __self_0,
                                max_amount: __self_1,
                            },
                            Effect::LoseGoldExpire {
                                min_amount: __arg1_0,
                                max_amount: __arg1_1,
                            },
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        _ => true,
                    }
            }
        }
        impl bincode::Encode for Effect {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Heal { amount } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::Shield { amount } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::ExtraReroll => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::EarnGold { amount } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::Lottery { amount, probability } => {
                        bincode::Encode::encode(&4u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                        bincode::Encode::encode(probability, encoder)?;
                    }
                    Self::DamageReduction { damage_multiply, duration } => {
                        bincode::Encode::encode(&5u32, encoder)?;
                        bincode::Encode::encode(damage_multiply, encoder)?;
                        bincode::Encode::encode(duration, encoder)?;
                    }
                    Self::UserDamageReduction { multiply, duration } => {
                        bincode::Encode::encode(&6u32, encoder)?;
                        bincode::Encode::encode(multiply, encoder)?;
                        bincode::Encode::encode(duration, encoder)?;
                    }
                    Self::LoseHealth { amount } => {
                        bincode::Encode::encode(&7u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::LoseGold { amount } => {
                        bincode::Encode::encode(&8u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::GrantUpgrade { rarity } => {
                        bincode::Encode::encode(&9u32, encoder)?;
                        bincode::Encode::encode(rarity, encoder)?;
                    }
                    Self::GrantItem { rarity } => {
                        bincode::Encode::encode(&10u32, encoder)?;
                        bincode::Encode::encode(rarity, encoder)?;
                    }
                    Self::AddChallengeMonster => {
                        bincode::Encode::encode(&11u32, encoder)?;
                    }
                    Self::IncreaseAllTowersDamage { multiplier } => {
                        bincode::Encode::encode(&12u32, encoder)?;
                        bincode::Encode::encode(multiplier, encoder)?;
                    }
                    Self::DecreaseAllTowersDamage { multiplier } => {
                        bincode::Encode::encode(&13u32, encoder)?;
                        bincode::Encode::encode(multiplier, encoder)?;
                    }
                    Self::IncreaseIncomingDamage { multiplier } => {
                        bincode::Encode::encode(&14u32, encoder)?;
                        bincode::Encode::encode(multiplier, encoder)?;
                    }
                    Self::IncreaseAllTowersAttackSpeed { multiplier } => {
                        bincode::Encode::encode(&15u32, encoder)?;
                        bincode::Encode::encode(multiplier, encoder)?;
                    }
                    Self::IncreaseAllTowersRange { multiplier } => {
                        bincode::Encode::encode(&16u32, encoder)?;
                        bincode::Encode::encode(multiplier, encoder)?;
                    }
                    Self::DecreaseIncomingDamage { multiplier } => {
                        bincode::Encode::encode(&17u32, encoder)?;
                        bincode::Encode::encode(multiplier, encoder)?;
                    }
                    Self::IncreaseGoldGain { multiplier } => {
                        bincode::Encode::encode(&18u32, encoder)?;
                        bincode::Encode::encode(multiplier, encoder)?;
                    }
                    Self::DecreaseGoldGainPercent { reduction_percentage } => {
                        bincode::Encode::encode(&19u32, encoder)?;
                        bincode::Encode::encode(reduction_percentage, encoder)?;
                    }
                    Self::DisableItemAndUpgradePurchases => {
                        bincode::Encode::encode(&20u32, encoder)?;
                    }
                    Self::DisableItemUse => {
                        bincode::Encode::encode(&21u32, encoder)?;
                    }
                    Self::IncreaseCardSelectionHandMaxSlots { bonus } => {
                        bincode::Encode::encode(&22u32, encoder)?;
                        bincode::Encode::encode(bonus, encoder)?;
                    }
                    Self::DecreaseCardSelectionHandMaxSlots { penalty } => {
                        bincode::Encode::encode(&23u32, encoder)?;
                        bincode::Encode::encode(penalty, encoder)?;
                    }
                    Self::IncreaseCardSelectionHandMaxRerolls { bonus } => {
                        bincode::Encode::encode(&24u32, encoder)?;
                        bincode::Encode::encode(bonus, encoder)?;
                    }
                    Self::DecreaseCardSelectionHandMaxRerolls { penalty } => {
                        bincode::Encode::encode(&25u32, encoder)?;
                        bincode::Encode::encode(penalty, encoder)?;
                    }
                    Self::IncreaseShopMaxRerolls { bonus } => {
                        bincode::Encode::encode(&26u32, encoder)?;
                        bincode::Encode::encode(bonus, encoder)?;
                    }
                    Self::DecreaseShopMaxRerolls { penalty } => {
                        bincode::Encode::encode(&27u32, encoder)?;
                        bincode::Encode::encode(penalty, encoder)?;
                    }
                    Self::AddCardSelectionHandRerollHealthCost { cost } => {
                        bincode::Encode::encode(&28u32, encoder)?;
                        bincode::Encode::encode(cost, encoder)?;
                    }
                    Self::AddShopRerollHealthCost { cost } => {
                        bincode::Encode::encode(&29u32, encoder)?;
                        bincode::Encode::encode(cost, encoder)?;
                    }
                    Self::DecreaseEnemyHealthPercent { percentage } => {
                        bincode::Encode::encode(&30u32, encoder)?;
                        bincode::Encode::encode(percentage, encoder)?;
                    }
                    Self::RankTowerDisable { rank } => {
                        bincode::Encode::encode(&31u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                    }
                    Self::SuitTowerDisable { suit } => {
                        bincode::Encode::encode(&32u32, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                    }
                    Self::AddBarricadeCardsToTowerPlacementHand { count } => {
                        bincode::Encode::encode(&33u32, encoder)?;
                        bincode::Encode::encode(count, encoder)?;
                    }
                    Self::GainShield { min_amount, max_amount } => {
                        bincode::Encode::encode(&34u32, encoder)?;
                        bincode::Encode::encode(min_amount, encoder)?;
                        bincode::Encode::encode(max_amount, encoder)?;
                    }
                    Self::HealHealth { min_amount, max_amount } => {
                        bincode::Encode::encode(&35u32, encoder)?;
                        bincode::Encode::encode(min_amount, encoder)?;
                        bincode::Encode::encode(max_amount, encoder)?;
                    }
                    Self::GainGold { min_amount, max_amount } => {
                        bincode::Encode::encode(&36u32, encoder)?;
                        bincode::Encode::encode(min_amount, encoder)?;
                        bincode::Encode::encode(max_amount, encoder)?;
                    }
                    Self::LoseHealthRange { min_amount, max_amount } => {
                        bincode::Encode::encode(&37u32, encoder)?;
                        bincode::Encode::encode(min_amount, encoder)?;
                        bincode::Encode::encode(max_amount, encoder)?;
                    }
                    Self::LoseGoldRange { min_amount, max_amount } => {
                        bincode::Encode::encode(&38u32, encoder)?;
                        bincode::Encode::encode(min_amount, encoder)?;
                        bincode::Encode::encode(max_amount, encoder)?;
                    }
                    Self::LoseHealthExpire { min_amount, max_amount } => {
                        bincode::Encode::encode(&39u32, encoder)?;
                        bincode::Encode::encode(min_amount, encoder)?;
                        bincode::Encode::encode(max_amount, encoder)?;
                    }
                    Self::LoseGoldExpire { min_amount, max_amount } => {
                        bincode::Encode::encode(&40u32, encoder)?;
                        bincode::Encode::encode(min_amount, encoder)?;
                        bincode::Encode::encode(max_amount, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for Effect {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::Heal {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::Shield {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => Ok(Self::ExtraReroll),
                    3u32 => {
                        Ok(Self::EarnGold {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    4u32 => {
                        Ok(Self::Lottery {
                            amount: bincode::Decode::decode(decoder)?,
                            probability: bincode::Decode::decode(decoder)?,
                        })
                    }
                    5u32 => {
                        Ok(Self::DamageReduction {
                            damage_multiply: bincode::Decode::decode(decoder)?,
                            duration: bincode::Decode::decode(decoder)?,
                        })
                    }
                    6u32 => {
                        Ok(Self::UserDamageReduction {
                            multiply: bincode::Decode::decode(decoder)?,
                            duration: bincode::Decode::decode(decoder)?,
                        })
                    }
                    7u32 => {
                        Ok(Self::LoseHealth {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    8u32 => {
                        Ok(Self::LoseGold {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    9u32 => {
                        Ok(Self::GrantUpgrade {
                            rarity: bincode::Decode::decode(decoder)?,
                        })
                    }
                    10u32 => {
                        Ok(Self::GrantItem {
                            rarity: bincode::Decode::decode(decoder)?,
                        })
                    }
                    11u32 => Ok(Self::AddChallengeMonster),
                    12u32 => {
                        Ok(Self::IncreaseAllTowersDamage {
                            multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    13u32 => {
                        Ok(Self::DecreaseAllTowersDamage {
                            multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    14u32 => {
                        Ok(Self::IncreaseIncomingDamage {
                            multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    15u32 => {
                        Ok(Self::IncreaseAllTowersAttackSpeed {
                            multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    16u32 => {
                        Ok(Self::IncreaseAllTowersRange {
                            multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    17u32 => {
                        Ok(Self::DecreaseIncomingDamage {
                            multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    18u32 => {
                        Ok(Self::IncreaseGoldGain {
                            multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    19u32 => {
                        Ok(Self::DecreaseGoldGainPercent {
                            reduction_percentage: bincode::Decode::decode(decoder)?,
                        })
                    }
                    20u32 => Ok(Self::DisableItemAndUpgradePurchases),
                    21u32 => Ok(Self::DisableItemUse),
                    22u32 => {
                        Ok(Self::IncreaseCardSelectionHandMaxSlots {
                            bonus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    23u32 => {
                        Ok(Self::DecreaseCardSelectionHandMaxSlots {
                            penalty: bincode::Decode::decode(decoder)?,
                        })
                    }
                    24u32 => {
                        Ok(Self::IncreaseCardSelectionHandMaxRerolls {
                            bonus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    25u32 => {
                        Ok(Self::DecreaseCardSelectionHandMaxRerolls {
                            penalty: bincode::Decode::decode(decoder)?,
                        })
                    }
                    26u32 => {
                        Ok(Self::IncreaseShopMaxRerolls {
                            bonus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    27u32 => {
                        Ok(Self::DecreaseShopMaxRerolls {
                            penalty: bincode::Decode::decode(decoder)?,
                        })
                    }
                    28u32 => {
                        Ok(Self::AddCardSelectionHandRerollHealthCost {
                            cost: bincode::Decode::decode(decoder)?,
                        })
                    }
                    29u32 => {
                        Ok(Self::AddShopRerollHealthCost {
                            cost: bincode::Decode::decode(decoder)?,
                        })
                    }
                    30u32 => {
                        Ok(Self::DecreaseEnemyHealthPercent {
                            percentage: bincode::Decode::decode(decoder)?,
                        })
                    }
                    31u32 => {
                        Ok(Self::RankTowerDisable {
                            rank: bincode::Decode::decode(decoder)?,
                        })
                    }
                    32u32 => {
                        Ok(Self::SuitTowerDisable {
                            suit: bincode::Decode::decode(decoder)?,
                        })
                    }
                    33u32 => {
                        Ok(Self::AddBarricadeCardsToTowerPlacementHand {
                            count: bincode::Decode::decode(decoder)?,
                        })
                    }
                    34u32 => {
                        Ok(Self::GainShield {
                            min_amount: bincode::Decode::decode(decoder)?,
                            max_amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    35u32 => {
                        Ok(Self::HealHealth {
                            min_amount: bincode::Decode::decode(decoder)?,
                            max_amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    36u32 => {
                        Ok(Self::GainGold {
                            min_amount: bincode::Decode::decode(decoder)?,
                            max_amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    37u32 => {
                        Ok(Self::LoseHealthRange {
                            min_amount: bincode::Decode::decode(decoder)?,
                            max_amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    38u32 => {
                        Ok(Self::LoseGoldRange {
                            min_amount: bincode::Decode::decode(decoder)?,
                            max_amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    39u32 => {
                        Ok(Self::LoseHealthExpire {
                            min_amount: bincode::Decode::decode(decoder)?,
                            max_amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    40u32 => {
                        Ok(Self::LoseGoldExpire {
                            min_amount: bincode::Decode::decode(decoder)?,
                            max_amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 40u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for Effect {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Heal { amount } => {
                        buf.write_string("Heal");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::Shield { amount } => {
                        buf.write_string("Shield");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::ExtraReroll => {
                        buf.write_string("ExtraReroll");
                    }
                    Self::EarnGold { amount } => {
                        buf.write_string("EarnGold");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::Lottery { amount, probability } => {
                        buf.write_string("Lottery");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                        buf.write_string("probability");
                        probability.serialize_without_name(buf);
                    }
                    Self::DamageReduction { damage_multiply, duration } => {
                        buf.write_string("DamageReduction");
                        buf.write_string("damage_multiply");
                        damage_multiply.serialize_without_name(buf);
                        buf.write_string("duration");
                        duration.serialize_without_name(buf);
                    }
                    Self::UserDamageReduction { multiply, duration } => {
                        buf.write_string("UserDamageReduction");
                        buf.write_string("multiply");
                        multiply.serialize_without_name(buf);
                        buf.write_string("duration");
                        duration.serialize_without_name(buf);
                    }
                    Self::LoseHealth { amount } => {
                        buf.write_string("LoseHealth");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::LoseGold { amount } => {
                        buf.write_string("LoseGold");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::GrantUpgrade { rarity } => {
                        buf.write_string("GrantUpgrade");
                        buf.write_string("rarity");
                        rarity.serialize_without_name(buf);
                    }
                    Self::GrantItem { rarity } => {
                        buf.write_string("GrantItem");
                        buf.write_string("rarity");
                        rarity.serialize_without_name(buf);
                    }
                    Self::AddChallengeMonster => {
                        buf.write_string("AddChallengeMonster");
                    }
                    Self::IncreaseAllTowersDamage { multiplier } => {
                        buf.write_string("IncreaseAllTowersDamage");
                        buf.write_string("multiplier");
                        multiplier.serialize_without_name(buf);
                    }
                    Self::DecreaseAllTowersDamage { multiplier } => {
                        buf.write_string("DecreaseAllTowersDamage");
                        buf.write_string("multiplier");
                        multiplier.serialize_without_name(buf);
                    }
                    Self::IncreaseIncomingDamage { multiplier } => {
                        buf.write_string("IncreaseIncomingDamage");
                        buf.write_string("multiplier");
                        multiplier.serialize_without_name(buf);
                    }
                    Self::IncreaseAllTowersAttackSpeed { multiplier } => {
                        buf.write_string("IncreaseAllTowersAttackSpeed");
                        buf.write_string("multiplier");
                        multiplier.serialize_without_name(buf);
                    }
                    Self::IncreaseAllTowersRange { multiplier } => {
                        buf.write_string("IncreaseAllTowersRange");
                        buf.write_string("multiplier");
                        multiplier.serialize_without_name(buf);
                    }
                    Self::DecreaseIncomingDamage { multiplier } => {
                        buf.write_string("DecreaseIncomingDamage");
                        buf.write_string("multiplier");
                        multiplier.serialize_without_name(buf);
                    }
                    Self::IncreaseGoldGain { multiplier } => {
                        buf.write_string("IncreaseGoldGain");
                        buf.write_string("multiplier");
                        multiplier.serialize_without_name(buf);
                    }
                    Self::DecreaseGoldGainPercent { reduction_percentage } => {
                        buf.write_string("DecreaseGoldGainPercent");
                        buf.write_string("reduction_percentage");
                        reduction_percentage.serialize_without_name(buf);
                    }
                    Self::DisableItemAndUpgradePurchases => {
                        buf.write_string("DisableItemAndUpgradePurchases");
                    }
                    Self::DisableItemUse => {
                        buf.write_string("DisableItemUse");
                    }
                    Self::IncreaseCardSelectionHandMaxSlots { bonus } => {
                        buf.write_string("IncreaseCardSelectionHandMaxSlots");
                        buf.write_string("bonus");
                        bonus.serialize_without_name(buf);
                    }
                    Self::DecreaseCardSelectionHandMaxSlots { penalty } => {
                        buf.write_string("DecreaseCardSelectionHandMaxSlots");
                        buf.write_string("penalty");
                        penalty.serialize_without_name(buf);
                    }
                    Self::IncreaseCardSelectionHandMaxRerolls { bonus } => {
                        buf.write_string("IncreaseCardSelectionHandMaxRerolls");
                        buf.write_string("bonus");
                        bonus.serialize_without_name(buf);
                    }
                    Self::DecreaseCardSelectionHandMaxRerolls { penalty } => {
                        buf.write_string("DecreaseCardSelectionHandMaxRerolls");
                        buf.write_string("penalty");
                        penalty.serialize_without_name(buf);
                    }
                    Self::IncreaseShopMaxRerolls { bonus } => {
                        buf.write_string("IncreaseShopMaxRerolls");
                        buf.write_string("bonus");
                        bonus.serialize_without_name(buf);
                    }
                    Self::DecreaseShopMaxRerolls { penalty } => {
                        buf.write_string("DecreaseShopMaxRerolls");
                        buf.write_string("penalty");
                        penalty.serialize_without_name(buf);
                    }
                    Self::AddCardSelectionHandRerollHealthCost { cost } => {
                        buf.write_string("AddCardSelectionHandRerollHealthCost");
                        buf.write_string("cost");
                        cost.serialize_without_name(buf);
                    }
                    Self::AddShopRerollHealthCost { cost } => {
                        buf.write_string("AddShopRerollHealthCost");
                        buf.write_string("cost");
                        cost.serialize_without_name(buf);
                    }
                    Self::DecreaseEnemyHealthPercent { percentage } => {
                        buf.write_string("DecreaseEnemyHealthPercent");
                        buf.write_string("percentage");
                        percentage.serialize_without_name(buf);
                    }
                    Self::RankTowerDisable { rank } => {
                        buf.write_string("RankTowerDisable");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                    }
                    Self::SuitTowerDisable { suit } => {
                        buf.write_string("SuitTowerDisable");
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                    }
                    Self::AddBarricadeCardsToTowerPlacementHand { count } => {
                        buf.write_string("AddBarricadeCardsToTowerPlacementHand");
                        buf.write_string("count");
                        count.serialize_without_name(buf);
                    }
                    Self::GainShield { min_amount, max_amount } => {
                        buf.write_string("GainShield");
                        buf.write_string("min_amount");
                        min_amount.serialize_without_name(buf);
                        buf.write_string("max_amount");
                        max_amount.serialize_without_name(buf);
                    }
                    Self::HealHealth { min_amount, max_amount } => {
                        buf.write_string("HealHealth");
                        buf.write_string("min_amount");
                        min_amount.serialize_without_name(buf);
                        buf.write_string("max_amount");
                        max_amount.serialize_without_name(buf);
                    }
                    Self::GainGold { min_amount, max_amount } => {
                        buf.write_string("GainGold");
                        buf.write_string("min_amount");
                        min_amount.serialize_without_name(buf);
                        buf.write_string("max_amount");
                        max_amount.serialize_without_name(buf);
                    }
                    Self::LoseHealthRange { min_amount, max_amount } => {
                        buf.write_string("LoseHealthRange");
                        buf.write_string("min_amount");
                        min_amount.serialize_without_name(buf);
                        buf.write_string("max_amount");
                        max_amount.serialize_without_name(buf);
                    }
                    Self::LoseGoldRange { min_amount, max_amount } => {
                        buf.write_string("LoseGoldRange");
                        buf.write_string("min_amount");
                        min_amount.serialize_without_name(buf);
                        buf.write_string("max_amount");
                        max_amount.serialize_without_name(buf);
                    }
                    Self::LoseHealthExpire { min_amount, max_amount } => {
                        buf.write_string("LoseHealthExpire");
                        buf.write_string("min_amount");
                        min_amount.serialize_without_name(buf);
                        buf.write_string("max_amount");
                        max_amount.serialize_without_name(buf);
                    }
                    Self::LoseGoldExpire { min_amount, max_amount } => {
                        buf.write_string("LoseGoldExpire");
                        buf.write_string("min_amount");
                        min_amount.serialize_without_name(buf);
                        buf.write_string("max_amount");
                        max_amount.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for Effect {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Heal" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Heal { amount })
                    }
                    "Shield" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Shield { amount })
                    }
                    "ExtraReroll" => Ok(Self::ExtraReroll),
                    "EarnGold" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::EarnGold { amount })
                    }
                    "Lottery" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("probability")?;
                        let probability = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Lottery {
                            amount,
                            probability,
                        })
                    }
                    "DamageReduction" => {
                        let field_name = buf.read_name("damage_multiply")?;
                        let damage_multiply = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        let field_name = buf.read_name("duration")?;
                        let duration = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DamageReduction {
                            damage_multiply,
                            duration,
                        })
                    }
                    "UserDamageReduction" => {
                        let field_name = buf.read_name("multiply")?;
                        let multiply = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("duration")?;
                        let duration = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::UserDamageReduction {
                            multiply,
                            duration,
                        })
                    }
                    "LoseHealth" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::LoseHealth { amount })
                    }
                    "LoseGold" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::LoseGold { amount })
                    }
                    "GrantUpgrade" => {
                        let field_name = buf.read_name("rarity")?;
                        let rarity = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::GrantUpgrade { rarity })
                    }
                    "GrantItem" => {
                        let field_name = buf.read_name("rarity")?;
                        let rarity = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::GrantItem { rarity })
                    }
                    "AddChallengeMonster" => Ok(Self::AddChallengeMonster),
                    "IncreaseAllTowersDamage" => {
                        let field_name = buf.read_name("multiplier")?;
                        let multiplier = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseAllTowersDamage {
                            multiplier,
                        })
                    }
                    "DecreaseAllTowersDamage" => {
                        let field_name = buf.read_name("multiplier")?;
                        let multiplier = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DecreaseAllTowersDamage {
                            multiplier,
                        })
                    }
                    "IncreaseIncomingDamage" => {
                        let field_name = buf.read_name("multiplier")?;
                        let multiplier = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseIncomingDamage {
                            multiplier,
                        })
                    }
                    "IncreaseAllTowersAttackSpeed" => {
                        let field_name = buf.read_name("multiplier")?;
                        let multiplier = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseAllTowersAttackSpeed {
                            multiplier,
                        })
                    }
                    "IncreaseAllTowersRange" => {
                        let field_name = buf.read_name("multiplier")?;
                        let multiplier = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseAllTowersRange {
                            multiplier,
                        })
                    }
                    "DecreaseIncomingDamage" => {
                        let field_name = buf.read_name("multiplier")?;
                        let multiplier = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DecreaseIncomingDamage {
                            multiplier,
                        })
                    }
                    "IncreaseGoldGain" => {
                        let field_name = buf.read_name("multiplier")?;
                        let multiplier = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseGoldGain {
                            multiplier,
                        })
                    }
                    "DecreaseGoldGainPercent" => {
                        let field_name = buf.read_name("reduction_percentage")?;
                        let reduction_percentage = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::DecreaseGoldGainPercent {
                            reduction_percentage,
                        })
                    }
                    "DisableItemAndUpgradePurchases" => {
                        Ok(Self::DisableItemAndUpgradePurchases)
                    }
                    "DisableItemUse" => Ok(Self::DisableItemUse),
                    "IncreaseCardSelectionHandMaxSlots" => {
                        let field_name = buf.read_name("bonus")?;
                        let bonus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseCardSelectionHandMaxSlots {
                            bonus,
                        })
                    }
                    "DecreaseCardSelectionHandMaxSlots" => {
                        let field_name = buf.read_name("penalty")?;
                        let penalty = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DecreaseCardSelectionHandMaxSlots {
                            penalty,
                        })
                    }
                    "IncreaseCardSelectionHandMaxRerolls" => {
                        let field_name = buf.read_name("bonus")?;
                        let bonus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseCardSelectionHandMaxRerolls {
                            bonus,
                        })
                    }
                    "DecreaseCardSelectionHandMaxRerolls" => {
                        let field_name = buf.read_name("penalty")?;
                        let penalty = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DecreaseCardSelectionHandMaxRerolls {
                            penalty,
                        })
                    }
                    "IncreaseShopMaxRerolls" => {
                        let field_name = buf.read_name("bonus")?;
                        let bonus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseShopMaxRerolls {
                            bonus,
                        })
                    }
                    "DecreaseShopMaxRerolls" => {
                        let field_name = buf.read_name("penalty")?;
                        let penalty = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DecreaseShopMaxRerolls {
                            penalty,
                        })
                    }
                    "AddCardSelectionHandRerollHealthCost" => {
                        let field_name = buf.read_name("cost")?;
                        let cost = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::AddCardSelectionHandRerollHealthCost {
                            cost,
                        })
                    }
                    "AddShopRerollHealthCost" => {
                        let field_name = buf.read_name("cost")?;
                        let cost = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::AddShopRerollHealthCost {
                            cost,
                        })
                    }
                    "DecreaseEnemyHealthPercent" => {
                        let field_name = buf.read_name("percentage")?;
                        let percentage = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DecreaseEnemyHealthPercent {
                            percentage,
                        })
                    }
                    "RankTowerDisable" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RankTowerDisable { rank })
                    }
                    "SuitTowerDisable" => {
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SuitTowerDisable { suit })
                    }
                    "AddBarricadeCardsToTowerPlacementHand" => {
                        let field_name = buf.read_name("count")?;
                        let count = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::AddBarricadeCardsToTowerPlacementHand {
                            count,
                        })
                    }
                    "GainShield" => {
                        let field_name = buf.read_name("min_amount")?;
                        let min_amount = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("max_amount")?;
                        let max_amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::GainShield {
                            min_amount,
                            max_amount,
                        })
                    }
                    "HealHealth" => {
                        let field_name = buf.read_name("min_amount")?;
                        let min_amount = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("max_amount")?;
                        let max_amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::HealHealth {
                            min_amount,
                            max_amount,
                        })
                    }
                    "GainGold" => {
                        let field_name = buf.read_name("min_amount")?;
                        let min_amount = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("max_amount")?;
                        let max_amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::GainGold {
                            min_amount,
                            max_amount,
                        })
                    }
                    "LoseHealthRange" => {
                        let field_name = buf.read_name("min_amount")?;
                        let min_amount = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("max_amount")?;
                        let max_amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::LoseHealthRange {
                            min_amount,
                            max_amount,
                        })
                    }
                    "LoseGoldRange" => {
                        let field_name = buf.read_name("min_amount")?;
                        let min_amount = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("max_amount")?;
                        let max_amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::LoseGoldRange {
                            min_amount,
                            max_amount,
                        })
                    }
                    "LoseHealthExpire" => {
                        let field_name = buf.read_name("min_amount")?;
                        let min_amount = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("max_amount")?;
                        let max_amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::LoseHealthExpire {
                            min_amount,
                            max_amount,
                        })
                    }
                    "LoseGoldExpire" => {
                        let field_name = buf.read_name("min_amount")?;
                        let min_amount = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("max_amount")?;
                        let max_amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::LoseGoldExpire {
                            min_amount,
                            max_amount,
                        })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub fn run_effect(game_state: &mut GameState, effect: &Effect) {
            use rand::thread_rng;
            let mut rng = thread_rng();
            run_effect_with_rng(game_state, effect, &mut rng);
        }
        /// 테스트 및 결정적(Deterministic) 실행을 위해 RNG를 주입할 수 있는 버전.
        /// 기존 `run_effect` 는 thread_rng() 를 사용하며, 이 함수는 재사용 가능한 코어 로직을 담는다.
        pub fn run_effect_with_rng<R: rand::Rng + ?Sized>(
            game_state: &mut GameState,
            effect: &Effect,
            rng: &mut R,
        ) {
            match effect {
                Effect::Heal { amount } => {
                    game_state.hp = (game_state.hp + amount)
                        .min(crate::game_state::MAX_HP);
                }
                Effect::Shield { amount } => {
                    game_state.shield += amount;
                }
                Effect::ExtraReroll => {
                    game_state.left_reroll_chance += 1;
                }
                Effect::EarnGold { amount } => {
                    game_state.gold = game_state.gold.saturating_add(*amount);
                }
                Effect::Lottery { amount, probability } => {
                    let is_winner = rng.gen_bool(*probability as f64);
                    let gold = if is_winner { *amount as usize } else { 0 };
                    game_state.earn_gold(gold);
                }
                Effect::DamageReduction { damage_multiply, duration } => {
                    let status_effect = UserStatusEffect {
                        kind: UserStatusEffectKind::DamageReduction {
                            damage_multiply: *damage_multiply,
                        },
                        end_at: game_state.now() + *duration,
                    };
                    game_state.user_status_effects.push(status_effect);
                }
                Effect::UserDamageReduction { multiply, duration } => {
                    let status_effect = UserStatusEffect {
                        kind: UserStatusEffectKind::DamageReduction {
                            damage_multiply: *multiply,
                        },
                        end_at: game_state.now() + *duration,
                    };
                    game_state.user_status_effects.push(status_effect);
                }
                Effect::LoseHealth { amount } => {
                    game_state.hp = (game_state.hp - amount).max(1.0);
                }
                Effect::LoseHealthRange { min_amount, max_amount } => {
                    let amount = rng.gen_range(*min_amount..=*max_amount);
                    game_state.hp = (game_state.hp - amount).max(1.0);
                }
                Effect::LoseGoldRange { min_amount, max_amount } => {
                    let amount = rng.gen_range(*min_amount..=*max_amount) as usize;
                    if game_state.gold >= amount {
                        game_state.gold -= amount;
                    } else {
                        let remaining = amount - game_state.gold;
                        game_state.gold = 0;
                        let health_penalty = (remaining as f32 / 10.0).max(1.0);
                        game_state.hp = (game_state.hp - health_penalty).max(1.0);
                    }
                }
                Effect::LoseHealthExpire { min_amount, max_amount } => {
                    let amount = rng.gen_range(*min_amount..=*max_amount);
                    game_state.hp = (game_state.hp - amount).max(1.0);
                }
                Effect::LoseGoldExpire { min_amount, max_amount } => {
                    let amount = rng.gen_range(*min_amount..=*max_amount) as usize;
                    if game_state.gold >= amount {
                        game_state.gold -= amount;
                    } else {
                        let remaining = amount - game_state.gold;
                        game_state.gold = 0;
                        let health_penalty = (remaining as f32 / 10.0).max(1.0);
                        game_state.hp = (game_state.hp - health_penalty).max(1.0);
                    }
                }
                Effect::LoseGold { amount } => {
                    if game_state.gold >= *amount {
                        game_state.gold -= *amount;
                    } else {
                        let remaining = *amount - game_state.gold;
                        game_state.gold = 0;
                        let health_penalty = (remaining as f32 / 10.0).max(1.0);
                        game_state.hp = (game_state.hp - health_penalty).max(1.0);
                    }
                }
                Effect::GrantUpgrade { rarity } => {
                    let upgrade = crate::game_state::upgrade::generate_upgrade(
                        game_state,
                        *rarity,
                    );
                    game_state.upgrade_state.upgrade(upgrade);
                }
                Effect::GrantItem { rarity } => {
                    let item = crate::game_state::item::generation::generate_item_with_rng(
                        *rarity,
                        rng,
                    );
                    game_state.items.push(item);
                }
                Effect::AddChallengeMonster => {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "not implemented: {0}",
                                format_args!(
                                    "AddChallengeMonster effect is not implemented yet",
                                ),
                            ),
                        );
                    };
                }
                Effect::IncreaseAllTowersDamage { multiplier } => {
                    game_state.stage_modifiers.apply_damage_multiplier(*multiplier);
                }
                Effect::DecreaseAllTowersDamage { multiplier } => {
                    game_state.stage_modifiers.apply_damage_multiplier(*multiplier);
                }
                Effect::IncreaseIncomingDamage { multiplier } => {
                    game_state
                        .stage_modifiers
                        .apply_incoming_damage_multiplier(*multiplier);
                }
                Effect::IncreaseAllTowersAttackSpeed { multiplier } => {
                    game_state
                        .stage_modifiers
                        .apply_attack_speed_multiplier(*multiplier);
                }
                Effect::IncreaseAllTowersRange { multiplier } => {
                    game_state.stage_modifiers.apply_range_multiplier(*multiplier);
                }
                Effect::DecreaseIncomingDamage { multiplier } => {
                    game_state
                        .stage_modifiers
                        .apply_damage_reduction_multiplier(*multiplier);
                }
                Effect::IncreaseGoldGain { multiplier } => {
                    game_state.stage_modifiers.apply_gold_gain_multiplier(*multiplier);
                }
                Effect::DecreaseGoldGainPercent { reduction_percentage } => {
                    game_state
                        .stage_modifiers
                        .apply_gold_gain_multiplier(1.0 - *reduction_percentage);
                }
                Effect::DisableItemAndUpgradePurchases => {
                    game_state.stage_modifiers.disable_item_and_upgrade_purchases();
                }
                Effect::DisableItemUse => {
                    game_state.stage_modifiers.disable_item_use();
                }
                Effect::DecreaseCardSelectionHandMaxSlots { penalty } => {
                    game_state
                        .stage_modifiers
                        .apply_card_selection_hand_max_slots_penalty(*penalty);
                }
                Effect::IncreaseCardSelectionHandMaxSlots { bonus } => {
                    game_state
                        .stage_modifiers
                        .apply_card_selection_hand_max_slots_bonus(*bonus);
                }
                Effect::IncreaseCardSelectionHandMaxRerolls { bonus } => {
                    game_state
                        .stage_modifiers
                        .apply_card_selection_hand_max_rerolls_bonus(*bonus);
                }
                Effect::DecreaseCardSelectionHandMaxRerolls { penalty } => {
                    game_state
                        .stage_modifiers
                        .apply_card_selection_hand_max_rerolls_penalty(*penalty);
                }
                Effect::IncreaseShopMaxRerolls { bonus } => {
                    game_state.stage_modifiers.apply_shop_max_rerolls_bonus(*bonus);
                }
                Effect::DecreaseShopMaxRerolls { penalty } => {
                    game_state.stage_modifiers.apply_shop_max_rerolls_penalty(*penalty);
                }
                Effect::AddCardSelectionHandRerollHealthCost { cost } => {
                    game_state
                        .stage_modifiers
                        .apply_card_selection_hand_reroll_health_cost(*cost);
                }
                Effect::AddShopRerollHealthCost { cost } => {
                    game_state.stage_modifiers.apply_shop_reroll_health_cost(*cost);
                }
                Effect::DecreaseEnemyHealthPercent { percentage } => {
                    let multiplier = 1.0 + percentage / 100.0;
                    game_state.stage_modifiers.apply_enemy_health_multiplier(multiplier);
                }
                Effect::RankTowerDisable { rank } => {
                    game_state.stage_modifiers.disable_rank(*rank);
                }
                Effect::SuitTowerDisable { suit } => {
                    game_state.stage_modifiers.disable_suit(*suit);
                }
                Effect::AddBarricadeCardsToTowerPlacementHand { count } => {
                    game_state.stage_modifiers.set_barricade_cards_per_stage(*count);
                }
                Effect::GainShield { min_amount, max_amount } => {
                    let shield_amount = rng.gen_range(*min_amount..=*max_amount);
                    game_state.shield += shield_amount;
                }
                Effect::HealHealth { min_amount, max_amount } => {
                    let heal_amount = rng.gen_range(*min_amount..=*max_amount);
                    game_state.hp = (game_state.hp + heal_amount)
                        .min(crate::game_state::MAX_HP);
                }
                Effect::GainGold { min_amount, max_amount } => {
                    let gold_amount = rng.gen_range(*min_amount..=*max_amount) as usize;
                    game_state.gold += gold_amount;
                }
            }
        }
        impl Effect {
            pub fn name(&self, text_manager: &crate::l10n::TextManager) -> String {
                text_manager.effect_name(self)
            }
            pub fn description(
                &self,
                text_manager: &crate::l10n::TextManager,
            ) -> String {
                text_manager.effect_description(self)
            }
        }
    }
    mod event_handlers {
        use super::*;
        use crate::{
            game_state::{
                contract::sign_contract, effect::run_effect, item,
                play_history::HistoryEventType, tower::Tower, upgrade::Upgrade,
            },
            shop::ShopSlot,
        };
        impl GameState {
            pub fn earn_gold(&mut self, gold: usize) {
                self.gold += gold;
            }
            /// WARNING: `gold` must be less than or equal to self.gold
            pub fn spend_gold(&mut self, gold: usize) {
                self.gold -= gold;
            }
            pub fn upgrade(&mut self, upgrade: Upgrade) {
                self.upgrade_state.upgrade(upgrade);
                self.record_event(HistoryEventType::UpgradeSelected {
                    upgrade,
                });
            }
            pub fn place_tower(&mut self, tower: Tower) {
                let rank = tower.rank;
                let suit = tower.suit;
                let hand = tower.kind;
                let left_top = tower.left_top;
                self.towers.place_tower(tower);
                self.route = calculate_routes(
                        &self.towers.coords(),
                        &TRAVEL_POINTS,
                        MAP_SIZE,
                    )
                    .unwrap();
                self.record_event(HistoryEventType::TowerPlaced {
                    tower_kind: hand,
                    rank,
                    suit,
                    left_top,
                });
            }
            pub fn take_damage(&mut self, damage: f32) {
                let mut actual_damage = damage;
                if self.shield > 0.0 {
                    let absorbed = damage.min(self.shield);
                    actual_damage -= absorbed;
                    self.shield -= absorbed;
                }
                self.hp -= actual_damage;
                if actual_damage > 0.0 {
                    self.record_event(HistoryEventType::DamageTaken {
                        amount: actual_damage,
                    });
                }
                if self.hp <= 0.0 {
                    self.goto_result();
                }
            }
            pub fn purchase_shop_item(&mut self, slot_index: usize) {
                let GameFlow::SelectingTower(flow) = &mut self.flow else {
                    ::core::panicking::panic("internal error: entered unreachable code")
                };
                let Some(slot) = flow.shop.slots.get_mut(slot_index) else {
                    return;
                };
                match slot {
                    ShopSlot::Locked => {}
                    ShopSlot::Item { item, cost, purchased } => {
                        if *purchased {
                            return;
                        }
                        if self.gold < *cost {
                            return;
                        }
                        if self.items.len() >= MAX_INVENTORY_SLOT {
                            return;
                        }
                        if self.stage_modifiers.is_item_and_upgrade_purchases_disabled()
                        {
                            return;
                        }
                        let item_clone = item.clone();
                        let cost_value = *cost;
                        *purchased = true;
                        self.items.push(item_clone.clone());
                        self.record_event(HistoryEventType::ItemPurchased {
                            item: item_clone,
                            cost: cost_value,
                        });
                        self.spend_gold(cost_value);
                    }
                    ShopSlot::Upgrade { upgrade, cost, purchased } => {
                        if *purchased {
                            return;
                        }
                        if self.gold < *cost {
                            return;
                        }
                        if self.stage_modifiers.is_item_and_upgrade_purchases_disabled()
                        {
                            return;
                        }
                        let upgrade_value = *upgrade;
                        let cost_value = *cost;
                        *purchased = true;
                        self.upgrade_state.upgrade(upgrade_value);
                        self.record_event(HistoryEventType::UpgradePurchased {
                            upgrade: upgrade_value,
                            cost: cost_value,
                        });
                        self.spend_gold(cost_value);
                    }
                    ShopSlot::Contract { contract, cost, purchased } => {
                        if *purchased {
                            return;
                        }
                        if self.gold < *cost {
                            return;
                        }
                        let contract_value = contract.clone();
                        let cost_value = *cost;
                        *purchased = true;
                        sign_contract(self, contract_value.clone());
                        self.record_event(HistoryEventType::ContractPurchased {
                            contract: contract_value,
                            cost: cost_value,
                        });
                        self.spend_gold(cost_value);
                    }
                }
            }
            pub fn use_item(&mut self, item: &item::Item) {
                if self.stage_modifiers.is_item_use_disabled() {
                    return;
                }
                self.item_used = true;
                run_effect(self, &item.effect);
                self.record_event(HistoryEventType::ItemUsed {
                    item_effect: item.effect.clone(),
                });
            }
            pub fn can_purchase_shop_item(&self, slot_index: usize) -> bool {
                let GameFlow::SelectingTower(flow) = &self.flow else {
                    return false;
                };
                let Some(slot) = flow.shop.slots.get(slot_index) else {
                    return false;
                };
                match slot {
                    ShopSlot::Locked => false,
                    ShopSlot::Item { cost, purchased, .. } => {
                        !*purchased && self.gold >= *cost
                            && self.items.len() < MAX_INVENTORY_SLOT
                            && !self
                                .stage_modifiers
                                .is_item_and_upgrade_purchases_disabled()
                    }
                    ShopSlot::Upgrade { cost, purchased, .. } => {
                        !*purchased && self.gold >= *cost
                            && !self
                                .stage_modifiers
                                .is_item_and_upgrade_purchases_disabled()
                    }
                    ShopSlot::Contract { cost, purchased, .. } => {
                        !*purchased && self.gold >= *cost
                    }
                }
            }
        }
    }
    pub mod fast_forward {
        use crate::*;
        use std::num::NonZeroUsize;
        pub enum FastForwardMultiplier {
            #[default]
            X1,
            X2,
            X4,
            X8,
            X16,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FastForwardMultiplier {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        FastForwardMultiplier::X1 => "X1",
                        FastForwardMultiplier::X2 => "X2",
                        FastForwardMultiplier::X4 => "X4",
                        FastForwardMultiplier::X8 => "X8",
                        FastForwardMultiplier::X16 => "X16",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FastForwardMultiplier {
            #[inline]
            fn clone(&self) -> FastForwardMultiplier {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for FastForwardMultiplier {}
        #[automatically_derived]
        impl ::core::default::Default for FastForwardMultiplier {
            #[inline]
            fn default() -> FastForwardMultiplier {
                Self::X1
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FastForwardMultiplier {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FastForwardMultiplier {
            #[inline]
            fn eq(&self, other: &FastForwardMultiplier) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for FastForwardMultiplier {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl bincode::Encode for FastForwardMultiplier {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::X1 => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::X2 => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::X4 => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::X8 => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                    Self::X16 => {
                        bincode::Encode::encode(&4u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for FastForwardMultiplier {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::X1),
                    1u32 => Ok(Self::X2),
                    2u32 => Ok(Self::X4),
                    3u32 => Ok(Self::X8),
                    4u32 => Ok(Self::X16),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 4u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for FastForwardMultiplier {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::X1 => {
                        buf.write_string("X1");
                    }
                    Self::X2 => {
                        buf.write_string("X2");
                    }
                    Self::X4 => {
                        buf.write_string("X4");
                    }
                    Self::X8 => {
                        buf.write_string("X8");
                    }
                    Self::X16 => {
                        buf.write_string("X16");
                    }
                }
            }
        }
        impl Deserialize for FastForwardMultiplier {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "X1" => Ok(Self::X1),
                    "X2" => Ok(Self::X2),
                    "X4" => Ok(Self::X4),
                    "X8" => Ok(Self::X8),
                    "X16" => Ok(Self::X16),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl FastForwardMultiplier {
            pub fn next(self) -> Self {
                match self {
                    FastForwardMultiplier::X1 => FastForwardMultiplier::X2,
                    FastForwardMultiplier::X2 => FastForwardMultiplier::X4,
                    FastForwardMultiplier::X4 => FastForwardMultiplier::X8,
                    FastForwardMultiplier::X8 => FastForwardMultiplier::X16,
                    FastForwardMultiplier::X16 => FastForwardMultiplier::X16,
                }
            }
            pub fn prev(self) -> Self {
                match self {
                    FastForwardMultiplier::X1 => FastForwardMultiplier::X1,
                    FastForwardMultiplier::X2 => FastForwardMultiplier::X1,
                    FastForwardMultiplier::X4 => FastForwardMultiplier::X2,
                    FastForwardMultiplier::X8 => FastForwardMultiplier::X4,
                    FastForwardMultiplier::X16 => FastForwardMultiplier::X8,
                }
            }
            pub fn time_scale(self) -> NonZeroUsize {
                NonZeroUsize::new(
                        match self {
                            FastForwardMultiplier::X1 => 1,
                            FastForwardMultiplier::X2 => 2,
                            FastForwardMultiplier::X4 => 4,
                            FastForwardMultiplier::X8 => 8,
                            FastForwardMultiplier::X16 => 16,
                        },
                    )
                    .unwrap()
            }
        }
    }
    pub mod field_particle {
        pub mod emitter {
            mod damage_text {
                use crate::{MapCoordF32, game_state::field_particle::DamageTextParticle};
                use namui::*;
                use rand::Rng;
                pub struct DamageTextEmitter {
                    monster_xy: MapCoordF32,
                    damage: f32,
                    emitted: bool,
                }
                impl bincode::Encode for DamageTextEmitter {
                    fn encode<__E: bincode::enc::Encoder>(
                        &self,
                        encoder: &mut __E,
                    ) -> core::result::Result<(), bincode::error::EncodeError> {
                        bincode::Encode::encode(&self.monster_xy, encoder)?;
                        bincode::Encode::encode(&self.damage, encoder)?;
                        bincode::Encode::encode(&self.emitted, encoder)?;
                        Ok(())
                    }
                }
                impl bincode::Decode<()> for DamageTextEmitter {
                    fn decode<__D: bincode::de::Decoder<Context = ()>>(
                        decoder: &mut __D,
                    ) -> core::result::Result<Self, bincode::error::DecodeError> {
                        Ok(Self {
                            monster_xy: bincode::Decode::decode(decoder)?,
                            damage: bincode::Decode::decode(decoder)?,
                            emitted: bincode::Decode::decode(decoder)?,
                        })
                    }
                }
                impl Serialize for DamageTextEmitter {
                    fn serialize(&self, buf: &mut Vec<u8>) {
                        buf.write_string(std::any::type_name::<Self>());
                        self.serialize_without_name(buf);
                    }
                    fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                        buf.write_string("monster_xy");
                        self.monster_xy.serialize_without_name(buf);
                        buf.write_string("damage");
                        self.damage.serialize_without_name(buf);
                        buf.write_string("emitted");
                        self.emitted.serialize_without_name(buf);
                    }
                }
                impl Deserialize for DamageTextEmitter {
                    fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                        buf.read_name(std::any::type_name::<Self>())?;
                        Self::deserialize_without_name(buf)
                    }
                    fn deserialize_without_name(
                        buf: &mut &[u8],
                    ) -> Result<Self, DeserializeError> {
                        let field_name = buf.read_name("monster_xy")?;
                        let monster_xy = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage")?;
                        let damage = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("emitted")?;
                        let emitted = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self {
                            monster_xy,
                            damage,
                            emitted,
                        })
                    }
                }
                impl DamageTextEmitter {
                    pub fn new(monster_xy: MapCoordF32, damage: f32) -> Self {
                        Self {
                            monster_xy,
                            damage,
                            emitted: false,
                        }
                    }
                    fn map_coord_to_pixel(&self, coord: MapCoordF32) -> Xy<Px> {
                        let tile_size = crate::game_state::TILE_PX_SIZE;
                        tile_size.to_xy() * coord
                    }
                }
                impl namui::particle::Emitter<
                    crate::game_state::field_particle::FieldParticle,
                > for DamageTextEmitter {
                    fn emit(
                        &mut self,
                        now: Instant,
                        _dt: Duration,
                    ) -> Vec<crate::game_state::field_particle::FieldParticle> {
                        if self.emitted {
                            return ::alloc::vec::Vec::new();
                        }
                        let mut rng = rand::thread_rng();
                        let xy = self.monster_xy
                            + MapCoordF32::new(
                                rng.gen_range(0.25..=0.75),
                                rng.gen_range(0.25..=0.75),
                            );
                        let xy = self.map_coord_to_pixel(xy);
                        let particle = DamageTextParticle::new(xy, self.damage, now);
                        self.emitted = true;
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                crate::game_state::field_particle::FieldParticle::DamageText {
                                    particle,
                                },
                            ]),
                        )
                    }
                    fn is_done(&self, _now: Instant) -> bool {
                        self.emitted
                    }
                }
            }
            mod monster_status_effect {
                use crate::MapCoordF32;
                use crate::game_state::{
                    field_particle::{
                        FieldParticle, particle::{IconParticle, IconParticleBehavior},
                    },
                    monster::MonsterStatusEffectKind,
                };
                use crate::icon::{
                    Icon, IconAttribute, IconAttributePosition, IconKind, IconSize,
                };
                use namui::*;
                use rand::Rng;
                const MONSTER_DEBUFF_ICON_SIZE: f32 = 24.0;
                const MONSTER_DEBUFF_FADE_DURATION_MS: i64 = 3000;
                const MONSTER_DEBUFF_MIN_SPEED: f32 = 6.0;
                const MONSTER_DEBUFF_MAX_SPEED: f32 = 12.0;
                const MONSTER_DEBUFF_INITIAL_OPACITY: f32 = 0.9;
                const MIN_INSTANT_PARTICLE_COUNT: usize = 1;
                const MAX_INSTANT_PARTICLE_COUNT: usize = 2;
                pub struct MonsterStatusEffectEmitter {
                    monster_xy: MapCoordF32,
                    debuff_kind: MonsterStatusEffectKind,
                    has_emitted: bool,
                }
                impl bincode::Encode for MonsterStatusEffectEmitter {
                    fn encode<__E: bincode::enc::Encoder>(
                        &self,
                        encoder: &mut __E,
                    ) -> core::result::Result<(), bincode::error::EncodeError> {
                        bincode::Encode::encode(&self.monster_xy, encoder)?;
                        bincode::Encode::encode(&self.debuff_kind, encoder)?;
                        bincode::Encode::encode(&self.has_emitted, encoder)?;
                        Ok(())
                    }
                }
                impl bincode::Decode<()> for MonsterStatusEffectEmitter {
                    fn decode<__D: bincode::de::Decoder<Context = ()>>(
                        decoder: &mut __D,
                    ) -> core::result::Result<Self, bincode::error::DecodeError> {
                        Ok(Self {
                            monster_xy: bincode::Decode::decode(decoder)?,
                            debuff_kind: bincode::Decode::decode(decoder)?,
                            has_emitted: bincode::Decode::decode(decoder)?,
                        })
                    }
                }
                impl Serialize for MonsterStatusEffectEmitter {
                    fn serialize(&self, buf: &mut Vec<u8>) {
                        buf.write_string(std::any::type_name::<Self>());
                        self.serialize_without_name(buf);
                    }
                    fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                        buf.write_string("monster_xy");
                        self.monster_xy.serialize_without_name(buf);
                        buf.write_string("debuff_kind");
                        self.debuff_kind.serialize_without_name(buf);
                        buf.write_string("has_emitted");
                        self.has_emitted.serialize_without_name(buf);
                    }
                }
                impl Deserialize for MonsterStatusEffectEmitter {
                    fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                        buf.read_name(std::any::type_name::<Self>())?;
                        Self::deserialize_without_name(buf)
                    }
                    fn deserialize_without_name(
                        buf: &mut &[u8],
                    ) -> Result<Self, DeserializeError> {
                        let field_name = buf.read_name("monster_xy")?;
                        let monster_xy = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("debuff_kind")?;
                        let debuff_kind = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("has_emitted")?;
                        let has_emitted = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self {
                            monster_xy,
                            debuff_kind,
                            has_emitted,
                        })
                    }
                }
                impl MonsterStatusEffectEmitter {
                    pub fn new(
                        _now: Instant,
                        monster_xy: MapCoordF32,
                        debuff_kind: MonsterStatusEffectKind,
                        _duration: Duration,
                    ) -> Self {
                        Self {
                            monster_xy,
                            debuff_kind,
                            has_emitted: false,
                        }
                    }
                    pub fn new_with_default_duration(
                        now: Instant,
                        monster_xy: MapCoordF32,
                        debuff_kind: MonsterStatusEffectKind,
                    ) -> Self {
                        Self::new(now, monster_xy, debuff_kind, Duration::ZERO)
                    }
                    fn create_monster_debuff_icon(&self) -> Icon {
                        let (icon_kind, attribute_icon) = match &self.debuff_kind {
                            MonsterStatusEffectKind::SpeedMul { mul } => {
                                if *mul < 1.0 {
                                    (IconKind::MoveSpeed, Some(IconKind::Down))
                                } else {
                                    (IconKind::MoveSpeed, Some(IconKind::Up))
                                }
                            }
                            MonsterStatusEffectKind::Invincible => {
                                (IconKind::Invincible, None)
                            }
                            MonsterStatusEffectKind::ImmuneToSlow => {
                                (IconKind::Shield, None)
                            }
                        };
                        Icon {
                            kind: icon_kind,
                            size: IconSize::Custom {
                                size: px(MONSTER_DEBUFF_ICON_SIZE),
                            },
                            attributes: if let Some(attr_icon) = attribute_icon {
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        IconAttribute {
                                            icon_kind: attr_icon,
                                            position: IconAttributePosition::TopRight,
                                        },
                                    ]),
                                )
                            } else {
                                ::alloc::vec::Vec::new()
                            },
                            wh: Wh::single(px(MONSTER_DEBUFF_ICON_SIZE)),
                            opacity: MONSTER_DEBUFF_INITIAL_OPACITY,
                        }
                    }
                    fn map_coord_to_pixel_f32(&self, coord: MapCoordF32) -> Xy<f32> {
                        let tile_size = crate::game_state::TILE_PX_SIZE;
                        let pixel = tile_size.to_xy() * coord;
                        Xy {
                            x: pixel.x.as_f32(),
                            y: pixel.y.as_f32(),
                        }
                    }
                    fn create_fade_rise_particle(&self, now: Instant) -> FieldParticle {
                        let mut rng = rand::thread_rng();
                        let xy = self.monster_xy
                            + MapCoordF32::new(
                                rng.gen_range(0.25..=0.75),
                                rng.gen_range(0.25..=0.75),
                            );
                        let position = self.map_coord_to_pixel_f32(xy);
                        let debuff_icon = self.create_monster_debuff_icon();
                        let behavior = IconParticleBehavior::FadeRise {
                            duration: Duration::from_millis(
                                MONSTER_DEBUFF_FADE_DURATION_MS,
                            ),
                            speed: rng
                                .gen_range(
                                    MONSTER_DEBUFF_MIN_SPEED..=MONSTER_DEBUFF_MAX_SPEED,
                                ),
                            created_at: now,
                            initial_opacity: MONSTER_DEBUFF_INITIAL_OPACITY,
                        };
                        let icon_particle = IconParticle {
                            icon: debuff_icon,
                            xy: Xy::new(px(position.x), px(position.y)),
                            rotation: 0.0.deg(),
                            behavior,
                        };
                        FieldParticle::Icon {
                            particle: icon_particle,
                        }
                    }
                    pub fn emit(
                        &mut self,
                        now: Instant,
                        _dt: Duration,
                    ) -> Vec<FieldParticle> {
                        if self.has_emitted {
                            return ::alloc::vec::Vec::new();
                        }
                        let mut rng = rand::thread_rng();
                        let particle_count = rng
                            .gen_range(
                                MIN_INSTANT_PARTICLE_COUNT..=MAX_INSTANT_PARTICLE_COUNT,
                            );
                        let mut particles = Vec::with_capacity(particle_count);
                        for _ in 0..particle_count {
                            particles.push(self.create_fade_rise_particle(now));
                        }
                        self.has_emitted = true;
                        particles
                    }
                    pub fn is_done(&self, _now: Instant) -> bool {
                        self.has_emitted
                    }
                }
            }
            pub use damage_text::*;
            pub use monster_status_effect::*;
        }
        pub mod particle {
            mod damage_text {
                use namui::*;
                pub struct DamageTextParticle {
                    pub position: Xy<Px>,
                    pub display_value: String,
                    pub display_color: Color,
                    pub created_at: Instant,
                    pub duration: Duration,
                    pub opacity: u8,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for DamageTextParticle {
                    #[inline]
                    fn clone(&self) -> DamageTextParticle {
                        DamageTextParticle {
                            position: ::core::clone::Clone::clone(&self.position),
                            display_value: ::core::clone::Clone::clone(
                                &self.display_value,
                            ),
                            display_color: ::core::clone::Clone::clone(
                                &self.display_color,
                            ),
                            created_at: ::core::clone::Clone::clone(&self.created_at),
                            duration: ::core::clone::Clone::clone(&self.duration),
                            opacity: ::core::clone::Clone::clone(&self.opacity),
                        }
                    }
                }
                impl bincode::Encode for DamageTextParticle {
                    fn encode<__E: bincode::enc::Encoder>(
                        &self,
                        encoder: &mut __E,
                    ) -> core::result::Result<(), bincode::error::EncodeError> {
                        bincode::Encode::encode(&self.position, encoder)?;
                        bincode::Encode::encode(&self.display_value, encoder)?;
                        bincode::Encode::encode(&self.display_color, encoder)?;
                        bincode::Encode::encode(&self.created_at, encoder)?;
                        bincode::Encode::encode(&self.duration, encoder)?;
                        bincode::Encode::encode(&self.opacity, encoder)?;
                        Ok(())
                    }
                }
                impl bincode::Decode<()> for DamageTextParticle {
                    fn decode<__D: bincode::de::Decoder<Context = ()>>(
                        decoder: &mut __D,
                    ) -> core::result::Result<Self, bincode::error::DecodeError> {
                        Ok(Self {
                            position: bincode::Decode::decode(decoder)?,
                            display_value: bincode::Decode::decode(decoder)?,
                            display_color: bincode::Decode::decode(decoder)?,
                            created_at: bincode::Decode::decode(decoder)?,
                            duration: bincode::Decode::decode(decoder)?,
                            opacity: bincode::Decode::decode(decoder)?,
                        })
                    }
                }
                impl Serialize for DamageTextParticle {
                    fn serialize(&self, buf: &mut Vec<u8>) {
                        buf.write_string(std::any::type_name::<Self>());
                        self.serialize_without_name(buf);
                    }
                    fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                        buf.write_string("position");
                        self.position.serialize_without_name(buf);
                        buf.write_string("display_value");
                        self.display_value.serialize_without_name(buf);
                        buf.write_string("display_color");
                        self.display_color.serialize_without_name(buf);
                        buf.write_string("created_at");
                        self.created_at.serialize_without_name(buf);
                        buf.write_string("duration");
                        self.duration.serialize_without_name(buf);
                        buf.write_string("opacity");
                        self.opacity.serialize_without_name(buf);
                    }
                }
                impl Deserialize for DamageTextParticle {
                    fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                        buf.read_name(std::any::type_name::<Self>())?;
                        Self::deserialize_without_name(buf)
                    }
                    fn deserialize_without_name(
                        buf: &mut &[u8],
                    ) -> Result<Self, DeserializeError> {
                        let field_name = buf.read_name("position")?;
                        let position = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("display_value")?;
                        let display_value = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("display_color")?;
                        let display_color = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("created_at")?;
                        let created_at = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("duration")?;
                        let duration = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("opacity")?;
                        let opacity = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self {
                            position,
                            display_value,
                            display_color,
                            created_at,
                            duration,
                            opacity,
                        })
                    }
                }
                impl DamageTextParticle {
                    pub fn new(
                        position: Xy<Px>,
                        damage_value: f32,
                        now: Instant,
                    ) -> Self {
                        let display_value = Self::format_display_value(damage_value);
                        let display_color = Self::calculate_display_color(damage_value);
                        Self {
                            position,
                            display_value,
                            display_color,
                            created_at: now,
                            duration: Duration::from_millis(800),
                            opacity: 255,
                        }
                    }
                    pub fn progress(&self, now: Instant) -> f32 {
                        ((now - self.created_at).as_secs_f32()
                            / self.duration.as_secs_f32())
                            .clamp(0.0, 1.0)
                    }
                    pub fn current_opacity(&self, now: Instant) -> u8 {
                        let progress = self.progress(now);
                        (self.opacity as f32 * (1.0 - progress))
                            .round()
                            .clamp(0.0, 255.0) as u8
                    }
                    pub fn y_offset(&self, now: Instant) -> Px {
                        px(self.progress(now) * 24.0)
                    }
                    pub fn is_done(&self, now: Instant) -> bool {
                        now - self.created_at >= self.duration
                    }
                    fn format_display_value(damage_value: f32) -> String {
                        let abs_value = damage_value.abs();
                        if abs_value >= 1_000_000_000.0 {
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0:.1}b", damage_value / 1_000_000_000.0),
                                )
                            })
                        } else if abs_value >= 1_000_000.0 {
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0:.1}m", damage_value / 1_000_000.0),
                                )
                            })
                        } else if abs_value >= 1_000.0 {
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0:.1}k", damage_value / 1_000.0),
                                )
                            })
                        } else {
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(format_args!("{0:.0}", damage_value))
                            })
                        }
                    }
                    pub fn tick(&mut self, now: Instant, delta_time: Duration) {
                        let elapsed = now - self.created_at;
                        let progress = (elapsed.as_secs_f32()
                            / self.duration.as_secs_f32())
                            .clamp(0.0, 1.0);
                        self.position.y
                            -= px(
                                24.0 * delta_time.as_secs_f32()
                                    / self.duration.as_secs_f32(),
                            );
                        self.opacity = (255.0 * (1.0 - progress))
                            .round()
                            .clamp(0.0, 255.0) as u8;
                    }
                    pub fn render(&self) -> RenderingTree {
                        let opacity = self.opacity;
                        let style = TextStyle {
                            border: Some(TextStyleBorder {
                                color: Color::BLACK.with_alpha(opacity),
                                width: 4.0.into(),
                            }),
                            color: self.display_color.with_alpha(opacity),
                            ..Default::default()
                        };
                        namui::translate(
                            self.position.x,
                            self.position.y,
                            namui::text(namui::TextParam {
                                text: self.display_value.clone(),
                                x: 0.px(),
                                y: 0.px(),
                                align: namui::TextAlign::Center,
                                baseline: namui::TextBaseline::Middle,
                                font: namui::Font {
                                    name: crate::theme::typography::HEADLINE_FONT_NAME
                                        .to_string(),
                                    size: int_px(64),
                                },
                                style,
                                max_width: None,
                            }),
                        )
                    }
                    fn calculate_display_color(damage_value: f32) -> Color {
                        const YELLOW_THRESHOLD: f32 = 2000.0;
                        const RED_THRESHOLD: f32 = 10000.0;
                        let (r, g, b) = if damage_value < YELLOW_THRESHOLD {
                            let t = (damage_value / YELLOW_THRESHOLD).clamp(0.0, 1.0);
                            let r = (255.0 * t + 255.0 * (1.0 - t)).round() as u8;
                            let g = (220.0 * t + 255.0 * (1.0 - t)).round() as u8;
                            let b = (40.0 * t + 255.0 * (1.0 - t)).round() as u8;
                            (r, g, b)
                        } else if damage_value < RED_THRESHOLD {
                            let t = ((damage_value - YELLOW_THRESHOLD)
                                / (RED_THRESHOLD - YELLOW_THRESHOLD))
                                .clamp(0.0, 1.0);
                            let r = 255u8;
                            let g = (40.0 * t + 220.0 * (1.0 - t)).round() as u8;
                            let b = (40.0 * t + 40.0 * (1.0 - t)).round() as u8;
                            (r, g, b)
                        } else {
                            (255u8, 40u8, 40u8)
                        };
                        Color::from_u8(r, g, b, 255)
                    }
                }
            }
            mod icon {
                use crate::icon::Icon;
                use namui::*;
                pub struct IconParticle {
                    pub icon: Icon,
                    pub xy: Xy<Px>,
                    pub rotation: Angle,
                    pub behavior: IconParticleBehavior,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for IconParticle {
                    #[inline]
                    fn clone(&self) -> IconParticle {
                        IconParticle {
                            icon: ::core::clone::Clone::clone(&self.icon),
                            xy: ::core::clone::Clone::clone(&self.xy),
                            rotation: ::core::clone::Clone::clone(&self.rotation),
                            behavior: ::core::clone::Clone::clone(&self.behavior),
                        }
                    }
                }
                impl bincode::Encode for IconParticle {
                    fn encode<__E: bincode::enc::Encoder>(
                        &self,
                        encoder: &mut __E,
                    ) -> core::result::Result<(), bincode::error::EncodeError> {
                        bincode::Encode::encode(&self.icon, encoder)?;
                        bincode::Encode::encode(&self.xy, encoder)?;
                        bincode::Encode::encode(&self.rotation, encoder)?;
                        bincode::Encode::encode(&self.behavior, encoder)?;
                        Ok(())
                    }
                }
                impl bincode::Decode<()> for IconParticle {
                    fn decode<__D: bincode::de::Decoder<Context = ()>>(
                        decoder: &mut __D,
                    ) -> core::result::Result<Self, bincode::error::DecodeError> {
                        Ok(Self {
                            icon: bincode::Decode::decode(decoder)?,
                            xy: bincode::Decode::decode(decoder)?,
                            rotation: bincode::Decode::decode(decoder)?,
                            behavior: bincode::Decode::decode(decoder)?,
                        })
                    }
                }
                impl Serialize for IconParticle {
                    fn serialize(&self, buf: &mut Vec<u8>) {
                        buf.write_string(std::any::type_name::<Self>());
                        self.serialize_without_name(buf);
                    }
                    fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                        buf.write_string("icon");
                        self.icon.serialize_without_name(buf);
                        buf.write_string("xy");
                        self.xy.serialize_without_name(buf);
                        buf.write_string("rotation");
                        self.rotation.serialize_without_name(buf);
                        buf.write_string("behavior");
                        self.behavior.serialize_without_name(buf);
                    }
                }
                impl Deserialize for IconParticle {
                    fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                        buf.read_name(std::any::type_name::<Self>())?;
                        Self::deserialize_without_name(buf)
                    }
                    fn deserialize_without_name(
                        buf: &mut &[u8],
                    ) -> Result<Self, DeserializeError> {
                        let field_name = buf.read_name("icon")?;
                        let icon = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("xy")?;
                        let xy = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("rotation")?;
                        let rotation = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("behavior")?;
                        let behavior = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self {
                            icon,
                            xy,
                            rotation,
                            behavior,
                        })
                    }
                }
                impl IconParticle {
                    pub fn tick(&mut self, now: Instant, dt: Duration) {
                        match &mut self.behavior {
                            IconParticleBehavior::FadeRise {
                                duration,
                                speed,
                                created_at,
                                initial_opacity,
                            } => {
                                let elapsed = now - *created_at;
                                let progress = (elapsed.as_secs_f64()
                                    / duration.as_secs_f64()) as f32;
                                self.xy.y -= px(*speed * dt.as_secs_f32());
                                self.icon.opacity = *initial_opacity
                                    * (1.0_f32 - progress).max(0.0_f32);
                            }
                            IconParticleBehavior::Physics {
                                velocity,
                                angular_velocity,
                                created_at,
                                duration,
                                scale,
                                air_resistance,
                                angular_resistance,
                                gravity_acceleration_per_second,
                                ..
                            } => {
                                let elapsed = now - *created_at;
                                let progress = (elapsed.as_secs_f64()
                                    / duration.as_secs_f64())
                                    .clamp(0.0, 1.0) as f32;
                                let mut delta_position_per_second = *velocity * 1.sec();
                                let gravity = *gravity_acceleration_per_second * 1.sec()
                                    * dt.as_secs_f32();
                                delta_position_per_second.y += gravity;
                                let resistance = 1.0 - (*air_resistance * dt);
                                delta_position_per_second *= resistance;
                                *velocity = Per::new(delta_position_per_second, 1.sec());
                                let v = *velocity * dt;
                                self.xy.x += v.x;
                                self.xy.y += v.y;
                                let mut delta_rotation_per_second = *angular_velocity
                                    * 1.sec();
                                let ang_resistance = 1.0 - (*angular_resistance * dt);
                                delta_rotation_per_second *= ang_resistance;
                                *angular_velocity = Per::new(
                                    delta_rotation_per_second,
                                    1.sec(),
                                );
                                self.rotation += *angular_velocity * dt;
                                let eased = fast_in_slow_out_easing(progress);
                                *scale = eased;
                                self.icon.opacity = eased;
                            }
                        }
                    }
                    pub fn render(&self) -> RenderingTree {
                        let half_wh = self.icon.wh / 2.0;
                        namui::translate(
                            self.xy.x,
                            self.xy.y,
                            namui::rotate(
                                self.rotation,
                                namui::translate(
                                    -half_wh.width,
                                    -half_wh.height,
                                    self.icon.to_rendering_tree(),
                                ),
                            ),
                        )
                    }
                    pub fn is_done(&self, now: Instant) -> bool {
                        match &self.behavior {
                            IconParticleBehavior::FadeRise {
                                duration,
                                created_at,
                                ..
                            } => {
                                let elapsed = now - *created_at;
                                elapsed >= *duration
                            }
                            IconParticleBehavior::Physics {
                                created_at,
                                duration,
                                ..
                            } => {
                                let elapsed = now - *created_at;
                                elapsed >= *duration
                            }
                        }
                    }
                }
                pub enum IconParticleBehavior {
                    FadeRise {
                        duration: Duration,
                        speed: f32,
                        created_at: Instant,
                        initial_opacity: f32,
                    },
                    Physics {
                        duration: Duration,
                        created_at: Instant,
                        velocity: Per<Xy<Px>, Duration>,
                        angular_velocity: Per<Angle, Duration>,
                        scale: f32,
                        air_resistance: Per<f32, Duration>,
                        angular_resistance: Per<f32, Duration>,
                        gravity_acceleration_per_second: Per<Px, Duration>,
                    },
                }
                #[automatically_derived]
                impl ::core::clone::Clone for IconParticleBehavior {
                    #[inline]
                    fn clone(&self) -> IconParticleBehavior {
                        match self {
                            IconParticleBehavior::FadeRise {
                                duration: __self_0,
                                speed: __self_1,
                                created_at: __self_2,
                                initial_opacity: __self_3,
                            } => {
                                IconParticleBehavior::FadeRise {
                                    duration: ::core::clone::Clone::clone(__self_0),
                                    speed: ::core::clone::Clone::clone(__self_1),
                                    created_at: ::core::clone::Clone::clone(__self_2),
                                    initial_opacity: ::core::clone::Clone::clone(__self_3),
                                }
                            }
                            IconParticleBehavior::Physics {
                                duration: __self_0,
                                created_at: __self_1,
                                velocity: __self_2,
                                angular_velocity: __self_3,
                                scale: __self_4,
                                air_resistance: __self_5,
                                angular_resistance: __self_6,
                                gravity_acceleration_per_second: __self_7,
                            } => {
                                IconParticleBehavior::Physics {
                                    duration: ::core::clone::Clone::clone(__self_0),
                                    created_at: ::core::clone::Clone::clone(__self_1),
                                    velocity: ::core::clone::Clone::clone(__self_2),
                                    angular_velocity: ::core::clone::Clone::clone(__self_3),
                                    scale: ::core::clone::Clone::clone(__self_4),
                                    air_resistance: ::core::clone::Clone::clone(__self_5),
                                    angular_resistance: ::core::clone::Clone::clone(__self_6),
                                    gravity_acceleration_per_second: ::core::clone::Clone::clone(
                                        __self_7,
                                    ),
                                }
                            }
                        }
                    }
                }
                impl bincode::Encode for IconParticleBehavior {
                    fn encode<__E: bincode::enc::Encoder>(
                        &self,
                        encoder: &mut __E,
                    ) -> core::result::Result<(), bincode::error::EncodeError> {
                        match self {
                            Self::FadeRise {
                                duration,
                                speed,
                                created_at,
                                initial_opacity,
                            } => {
                                bincode::Encode::encode(&0u32, encoder)?;
                                bincode::Encode::encode(duration, encoder)?;
                                bincode::Encode::encode(speed, encoder)?;
                                bincode::Encode::encode(created_at, encoder)?;
                                bincode::Encode::encode(initial_opacity, encoder)?;
                            }
                            Self::Physics {
                                duration,
                                created_at,
                                velocity,
                                angular_velocity,
                                scale,
                                air_resistance,
                                angular_resistance,
                                gravity_acceleration_per_second,
                            } => {
                                bincode::Encode::encode(&1u32, encoder)?;
                                bincode::Encode::encode(duration, encoder)?;
                                bincode::Encode::encode(created_at, encoder)?;
                                bincode::Encode::encode(velocity, encoder)?;
                                bincode::Encode::encode(angular_velocity, encoder)?;
                                bincode::Encode::encode(scale, encoder)?;
                                bincode::Encode::encode(air_resistance, encoder)?;
                                bincode::Encode::encode(angular_resistance, encoder)?;
                                bincode::Encode::encode(
                                    gravity_acceleration_per_second,
                                    encoder,
                                )?;
                            }
                        }
                        Ok(())
                    }
                }
                impl bincode::Decode<()> for IconParticleBehavior {
                    fn decode<__D: bincode::de::Decoder<Context = ()>>(
                        decoder: &mut __D,
                    ) -> core::result::Result<Self, bincode::error::DecodeError> {
                        let discriminant: u32 = bincode::Decode::decode(decoder)?;
                        match discriminant {
                            0u32 => {
                                Ok(Self::FadeRise {
                                    duration: bincode::Decode::decode(decoder)?,
                                    speed: bincode::Decode::decode(decoder)?,
                                    created_at: bincode::Decode::decode(decoder)?,
                                    initial_opacity: bincode::Decode::decode(decoder)?,
                                })
                            }
                            1u32 => {
                                Ok(Self::Physics {
                                    duration: bincode::Decode::decode(decoder)?,
                                    created_at: bincode::Decode::decode(decoder)?,
                                    velocity: bincode::Decode::decode(decoder)?,
                                    angular_velocity: bincode::Decode::decode(decoder)?,
                                    scale: bincode::Decode::decode(decoder)?,
                                    air_resistance: bincode::Decode::decode(decoder)?,
                                    angular_resistance: bincode::Decode::decode(decoder)?,
                                    gravity_acceleration_per_second: bincode::Decode::decode(
                                        decoder,
                                    )?,
                                })
                            }
                            _ => {
                                Err(bincode::error::DecodeError::UnexpectedVariant {
                                    type_name: core::any::type_name::<Self>(),
                                    allowed: &bincode::error::AllowedEnumVariants::Range {
                                        min: 0,
                                        max: 1u32,
                                    },
                                    found: discriminant,
                                })
                            }
                        }
                    }
                }
                impl Serialize for IconParticleBehavior {
                    fn serialize(&self, buf: &mut Vec<u8>) {
                        buf.write_string(std::any::type_name::<Self>());
                        self.serialize_without_name(buf);
                    }
                    fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                        match self {
                            Self::FadeRise {
                                duration,
                                speed,
                                created_at,
                                initial_opacity,
                            } => {
                                buf.write_string("FadeRise");
                                buf.write_string("duration");
                                duration.serialize_without_name(buf);
                                buf.write_string("speed");
                                speed.serialize_without_name(buf);
                                buf.write_string("created_at");
                                created_at.serialize_without_name(buf);
                                buf.write_string("initial_opacity");
                                initial_opacity.serialize_without_name(buf);
                            }
                            Self::Physics {
                                duration,
                                created_at,
                                velocity,
                                angular_velocity,
                                scale,
                                air_resistance,
                                angular_resistance,
                                gravity_acceleration_per_second,
                            } => {
                                buf.write_string("Physics");
                                buf.write_string("duration");
                                duration.serialize_without_name(buf);
                                buf.write_string("created_at");
                                created_at.serialize_without_name(buf);
                                buf.write_string("velocity");
                                velocity.serialize_without_name(buf);
                                buf.write_string("angular_velocity");
                                angular_velocity.serialize_without_name(buf);
                                buf.write_string("scale");
                                scale.serialize_without_name(buf);
                                buf.write_string("air_resistance");
                                air_resistance.serialize_without_name(buf);
                                buf.write_string("angular_resistance");
                                angular_resistance.serialize_without_name(buf);
                                buf.write_string("gravity_acceleration_per_second");
                                gravity_acceleration_per_second.serialize_without_name(buf);
                            }
                        }
                    }
                }
                impl Deserialize for IconParticleBehavior {
                    fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                        buf.read_name(std::any::type_name::<Self>())?;
                        Self::deserialize_without_name(buf)
                    }
                    fn deserialize_without_name(
                        buf: &mut &[u8],
                    ) -> Result<Self, DeserializeError> {
                        let variant_name = buf.read_string();
                        match variant_name.as_ref() {
                            "FadeRise" => {
                                let field_name = buf.read_name("duration")?;
                                let duration = Deserialize::deserialize_without_name(buf)?;
                                let field_name = buf.read_name("speed")?;
                                let speed = Deserialize::deserialize_without_name(buf)?;
                                let field_name = buf.read_name("created_at")?;
                                let created_at = Deserialize::deserialize_without_name(
                                    buf,
                                )?;
                                let field_name = buf.read_name("initial_opacity")?;
                                let initial_opacity = Deserialize::deserialize_without_name(
                                    buf,
                                )?;
                                Ok(Self::FadeRise {
                                    duration,
                                    speed,
                                    created_at,
                                    initial_opacity,
                                })
                            }
                            "Physics" => {
                                let field_name = buf.read_name("duration")?;
                                let duration = Deserialize::deserialize_without_name(buf)?;
                                let field_name = buf.read_name("created_at")?;
                                let created_at = Deserialize::deserialize_without_name(
                                    buf,
                                )?;
                                let field_name = buf.read_name("velocity")?;
                                let velocity = Deserialize::deserialize_without_name(buf)?;
                                let field_name = buf.read_name("angular_velocity")?;
                                let angular_velocity = Deserialize::deserialize_without_name(
                                    buf,
                                )?;
                                let field_name = buf.read_name("scale")?;
                                let scale = Deserialize::deserialize_without_name(buf)?;
                                let field_name = buf.read_name("air_resistance")?;
                                let air_resistance = Deserialize::deserialize_without_name(
                                    buf,
                                )?;
                                let field_name = buf.read_name("angular_resistance")?;
                                let angular_resistance = Deserialize::deserialize_without_name(
                                    buf,
                                )?;
                                let field_name = buf
                                    .read_name("gravity_acceleration_per_second")?;
                                let gravity_acceleration_per_second = Deserialize::deserialize_without_name(
                                    buf,
                                )?;
                                Ok(Self::Physics {
                                    duration,
                                    created_at,
                                    velocity,
                                    angular_velocity,
                                    scale,
                                    air_resistance,
                                    angular_resistance,
                                    gravity_acceleration_per_second,
                                })
                            }
                            _ => {
                                Err(DeserializeError::InvalidEnumVariant {
                                    expected: std::any::type_name::<Self>().to_string(),
                                    actual: variant_name,
                                })
                            }
                        }
                    }
                }
                fn fast_in_slow_out_easing(t: f32) -> f32 {
                    let t = t.clamp(0.0, 1.0);
                    if t < 0.1 { t / 0.1 } else { (1.0 - (t - 0.1) / 0.9).max(0.0) }
                }
            }
            pub use damage_text::*;
            pub use icon::*;
        }
        use crate::game_state::{
            GameState,
            field_particle::emitter::{DamageTextEmitter, MonsterStatusEffectEmitter},
        };
        use namui::{
            particle::{Emitter, Particle},
            *,
        };
        pub use particle::{DamageTextParticle, IconParticle};
        pub struct TempParticleEmitter {
            particles: Vec<FieldParticle>,
            emitted: bool,
        }
        impl bincode::Encode for TempParticleEmitter {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.particles, encoder)?;
                bincode::Encode::encode(&self.emitted, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for TempParticleEmitter {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    particles: bincode::Decode::decode(decoder)?,
                    emitted: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for TempParticleEmitter {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("particles");
                self.particles.serialize_without_name(buf);
                buf.write_string("emitted");
                self.emitted.serialize_without_name(buf);
            }
        }
        impl Deserialize for TempParticleEmitter {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("particles")?;
                let particles = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("emitted")?;
                let emitted = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { particles, emitted })
            }
        }
        impl TempParticleEmitter {
            pub fn new(particles: Vec<FieldParticle>) -> Self {
                Self { particles, emitted: false }
            }
            pub fn emit(&mut self, _now: Instant, _dt: Duration) -> Vec<FieldParticle> {
                if self.emitted {
                    return ::alloc::vec::Vec::new();
                }
                self.emitted = true;
                std::mem::take(&mut self.particles)
            }
            pub fn is_done(&self, _now: Instant) -> bool {
                self.emitted
            }
        }
        pub type FieldParticleSystem = namui::particle::System<
            FieldParticleEmitter,
            FieldParticle,
        >;
        pub struct FieldParticleSystemManager {
            systems: Vec<FieldParticleSystem>,
        }
        #[automatically_derived]
        impl ::core::default::Default for FieldParticleSystemManager {
            #[inline]
            fn default() -> FieldParticleSystemManager {
                FieldParticleSystemManager {
                    systems: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for FieldParticleSystemManager {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.systems, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for FieldParticleSystemManager {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    systems: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for FieldParticleSystemManager {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("systems");
                self.systems.serialize_without_name(buf);
            }
        }
        impl Deserialize for FieldParticleSystemManager {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("systems")?;
                let systems = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { systems })
            }
        }
        impl FieldParticleSystemManager {
            pub fn render(&self, ctx: &ComposeCtx, now: Instant) {
                for system in &self.systems {
                    system.render(ctx, now);
                }
            }
            pub fn add_system(&mut self, system: FieldParticleSystem) {
                self.systems.push(system);
            }
            pub fn add_emitter(&mut self, emitter: FieldParticleEmitter) {
                let system = FieldParticleSystem::new(
                    <[_]>::into_vec(::alloc::boxed::box_new([emitter])),
                );
                self.add_system(system);
            }
            pub fn add_emitters(&mut self, emitters: Vec<FieldParticleEmitter>) {
                if !emitters.is_empty() {
                    let system = FieldParticleSystem::new(emitters);
                    self.add_system(system);
                }
            }
            pub fn add_particles(&mut self, particles: Vec<FieldParticle>) {
                if !particles.is_empty() {
                    let temp_emitter = TempParticleEmitter::new(particles);
                    let emitter = FieldParticleEmitter::TempParticle {
                        emitter: temp_emitter,
                    };
                    self.add_emitter(emitter);
                }
            }
            fn remove_finished_field_particle_systems(&mut self, now: Instant) {
                self.systems.retain(|system| !system.is_done(now));
            }
        }
        pub enum FieldParticleEmitter {
            TempParticle { emitter: TempParticleEmitter },
            MonsterStatusEffect { emitter: MonsterStatusEffectEmitter },
            DamageText { emitter: DamageTextEmitter },
        }
        impl bincode::Encode for FieldParticleEmitter {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::TempParticle { emitter } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(emitter, encoder)?;
                    }
                    Self::MonsterStatusEffect { emitter } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(emitter, encoder)?;
                    }
                    Self::DamageText { emitter } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(emitter, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for FieldParticleEmitter {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::TempParticle {
                            emitter: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::MonsterStatusEffect {
                            emitter: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => {
                        Ok(Self::DamageText {
                            emitter: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 2u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for FieldParticleEmitter {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::TempParticle { emitter } => {
                        buf.write_string("TempParticle");
                        buf.write_string("emitter");
                        emitter.serialize_without_name(buf);
                    }
                    Self::MonsterStatusEffect { emitter } => {
                        buf.write_string("MonsterStatusEffect");
                        buf.write_string("emitter");
                        emitter.serialize_without_name(buf);
                    }
                    Self::DamageText { emitter } => {
                        buf.write_string("DamageText");
                        buf.write_string("emitter");
                        emitter.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for FieldParticleEmitter {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "TempParticle" => {
                        let field_name = buf.read_name("emitter")?;
                        let emitter = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TempParticle { emitter })
                    }
                    "MonsterStatusEffect" => {
                        let field_name = buf.read_name("emitter")?;
                        let emitter = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::MonsterStatusEffect {
                            emitter,
                        })
                    }
                    "DamageText" => {
                        let field_name = buf.read_name("emitter")?;
                        let emitter = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DamageText { emitter })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl Emitter<FieldParticle> for FieldParticleEmitter {
            fn emit(&mut self, now: Instant, dt: Duration) -> Vec<FieldParticle> {
                match self {
                    FieldParticleEmitter::TempParticle { emitter } => {
                        emitter.emit(now, dt)
                    }
                    FieldParticleEmitter::MonsterStatusEffect { emitter } => {
                        emitter.emit(now, dt)
                    }
                    FieldParticleEmitter::DamageText { emitter } => emitter.emit(now, dt),
                }
            }
            fn is_done(&self, now: Instant) -> bool {
                match self {
                    FieldParticleEmitter::TempParticle { emitter } => {
                        emitter.is_done(now)
                    }
                    FieldParticleEmitter::MonsterStatusEffect { emitter } => {
                        emitter.is_done(now)
                    }
                    FieldParticleEmitter::DamageText { emitter } => emitter.is_done(now),
                }
            }
        }
        pub enum FieldParticle {
            Icon { particle: IconParticle },
            DamageText { particle: DamageTextParticle },
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FieldParticle {
            #[inline]
            fn clone(&self) -> FieldParticle {
                match self {
                    FieldParticle::Icon { particle: __self_0 } => {
                        FieldParticle::Icon {
                            particle: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    FieldParticle::DamageText { particle: __self_0 } => {
                        FieldParticle::DamageText {
                            particle: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                }
            }
        }
        impl bincode::Encode for FieldParticle {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Icon { particle } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(particle, encoder)?;
                    }
                    Self::DamageText { particle } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(particle, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for FieldParticle {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::Icon {
                            particle: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::DamageText {
                            particle: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 1u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for FieldParticle {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Icon { particle } => {
                        buf.write_string("Icon");
                        buf.write_string("particle");
                        particle.serialize_without_name(buf);
                    }
                    Self::DamageText { particle } => {
                        buf.write_string("DamageText");
                        buf.write_string("particle");
                        particle.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for FieldParticle {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Icon" => {
                        let field_name = buf.read_name("particle")?;
                        let particle = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Icon { particle })
                    }
                    "DamageText" => {
                        let field_name = buf.read_name("particle")?;
                        let particle = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DamageText { particle })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl Particle<FieldParticleEmitter> for FieldParticle {
            fn tick(&mut self, now: Instant, dt: Duration) -> Vec<FieldParticleEmitter> {
                match self {
                    FieldParticle::Icon { particle } => {
                        particle.tick(now, dt);
                        ::alloc::vec::Vec::new()
                    }
                    FieldParticle::DamageText { particle } => {
                        particle.tick(now, dt);
                        ::alloc::vec::Vec::new()
                    }
                }
            }
            fn render(&self) -> RenderingTree {
                match self {
                    FieldParticle::Icon { particle } => particle.render(),
                    FieldParticle::DamageText { particle } => particle.render(),
                }
            }
            fn is_done(&self, now: Instant) -> bool {
                match self {
                    FieldParticle::Icon { particle } => particle.is_done(now),
                    FieldParticle::DamageText { particle } => particle.is_done(now),
                }
            }
        }
        pub fn remove_finished_field_particle_systems(
            game_state: &mut GameState,
            now: Instant,
        ) {
            game_state
                .field_particle_system_manager
                .remove_finished_field_particle_systems(now);
        }
    }
    pub mod flow {
        pub mod contract {
            use crate::game_state::{
                contract::{Contract, ContractEvent},
                effect::run_effect, flow::GameFlow, *,
            };
            use namui::*;
            use std::collections::VecDeque;
            const STANDBY_DURATION: Duration = Duration::from_millis(250);
            const ACTIVE_DURATION: Duration = Duration::from_millis(750);
            pub struct ContractFlow {
                pub contract_event_queue: VecDeque<ContractEvent>,
                pub state: ContractFlowState,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ContractFlow {
                #[inline]
                fn clone(&self) -> ContractFlow {
                    ContractFlow {
                        contract_event_queue: ::core::clone::Clone::clone(
                            &self.contract_event_queue,
                        ),
                        state: ::core::clone::Clone::clone(&self.state),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ContractFlow {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ContractFlow",
                        "contract_event_queue",
                        &self.contract_event_queue,
                        "state",
                        &&self.state,
                    )
                }
            }
            impl bincode::Encode for ContractFlow {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.contract_event_queue, encoder)?;
                    bincode::Encode::encode(&self.state, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for ContractFlow {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        contract_event_queue: bincode::Decode::decode(decoder)?,
                        state: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for ContractFlow {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("contract_event_queue");
                    self.contract_event_queue.serialize_without_name(buf);
                    buf.write_string("state");
                    self.state.serialize_without_name(buf);
                }
            }
            impl Deserialize for ContractFlow {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("contract_event_queue")?;
                    let contract_event_queue = Deserialize::deserialize_without_name(
                        buf,
                    )?;
                    let field_name = buf.read_name("state")?;
                    let state = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self {
                        contract_event_queue,
                        state,
                    })
                }
            }
            impl ContractFlow {
                /// Creates a new ContractFlow with the given events.
                pub fn new(events: Vec<ContractEvent>) -> Self {
                    ContractFlow {
                        contract_event_queue: VecDeque::from(events),
                        state: Default::default(),
                    }
                }
                /// Creates an empty ContractFlow.
                pub fn empty() -> Self {
                    Self::new(::alloc::vec::Vec::new())
                }
                /// Steps all contracts to the next stage (Command - modifies state only).
                /// This follows Command-Query Separation by only modifying state.
                /// Events are stored internally in each contract.
                pub fn step_all_contracts(contracts: &mut [Contract]) {
                    for contract in contracts.iter_mut() {
                        contract.step_stage();
                    }
                }
                /// Drains all pending events from all contracts (Query - returns data only).
                /// This follows Command-Query Separation by only reading data.
                /// Call this after step_all_contracts to collect generated events.
                pub fn drain_all_events(
                    contracts: &mut [Contract],
                ) -> Vec<ContractEvent> {
                    contracts
                        .iter_mut()
                        .flat_map(|contract| contract.drain_events())
                        .collect()
                }
            }
            pub enum ContractFlowState {
                #[default]
                Unset,
                Standby {
                    /// game_now
                    end_at: Instant,
                    event: ContractEvent,
                },
                Active {
                    /// game_now
                    end_at: Instant,
                    event: ContractEvent,
                },
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ContractFlowState {
                #[inline]
                fn clone(&self) -> ContractFlowState {
                    match self {
                        ContractFlowState::Unset => ContractFlowState::Unset,
                        ContractFlowState::Standby {
                            end_at: __self_0,
                            event: __self_1,
                        } => {
                            ContractFlowState::Standby {
                                end_at: ::core::clone::Clone::clone(__self_0),
                                event: ::core::clone::Clone::clone(__self_1),
                            }
                        }
                        ContractFlowState::Active {
                            end_at: __self_0,
                            event: __self_1,
                        } => {
                            ContractFlowState::Active {
                                end_at: ::core::clone::Clone::clone(__self_0),
                                event: ::core::clone::Clone::clone(__self_1),
                            }
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ContractFlowState {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        ContractFlowState::Unset => {
                            ::core::fmt::Formatter::write_str(f, "Unset")
                        }
                        ContractFlowState::Standby {
                            end_at: __self_0,
                            event: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "Standby",
                                "end_at",
                                __self_0,
                                "event",
                                &__self_1,
                            )
                        }
                        ContractFlowState::Active {
                            end_at: __self_0,
                            event: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "Active",
                                "end_at",
                                __self_0,
                                "event",
                                &__self_1,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for ContractFlowState {
                #[inline]
                fn default() -> ContractFlowState {
                    Self::Unset
                }
            }
            impl bincode::Encode for ContractFlowState {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::Unset => {
                            bincode::Encode::encode(&0u32, encoder)?;
                        }
                        Self::Standby { end_at, event } => {
                            bincode::Encode::encode(&1u32, encoder)?;
                            bincode::Encode::encode(end_at, encoder)?;
                            bincode::Encode::encode(event, encoder)?;
                        }
                        Self::Active { end_at, event } => {
                            bincode::Encode::encode(&2u32, encoder)?;
                            bincode::Encode::encode(end_at, encoder)?;
                            bincode::Encode::encode(event, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for ContractFlowState {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => Ok(Self::Unset),
                        1u32 => {
                            Ok(Self::Standby {
                                end_at: bincode::Decode::decode(decoder)?,
                                event: bincode::Decode::decode(decoder)?,
                            })
                        }
                        2u32 => {
                            Ok(Self::Active {
                                end_at: bincode::Decode::decode(decoder)?,
                                event: bincode::Decode::decode(decoder)?,
                            })
                        }
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 2u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for ContractFlowState {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::Unset => {
                            buf.write_string("Unset");
                        }
                        Self::Standby { end_at, event } => {
                            buf.write_string("Standby");
                            buf.write_string("end_at");
                            end_at.serialize_without_name(buf);
                            buf.write_string("event");
                            event.serialize_without_name(buf);
                        }
                        Self::Active { end_at, event } => {
                            buf.write_string("Active");
                            buf.write_string("end_at");
                            end_at.serialize_without_name(buf);
                            buf.write_string("event");
                            event.serialize_without_name(buf);
                        }
                    }
                }
            }
            impl Deserialize for ContractFlowState {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "Unset" => Ok(Self::Unset),
                        "Standby" => {
                            let field_name = buf.read_name("end_at")?;
                            let end_at = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("event")?;
                            let event = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::Standby { end_at, event })
                        }
                        "Active" => {
                            let field_name = buf.read_name("end_at")?;
                            let end_at = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("event")?;
                            let event = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::Active { end_at, event })
                        }
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            pub fn update_contract_flow(game_state: &mut GameState) {
                let game_now = game_state.now();
                let GameFlow::Contract(contract_flow) = &mut game_state.flow else {
                    return;
                };
                match &mut contract_flow.state {
                    ContractFlowState::Unset => {
                        let Some(contract_event) = contract_flow
                            .contract_event_queue
                            .pop_front() else {
                            game_state.goto_selecting_tower();
                            return;
                        };
                        contract_flow.state = ContractFlowState::Standby {
                            end_at: game_now + STANDBY_DURATION,
                            event: contract_event,
                        };
                    }
                    ContractFlowState::Standby { end_at, event } => {
                        if game_now < *end_at {
                            return;
                        }
                        let effect = event.effect.clone();
                        contract_flow.state = ContractFlowState::Active {
                            end_at: game_now + ACTIVE_DURATION,
                            event: event.clone(),
                        };
                        run_effect(game_state, &effect);
                    }
                    ContractFlowState::Active { end_at, .. } => {
                        if game_now < *end_at {
                            return;
                        }
                        contract_flow.state = ContractFlowState::Unset;
                    }
                }
            }
        }
        use super::{
            GameState, monster_spawn::start_spawn, tower::TowerTemplate,
            upgrade::{Upgrade, generate_upgrades_for_boss_reward},
        };
        use crate::{
            card::Card, game_state::{flow::contract::ContractFlow, hand::Hand},
            shop::Shop, *,
        };
        #[allow(clippy::large_enum_variant)]
        pub enum GameFlow {
            Initializing,
            Contract(ContractFlow),
            SelectingTower(SelectingTowerFlow),
            PlacingTower { hand: Hand<TowerTemplate> },
            Defense,
            SelectingUpgrade { upgrades: Vec<Upgrade> },
            Result,
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl ::core::clone::Clone for GameFlow {
            #[inline]
            fn clone(&self) -> GameFlow {
                match self {
                    GameFlow::Initializing => GameFlow::Initializing,
                    GameFlow::Contract(__self_0) => {
                        GameFlow::Contract(::core::clone::Clone::clone(__self_0))
                    }
                    GameFlow::SelectingTower(__self_0) => {
                        GameFlow::SelectingTower(::core::clone::Clone::clone(__self_0))
                    }
                    GameFlow::PlacingTower { hand: __self_0 } => {
                        GameFlow::PlacingTower {
                            hand: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    GameFlow::Defense => GameFlow::Defense,
                    GameFlow::SelectingUpgrade { upgrades: __self_0 } => {
                        GameFlow::SelectingUpgrade {
                            upgrades: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    GameFlow::Result => GameFlow::Result,
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl ::core::fmt::Debug for GameFlow {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    GameFlow::Initializing => {
                        ::core::fmt::Formatter::write_str(f, "Initializing")
                    }
                    GameFlow::Contract(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Contract",
                            &__self_0,
                        )
                    }
                    GameFlow::SelectingTower(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "SelectingTower",
                            &__self_0,
                        )
                    }
                    GameFlow::PlacingTower { hand: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "PlacingTower",
                            "hand",
                            &__self_0,
                        )
                    }
                    GameFlow::Defense => ::core::fmt::Formatter::write_str(f, "Defense"),
                    GameFlow::SelectingUpgrade { upgrades: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "SelectingUpgrade",
                            "upgrades",
                            &__self_0,
                        )
                    }
                    GameFlow::Result => ::core::fmt::Formatter::write_str(f, "Result"),
                }
            }
        }
        impl bincode::Encode for GameFlow {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Initializing => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Contract(field0) => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(field0, encoder)?;
                    }
                    Self::SelectingTower(field0) => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(field0, encoder)?;
                    }
                    Self::PlacingTower { hand } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(hand, encoder)?;
                    }
                    Self::Defense => {
                        bincode::Encode::encode(&4u32, encoder)?;
                    }
                    Self::SelectingUpgrade { upgrades } => {
                        bincode::Encode::encode(&5u32, encoder)?;
                        bincode::Encode::encode(upgrades, encoder)?;
                    }
                    Self::Result => {
                        bincode::Encode::encode(&6u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for GameFlow {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Initializing),
                    1u32 => Ok(Self::Contract(bincode::Decode::decode(decoder)?)),
                    2u32 => Ok(Self::SelectingTower(bincode::Decode::decode(decoder)?)),
                    3u32 => {
                        Ok(Self::PlacingTower {
                            hand: bincode::Decode::decode(decoder)?,
                        })
                    }
                    4u32 => Ok(Self::Defense),
                    5u32 => {
                        Ok(Self::SelectingUpgrade {
                            upgrades: bincode::Decode::decode(decoder)?,
                        })
                    }
                    6u32 => Ok(Self::Result),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 6u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for GameFlow {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Initializing => {
                        buf.write_string("Initializing");
                    }
                    Self::Contract(field0) => {
                        buf.write_string("Contract");
                        field0.serialize_without_name(buf);
                    }
                    Self::SelectingTower(field0) => {
                        buf.write_string("SelectingTower");
                        field0.serialize_without_name(buf);
                    }
                    Self::PlacingTower { hand } => {
                        buf.write_string("PlacingTower");
                        buf.write_string("hand");
                        hand.serialize_without_name(buf);
                    }
                    Self::Defense => {
                        buf.write_string("Defense");
                    }
                    Self::SelectingUpgrade { upgrades } => {
                        buf.write_string("SelectingUpgrade");
                        buf.write_string("upgrades");
                        upgrades.serialize_without_name(buf);
                    }
                    Self::Result => {
                        buf.write_string("Result");
                    }
                }
            }
        }
        impl Deserialize for GameFlow {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Initializing" => Ok(Self::Initializing),
                    "Contract" => {
                        let field0 = { Deserialize::deserialize_without_name(buf)? };
                        Ok(Self::Contract(field0))
                    }
                    "SelectingTower" => {
                        let field0 = { Deserialize::deserialize_without_name(buf)? };
                        Ok(Self::SelectingTower(field0))
                    }
                    "PlacingTower" => {
                        let field_name = buf.read_name("hand")?;
                        let hand = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::PlacingTower { hand })
                    }
                    "Defense" => Ok(Self::Defense),
                    "SelectingUpgrade" => {
                        let field_name = buf.read_name("upgrades")?;
                        let upgrades = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SelectingUpgrade { upgrades })
                    }
                    "Result" => Ok(Self::Result),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl GameFlow {
            pub(crate) fn update(&mut self) {
                match self {
                    GameFlow::SelectingTower(selecting_tower) => {
                        selecting_tower.update();
                    }
                    GameFlow::PlacingTower { hand } => {
                        hand.update();
                    }
                    _ => {}
                }
            }
        }
        pub struct SelectingTowerFlow {
            pub hand: Hand<Card>,
            pub shop: Shop,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SelectingTowerFlow {
            #[inline]
            fn clone(&self) -> SelectingTowerFlow {
                SelectingTowerFlow {
                    hand: ::core::clone::Clone::clone(&self.hand),
                    shop: ::core::clone::Clone::clone(&self.shop),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SelectingTowerFlow {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "SelectingTowerFlow",
                    "hand",
                    &self.hand,
                    "shop",
                    &&self.shop,
                )
            }
        }
        impl bincode::Encode for SelectingTowerFlow {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.hand, encoder)?;
                bincode::Encode::encode(&self.shop, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for SelectingTowerFlow {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    hand: bincode::Decode::decode(decoder)?,
                    shop: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for SelectingTowerFlow {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("hand");
                self.hand.serialize_without_name(buf);
                buf.write_string("shop");
                self.shop.serialize_without_name(buf);
            }
        }
        impl Deserialize for SelectingTowerFlow {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("hand")?;
                let hand = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("shop")?;
                let shop = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { hand, shop })
            }
        }
        impl SelectingTowerFlow {
            pub fn new(game_state: &GameState) -> Self {
                let max_slots = (5
                    + game_state
                        .stage_modifiers
                        .get_card_selection_hand_max_slots_bonus())
                    .saturating_sub(
                        game_state
                            .stage_modifiers
                            .get_card_selection_hand_max_slots_penalty(),
                    )
                    .max(1);
                SelectingTowerFlow {
                    hand: Hand::new((0..max_slots).map(|_| Card::new_random())),
                    shop: Shop::new(game_state),
                }
            }
            fn update(&mut self) {
                self.hand.update();
            }
        }
        impl GameState {
            pub fn goto_next_stage(&mut self) {
                contract::ContractFlow::step_all_contracts(&mut self.contracts);
                let contract_events = contract::ContractFlow::drain_all_events(
                    &mut self.contracts,
                );
                self.contracts.retain(|c| !c.is_expired());
                self.flow = GameFlow::Contract(
                    contract::ContractFlow::new(contract_events),
                );
                self.stage_modifiers.reset_stage_state();
                self.left_reroll_chance = self.max_reroll_chance();
                self.left_shop_refresh_chance = self.max_shop_refresh_chance();
                self.shield = 0.0;
                self.item_used = false;
                self.rerolled_count = 0;
            }
            pub fn goto_selecting_tower(&mut self) {
                self.flow = GameFlow::SelectingTower(SelectingTowerFlow::new(self));
            }
            pub fn goto_placing_tower(&mut self, tower_template: TowerTemplate) {
                let barricade_count = 4
                    + self.stage_modifiers.get_barricade_cards_per_stage();
                let mut barricades = ::alloc::vec::Vec::new();
                for _ in 0..barricade_count {
                    barricades.push(TowerTemplate::barricade());
                }
                let mut hand_items = <[_]>::into_vec(
                    ::alloc::boxed::box_new([tower_template]),
                );
                hand_items.extend(barricades);
                let mut hand = Hand::new(hand_items);
                let first_slot_id = hand.get_slot_id_by_index(0).unwrap();
                hand.select_slot(first_slot_id);
                self.flow = GameFlow::PlacingTower { hand };
            }
            pub fn goto_defense(&mut self) {
                self.flow = GameFlow::Defense;
                start_spawn(self);
            }
            pub fn goto_selecting_upgrade(&mut self) {
                let upgrades = generate_upgrades_for_boss_reward(self, 3);
                self.flow = GameFlow::SelectingUpgrade {
                    upgrades,
                };
            }
            pub fn goto_result(&mut self) {
                self.flow = GameFlow::Result;
            }
        }
    }
    pub mod item {
        pub mod generation {
            use super::Item;
            use crate::{game_state::effect::Effect, rarity::Rarity};
            use namui::*;
            use rand::{Rng, seq::SliceRandom, thread_rng};
            /// 주어진 value(0.0~1.0)를 범위에 맞는 실제 값으로 변환
            fn calculate_amount_from_value(
                value: f32,
                min_value: f32,
                max_value: f32,
            ) -> f32 {
                let clamped_value = value.clamp(0.0, 1.0);
                min_value + (max_value - min_value) * clamped_value
            }
            /// MovementSpeedDebuff나 DamageReduction 같은 역효과 아이템용 변환
            fn calculate_reverse_amount_from_value(
                value: f32,
                min_value: f32,
                max_value: f32,
            ) -> f32 {
                let clamped_value = value.clamp(0.0, 1.0);
                max_value - (max_value - min_value) * clamped_value
            }
            /// 외부에서 RNG를 주입할 수 있는 아이템 생성 함수 (테스트/결정성 보장 목적)
            pub fn generate_item_with_rng<R: Rng + ?Sized>(
                rarity: Rarity,
                rng: &mut R,
            ) -> Item {
                let candidates = generate_item_candidate_table(rarity);
                let candidate = &candidates
                    .choose_weighted(rng, |x| x.1)
                    .expect("item candidate table should not be empty")
                    .0;
                let value = rng.gen_range(0.0..1.0);
                let effect = match candidate {
                    ItemCandidate::Heal => {
                        let range = match rarity {
                            Rarity::Common => 5.0..9.0,
                            Rarity::Rare => 10.0..14.0,
                            Rarity::Epic => 15.0..19.0,
                            Rarity::Legendary => 20.0..25.0,
                        };
                        let amount = calculate_amount_from_value(
                            value,
                            range.start,
                            range.end,
                        );
                        Effect::Heal { amount }
                    }
                    ItemCandidate::Lottery => {
                        let amount = match rarity {
                            Rarity::Common => 250.0,
                            Rarity::Rare => 500.0,
                            Rarity::Epic => 1000.0,
                            Rarity::Legendary => 2500.0,
                        };
                        let probability = match rarity {
                            Rarity::Common => 0.01,
                            Rarity::Rare => 0.02,
                            Rarity::Epic => 0.03,
                            Rarity::Legendary => 0.05,
                        };
                        Effect::Lottery {
                            amount,
                            probability,
                        }
                    }
                    ItemCandidate::ExtraReroll => Effect::ExtraReroll,
                    ItemCandidate::Shield => {
                        let range = match rarity {
                            Rarity::Common => 10.0..15.0,
                            Rarity::Rare => 15.0..25.0,
                            Rarity::Epic => 25.0..35.0,
                            Rarity::Legendary => 35.0..50.0,
                        };
                        let amount = calculate_amount_from_value(
                            value,
                            range.start,
                            range.end,
                        );
                        Effect::Shield { amount }
                    }
                    ItemCandidate::DamageReduction => {
                        let range = match rarity {
                            Rarity::Common => 0.85..0.9,
                            Rarity::Rare => 0.8..0.85,
                            Rarity::Epic => 0.7..0.8,
                            Rarity::Legendary => 0.55..0.7,
                        };
                        let amount = calculate_reverse_amount_from_value(
                            value,
                            range.start,
                            range.end,
                        );
                        let duration = Duration::from_secs(
                            match rarity {
                                Rarity::Common => 3,
                                Rarity::Rare => 4,
                                Rarity::Epic => 6,
                                Rarity::Legendary => 8,
                            },
                        );
                        Effect::UserDamageReduction {
                            multiply: amount,
                            duration,
                        }
                    }
                };
                Item {
                    effect,
                    rarity,
                    value: value.into(),
                }
            }
            /// 기존 외부 API: thread_rng() 사용 (기존 호출 코드 호환성 유지)
            pub fn generate_item(rarity: Rarity) -> Item {
                let mut rng = thread_rng();
                generate_item_with_rng(rarity, &mut rng)
            }
            fn generate_item_candidate_table(
                rarity: Rarity,
            ) -> Vec<(ItemCandidate, f32)> {
                let candidate_weight = match rarity {
                    Rarity::Common => [100.0, 10.0, 5.0, 5.0, 5.0],
                    Rarity::Rare => [100.0, 30.0, 10.0, 10.0, 10.0],
                    Rarity::Epic => [100.0, 30.0, 20.0, 30.0, 30.0],
                    Rarity::Legendary => [100.0, 30.0, 30.0, 50.0, 30.0],
                };
                let candidate_table = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        (ItemCandidate::Heal, candidate_weight[0]),
                        (ItemCandidate::Lottery, candidate_weight[1]),
                        (ItemCandidate::ExtraReroll, candidate_weight[2]),
                        (ItemCandidate::Shield, candidate_weight[3]),
                        (ItemCandidate::DamageReduction, candidate_weight[4]),
                    ]),
                );
                candidate_table
            }
            enum ItemCandidate {
                Heal,
                Lottery,
                ExtraReroll,
                Shield,
                DamageReduction,
            }
        }
        mod thumbnail {
            use crate::{
                game_state::effect::Effect,
                icon::{Icon, IconAttribute, IconAttributePosition, IconKind, IconSize},
                thumbnail::ThumbnailComposer,
            };
            use namui::*;
            impl Effect {
                pub fn thumbnail(&self, width_height: Wh<Px>) -> RenderingTree {
                    match self {
                        Effect::Heal { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Health)
                                .build()
                        }
                        Effect::Lottery { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Gold)
                                .build()
                        }
                        Effect::ExtraReroll => {
                            Icon::new(IconKind::Refresh)
                                .wh(width_height)
                                .size(IconSize::Custom {
                                    size: width_height.width,
                                })
                                .attributes(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            IconAttribute::new(IconKind::Up)
                                                .position(IconAttributePosition::BottomRight),
                                        ]),
                                    ),
                                )
                                .to_rendering_tree()
                        }
                        Effect::Shield { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Shield)
                                .build()
                        }
                        Effect::EarnGold { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Gold)
                                .build()
                        }
                        Effect::DamageReduction { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::AttackDamage)
                                .build()
                        }
                        Effect::UserDamageReduction { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::AttackDamage)
                                .build()
                        }
                        Effect::LoseHealth { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Health)
                                .build()
                        }
                        Effect::LoseHealthRange { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Health)
                                .build()
                        }
                        Effect::LoseGoldRange { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Gold)
                                .build()
                        }
                        Effect::LoseHealthExpire { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Health)
                                .build()
                        }
                        Effect::LoseGoldExpire { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Gold)
                                .build()
                        }
                        Effect::LoseGold { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Gold)
                                .build()
                        }
                        Effect::GrantUpgrade { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Refresh)
                                .build()
                        }
                        Effect::GrantItem { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Item)
                                .build()
                        }
                        Effect::AddChallengeMonster => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::AttackDamage)
                                .build()
                        }
                        Effect::IncreaseAllTowersDamage { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::AttackDamage)
                                .build()
                        }
                        Effect::DecreaseAllTowersDamage { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::AttackDamage)
                                .build()
                        }
                        Effect::IncreaseAllTowersAttackSpeed { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::AttackSpeed)
                                .build()
                        }
                        Effect::IncreaseAllTowersRange { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::AttackRange)
                                .build()
                        }
                        Effect::DecreaseIncomingDamage { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::AttackDamage)
                                .build()
                        }
                        Effect::IncreaseCardSelectionHandMaxSlots { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Card)
                                .build()
                        }
                        Effect::IncreaseCardSelectionHandMaxRerolls { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Refresh)
                                .build()
                        }
                        Effect::IncreaseShopMaxRerolls { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Refresh)
                                .build()
                        }
                        Effect::IncreaseGoldGain { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Gold)
                                .build()
                        }
                        Effect::DecreaseGoldGainPercent { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Gold)
                                .build()
                        }
                        Effect::IncreaseIncomingDamage { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::AttackDamage)
                                .build()
                        }
                        Effect::DisableItemAndUpgradePurchases => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Item)
                                .build()
                        }
                        Effect::DisableItemUse => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Reject)
                                .build()
                        }
                        Effect::DecreaseCardSelectionHandMaxSlots { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Card)
                                .build()
                        }
                        Effect::DecreaseCardSelectionHandMaxRerolls { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Refresh)
                                .build()
                        }
                        Effect::DecreaseShopMaxRerolls { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Shop)
                                .build()
                        }
                        Effect::AddCardSelectionHandRerollHealthCost { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Health)
                                .build()
                        }
                        Effect::AddShopRerollHealthCost { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Health)
                                .build()
                        }
                        Effect::DecreaseEnemyHealthPercent { .. } => {
                            Icon::new(IconKind::Health)
                                .wh(width_height)
                                .size(IconSize::Custom {
                                    size: width_height.width,
                                })
                                .attributes(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            IconAttribute::new(IconKind::Up)
                                                .position(IconAttributePosition::BottomRight),
                                        ]),
                                    ),
                                )
                                .to_rendering_tree()
                        }
                        Effect::RankTowerDisable { .. } => {
                            Icon::new(IconKind::AttackDamage)
                                .wh(width_height)
                                .size(IconSize::Custom {
                                    size: width_height.width,
                                })
                                .attributes(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            IconAttribute::new(IconKind::Reject)
                                                .position(IconAttributePosition::Center),
                                        ]),
                                    ),
                                )
                                .to_rendering_tree()
                        }
                        Effect::SuitTowerDisable { .. } => {
                            Icon::new(IconKind::Card)
                                .wh(width_height)
                                .size(IconSize::Custom {
                                    size: width_height.width,
                                })
                                .attributes(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            IconAttribute::new(IconKind::Reject)
                                                .position(IconAttributePosition::Center),
                                        ]),
                                    ),
                                )
                                .to_rendering_tree()
                        }
                        Effect::AddBarricadeCardsToTowerPlacementHand { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Card)
                                .build()
                        }
                        Effect::GainShield { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Shield)
                                .build()
                        }
                        Effect::HealHealth { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Health)
                                .build()
                        }
                        Effect::GainGold { .. } => {
                            ThumbnailComposer::new(width_height)
                                .with_icon_base(IconKind::Gold)
                                .build()
                        }
                    }
                }
            }
        }
        mod usage {
            use super::Item;
            use crate::game_state::GameState;
            pub fn use_item(game_state: &mut GameState, item: &Item) {
                game_state.use_item(item);
            }
        }
        pub use crate::game_state::effect::Effect;
        use crate::rarity::Rarity;
        use namui::*;
        pub use usage::*;
        pub struct Item {
            pub effect: Effect,
            pub rarity: Rarity,
            pub value: OneZero,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Item {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Item",
                    "effect",
                    &self.effect,
                    "rarity",
                    &self.rarity,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Item {
            #[inline]
            fn clone(&self) -> Item {
                Item {
                    effect: ::core::clone::Clone::clone(&self.effect),
                    rarity: ::core::clone::Clone::clone(&self.rarity),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Item {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Item {
            #[inline]
            fn eq(&self, other: &Item) -> bool {
                self.effect == other.effect && self.rarity == other.rarity
                    && self.value == other.value
            }
        }
        impl bincode::Encode for Item {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.effect, encoder)?;
                bincode::Encode::encode(&self.rarity, encoder)?;
                bincode::Encode::encode(&self.value, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Item {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    effect: bincode::Decode::decode(decoder)?,
                    rarity: bincode::Decode::decode(decoder)?,
                    value: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Item {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("effect");
                self.effect.serialize_without_name(buf);
                buf.write_string("rarity");
                self.rarity.serialize_without_name(buf);
                buf.write_string("value");
                self.value.serialize_without_name(buf);
            }
        }
        impl Deserialize for Item {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("effect")?;
                let effect = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("rarity")?;
                let rarity = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("value")?;
                let value = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { effect, rarity, value })
            }
        }
        impl Item {
            pub fn name(&self, text_manager: &crate::l10n::TextManager) -> String {
                self.effect.name(text_manager)
            }
            pub fn description(
                &self,
                text_manager: &crate::l10n::TextManager,
            ) -> String {
                self.effect.description(text_manager)
            }
            pub fn effect_kind(&self) -> &Effect {
                &self.effect
            }
        }
    }
    mod level_rarity_weight {
        use super::GameState;
        use crate::{rarity::Rarity, *};
        use std::num::NonZero;
        pub const LEVEL_RARITY_WEIGHT: [[usize; 4]; 10] = [
            [90, 10, 1, 0],
            [75, 25, 5, 0],
            [55, 30, 10, 1],
            [45, 45, 20, 2],
            [25, 40, 30, 5],
            [20, 30, 35, 15],
            [15, 30, 40, 20],
            [10, 25, 35, 25],
            [5, 25, 30, 30],
            [5, 20, 30, 40],
        ];
        pub struct RarityGenerationOption {
            pub no_common: bool,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RarityGenerationOption {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "RarityGenerationOption",
                    "no_common",
                    &&self.no_common,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RarityGenerationOption {
            #[inline]
            fn clone(&self) -> RarityGenerationOption {
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for RarityGenerationOption {}
        #[automatically_derived]
        impl ::core::default::Default for RarityGenerationOption {
            #[inline]
            fn default() -> RarityGenerationOption {
                RarityGenerationOption {
                    no_common: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for RarityGenerationOption {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.no_common, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for RarityGenerationOption {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    no_common: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for RarityGenerationOption {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("no_common");
                self.no_common.serialize_without_name(buf);
            }
        }
        impl Deserialize for RarityGenerationOption {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("no_common")?;
                let no_common = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { no_common })
            }
        }
        impl GameState {
            pub fn generate_rarity(&self, option: RarityGenerationOption) -> Rarity {
                let mut weights = level_rarity_weight(self.level);
                if option.no_common {
                    weights[0] = 0;
                }
                let total_weight: usize = weights.iter().sum();
                let random_value = rand::random::<usize>() % total_weight;
                let mut cumulative_weight = 0;
                const RARITIES: [Rarity; 4] = [
                    Rarity::Common,
                    Rarity::Rare,
                    Rarity::Epic,
                    Rarity::Legendary,
                ];
                for (i, &weight) in weights.iter().enumerate() {
                    cumulative_weight += weight;
                    if random_value < cumulative_weight {
                        return RARITIES[i];
                    }
                }
                ::core::panicking::panic("internal error: entered unreachable code")
            }
        }
        pub fn level_rarity_weight(level: NonZero<usize>) -> [usize; 4] {
            LEVEL_RARITY_WEIGHT[level.get() - 1]
        }
    }
    mod modal {
        use crate::{
            game_state::start_confirm_modal::StartConfirmModal, settings::SettingsModal,
            upgrade_board::UpgradeBoardModal,
        };
        use namui::*;
        pub enum Modal {
            UpgradeBoard,
            Settings,
            StartConfirm,
        }
        impl bincode::Encode for Modal {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::UpgradeBoard => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Settings => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::StartConfirm => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for Modal {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::UpgradeBoard),
                    1u32 => Ok(Self::Settings),
                    2u32 => Ok(Self::StartConfirm),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 2u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for Modal {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::UpgradeBoard => {
                        buf.write_string("UpgradeBoard");
                    }
                    Self::Settings => {
                        buf.write_string("Settings");
                    }
                    Self::StartConfirm => {
                        buf.write_string("StartConfirm");
                    }
                }
            }
        }
        impl Deserialize for Modal {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "UpgradeBoard" => Ok(Self::UpgradeBoard),
                    "Settings" => Ok(Self::Settings),
                    "StartConfirm" => Ok(Self::StartConfirm),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl Component for &Modal {
            fn render(self, ctx: &RenderCtx) {
                match self {
                    Modal::UpgradeBoard => ctx.add(UpgradeBoardModal),
                    Modal::Settings => ctx.add(SettingsModal),
                    Modal::StartConfirm => ctx.add(StartConfirmModal),
                };
            }
        }
    }
    mod monster {
        mod monster_hp_bar {
            use crate::game_state::theme::palette;
            use namui::*;
            pub struct MonsterHpBar {
                pub wh: Wh<Px>,
                pub progress: f32,
            }
            impl Component for MonsterHpBar {
                fn render(self, ctx: &RenderCtx) {
                    let Self { wh, progress } = self;
                    let container_rect = Rect::from_xy_wh(wh.to_xy() * -0.5, wh);
                    ctx.add(
                        rect(RectParam {
                            rect: Rect::from_xy_wh(
                                container_rect.xy(),
                                Wh::new(wh.width * progress, wh.height),
                            ),
                            style: RectStyle {
                                stroke: None,
                                fill: Some(RectFill { color: Color::RED }),
                                round: None,
                            },
                        }),
                    );
                    ctx.add(
                        rect(RectParam {
                            rect: container_rect,
                            style: RectStyle {
                                stroke: Some(RectStroke {
                                    color: palette::OUTLINE,
                                    width: 1.px(),
                                    border_position: BorderPosition::Outside,
                                }),
                                fill: Some(RectFill {
                                    color: palette::SURFACE_CONTAINER,
                                }),
                                round: None,
                            },
                        }),
                    );
                }
            }
        }
        mod monster_kind {
            use crate::*;
            pub enum MonsterKind {
                Mob01,
                Mob02,
                Mob03,
                Mob04,
                Mob05,
                Mob06,
                Mob07,
                Mob08,
                Mob09,
                Mob10,
                Mob11,
                Mob12,
                Mob13,
                Mob14,
                Mob15,
                Named01,
                Named02,
                Named03,
                Named04,
                Named05,
                Named06,
                Named07,
                Named08,
                Named09,
                Named10,
                Named11,
                Named12,
                Named13,
                Named14,
                Named15,
                Named16,
                Boss01,
                Boss02,
                Boss03,
                Boss04,
                Boss05,
                Boss06,
                Boss07,
                Boss08,
                Boss09,
                Boss10,
                Boss11,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MonsterKind {
                #[inline]
                fn clone(&self) -> MonsterKind {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for MonsterKind {}
            impl bincode::Encode for MonsterKind {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::Mob01 => {
                            bincode::Encode::encode(&0u32, encoder)?;
                        }
                        Self::Mob02 => {
                            bincode::Encode::encode(&1u32, encoder)?;
                        }
                        Self::Mob03 => {
                            bincode::Encode::encode(&2u32, encoder)?;
                        }
                        Self::Mob04 => {
                            bincode::Encode::encode(&3u32, encoder)?;
                        }
                        Self::Mob05 => {
                            bincode::Encode::encode(&4u32, encoder)?;
                        }
                        Self::Mob06 => {
                            bincode::Encode::encode(&5u32, encoder)?;
                        }
                        Self::Mob07 => {
                            bincode::Encode::encode(&6u32, encoder)?;
                        }
                        Self::Mob08 => {
                            bincode::Encode::encode(&7u32, encoder)?;
                        }
                        Self::Mob09 => {
                            bincode::Encode::encode(&8u32, encoder)?;
                        }
                        Self::Mob10 => {
                            bincode::Encode::encode(&9u32, encoder)?;
                        }
                        Self::Mob11 => {
                            bincode::Encode::encode(&10u32, encoder)?;
                        }
                        Self::Mob12 => {
                            bincode::Encode::encode(&11u32, encoder)?;
                        }
                        Self::Mob13 => {
                            bincode::Encode::encode(&12u32, encoder)?;
                        }
                        Self::Mob14 => {
                            bincode::Encode::encode(&13u32, encoder)?;
                        }
                        Self::Mob15 => {
                            bincode::Encode::encode(&14u32, encoder)?;
                        }
                        Self::Named01 => {
                            bincode::Encode::encode(&15u32, encoder)?;
                        }
                        Self::Named02 => {
                            bincode::Encode::encode(&16u32, encoder)?;
                        }
                        Self::Named03 => {
                            bincode::Encode::encode(&17u32, encoder)?;
                        }
                        Self::Named04 => {
                            bincode::Encode::encode(&18u32, encoder)?;
                        }
                        Self::Named05 => {
                            bincode::Encode::encode(&19u32, encoder)?;
                        }
                        Self::Named06 => {
                            bincode::Encode::encode(&20u32, encoder)?;
                        }
                        Self::Named07 => {
                            bincode::Encode::encode(&21u32, encoder)?;
                        }
                        Self::Named08 => {
                            bincode::Encode::encode(&22u32, encoder)?;
                        }
                        Self::Named09 => {
                            bincode::Encode::encode(&23u32, encoder)?;
                        }
                        Self::Named10 => {
                            bincode::Encode::encode(&24u32, encoder)?;
                        }
                        Self::Named11 => {
                            bincode::Encode::encode(&25u32, encoder)?;
                        }
                        Self::Named12 => {
                            bincode::Encode::encode(&26u32, encoder)?;
                        }
                        Self::Named13 => {
                            bincode::Encode::encode(&27u32, encoder)?;
                        }
                        Self::Named14 => {
                            bincode::Encode::encode(&28u32, encoder)?;
                        }
                        Self::Named15 => {
                            bincode::Encode::encode(&29u32, encoder)?;
                        }
                        Self::Named16 => {
                            bincode::Encode::encode(&30u32, encoder)?;
                        }
                        Self::Boss01 => {
                            bincode::Encode::encode(&31u32, encoder)?;
                        }
                        Self::Boss02 => {
                            bincode::Encode::encode(&32u32, encoder)?;
                        }
                        Self::Boss03 => {
                            bincode::Encode::encode(&33u32, encoder)?;
                        }
                        Self::Boss04 => {
                            bincode::Encode::encode(&34u32, encoder)?;
                        }
                        Self::Boss05 => {
                            bincode::Encode::encode(&35u32, encoder)?;
                        }
                        Self::Boss06 => {
                            bincode::Encode::encode(&36u32, encoder)?;
                        }
                        Self::Boss07 => {
                            bincode::Encode::encode(&37u32, encoder)?;
                        }
                        Self::Boss08 => {
                            bincode::Encode::encode(&38u32, encoder)?;
                        }
                        Self::Boss09 => {
                            bincode::Encode::encode(&39u32, encoder)?;
                        }
                        Self::Boss10 => {
                            bincode::Encode::encode(&40u32, encoder)?;
                        }
                        Self::Boss11 => {
                            bincode::Encode::encode(&41u32, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for MonsterKind {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => Ok(Self::Mob01),
                        1u32 => Ok(Self::Mob02),
                        2u32 => Ok(Self::Mob03),
                        3u32 => Ok(Self::Mob04),
                        4u32 => Ok(Self::Mob05),
                        5u32 => Ok(Self::Mob06),
                        6u32 => Ok(Self::Mob07),
                        7u32 => Ok(Self::Mob08),
                        8u32 => Ok(Self::Mob09),
                        9u32 => Ok(Self::Mob10),
                        10u32 => Ok(Self::Mob11),
                        11u32 => Ok(Self::Mob12),
                        12u32 => Ok(Self::Mob13),
                        13u32 => Ok(Self::Mob14),
                        14u32 => Ok(Self::Mob15),
                        15u32 => Ok(Self::Named01),
                        16u32 => Ok(Self::Named02),
                        17u32 => Ok(Self::Named03),
                        18u32 => Ok(Self::Named04),
                        19u32 => Ok(Self::Named05),
                        20u32 => Ok(Self::Named06),
                        21u32 => Ok(Self::Named07),
                        22u32 => Ok(Self::Named08),
                        23u32 => Ok(Self::Named09),
                        24u32 => Ok(Self::Named10),
                        25u32 => Ok(Self::Named11),
                        26u32 => Ok(Self::Named12),
                        27u32 => Ok(Self::Named13),
                        28u32 => Ok(Self::Named14),
                        29u32 => Ok(Self::Named15),
                        30u32 => Ok(Self::Named16),
                        31u32 => Ok(Self::Boss01),
                        32u32 => Ok(Self::Boss02),
                        33u32 => Ok(Self::Boss03),
                        34u32 => Ok(Self::Boss04),
                        35u32 => Ok(Self::Boss05),
                        36u32 => Ok(Self::Boss06),
                        37u32 => Ok(Self::Boss07),
                        38u32 => Ok(Self::Boss08),
                        39u32 => Ok(Self::Boss09),
                        40u32 => Ok(Self::Boss10),
                        41u32 => Ok(Self::Boss11),
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 41u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for MonsterKind {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::Mob01 => {
                            buf.write_string("Mob01");
                        }
                        Self::Mob02 => {
                            buf.write_string("Mob02");
                        }
                        Self::Mob03 => {
                            buf.write_string("Mob03");
                        }
                        Self::Mob04 => {
                            buf.write_string("Mob04");
                        }
                        Self::Mob05 => {
                            buf.write_string("Mob05");
                        }
                        Self::Mob06 => {
                            buf.write_string("Mob06");
                        }
                        Self::Mob07 => {
                            buf.write_string("Mob07");
                        }
                        Self::Mob08 => {
                            buf.write_string("Mob08");
                        }
                        Self::Mob09 => {
                            buf.write_string("Mob09");
                        }
                        Self::Mob10 => {
                            buf.write_string("Mob10");
                        }
                        Self::Mob11 => {
                            buf.write_string("Mob11");
                        }
                        Self::Mob12 => {
                            buf.write_string("Mob12");
                        }
                        Self::Mob13 => {
                            buf.write_string("Mob13");
                        }
                        Self::Mob14 => {
                            buf.write_string("Mob14");
                        }
                        Self::Mob15 => {
                            buf.write_string("Mob15");
                        }
                        Self::Named01 => {
                            buf.write_string("Named01");
                        }
                        Self::Named02 => {
                            buf.write_string("Named02");
                        }
                        Self::Named03 => {
                            buf.write_string("Named03");
                        }
                        Self::Named04 => {
                            buf.write_string("Named04");
                        }
                        Self::Named05 => {
                            buf.write_string("Named05");
                        }
                        Self::Named06 => {
                            buf.write_string("Named06");
                        }
                        Self::Named07 => {
                            buf.write_string("Named07");
                        }
                        Self::Named08 => {
                            buf.write_string("Named08");
                        }
                        Self::Named09 => {
                            buf.write_string("Named09");
                        }
                        Self::Named10 => {
                            buf.write_string("Named10");
                        }
                        Self::Named11 => {
                            buf.write_string("Named11");
                        }
                        Self::Named12 => {
                            buf.write_string("Named12");
                        }
                        Self::Named13 => {
                            buf.write_string("Named13");
                        }
                        Self::Named14 => {
                            buf.write_string("Named14");
                        }
                        Self::Named15 => {
                            buf.write_string("Named15");
                        }
                        Self::Named16 => {
                            buf.write_string("Named16");
                        }
                        Self::Boss01 => {
                            buf.write_string("Boss01");
                        }
                        Self::Boss02 => {
                            buf.write_string("Boss02");
                        }
                        Self::Boss03 => {
                            buf.write_string("Boss03");
                        }
                        Self::Boss04 => {
                            buf.write_string("Boss04");
                        }
                        Self::Boss05 => {
                            buf.write_string("Boss05");
                        }
                        Self::Boss06 => {
                            buf.write_string("Boss06");
                        }
                        Self::Boss07 => {
                            buf.write_string("Boss07");
                        }
                        Self::Boss08 => {
                            buf.write_string("Boss08");
                        }
                        Self::Boss09 => {
                            buf.write_string("Boss09");
                        }
                        Self::Boss10 => {
                            buf.write_string("Boss10");
                        }
                        Self::Boss11 => {
                            buf.write_string("Boss11");
                        }
                    }
                }
            }
            impl Deserialize for MonsterKind {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "Mob01" => Ok(Self::Mob01),
                        "Mob02" => Ok(Self::Mob02),
                        "Mob03" => Ok(Self::Mob03),
                        "Mob04" => Ok(Self::Mob04),
                        "Mob05" => Ok(Self::Mob05),
                        "Mob06" => Ok(Self::Mob06),
                        "Mob07" => Ok(Self::Mob07),
                        "Mob08" => Ok(Self::Mob08),
                        "Mob09" => Ok(Self::Mob09),
                        "Mob10" => Ok(Self::Mob10),
                        "Mob11" => Ok(Self::Mob11),
                        "Mob12" => Ok(Self::Mob12),
                        "Mob13" => Ok(Self::Mob13),
                        "Mob14" => Ok(Self::Mob14),
                        "Mob15" => Ok(Self::Mob15),
                        "Named01" => Ok(Self::Named01),
                        "Named02" => Ok(Self::Named02),
                        "Named03" => Ok(Self::Named03),
                        "Named04" => Ok(Self::Named04),
                        "Named05" => Ok(Self::Named05),
                        "Named06" => Ok(Self::Named06),
                        "Named07" => Ok(Self::Named07),
                        "Named08" => Ok(Self::Named08),
                        "Named09" => Ok(Self::Named09),
                        "Named10" => Ok(Self::Named10),
                        "Named11" => Ok(Self::Named11),
                        "Named12" => Ok(Self::Named12),
                        "Named13" => Ok(Self::Named13),
                        "Named14" => Ok(Self::Named14),
                        "Named15" => Ok(Self::Named15),
                        "Named16" => Ok(Self::Named16),
                        "Boss01" => Ok(Self::Boss01),
                        "Boss02" => Ok(Self::Boss02),
                        "Boss03" => Ok(Self::Boss03),
                        "Boss04" => Ok(Self::Boss04),
                        "Boss05" => Ok(Self::Boss05),
                        "Boss06" => Ok(Self::Boss06),
                        "Boss07" => Ok(Self::Boss07),
                        "Boss08" => Ok(Self::Boss08),
                        "Boss09" => Ok(Self::Boss09),
                        "Boss10" => Ok(Self::Boss10),
                        "Boss11" => Ok(Self::Boss11),
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            impl MonsterKind {
                pub fn image(self) -> Image {
                    match self {
                        MonsterKind::Mob01 => crate::asset::image::monster::MOB01,
                        MonsterKind::Mob02 => crate::asset::image::monster::MOB02,
                        MonsterKind::Mob03 => crate::asset::image::monster::MOB03,
                        MonsterKind::Mob04 => crate::asset::image::monster::MOB04,
                        MonsterKind::Mob05 => crate::asset::image::monster::MOB05,
                        MonsterKind::Mob06 => crate::asset::image::monster::MOB06,
                        MonsterKind::Mob07 => crate::asset::image::monster::MOB07,
                        MonsterKind::Mob08 => crate::asset::image::monster::MOB08,
                        MonsterKind::Mob09 => crate::asset::image::monster::MOB09,
                        MonsterKind::Mob10 => crate::asset::image::monster::MOB10,
                        MonsterKind::Mob11 => crate::asset::image::monster::MOB11,
                        MonsterKind::Mob12 => crate::asset::image::monster::MOB12,
                        MonsterKind::Mob13 => crate::asset::image::monster::MOB13,
                        MonsterKind::Mob14 => crate::asset::image::monster::MOB14,
                        MonsterKind::Mob15 => crate::asset::image::monster::MOB15,
                        MonsterKind::Named01 => crate::asset::image::monster::NAMED01,
                        MonsterKind::Named02 => crate::asset::image::monster::NAMED02,
                        MonsterKind::Named03 => crate::asset::image::monster::NAMED03,
                        MonsterKind::Named04 => crate::asset::image::monster::NAMED04,
                        MonsterKind::Named05 => crate::asset::image::monster::NAMED05,
                        MonsterKind::Named06 => crate::asset::image::monster::NAMED06,
                        MonsterKind::Named07 => crate::asset::image::monster::NAMED07,
                        MonsterKind::Named08 => crate::asset::image::monster::NAMED08,
                        MonsterKind::Named09 => crate::asset::image::monster::NAMED09,
                        MonsterKind::Named10 => crate::asset::image::monster::NAMED10,
                        MonsterKind::Named11 => crate::asset::image::monster::NAMED11,
                        MonsterKind::Named12 => crate::asset::image::monster::NAMED12,
                        MonsterKind::Named13 => crate::asset::image::monster::NAMED13,
                        MonsterKind::Named14 => crate::asset::image::monster::NAMED14,
                        MonsterKind::Named15 => crate::asset::image::monster::NAMED15,
                        MonsterKind::Named16 => crate::asset::image::monster::NAMED16,
                        MonsterKind::Boss01 => crate::asset::image::monster::BOSS01,
                        MonsterKind::Boss02 => crate::asset::image::monster::BOSS02,
                        MonsterKind::Boss03 => crate::asset::image::monster::BOSS03,
                        MonsterKind::Boss04 => crate::asset::image::monster::BOSS04,
                        MonsterKind::Boss05 => crate::asset::image::monster::BOSS05,
                        MonsterKind::Boss06 => crate::asset::image::monster::BOSS06,
                        MonsterKind::Boss07 => crate::asset::image::monster::BOSS07,
                        MonsterKind::Boss08 => crate::asset::image::monster::BOSS08,
                        MonsterKind::Boss09 => crate::asset::image::monster::BOSS09,
                        MonsterKind::Boss10 => crate::asset::image::monster::BOSS10,
                        MonsterKind::Boss11 => crate::asset::image::monster::BOSS11,
                    }
                }
                pub fn emoji(&self) -> &str {
                    match self {
                        MonsterKind::Mob01 => "🌱",
                        MonsterKind::Mob02 => "🌿",
                        MonsterKind::Mob03 => "🌵",
                        MonsterKind::Mob04 => "🍀",
                        MonsterKind::Mob05 => "💮",
                        MonsterKind::Mob06 => "🥬",
                        MonsterKind::Mob07 => "🥒",
                        MonsterKind::Mob08 => "🫐",
                        MonsterKind::Mob09 => "🍇",
                        MonsterKind::Mob10 => "🫑",
                        MonsterKind::Mob11 => "🍒",
                        MonsterKind::Mob12 => "🐝",
                        MonsterKind::Mob13 => "🪲",
                        MonsterKind::Mob14 => "🪳",
                        MonsterKind::Mob15 => "🐨",
                        MonsterKind::Named01 => "🌺",
                        MonsterKind::Named02 => "🌸",
                        MonsterKind::Named03 => "🥕",
                        MonsterKind::Named04 => "🌽",
                        MonsterKind::Named05 => "🍊",
                        MonsterKind::Named06 => "🍄",
                        MonsterKind::Named07 => "🍎",
                        MonsterKind::Named08 => "🦂",
                        MonsterKind::Named09 => "🐜",
                        MonsterKind::Named10 => "🦟",
                        MonsterKind::Named11 => "🦊",
                        MonsterKind::Named12 => "🐺",
                        MonsterKind::Named13 => "🦏",
                        MonsterKind::Named14 => "🐻",
                        MonsterKind::Named15 => "🐻‍❄️",
                        MonsterKind::Named16 => "🦅",
                        MonsterKind::Boss01 => "🥦",
                        MonsterKind::Boss02 => "🦋",
                        MonsterKind::Boss03 => "🐞",
                        MonsterKind::Boss04 => "🦁",
                        MonsterKind::Boss05 => "🦝",
                        MonsterKind::Boss06 => "🐮",
                        MonsterKind::Boss07 => "🐯",
                        MonsterKind::Boss08 => "🐼",
                        MonsterKind::Boss09 => "🦍",
                        MonsterKind::Boss10 => "🦖",
                        MonsterKind::Boss11 => "🦚",
                    }
                }
            }
        }
        mod monster_template {
            use super::MonsterSkillTemplate;
            use super::PrebuiltSkill;
            use crate::game_state::monster::MonsterKind;
            use crate::game_state::route::Velocity;
            use crate::*;
            use namui::{Duration, State};
            pub struct MonsterTemplate {
                pub kind: MonsterKind,
                pub max_hp: f32,
                pub skills: Vec<MonsterSkillTemplate>,
                pub velocity: Velocity,
                pub damage: f32,
                pub reward: usize,
            }
            impl bincode::Encode for MonsterTemplate {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.kind, encoder)?;
                    bincode::Encode::encode(&self.max_hp, encoder)?;
                    bincode::Encode::encode(&self.skills, encoder)?;
                    bincode::Encode::encode(&self.velocity, encoder)?;
                    bincode::Encode::encode(&self.damage, encoder)?;
                    bincode::Encode::encode(&self.reward, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for MonsterTemplate {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        kind: bincode::Decode::decode(decoder)?,
                        max_hp: bincode::Decode::decode(decoder)?,
                        skills: bincode::Decode::decode(decoder)?,
                        velocity: bincode::Decode::decode(decoder)?,
                        damage: bincode::Decode::decode(decoder)?,
                        reward: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for MonsterTemplate {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("kind");
                    self.kind.serialize_without_name(buf);
                    buf.write_string("max_hp");
                    self.max_hp.serialize_without_name(buf);
                    buf.write_string("skills");
                    self.skills.serialize_without_name(buf);
                    buf.write_string("velocity");
                    self.velocity.serialize_without_name(buf);
                    buf.write_string("damage");
                    self.damage.serialize_without_name(buf);
                    buf.write_string("reward");
                    self.reward.serialize_without_name(buf);
                }
            }
            impl Deserialize for MonsterTemplate {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("kind")?;
                    let kind = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("max_hp")?;
                    let max_hp = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("skills")?;
                    let skills = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("velocity")?;
                    let velocity = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("damage")?;
                    let damage = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("reward")?;
                    let reward = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self {
                        kind,
                        max_hp,
                        skills,
                        velocity,
                        damage,
                        reward,
                    })
                }
            }
            impl MonsterTemplate {
                fn velocity(mul: f32) -> Velocity {
                    Velocity::new(5.0 * mul, Duration::from_secs(1))
                }
                fn damage(mul: f32) -> f32 {
                    mul
                }
                fn reward(mul: usize) -> usize {
                    mul
                }
                pub fn new(kind: MonsterKind) -> Self {
                    let (max_hp, velocity, damage, reward, skills) = match kind {
                        MonsterKind::Mob01 => {
                            (10.0, 0.5, 1.0, 3, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob02 => {
                            (25.0, 0.5, 1.0, 3, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob03 => {
                            (90.0, 0.3, 1.0, 3, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob04 => {
                            (75.0, 1.1, 1.0, 3, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob05 => {
                            (
                                250.0,
                                1.0,
                                1.0,
                                3,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Invincible01]),
                                ),
                            )
                        }
                        MonsterKind::Mob06 => {
                            (850.0, 0.75, 1.0, 5, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob07 => {
                            (1750.0, 0.75, 1.0, 5, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob08 => {
                            (6000.0, 0.4, 1.0, 5, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob09 => {
                            (
                                3500.0,
                                1.25,
                                1.0,
                                5,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Speedmul01]),
                                ),
                            )
                        }
                        MonsterKind::Mob10 => {
                            (
                                7500.0,
                                0.75,
                                1.0,
                                5,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Speedmul02]),
                                ),
                            )
                        }
                        MonsterKind::Mob11 => {
                            (10000.0, 1.0, 1.0, 5, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob12 => {
                            (15000.0, 1.0, 1.0, 5, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob13 => {
                            (45000.0, 0.5, 1.0, 5, ::alloc::vec::Vec::new())
                        }
                        MonsterKind::Mob14 => {
                            (
                                20000.0,
                                1.5,
                                1.0,
                                5,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::ImmuneSlow01]),
                                ),
                            )
                        }
                        MonsterKind::Mob15 => {
                            (
                                45000.0,
                                1.0,
                                1.0,
                                5,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Invincible02]),
                                ),
                            )
                        }
                        MonsterKind::Named01 => {
                            (
                                100.0,
                                0.5,
                                3.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::ImmuneSlow02]),
                                ),
                            )
                        }
                        MonsterKind::Named02 => {
                            (
                                500.0,
                                0.75,
                                3.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Invincible03]),
                                ),
                            )
                        }
                        MonsterKind::Named03 => {
                            (
                                1500.0,
                                1.0,
                                3.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Speedmul03]),
                                ),
                            )
                        }
                        MonsterKind::Named04 => {
                            (
                                3500.0,
                                1.25,
                                3.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::ImmuneSlow03]),
                                ),
                            )
                        }
                        MonsterKind::Named05 => {
                            (
                                15000.0,
                                0.5,
                                5.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Heal01]),
                                ),
                            )
                        }
                        MonsterKind::Named06 => {
                            (
                                30000.0,
                                0.75,
                                5.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::ImmuneSlow04]),
                                ),
                            )
                        }
                        MonsterKind::Named07 => {
                            (
                                45000.0,
                                1.0,
                                5.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Heal02]),
                                ),
                            )
                        }
                        MonsterKind::Named08 => {
                            (
                                65000.0,
                                1.25,
                                5.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Speedmul04]),
                                ),
                            )
                        }
                        MonsterKind::Named09 => {
                            (
                                200000.0,
                                0.5,
                                7.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Invincible04]),
                                ),
                            )
                        }
                        MonsterKind::Named10 => {
                            (
                                250000.0,
                                0.75,
                                7.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Heal03]),
                                ),
                            )
                        }
                        MonsterKind::Named11 => {
                            (
                                300000.0,
                                1.0,
                                7.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::Heal04]),
                                ),
                            )
                        }
                        MonsterKind::Named12 => {
                            (
                                300000.0,
                                1.25,
                                7.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaSpeedmul01]),
                                ),
                            )
                        }
                        MonsterKind::Named13 => {
                            (
                                650000.0,
                                0.5,
                                10.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaImmuneSlow01]),
                                ),
                            )
                        }
                        MonsterKind::Named14 => {
                            (
                                550000.0,
                                0.75,
                                10.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaInvincible01]),
                                ),
                            )
                        }
                        MonsterKind::Named15 => {
                            (
                                550000.0,
                                1.0,
                                10.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaInvincible02]),
                                ),
                            )
                        }
                        MonsterKind::Named16 => {
                            (
                                750000.0,
                                1.25,
                                10.0,
                                30,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaImmuneSlow02]),
                                ),
                            )
                        }
                        MonsterKind::Boss01 => {
                            (
                                3500.0,
                                1.0,
                                15.0,
                                50,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaInvincible03]),
                                ),
                            )
                        }
                        MonsterKind::Boss02 => {
                            (
                                10000.0,
                                1.0,
                                20.0,
                                75,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaHeal01]),
                                ),
                            )
                        }
                        MonsterKind::Boss03 => {
                            (
                                35000.0,
                                1.0,
                                20.0,
                                100,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaSpeedmul02]),
                                ),
                            )
                        }
                        MonsterKind::Boss04 => {
                            (
                                85000.0,
                                1.0,
                                25.0,
                                100,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaSpeedmul03]),
                                ),
                            )
                        }
                        MonsterKind::Boss05 => {
                            (
                                200000.0,
                                1.0,
                                25.0,
                                125,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaImmuneSlow03]),
                                ),
                            )
                        }
                        MonsterKind::Boss06 => {
                            (
                                300000.0,
                                1.0,
                                25.0,
                                125,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaHeal02]),
                                ),
                            )
                        }
                        MonsterKind::Boss07 => {
                            (
                                375000.0,
                                1.0,
                                50.0,
                                125,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaImmuneSlow04]),
                                ),
                            )
                        }
                        MonsterKind::Boss08 => {
                            (
                                500000.0,
                                1.0,
                                50.0,
                                125,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaHeal03]),
                                ),
                            )
                        }
                        MonsterKind::Boss09 => {
                            (
                                700000.0,
                                1.0,
                                50.0,
                                125,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaSpeedmul04]),
                                ),
                            )
                        }
                        MonsterKind::Boss10 => {
                            (
                                850000.0,
                                1.0,
                                50.0,
                                125,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaInvincible04]),
                                ),
                            )
                        }
                        MonsterKind::Boss11 => {
                            (
                                1125000.0,
                                1.0,
                                50.0,
                                125,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([PrebuiltSkill::AreaHeal04]),
                                ),
                            )
                        }
                    };
                    Self {
                        kind,
                        max_hp,
                        skills: skills
                            .into_iter()
                            .map(|prebuilt| prebuilt.into())
                            .collect(),
                        velocity: Self::velocity(velocity),
                        damage: Self::damage(damage),
                        reward: Self::reward(reward),
                    }
                }
            }
        }
        mod move_monsters {
            use crate::game_state::GameState;
            use crate::game_state::user_status_effect::UserStatusEffectKind;
            use namui::Duration;
            pub fn move_monsters(game_state: &mut GameState, dt: Duration) {
                for monster in &mut game_state.monsters {
                    let mut dt = dt;
                    dt *= monster.get_speed_multiplier();
                    monster.move_on_route.move_by(dt);
                }
                let mut damage = 0.0;
                game_state
                    .monsters
                    .retain(|monster| {
                        if monster.move_on_route.is_finished() {
                            damage += monster.get_damage_to_user();
                            return false;
                        }
                        true
                    });
                for user_status_effect in &game_state.user_status_effects {
                    match user_status_effect.kind {
                        UserStatusEffectKind::DamageReduction { damage_multiply } => {
                            damage *= damage_multiply;
                        }
                    }
                }
                damage *= game_state.stage_modifiers.get_damage_reduction_multiplier();
                damage *= game_state.stage_modifiers.get_incoming_damage_multiplier();
                game_state.take_damage(damage);
            }
        }
        mod render {
            use crate::game_state::{
                GameState, MonsterKind, TILE_PX_SIZE,
                monster::{MONSTER_HP_BAR_HEIGHT, Monster, monster_hp_bar::MonsterHpBar},
            };
            use namui::*;
            impl Component for &Monster {
                fn render(self, ctx: &RenderCtx) {
                    let Monster { kind, animation, .. } = self;
                    let image = kind.image();
                    let monster_wh = monster_wh(*kind);
                    ctx.translate(
                            Xy::new(
                                TILE_PX_SIZE.width * 0.5,
                                TILE_PX_SIZE.height - monster_wh.height * 0.5
                                    + TILE_PX_SIZE.height * animation.y_offset,
                            ),
                        )
                        .rotate(animation.rotation)
                        .add(
                            namui::image(ImageParam {
                                rect: Rect::from_xy_wh(
                                    monster_wh.to_xy() * -0.5,
                                    monster_wh,
                                ),
                                image,
                                style: ImageStyle {
                                    fit: ImageFit::Contain,
                                    paint: None,
                                },
                            }),
                        );
                    let hp_bar_wh = Wh::new(monster_wh.width, MONSTER_HP_BAR_HEIGHT);
                    ctx.translate(
                            Xy::new(
                                TILE_PX_SIZE.width * 0.5,
                                TILE_PX_SIZE.width * 0.5 + monster_wh.height * 0.6,
                            ),
                        )
                        .add(MonsterHpBar {
                            wh: hp_bar_wh,
                            progress: self.hp / self.max_hp,
                        });
                }
            }
            fn monster_wh(kind: MonsterKind) -> Wh<Px> {
                match kind {
                    MonsterKind::Boss01
                    | MonsterKind::Boss02
                    | MonsterKind::Boss03
                    | MonsterKind::Boss04
                    | MonsterKind::Boss05
                    | MonsterKind::Boss06
                    | MonsterKind::Boss07
                    | MonsterKind::Boss08
                    | MonsterKind::Boss09
                    | MonsterKind::Boss10
                    | MonsterKind::Boss11 => TILE_PX_SIZE * 0.8,
                    MonsterKind::Named01
                    | MonsterKind::Named02
                    | MonsterKind::Named03
                    | MonsterKind::Named04
                    | MonsterKind::Named05
                    | MonsterKind::Named06
                    | MonsterKind::Named07
                    | MonsterKind::Named08
                    | MonsterKind::Named09
                    | MonsterKind::Named10
                    | MonsterKind::Named11
                    | MonsterKind::Named12
                    | MonsterKind::Named13
                    | MonsterKind::Named14
                    | MonsterKind::Named15
                    | MonsterKind::Named16 => TILE_PX_SIZE * 0.7,
                    _ => TILE_PX_SIZE * 0.5,
                }
            }
            pub fn monster_animation_tick(game_state: &mut GameState, dt: Duration) {
                const STIFFNESS: f32 = 750.0;
                const DAMPING: f32 = -5.0;
                const GRAVITY: f32 = 10.0;
                game_state
                    .monsters
                    .iter_mut()
                    .for_each(|monster| {
                        let target_rotation = match monster.animation.rotated_side {
                            MonsterAnimationRotatedSide::Left => (-15.0).deg(),
                            MonsterAnimationRotatedSide::Right => 15.0.deg(),
                        };
                        let rotation_difference = target_rotation
                            - monster.animation.rotation;
                        let rotation_acceleration = STIFFNESS
                            * rotation_difference.as_degrees()
                            + DAMPING * monster.animation.rotation_velocity;
                        monster.animation.rotation_velocity
                            += rotation_acceleration * dt.as_secs_f32();
                        monster.animation.rotation
                            += (monster.animation.rotation_velocity * dt.as_secs_f32())
                                .deg();
                        monster.animation.y_offset_velocity
                            += GRAVITY * dt.as_secs_f32();
                        monster.animation.y_offset
                            += monster.animation.y_offset_velocity * dt.as_secs_f32();
                        if monster.animation.y_offset >= 0.0 {
                            monster.animation.y_offset = 0.0;
                            let movement_speed = monster.move_on_route.velocity()
                                * 1.sec() * monster.get_speed_multiplier();
                            monster.animation.y_offset_velocity = (-3.25
                                + ((movement_speed - 1.5) / (4.0 - 1.5)) * (-1.5))
                                .clamp(-3.25, -1.75);
                            monster.animation.rotated_side = match monster
                                .animation
                                .rotated_side
                            {
                                MonsterAnimationRotatedSide::Left => {
                                    MonsterAnimationRotatedSide::Right
                                }
                                MonsterAnimationRotatedSide::Right => {
                                    MonsterAnimationRotatedSide::Left
                                }
                            };
                        }
                    });
            }
            pub struct MonsterAnimation {
                rotation: Angle,
                rotation_velocity: f32,
                y_offset: f32,
                y_offset_velocity: f32,
                rotated_side: MonsterAnimationRotatedSide,
            }
            impl bincode::Encode for MonsterAnimation {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.rotation, encoder)?;
                    bincode::Encode::encode(&self.rotation_velocity, encoder)?;
                    bincode::Encode::encode(&self.y_offset, encoder)?;
                    bincode::Encode::encode(&self.y_offset_velocity, encoder)?;
                    bincode::Encode::encode(&self.rotated_side, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for MonsterAnimation {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        rotation: bincode::Decode::decode(decoder)?,
                        rotation_velocity: bincode::Decode::decode(decoder)?,
                        y_offset: bincode::Decode::decode(decoder)?,
                        y_offset_velocity: bincode::Decode::decode(decoder)?,
                        rotated_side: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for MonsterAnimation {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("rotation");
                    self.rotation.serialize_without_name(buf);
                    buf.write_string("rotation_velocity");
                    self.rotation_velocity.serialize_without_name(buf);
                    buf.write_string("y_offset");
                    self.y_offset.serialize_without_name(buf);
                    buf.write_string("y_offset_velocity");
                    self.y_offset_velocity.serialize_without_name(buf);
                    buf.write_string("rotated_side");
                    self.rotated_side.serialize_without_name(buf);
                }
            }
            impl Deserialize for MonsterAnimation {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("rotation")?;
                    let rotation = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("rotation_velocity")?;
                    let rotation_velocity = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("y_offset")?;
                    let y_offset = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("y_offset_velocity")?;
                    let y_offset_velocity = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("rotated_side")?;
                    let rotated_side = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self {
                        rotation,
                        rotation_velocity,
                        y_offset,
                        y_offset_velocity,
                        rotated_side,
                    })
                }
            }
            impl Default for MonsterAnimation {
                fn default() -> Self {
                    Self::new()
                }
            }
            impl MonsterAnimation {
                pub fn new() -> Self {
                    Self {
                        rotation: 0.deg(),
                        rotation_velocity: 0.0,
                        y_offset: 0.0,
                        y_offset_velocity: 0.0,
                        rotated_side: MonsterAnimationRotatedSide::Left,
                    }
                }
            }
            enum MonsterAnimationRotatedSide {
                Left,
                Right,
            }
            impl bincode::Encode for MonsterAnimationRotatedSide {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::Left => {
                            bincode::Encode::encode(&0u32, encoder)?;
                        }
                        Self::Right => {
                            bincode::Encode::encode(&1u32, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for MonsterAnimationRotatedSide {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => Ok(Self::Left),
                        1u32 => Ok(Self::Right),
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 1u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for MonsterAnimationRotatedSide {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::Left => {
                            buf.write_string("Left");
                        }
                        Self::Right => {
                            buf.write_string("Right");
                        }
                    }
                }
            }
            impl Deserialize for MonsterAnimationRotatedSide {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "Left" => Ok(Self::Left),
                        "Right" => Ok(Self::Right),
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
        }
        mod skill {
            use super::*;
            use crate::game_state::GameState;
            use namui::Instant;
            use std::ops::Deref;
            pub struct MonsterSkillTemplate {
                pub kind: MonsterSkillKind,
                pub target: Target,
                pub cooldown: Duration,
                pub duration: Duration,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MonsterSkillTemplate {
                #[inline]
                fn clone(&self) -> MonsterSkillTemplate {
                    let _: ::core::clone::AssertParamIsClone<MonsterSkillKind>;
                    let _: ::core::clone::AssertParamIsClone<Target>;
                    let _: ::core::clone::AssertParamIsClone<Duration>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for MonsterSkillTemplate {}
            impl bincode::Encode for MonsterSkillTemplate {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.kind, encoder)?;
                    bincode::Encode::encode(&self.target, encoder)?;
                    bincode::Encode::encode(&self.cooldown, encoder)?;
                    bincode::Encode::encode(&self.duration, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for MonsterSkillTemplate {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        kind: bincode::Decode::decode(decoder)?,
                        target: bincode::Decode::decode(decoder)?,
                        cooldown: bincode::Decode::decode(decoder)?,
                        duration: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for MonsterSkillTemplate {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("kind");
                    self.kind.serialize_without_name(buf);
                    buf.write_string("target");
                    self.target.serialize_without_name(buf);
                    buf.write_string("cooldown");
                    self.cooldown.serialize_without_name(buf);
                    buf.write_string("duration");
                    self.duration.serialize_without_name(buf);
                }
            }
            impl Deserialize for MonsterSkillTemplate {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("kind")?;
                    let kind = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("target")?;
                    let target = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("cooldown")?;
                    let cooldown = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("duration")?;
                    let duration = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self {
                        kind,
                        target,
                        cooldown,
                        duration,
                    })
                }
            }
            pub struct MonsterSkill {
                pub last_used_at: Instant,
                pub template: MonsterSkillTemplate,
            }
            impl bincode::Encode for MonsterSkill {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.last_used_at, encoder)?;
                    bincode::Encode::encode(&self.template, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for MonsterSkill {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        last_used_at: bincode::Decode::decode(decoder)?,
                        template: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for MonsterSkill {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("last_used_at");
                    self.last_used_at.serialize_without_name(buf);
                    buf.write_string("template");
                    self.template.serialize_without_name(buf);
                }
            }
            impl Deserialize for MonsterSkill {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("last_used_at")?;
                    let last_used_at = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("template")?;
                    let template = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self { last_used_at, template })
                }
            }
            impl MonsterSkill {
                pub fn new(template: MonsterSkillTemplate, now: Instant) -> Self {
                    Self {
                        last_used_at: now,
                        template,
                    }
                }
            }
            impl Deref for MonsterSkill {
                type Target = MonsterSkillTemplate;
                fn deref(&self) -> &Self::Target {
                    &self.template
                }
            }
            pub enum MonsterSkillKind {
                Invincible,
                SpeedMul { mul: f32 },
                ImmuneToSlow,
                HealByMaxHp { ratio: f32 },
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MonsterSkillKind {
                #[inline]
                fn clone(&self) -> MonsterSkillKind {
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for MonsterSkillKind {}
            impl bincode::Encode for MonsterSkillKind {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::Invincible => {
                            bincode::Encode::encode(&0u32, encoder)?;
                        }
                        Self::SpeedMul { mul } => {
                            bincode::Encode::encode(&1u32, encoder)?;
                            bincode::Encode::encode(mul, encoder)?;
                        }
                        Self::ImmuneToSlow => {
                            bincode::Encode::encode(&2u32, encoder)?;
                        }
                        Self::HealByMaxHp { ratio } => {
                            bincode::Encode::encode(&3u32, encoder)?;
                            bincode::Encode::encode(ratio, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for MonsterSkillKind {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => Ok(Self::Invincible),
                        1u32 => {
                            Ok(Self::SpeedMul {
                                mul: bincode::Decode::decode(decoder)?,
                            })
                        }
                        2u32 => Ok(Self::ImmuneToSlow),
                        3u32 => {
                            Ok(Self::HealByMaxHp {
                                ratio: bincode::Decode::decode(decoder)?,
                            })
                        }
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 3u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for MonsterSkillKind {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::Invincible => {
                            buf.write_string("Invincible");
                        }
                        Self::SpeedMul { mul } => {
                            buf.write_string("SpeedMul");
                            buf.write_string("mul");
                            mul.serialize_without_name(buf);
                        }
                        Self::ImmuneToSlow => {
                            buf.write_string("ImmuneToSlow");
                        }
                        Self::HealByMaxHp { ratio } => {
                            buf.write_string("HealByMaxHp");
                            buf.write_string("ratio");
                            ratio.serialize_without_name(buf);
                        }
                    }
                }
            }
            impl Deserialize for MonsterSkillKind {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "Invincible" => Ok(Self::Invincible),
                        "SpeedMul" => {
                            let field_name = buf.read_name("mul")?;
                            let mul = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::SpeedMul { mul })
                        }
                        "ImmuneToSlow" => Ok(Self::ImmuneToSlow),
                        "HealByMaxHp" => {
                            let field_name = buf.read_name("ratio")?;
                            let ratio = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::HealByMaxHp { ratio })
                        }
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            pub struct MonsterStatusEffect {
                pub kind: MonsterStatusEffectKind,
                pub end_at: Instant,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MonsterStatusEffect {
                #[inline]
                fn clone(&self) -> MonsterStatusEffect {
                    MonsterStatusEffect {
                        kind: ::core::clone::Clone::clone(&self.kind),
                        end_at: ::core::clone::Clone::clone(&self.end_at),
                    }
                }
            }
            impl bincode::Encode for MonsterStatusEffect {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.kind, encoder)?;
                    bincode::Encode::encode(&self.end_at, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for MonsterStatusEffect {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        kind: bincode::Decode::decode(decoder)?,
                        end_at: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for MonsterStatusEffect {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("kind");
                    self.kind.serialize_without_name(buf);
                    buf.write_string("end_at");
                    self.end_at.serialize_without_name(buf);
                }
            }
            impl Deserialize for MonsterStatusEffect {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("kind")?;
                    let kind = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("end_at")?;
                    let end_at = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self { kind, end_at })
                }
            }
            pub enum Target {
                MySelf,
                MeAndNearby { radius: f32 },
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Target {
                #[inline]
                fn clone(&self) -> Target {
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Target {}
            impl bincode::Encode for Target {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::MySelf => {
                            bincode::Encode::encode(&0u32, encoder)?;
                        }
                        Self::MeAndNearby { radius } => {
                            bincode::Encode::encode(&1u32, encoder)?;
                            bincode::Encode::encode(radius, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for Target {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => Ok(Self::MySelf),
                        1u32 => {
                            Ok(Self::MeAndNearby {
                                radius: bincode::Decode::decode(decoder)?,
                            })
                        }
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 1u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for Target {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::MySelf => {
                            buf.write_string("MySelf");
                        }
                        Self::MeAndNearby { radius } => {
                            buf.write_string("MeAndNearby");
                            buf.write_string("radius");
                            radius.serialize_without_name(buf);
                        }
                    }
                }
            }
            impl Deserialize for Target {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "MySelf" => Ok(Self::MySelf),
                        "MeAndNearby" => {
                            let field_name = buf.read_name("radius")?;
                            let radius = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::MeAndNearby { radius })
                        }
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            pub enum MonsterStatusEffectKind {
                SpeedMul { mul: f32 },
                Invincible,
                ImmuneToSlow,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MonsterStatusEffectKind {
                #[inline]
                fn clone(&self) -> MonsterStatusEffectKind {
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for MonsterStatusEffectKind {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MonsterStatusEffectKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for MonsterStatusEffectKind {
                #[inline]
                fn eq(&self, other: &MonsterStatusEffectKind) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                        && match (self, other) {
                            (
                                MonsterStatusEffectKind::SpeedMul { mul: __self_0 },
                                MonsterStatusEffectKind::SpeedMul { mul: __arg1_0 },
                            ) => __self_0 == __arg1_0,
                            _ => true,
                        }
                }
            }
            impl bincode::Encode for MonsterStatusEffectKind {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::SpeedMul { mul } => {
                            bincode::Encode::encode(&0u32, encoder)?;
                            bincode::Encode::encode(mul, encoder)?;
                        }
                        Self::Invincible => {
                            bincode::Encode::encode(&1u32, encoder)?;
                        }
                        Self::ImmuneToSlow => {
                            bincode::Encode::encode(&2u32, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for MonsterStatusEffectKind {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => {
                            Ok(Self::SpeedMul {
                                mul: bincode::Decode::decode(decoder)?,
                            })
                        }
                        1u32 => Ok(Self::Invincible),
                        2u32 => Ok(Self::ImmuneToSlow),
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 2u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for MonsterStatusEffectKind {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::SpeedMul { mul } => {
                            buf.write_string("SpeedMul");
                            buf.write_string("mul");
                            mul.serialize_without_name(buf);
                        }
                        Self::Invincible => {
                            buf.write_string("Invincible");
                        }
                        Self::ImmuneToSlow => {
                            buf.write_string("ImmuneToSlow");
                        }
                    }
                }
            }
            impl Deserialize for MonsterStatusEffectKind {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "SpeedMul" => {
                            let field_name = buf.read_name("mul")?;
                            let mul = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::SpeedMul { mul })
                        }
                        "Invincible" => Ok(Self::Invincible),
                        "ImmuneToSlow" => Ok(Self::ImmuneToSlow),
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            pub fn remove_monster_finished_status_effects(
                game_state: &mut GameState,
                now: Instant,
            ) {
                for monster in game_state.monsters.iter_mut() {
                    monster.status_effects.retain(|e| now < e.end_at);
                }
            }
            pub fn activate_monster_skills(game_state: &mut GameState, now: Instant) {
                let mut activated_skills = ::alloc::vec::Vec::new();
                for monster in game_state.monsters.iter_mut() {
                    for skill in monster.skills.iter_mut() {
                        if now < skill.last_used_at + skill.cooldown {
                            continue;
                        }
                        skill.last_used_at = now;
                        activated_skills.push((monster.id, skill.template));
                    }
                }
                for (monster_id, skill) in activated_skills {
                    let target_monsters = match skill.target {
                        Target::MySelf => {
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    game_state
                                        .monsters
                                        .iter_mut()
                                        .find(|m| m.id == monster_id)
                                        .unwrap(),
                                ]),
                            )
                        }
                        Target::MeAndNearby { radius } => {
                            let caster_xy = game_state
                                .monsters
                                .iter()
                                .find(|m| m.id == monster_id)
                                .unwrap()
                                .xy();
                            game_state
                                .monsters
                                .iter_mut()
                                .filter(|monster| {
                                    monster.id != monster_id
                                        && caster_xy.distance(monster.xy()) <= radius
                                })
                                .collect()
                        }
                    };
                    target_monsters
                        .into_iter()
                        .for_each(|monster| {
                            let mut push_status_effect = |kind| {
                                monster
                                    .status_effects
                                    .push(MonsterStatusEffect {
                                        kind,
                                        end_at: now + skill.duration,
                                    });
                            };
                            match skill.kind {
                                MonsterSkillKind::Invincible => {
                                    push_status_effect(MonsterStatusEffectKind::Invincible);
                                }
                                MonsterSkillKind::SpeedMul { mul } => {
                                    push_status_effect(MonsterStatusEffectKind::SpeedMul {
                                        mul,
                                    });
                                }
                                MonsterSkillKind::ImmuneToSlow => {
                                    push_status_effect(MonsterStatusEffectKind::ImmuneToSlow);
                                }
                                MonsterSkillKind::HealByMaxHp { ratio } => {
                                    monster.heal(monster.max_hp * ratio);
                                }
                            }
                        });
                }
            }
            pub enum PrebuiltSkill {
                AreaHeal01,
                AreaHeal02,
                AreaHeal03,
                AreaHeal04,
                AreaImmuneSlow01,
                AreaImmuneSlow02,
                AreaImmuneSlow03,
                AreaImmuneSlow04,
                AreaInvincible01,
                AreaInvincible02,
                AreaInvincible03,
                AreaInvincible04,
                AreaSpeedmul01,
                AreaSpeedmul02,
                AreaSpeedmul03,
                AreaSpeedmul04,
                Heal01,
                Heal02,
                Heal03,
                Heal04,
                ImmuneSlow01,
                ImmuneSlow02,
                ImmuneSlow03,
                ImmuneSlow04,
                Invincible01,
                Invincible02,
                Invincible03,
                Invincible04,
                Speedmul01,
                Speedmul02,
                Speedmul03,
                Speedmul04,
            }
            impl bincode::Encode for PrebuiltSkill {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::AreaHeal01 => {
                            bincode::Encode::encode(&0u32, encoder)?;
                        }
                        Self::AreaHeal02 => {
                            bincode::Encode::encode(&1u32, encoder)?;
                        }
                        Self::AreaHeal03 => {
                            bincode::Encode::encode(&2u32, encoder)?;
                        }
                        Self::AreaHeal04 => {
                            bincode::Encode::encode(&3u32, encoder)?;
                        }
                        Self::AreaImmuneSlow01 => {
                            bincode::Encode::encode(&4u32, encoder)?;
                        }
                        Self::AreaImmuneSlow02 => {
                            bincode::Encode::encode(&5u32, encoder)?;
                        }
                        Self::AreaImmuneSlow03 => {
                            bincode::Encode::encode(&6u32, encoder)?;
                        }
                        Self::AreaImmuneSlow04 => {
                            bincode::Encode::encode(&7u32, encoder)?;
                        }
                        Self::AreaInvincible01 => {
                            bincode::Encode::encode(&8u32, encoder)?;
                        }
                        Self::AreaInvincible02 => {
                            bincode::Encode::encode(&9u32, encoder)?;
                        }
                        Self::AreaInvincible03 => {
                            bincode::Encode::encode(&10u32, encoder)?;
                        }
                        Self::AreaInvincible04 => {
                            bincode::Encode::encode(&11u32, encoder)?;
                        }
                        Self::AreaSpeedmul01 => {
                            bincode::Encode::encode(&12u32, encoder)?;
                        }
                        Self::AreaSpeedmul02 => {
                            bincode::Encode::encode(&13u32, encoder)?;
                        }
                        Self::AreaSpeedmul03 => {
                            bincode::Encode::encode(&14u32, encoder)?;
                        }
                        Self::AreaSpeedmul04 => {
                            bincode::Encode::encode(&15u32, encoder)?;
                        }
                        Self::Heal01 => {
                            bincode::Encode::encode(&16u32, encoder)?;
                        }
                        Self::Heal02 => {
                            bincode::Encode::encode(&17u32, encoder)?;
                        }
                        Self::Heal03 => {
                            bincode::Encode::encode(&18u32, encoder)?;
                        }
                        Self::Heal04 => {
                            bincode::Encode::encode(&19u32, encoder)?;
                        }
                        Self::ImmuneSlow01 => {
                            bincode::Encode::encode(&20u32, encoder)?;
                        }
                        Self::ImmuneSlow02 => {
                            bincode::Encode::encode(&21u32, encoder)?;
                        }
                        Self::ImmuneSlow03 => {
                            bincode::Encode::encode(&22u32, encoder)?;
                        }
                        Self::ImmuneSlow04 => {
                            bincode::Encode::encode(&23u32, encoder)?;
                        }
                        Self::Invincible01 => {
                            bincode::Encode::encode(&24u32, encoder)?;
                        }
                        Self::Invincible02 => {
                            bincode::Encode::encode(&25u32, encoder)?;
                        }
                        Self::Invincible03 => {
                            bincode::Encode::encode(&26u32, encoder)?;
                        }
                        Self::Invincible04 => {
                            bincode::Encode::encode(&27u32, encoder)?;
                        }
                        Self::Speedmul01 => {
                            bincode::Encode::encode(&28u32, encoder)?;
                        }
                        Self::Speedmul02 => {
                            bincode::Encode::encode(&29u32, encoder)?;
                        }
                        Self::Speedmul03 => {
                            bincode::Encode::encode(&30u32, encoder)?;
                        }
                        Self::Speedmul04 => {
                            bincode::Encode::encode(&31u32, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for PrebuiltSkill {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => Ok(Self::AreaHeal01),
                        1u32 => Ok(Self::AreaHeal02),
                        2u32 => Ok(Self::AreaHeal03),
                        3u32 => Ok(Self::AreaHeal04),
                        4u32 => Ok(Self::AreaImmuneSlow01),
                        5u32 => Ok(Self::AreaImmuneSlow02),
                        6u32 => Ok(Self::AreaImmuneSlow03),
                        7u32 => Ok(Self::AreaImmuneSlow04),
                        8u32 => Ok(Self::AreaInvincible01),
                        9u32 => Ok(Self::AreaInvincible02),
                        10u32 => Ok(Self::AreaInvincible03),
                        11u32 => Ok(Self::AreaInvincible04),
                        12u32 => Ok(Self::AreaSpeedmul01),
                        13u32 => Ok(Self::AreaSpeedmul02),
                        14u32 => Ok(Self::AreaSpeedmul03),
                        15u32 => Ok(Self::AreaSpeedmul04),
                        16u32 => Ok(Self::Heal01),
                        17u32 => Ok(Self::Heal02),
                        18u32 => Ok(Self::Heal03),
                        19u32 => Ok(Self::Heal04),
                        20u32 => Ok(Self::ImmuneSlow01),
                        21u32 => Ok(Self::ImmuneSlow02),
                        22u32 => Ok(Self::ImmuneSlow03),
                        23u32 => Ok(Self::ImmuneSlow04),
                        24u32 => Ok(Self::Invincible01),
                        25u32 => Ok(Self::Invincible02),
                        26u32 => Ok(Self::Invincible03),
                        27u32 => Ok(Self::Invincible04),
                        28u32 => Ok(Self::Speedmul01),
                        29u32 => Ok(Self::Speedmul02),
                        30u32 => Ok(Self::Speedmul03),
                        31u32 => Ok(Self::Speedmul04),
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 31u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for PrebuiltSkill {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::AreaHeal01 => {
                            buf.write_string("AreaHeal01");
                        }
                        Self::AreaHeal02 => {
                            buf.write_string("AreaHeal02");
                        }
                        Self::AreaHeal03 => {
                            buf.write_string("AreaHeal03");
                        }
                        Self::AreaHeal04 => {
                            buf.write_string("AreaHeal04");
                        }
                        Self::AreaImmuneSlow01 => {
                            buf.write_string("AreaImmuneSlow01");
                        }
                        Self::AreaImmuneSlow02 => {
                            buf.write_string("AreaImmuneSlow02");
                        }
                        Self::AreaImmuneSlow03 => {
                            buf.write_string("AreaImmuneSlow03");
                        }
                        Self::AreaImmuneSlow04 => {
                            buf.write_string("AreaImmuneSlow04");
                        }
                        Self::AreaInvincible01 => {
                            buf.write_string("AreaInvincible01");
                        }
                        Self::AreaInvincible02 => {
                            buf.write_string("AreaInvincible02");
                        }
                        Self::AreaInvincible03 => {
                            buf.write_string("AreaInvincible03");
                        }
                        Self::AreaInvincible04 => {
                            buf.write_string("AreaInvincible04");
                        }
                        Self::AreaSpeedmul01 => {
                            buf.write_string("AreaSpeedmul01");
                        }
                        Self::AreaSpeedmul02 => {
                            buf.write_string("AreaSpeedmul02");
                        }
                        Self::AreaSpeedmul03 => {
                            buf.write_string("AreaSpeedmul03");
                        }
                        Self::AreaSpeedmul04 => {
                            buf.write_string("AreaSpeedmul04");
                        }
                        Self::Heal01 => {
                            buf.write_string("Heal01");
                        }
                        Self::Heal02 => {
                            buf.write_string("Heal02");
                        }
                        Self::Heal03 => {
                            buf.write_string("Heal03");
                        }
                        Self::Heal04 => {
                            buf.write_string("Heal04");
                        }
                        Self::ImmuneSlow01 => {
                            buf.write_string("ImmuneSlow01");
                        }
                        Self::ImmuneSlow02 => {
                            buf.write_string("ImmuneSlow02");
                        }
                        Self::ImmuneSlow03 => {
                            buf.write_string("ImmuneSlow03");
                        }
                        Self::ImmuneSlow04 => {
                            buf.write_string("ImmuneSlow04");
                        }
                        Self::Invincible01 => {
                            buf.write_string("Invincible01");
                        }
                        Self::Invincible02 => {
                            buf.write_string("Invincible02");
                        }
                        Self::Invincible03 => {
                            buf.write_string("Invincible03");
                        }
                        Self::Invincible04 => {
                            buf.write_string("Invincible04");
                        }
                        Self::Speedmul01 => {
                            buf.write_string("Speedmul01");
                        }
                        Self::Speedmul02 => {
                            buf.write_string("Speedmul02");
                        }
                        Self::Speedmul03 => {
                            buf.write_string("Speedmul03");
                        }
                        Self::Speedmul04 => {
                            buf.write_string("Speedmul04");
                        }
                    }
                }
            }
            impl Deserialize for PrebuiltSkill {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "AreaHeal01" => Ok(Self::AreaHeal01),
                        "AreaHeal02" => Ok(Self::AreaHeal02),
                        "AreaHeal03" => Ok(Self::AreaHeal03),
                        "AreaHeal04" => Ok(Self::AreaHeal04),
                        "AreaImmuneSlow01" => Ok(Self::AreaImmuneSlow01),
                        "AreaImmuneSlow02" => Ok(Self::AreaImmuneSlow02),
                        "AreaImmuneSlow03" => Ok(Self::AreaImmuneSlow03),
                        "AreaImmuneSlow04" => Ok(Self::AreaImmuneSlow04),
                        "AreaInvincible01" => Ok(Self::AreaInvincible01),
                        "AreaInvincible02" => Ok(Self::AreaInvincible02),
                        "AreaInvincible03" => Ok(Self::AreaInvincible03),
                        "AreaInvincible04" => Ok(Self::AreaInvincible04),
                        "AreaSpeedmul01" => Ok(Self::AreaSpeedmul01),
                        "AreaSpeedmul02" => Ok(Self::AreaSpeedmul02),
                        "AreaSpeedmul03" => Ok(Self::AreaSpeedmul03),
                        "AreaSpeedmul04" => Ok(Self::AreaSpeedmul04),
                        "Heal01" => Ok(Self::Heal01),
                        "Heal02" => Ok(Self::Heal02),
                        "Heal03" => Ok(Self::Heal03),
                        "Heal04" => Ok(Self::Heal04),
                        "ImmuneSlow01" => Ok(Self::ImmuneSlow01),
                        "ImmuneSlow02" => Ok(Self::ImmuneSlow02),
                        "ImmuneSlow03" => Ok(Self::ImmuneSlow03),
                        "ImmuneSlow04" => Ok(Self::ImmuneSlow04),
                        "Invincible01" => Ok(Self::Invincible01),
                        "Invincible02" => Ok(Self::Invincible02),
                        "Invincible03" => Ok(Self::Invincible03),
                        "Invincible04" => Ok(Self::Invincible04),
                        "Speedmul01" => Ok(Self::Speedmul01),
                        "Speedmul02" => Ok(Self::Speedmul02),
                        "Speedmul03" => Ok(Self::Speedmul03),
                        "Speedmul04" => Ok(Self::Speedmul04),
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            impl From<PrebuiltSkill> for MonsterSkillTemplate {
                fn from(val: PrebuiltSkill) -> Self {
                    match val {
                        PrebuiltSkill::AreaHeal01 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::HealByMaxHp {
                                    ratio: 0.25,
                                },
                                target: Target::MeAndNearby { radius: 3.0 },
                                cooldown: Duration::from_secs(5),
                                duration: Duration::ZERO,
                            }
                        }
                        PrebuiltSkill::AreaHeal02 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::HealByMaxHp {
                                    ratio: 0.125,
                                },
                                target: Target::MeAndNearby { radius: 5.0 },
                                cooldown: Duration::from_secs(4),
                                duration: Duration::ZERO,
                            }
                        }
                        PrebuiltSkill::AreaHeal03 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::HealByMaxHp {
                                    ratio: 0.125,
                                },
                                target: Target::MeAndNearby { radius: 5.0 },
                                cooldown: Duration::from_secs(3),
                                duration: Duration::ZERO,
                            }
                        }
                        PrebuiltSkill::AreaHeal04 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::HealByMaxHp {
                                    ratio: 0.125,
                                },
                                target: Target::MeAndNearby { radius: 7.0 },
                                cooldown: Duration::from_secs(2),
                                duration: Duration::ZERO,
                            }
                        }
                        PrebuiltSkill::AreaImmuneSlow01 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::ImmuneToSlow,
                                target: Target::MeAndNearby { radius: 5.0 },
                                cooldown: Duration::from_secs(5),
                                duration: Duration::from_secs(1),
                            }
                        }
                        PrebuiltSkill::AreaImmuneSlow02 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::ImmuneToSlow,
                                target: Target::MeAndNearby { radius: 5.0 },
                                cooldown: Duration::from_secs(5),
                                duration: Duration::from_secs(2),
                            }
                        }
                        PrebuiltSkill::AreaImmuneSlow03 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::ImmuneToSlow,
                                target: Target::MeAndNearby { radius: 7.0 },
                                cooldown: Duration::from_secs(10),
                                duration: Duration::from_secs(4),
                            }
                        }
                        PrebuiltSkill::AreaImmuneSlow04 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::ImmuneToSlow,
                                target: Target::MeAndNearby { radius: 9.0 },
                                cooldown: Duration::from_secs(10),
                                duration: Duration::from_secs(5),
                            }
                        }
                        PrebuiltSkill::AreaInvincible01 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::Invincible,
                                target: Target::MeAndNearby { radius: 3.0 },
                                cooldown: Duration::from_secs(4),
                                duration: Duration::from_millis(500),
                            }
                        }
                        PrebuiltSkill::AreaInvincible02 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::Invincible,
                                target: Target::MeAndNearby { radius: 3.0 },
                                cooldown: Duration::from_secs(4),
                                duration: Duration::from_secs(1),
                            }
                        }
                        PrebuiltSkill::AreaInvincible03 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::Invincible,
                                target: Target::MeAndNearby { radius: 3.0 },
                                cooldown: Duration::from_secs(4),
                                duration: Duration::from_secs(1)
                                    + Duration::from_millis(500),
                            }
                        }
                        PrebuiltSkill::AreaInvincible04 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::Invincible,
                                target: Target::MeAndNearby { radius: 5.0 },
                                cooldown: Duration::from_secs(4),
                                duration: Duration::from_secs(2),
                            }
                        }
                        PrebuiltSkill::AreaSpeedmul01 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::SpeedMul {
                                    mul: 1.25,
                                },
                                target: Target::MeAndNearby { radius: 3.0 },
                                cooldown: Duration::from_secs(5),
                                duration: Duration::from_secs(1),
                            }
                        }
                        PrebuiltSkill::AreaSpeedmul02 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::SpeedMul {
                                    mul: 1.25,
                                },
                                target: Target::MeAndNearby { radius: 5.0 },
                                cooldown: Duration::from_secs(10),
                                duration: Duration::from_secs(3),
                            }
                        }
                        PrebuiltSkill::AreaSpeedmul03 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::SpeedMul {
                                    mul: 1.5,
                                },
                                target: Target::MeAndNearby { radius: 5.0 },
                                cooldown: Duration::from_secs(10),
                                duration: Duration::from_secs(2),
                            }
                        }
                        PrebuiltSkill::AreaSpeedmul04 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::SpeedMul {
                                    mul: 1.75,
                                },
                                target: Target::MeAndNearby { radius: 7.0 },
                                cooldown: Duration::from_secs(15),
                                duration: Duration::from_secs(4),
                            }
                        }
                        PrebuiltSkill::Heal01 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::HealByMaxHp {
                                    ratio: 0.25,
                                },
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(5),
                                duration: Duration::ZERO,
                            }
                        }
                        PrebuiltSkill::Heal02 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::HealByMaxHp {
                                    ratio: 0.125,
                                },
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(4),
                                duration: Duration::ZERO,
                            }
                        }
                        PrebuiltSkill::Heal03 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::HealByMaxHp {
                                    ratio: 0.125,
                                },
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(3),
                                duration: Duration::ZERO,
                            }
                        }
                        PrebuiltSkill::Heal04 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::HealByMaxHp {
                                    ratio: 0.125,
                                },
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(2),
                                duration: Duration::ZERO,
                            }
                        }
                        PrebuiltSkill::ImmuneSlow01 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::ImmuneToSlow,
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(5),
                                duration: Duration::from_secs(1),
                            }
                        }
                        PrebuiltSkill::ImmuneSlow02 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::ImmuneToSlow,
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(5),
                                duration: Duration::from_secs(2),
                            }
                        }
                        PrebuiltSkill::ImmuneSlow03 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::ImmuneToSlow,
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(10),
                                duration: Duration::from_secs(4),
                            }
                        }
                        PrebuiltSkill::ImmuneSlow04 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::ImmuneToSlow,
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(10),
                                duration: Duration::from_secs(5),
                            }
                        }
                        PrebuiltSkill::Invincible01 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::Invincible,
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(4),
                                duration: Duration::from_millis(500),
                            }
                        }
                        PrebuiltSkill::Invincible02 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::Invincible,
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(4),
                                duration: Duration::from_secs(1),
                            }
                        }
                        PrebuiltSkill::Invincible03 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::Invincible,
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(4),
                                duration: Duration::from_secs(1)
                                    + Duration::from_millis(500),
                            }
                        }
                        PrebuiltSkill::Invincible04 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::Invincible,
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(4),
                                duration: Duration::from_secs(2),
                            }
                        }
                        PrebuiltSkill::Speedmul01 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::SpeedMul {
                                    mul: 1.25,
                                },
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(5),
                                duration: Duration::from_secs(1),
                            }
                        }
                        PrebuiltSkill::Speedmul02 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::SpeedMul {
                                    mul: 1.25,
                                },
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(10),
                                duration: Duration::from_secs(3),
                            }
                        }
                        PrebuiltSkill::Speedmul03 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::SpeedMul {
                                    mul: 1.5,
                                },
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(10),
                                duration: Duration::from_secs(2),
                            }
                        }
                        PrebuiltSkill::Speedmul04 => {
                            MonsterSkillTemplate {
                                kind: MonsterSkillKind::SpeedMul {
                                    mul: 1.75,
                                },
                                target: Target::MySelf,
                                cooldown: Duration::from_secs(15),
                                duration: Duration::from_secs(4),
                            }
                        }
                    }
                }
            }
        }
        use crate::{
            MapCoordF32,
            game_state::{
                monster::render::MonsterAnimation, projectile::ProjectileTargetIndicator,
            },
            route::{MoveOnRoute, Route},
        };
        pub use monster_kind::MonsterKind;
        pub use monster_template::MonsterTemplate;
        pub use move_monsters::move_monsters;
        use namui::*;
        pub use render::monster_animation_tick;
        pub use skill::{
            MonsterSkill, MonsterSkillTemplate, MonsterStatusEffect,
            MonsterStatusEffectKind, PrebuiltSkill, activate_monster_skills,
            remove_monster_finished_status_effects,
        };
        use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
        const MONSTER_HP_BAR_HEIGHT: Px = px(4.);
        pub struct Monster {
            id: usize,
            pub move_on_route: MoveOnRoute,
            pub kind: MonsterKind,
            pub projectile_target_indicator: ProjectileTargetIndicator,
            pub hp: f32,
            pub max_hp: f32,
            pub skills: Vec<MonsterSkill>,
            pub status_effects: Vec<MonsterStatusEffect>,
            pub damage: f32,
            pub reward: usize,
            pub animation: MonsterAnimation,
        }
        impl bincode::Encode for Monster {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.id, encoder)?;
                bincode::Encode::encode(&self.move_on_route, encoder)?;
                bincode::Encode::encode(&self.kind, encoder)?;
                bincode::Encode::encode(&self.projectile_target_indicator, encoder)?;
                bincode::Encode::encode(&self.hp, encoder)?;
                bincode::Encode::encode(&self.max_hp, encoder)?;
                bincode::Encode::encode(&self.skills, encoder)?;
                bincode::Encode::encode(&self.status_effects, encoder)?;
                bincode::Encode::encode(&self.damage, encoder)?;
                bincode::Encode::encode(&self.reward, encoder)?;
                bincode::Encode::encode(&self.animation, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Monster {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    id: bincode::Decode::decode(decoder)?,
                    move_on_route: bincode::Decode::decode(decoder)?,
                    kind: bincode::Decode::decode(decoder)?,
                    projectile_target_indicator: bincode::Decode::decode(decoder)?,
                    hp: bincode::Decode::decode(decoder)?,
                    max_hp: bincode::Decode::decode(decoder)?,
                    skills: bincode::Decode::decode(decoder)?,
                    status_effects: bincode::Decode::decode(decoder)?,
                    damage: bincode::Decode::decode(decoder)?,
                    reward: bincode::Decode::decode(decoder)?,
                    animation: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Monster {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("id");
                self.id.serialize_without_name(buf);
                buf.write_string("move_on_route");
                self.move_on_route.serialize_without_name(buf);
                buf.write_string("kind");
                self.kind.serialize_without_name(buf);
                buf.write_string("projectile_target_indicator");
                self.projectile_target_indicator.serialize_without_name(buf);
                buf.write_string("hp");
                self.hp.serialize_without_name(buf);
                buf.write_string("max_hp");
                self.max_hp.serialize_without_name(buf);
                buf.write_string("skills");
                self.skills.serialize_without_name(buf);
                buf.write_string("status_effects");
                self.status_effects.serialize_without_name(buf);
                buf.write_string("damage");
                self.damage.serialize_without_name(buf);
                buf.write_string("reward");
                self.reward.serialize_without_name(buf);
                buf.write_string("animation");
                self.animation.serialize_without_name(buf);
            }
        }
        impl Deserialize for Monster {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("id")?;
                let id = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("move_on_route")?;
                let move_on_route = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("kind")?;
                let kind = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("projectile_target_indicator")?;
                let projectile_target_indicator = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("hp")?;
                let hp = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("max_hp")?;
                let max_hp = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("skills")?;
                let skills = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("status_effects")?;
                let status_effects = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("damage")?;
                let damage = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("reward")?;
                let reward = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("animation")?;
                let animation = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    id,
                    move_on_route,
                    kind,
                    projectile_target_indicator,
                    hp,
                    max_hp,
                    skills,
                    status_effects,
                    damage,
                    reward,
                    animation,
                })
            }
        }
        impl Monster {
            pub fn new(
                template: &MonsterTemplate,
                route: Arc<Route>,
                now: Instant,
                health_multiplier: f32,
            ) -> Self {
                static ID: AtomicUsize = AtomicUsize::new(0);
                let adjusted_max_hp = template.max_hp * health_multiplier;
                Self {
                    id: ID.fetch_add(1, Ordering::Relaxed),
                    move_on_route: MoveOnRoute::new(route, template.velocity),
                    kind: template.kind,
                    projectile_target_indicator: ProjectileTargetIndicator::new(),
                    hp: adjusted_max_hp,
                    max_hp: adjusted_max_hp,
                    skills: template
                        .skills
                        .iter()
                        .map(|&t| MonsterSkill::new(t, now))
                        .collect(),
                    status_effects: ::alloc::vec::Vec::new(),
                    damage: template.damage,
                    reward: template.reward,
                    animation: MonsterAnimation::new(),
                }
            }
            pub fn get_damage(&mut self, damage: f32) {
                if self.dead()
                    || self
                        .status_effects
                        .iter()
                        .any(|status_effect| {
                            #[allow(non_exhaustive_omitted_patterns)]
                            match status_effect.kind {
                                MonsterStatusEffectKind::Invincible => true,
                                _ => false,
                            }
                        })
                {
                    return;
                }
                self.hp -= damage;
            }
            pub fn heal(&mut self, amount: f32) {
                if self.dead() {
                    return;
                }
                self.hp += amount;
                if self.hp > self.max_hp {
                    self.hp = self.max_hp;
                }
            }
            pub fn get_damage_to_user(&self) -> f32 {
                self.damage
            }
            pub fn dead(&self) -> bool {
                self.hp <= 0.0
            }
            pub fn xy(&self) -> MapCoordF32 {
                self.move_on_route.xy()
            }
            pub fn id(&self) -> usize {
                self.id
            }
            pub fn get_speed_multiplier(&self) -> f32 {
                let is_immune_to_slow = self
                    .status_effects
                    .iter()
                    .any(|status_effect| {
                        #[allow(non_exhaustive_omitted_patterns)]
                        match status_effect.kind {
                            MonsterStatusEffectKind::ImmuneToSlow => true,
                            _ => false,
                        }
                    });
                let mut speed_multiplier = 1.0f32;
                for status_effect in &self.status_effects {
                    match status_effect.kind {
                        MonsterStatusEffectKind::SpeedMul { mul } => {
                            if is_immune_to_slow && mul < 1.0 {
                                continue;
                            }
                            speed_multiplier *= mul;
                        }
                        MonsterStatusEffectKind::Invincible
                        | MonsterStatusEffectKind::ImmuneToSlow => {}
                    }
                }
                speed_multiplier
            }
        }
    }
    mod monster_spawn {
        use super::*;
        use std::{collections::VecDeque, iter, vec};
        pub enum MonsterSpawnState {
            Idle,
            Spawning {
                monster_queue: VecDeque<MonsterKind>,
                next_spawn_time: Instant,
                spawn_interval: Duration,
            },
        }
        impl bincode::Encode for MonsterSpawnState {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Idle => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Spawning {
                        monster_queue,
                        next_spawn_time,
                        spawn_interval,
                    } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(monster_queue, encoder)?;
                        bincode::Encode::encode(next_spawn_time, encoder)?;
                        bincode::Encode::encode(spawn_interval, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for MonsterSpawnState {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Idle),
                    1u32 => {
                        Ok(Self::Spawning {
                            monster_queue: bincode::Decode::decode(decoder)?,
                            next_spawn_time: bincode::Decode::decode(decoder)?,
                            spawn_interval: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 1u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for MonsterSpawnState {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Idle => {
                        buf.write_string("Idle");
                    }
                    Self::Spawning {
                        monster_queue,
                        next_spawn_time,
                        spawn_interval,
                    } => {
                        buf.write_string("Spawning");
                        buf.write_string("monster_queue");
                        monster_queue.serialize_without_name(buf);
                        buf.write_string("next_spawn_time");
                        next_spawn_time.serialize_without_name(buf);
                        buf.write_string("spawn_interval");
                        spawn_interval.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for MonsterSpawnState {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Idle" => Ok(Self::Idle),
                    "Spawning" => {
                        let field_name = buf.read_name("monster_queue")?;
                        let monster_queue = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("next_spawn_time")?;
                        let next_spawn_time = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        let field_name = buf.read_name("spawn_interval")?;
                        let spawn_interval = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Spawning {
                            monster_queue,
                            next_spawn_time,
                            spawn_interval,
                        })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        /// This won't immediately spawn a monster or update game_state,
        /// but it just requests to start spawning a monster.
        pub fn start_spawn(game_state: &mut GameState) {
            if !#[allow(non_exhaustive_omitted_patterns)]
            match game_state.monster_spawn_state {
                MonsterSpawnState::Idle => true,
                _ => false,
            } {
                return;
            }
            let (monster_queue, spawn_interval) = monster_queue_table(game_state.stage);
            game_state.monster_spawn_state = MonsterSpawnState::Spawning {
                monster_queue,
                next_spawn_time: game_state.now(),
                spawn_interval,
            };
        }
        pub fn tick(game_state: &mut GameState, now: Instant) {
            let MonsterSpawnState::Spawning {
                monster_queue,
                next_spawn_time,
                spawn_interval,
            } = &mut game_state.monster_spawn_state else {
                return;
            };
            if now < *next_spawn_time {
                return;
            }
            let Some(next_monster_kind) = monster_queue.pop_front() else {
                game_state.monster_spawn_state = MonsterSpawnState::Idle;
                return;
            };
            let next_monster_template = MonsterTemplate::new(next_monster_kind);
            let health_multiplier = game_state
                .stage_modifiers
                .get_enemy_health_multiplier();
            game_state
                .monsters
                .push(
                    Monster::new(
                        &next_monster_template,
                        game_state.route.clone(),
                        now,
                        health_multiplier,
                    ),
                );
            *next_spawn_time = now + *spawn_interval;
        }
        fn monster_queue_table(stage: usize) -> (VecDeque<MonsterKind>, Duration) {
            let spawn_interval = Duration::from_millis(
                (10000.0 / (26.0 * (stage as f32 / 50.0) + 4.0)) as i64,
            );
            let monster_queue = match stage {
                1 => <[_]>::into_vec(::alloc::boxed::box_new([(MonsterKind::Mob01, 4)])),
                2 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob02, 1),
                            (MonsterKind::Mob01, 3),
                        ]),
                    )
                }
                3 => <[_]>::into_vec(::alloc::boxed::box_new([(MonsterKind::Mob02, 4)])),
                4 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob03, 1),
                            (MonsterKind::Mob02, 3),
                        ]),
                    )
                }
                5 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named01, 1),
                            (MonsterKind::Mob01, 3),
                        ]),
                    )
                }
                6 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob04, 1),
                            (MonsterKind::Mob03, 3),
                        ]),
                    )
                }
                7 => <[_]>::into_vec(::alloc::boxed::box_new([(MonsterKind::Mob04, 4)])),
                8 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named02, 1),
                            (MonsterKind::Mob05, 1),
                            (MonsterKind::Mob04, 4),
                        ]),
                    )
                }
                9 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob05, 4),
                            (MonsterKind::Mob02, 2),
                        ]),
                    )
                }
                10 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob06, 1),
                            (MonsterKind::Mob05, 2),
                            (MonsterKind::Mob02, 3),
                        ]),
                    )
                }
                11 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named03, 1),
                            (MonsterKind::Mob06, 2),
                            (MonsterKind::Mob05, 5),
                        ]),
                    )
                }
                12 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob06, 5),
                            (MonsterKind::Mob03, 3),
                        ]),
                    )
                }
                13 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob07, 1),
                            (MonsterKind::Mob06, 3),
                            (MonsterKind::Mob03, 4),
                        ]),
                    )
                }
                14 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named04, 1),
                            (MonsterKind::Mob07, 3),
                            (MonsterKind::Mob06, 6),
                        ]),
                    )
                }
                15 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss01, 1),
                            (MonsterKind::Mob07, 5),
                            (MonsterKind::Mob04, 4),
                        ]),
                    )
                }
                16 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob08, 1),
                            (MonsterKind::Mob07, 4),
                            (MonsterKind::Mob04, 5),
                        ]),
                    )
                }
                17 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named05, 1),
                            (MonsterKind::Mob08, 4),
                            (MonsterKind::Mob07, 7),
                        ]),
                    )
                }
                18 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob08, 7),
                            (MonsterKind::Mob05, 5),
                        ]),
                    )
                }
                19 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob09, 1),
                            (MonsterKind::Mob08, 5),
                            (MonsterKind::Mob05, 6),
                        ]),
                    )
                }
                20 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named06, 1),
                            (MonsterKind::Mob09, 5),
                            (MonsterKind::Mob08, 8),
                        ]),
                    )
                }
                21 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob09, 8),
                            (MonsterKind::Mob08, 6),
                        ]),
                    )
                }
                22 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob10, 1),
                            (MonsterKind::Mob09, 6),
                            (MonsterKind::Mob06, 7),
                        ]),
                    )
                }
                23 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named07, 1),
                            (MonsterKind::Mob10, 6),
                            (MonsterKind::Mob09, 9),
                        ]),
                    )
                }
                24 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob10, 9),
                            (MonsterKind::Mob09, 7),
                        ]),
                    )
                }
                25 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss02, 1),
                            (MonsterKind::Mob11, 1),
                            (MonsterKind::Mob10, 6),
                            (MonsterKind::Mob07, 8),
                        ]),
                    )
                }
                26 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named08, 1),
                            (MonsterKind::Mob11, 7),
                            (MonsterKind::Mob10, 10),
                        ]),
                    )
                }
                27 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob11, 10),
                            (MonsterKind::Mob10, 8),
                        ]),
                    )
                }
                28 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob12, 1),
                            (MonsterKind::Mob11, 8),
                            (MonsterKind::Mob08, 9),
                        ]),
                    )
                }
                29 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named09, 1),
                            (MonsterKind::Mob12, 8),
                            (MonsterKind::Mob11, 11),
                        ]),
                    )
                }
                30 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss03, 1),
                            (MonsterKind::Mob12, 10),
                            (MonsterKind::Mob11, 9),
                        ]),
                    )
                }
                31 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob13, 1),
                            (MonsterKind::Mob12, 9),
                            (MonsterKind::Mob09, 10),
                        ]),
                    )
                }
                32 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named10, 1),
                            (MonsterKind::Mob13, 9),
                            (MonsterKind::Mob12, 12),
                        ]),
                    )
                }
                33 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob13, 12),
                            (MonsterKind::Mob12, 10),
                        ]),
                    )
                }
                34 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob14, 1),
                            (MonsterKind::Mob13, 10),
                            (MonsterKind::Mob10, 11),
                        ]),
                    )
                }
                35 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss04, 1),
                            (MonsterKind::Named11, 1),
                            (MonsterKind::Mob14, 9),
                            (MonsterKind::Mob13, 13),
                        ]),
                    )
                }
                36 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob14, 13),
                            (MonsterKind::Mob13, 11),
                        ]),
                    )
                }
                37 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob15, 1),
                            (MonsterKind::Mob14, 11),
                            (MonsterKind::Mob11, 12),
                        ]),
                    )
                }
                38 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named12, 1),
                            (MonsterKind::Mob15, 11),
                            (MonsterKind::Mob14, 14),
                        ]),
                    )
                }
                39 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob15, 14),
                            (MonsterKind::Mob14, 12),
                        ]),
                    )
                }
                40 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss05, 1),
                            (MonsterKind::Mob15, 12),
                            (MonsterKind::Mob12, 13),
                        ]),
                    )
                }
                41 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named13, 1),
                            (MonsterKind::Mob15, 20),
                            (MonsterKind::Mob14, 7),
                        ]),
                    )
                }
                42 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Mob15, 16),
                            (MonsterKind::Mob14, 12),
                        ]),
                    )
                }
                43 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named11, 1),
                            (MonsterKind::Named10, 1),
                            (MonsterKind::Mob15, 12),
                            (MonsterKind::Mob14, 14),
                        ]),
                    )
                }
                44 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Named14, 1),
                            (MonsterKind::Named11, 1),
                            (MonsterKind::Mob15, 18),
                            (MonsterKind::Mob14, 10),
                        ]),
                    )
                }
                45 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss06, 1),
                            (MonsterKind::Named11, 1),
                            (MonsterKind::Named09, 1),
                            (MonsterKind::Mob15, 20),
                            (MonsterKind::Mob14, 7),
                        ]),
                    )
                }
                46 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss07, 1),
                            (MonsterKind::Named11, 1),
                            (MonsterKind::Named09, 1),
                            (MonsterKind::Mob15, 24),
                            (MonsterKind::Mob14, 3),
                        ]),
                    )
                }
                47 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss08, 1),
                            (MonsterKind::Named15, 1),
                            (MonsterKind::Named13, 1),
                            (MonsterKind::Named12, 1),
                            (MonsterKind::Mob15, 24),
                            (MonsterKind::Mob14, 4),
                        ]),
                    )
                }
                48 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss09, 1),
                            (MonsterKind::Named14, 1),
                            (MonsterKind::Named13, 1),
                            (MonsterKind::Named12, 1),
                            (MonsterKind::Mob15, 28),
                        ]),
                    )
                }
                49 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss10, 1),
                            (MonsterKind::Named15, 1),
                            (MonsterKind::Named14, 1),
                            (MonsterKind::Named13, 1),
                            (MonsterKind::Mob15, 28),
                        ]),
                    )
                }
                50 => {
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            (MonsterKind::Boss11, 1),
                            (MonsterKind::Named16, 1),
                            (MonsterKind::Named15, 1),
                            (MonsterKind::Named14, 1),
                            (MonsterKind::Mob15, 30),
                        ]),
                    )
                }
                _ => ::core::panicking::panic("not implemented"),
            }
                .iter()
                .flat_map(|(kind, count)| iter::repeat_n(*kind, *count))
                .collect::<VecDeque<_>>();
            (monster_queue, spawn_interval)
        }
    }
    mod placed_towers {
        use super::*;
        /// Assume that the tower's size is 2x2.
        /// All iteration in this struct will be in the order of left-top, right-top, left-bottom, right-bottom.
        pub struct PlacedTowers {
            /// key is the left-top coord of the tower.
            inner: Vec<Tower>,
        }
        #[automatically_derived]
        impl ::core::default::Default for PlacedTowers {
            #[inline]
            fn default() -> PlacedTowers {
                PlacedTowers {
                    inner: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PlacedTowers {
            #[inline]
            fn clone(&self) -> PlacedTowers {
                PlacedTowers {
                    inner: ::core::clone::Clone::clone(&self.inner),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PlacedTowers {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PlacedTowers {
            #[inline]
            fn eq(&self, other: &PlacedTowers) -> bool {
                self.inner == other.inner
            }
        }
        impl bincode::Encode for PlacedTowers {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.inner, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for PlacedTowers {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    inner: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for PlacedTowers {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("inner");
                self.inner.serialize_without_name(buf);
            }
        }
        impl Deserialize for PlacedTowers {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("inner")?;
                let inner = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { inner })
            }
        }
        impl PlacedTowers {
            pub fn iter(&self) -> impl Iterator<Item = &Tower> {
                self.inner.iter()
            }
            pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut Tower> {
                self.inner.iter_mut()
            }
            pub fn coords(&self) -> Vec<MapCoord> {
                self.iter()
                    .flat_map(|tower| {
                        let left_top = tower.left_top;
                        let right_top = left_top + MapCoord::new(1, 0);
                        let left_bottom = left_top + MapCoord::new(0, 1);
                        let right_bottom = left_top + MapCoord::new(1, 1);
                        [left_top, right_top, left_bottom, right_bottom]
                    })
                    .collect()
            }
            pub fn place_tower(&mut self, tower: Tower) {
                let Some(index) = self
                    .inner
                    .iter()
                    .position(|placed_tower| {
                        tower.left_top.y < placed_tower.left_top.y
                            || tower.left_top.x < placed_tower.left_top.x
                    }) else {
                    self.inner.push(tower);
                    return;
                };
                self.inner.insert(index, tower);
            }
            pub fn remove_tower(&mut self, tower_id: usize) {
                self.inner.retain(|tower| tower.id() != tower_id);
            }
            pub fn find_by_id(&self, tower_id: usize) -> Option<&Tower> {
                self.inner.iter().find(|tower| tower.id() == tower_id)
            }
            pub fn find_by_xy(&self, xy: MapCoord) -> Option<&Tower> {
                self.inner
                    .iter()
                    .find(|tower| {
                        tower.left_top.x <= xy.x && xy.x < tower.left_top.x + 2
                            && tower.left_top.y <= xy.y && xy.y < tower.left_top.y + 2
                    })
            }
        }
    }
    pub mod play_history {
        use super::*;
        use crate::{
            card::{Rank, Suit},
            game_state::{
                contract::Contract, item::{Effect, Item},
                upgrade::Upgrade,
            },
            *,
        };
        pub struct PlayHistory {
            pub events: Vec<HistoryEvent>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PlayHistory {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "PlayHistory",
                    "events",
                    &&self.events,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PlayHistory {
            #[inline]
            fn clone(&self) -> PlayHistory {
                PlayHistory {
                    events: ::core::clone::Clone::clone(&self.events),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for PlayHistory {
            #[inline]
            fn default() -> PlayHistory {
                PlayHistory {
                    events: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for PlayHistory {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.events, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for PlayHistory {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    events: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for PlayHistory {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("events");
                self.events.serialize_without_name(buf);
            }
        }
        impl Deserialize for PlayHistory {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("events")?;
                let events = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { events })
            }
        }
        pub struct HistoryEvent {
            pub stage: usize,
            pub timestamp: Instant,
            pub event_type: HistoryEventType,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for HistoryEvent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "HistoryEvent",
                    "stage",
                    &self.stage,
                    "timestamp",
                    &self.timestamp,
                    "event_type",
                    &&self.event_type,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for HistoryEvent {
            #[inline]
            fn clone(&self) -> HistoryEvent {
                HistoryEvent {
                    stage: ::core::clone::Clone::clone(&self.stage),
                    timestamp: ::core::clone::Clone::clone(&self.timestamp),
                    event_type: ::core::clone::Clone::clone(&self.event_type),
                }
            }
        }
        impl bincode::Encode for HistoryEvent {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.stage, encoder)?;
                bincode::Encode::encode(&self.timestamp, encoder)?;
                bincode::Encode::encode(&self.event_type, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for HistoryEvent {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    stage: bincode::Decode::decode(decoder)?,
                    timestamp: bincode::Decode::decode(decoder)?,
                    event_type: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for HistoryEvent {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("stage");
                self.stage.serialize_without_name(buf);
                buf.write_string("timestamp");
                self.timestamp.serialize_without_name(buf);
                buf.write_string("event_type");
                self.event_type.serialize_without_name(buf);
            }
        }
        impl Deserialize for HistoryEvent {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("stage")?;
                let stage = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("timestamp")?;
                let timestamp = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("event_type")?;
                let event_type = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    stage,
                    timestamp,
                    event_type,
                })
            }
        }
        pub enum HistoryEventType {
            TowerPlaced {
                tower_kind: TowerKind,
                rank: Rank,
                suit: Suit,
                left_top: MapCoord,
            },
            DamageTaken { amount: f32 },
            ItemPurchased { item: Item, cost: usize },
            ItemUsed { item_effect: Effect },
            UpgradeSelected { upgrade: Upgrade },
            UpgradePurchased { upgrade: Upgrade, cost: usize },
            ContractPurchased { contract: Contract, cost: usize },
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for HistoryEventType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    HistoryEventType::TowerPlaced {
                        tower_kind: __self_0,
                        rank: __self_1,
                        suit: __self_2,
                        left_top: __self_3,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "TowerPlaced",
                            "tower_kind",
                            __self_0,
                            "rank",
                            __self_1,
                            "suit",
                            __self_2,
                            "left_top",
                            &__self_3,
                        )
                    }
                    HistoryEventType::DamageTaken { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DamageTaken",
                            "amount",
                            &__self_0,
                        )
                    }
                    HistoryEventType::ItemPurchased {
                        item: __self_0,
                        cost: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ItemPurchased",
                            "item",
                            __self_0,
                            "cost",
                            &__self_1,
                        )
                    }
                    HistoryEventType::ItemUsed { item_effect: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "ItemUsed",
                            "item_effect",
                            &__self_0,
                        )
                    }
                    HistoryEventType::UpgradeSelected { upgrade: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "UpgradeSelected",
                            "upgrade",
                            &__self_0,
                        )
                    }
                    HistoryEventType::UpgradePurchased {
                        upgrade: __self_0,
                        cost: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "UpgradePurchased",
                            "upgrade",
                            __self_0,
                            "cost",
                            &__self_1,
                        )
                    }
                    HistoryEventType::ContractPurchased {
                        contract: __self_0,
                        cost: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ContractPurchased",
                            "contract",
                            __self_0,
                            "cost",
                            &__self_1,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for HistoryEventType {
            #[inline]
            fn clone(&self) -> HistoryEventType {
                match self {
                    HistoryEventType::TowerPlaced {
                        tower_kind: __self_0,
                        rank: __self_1,
                        suit: __self_2,
                        left_top: __self_3,
                    } => {
                        HistoryEventType::TowerPlaced {
                            tower_kind: ::core::clone::Clone::clone(__self_0),
                            rank: ::core::clone::Clone::clone(__self_1),
                            suit: ::core::clone::Clone::clone(__self_2),
                            left_top: ::core::clone::Clone::clone(__self_3),
                        }
                    }
                    HistoryEventType::DamageTaken { amount: __self_0 } => {
                        HistoryEventType::DamageTaken {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    HistoryEventType::ItemPurchased {
                        item: __self_0,
                        cost: __self_1,
                    } => {
                        HistoryEventType::ItemPurchased {
                            item: ::core::clone::Clone::clone(__self_0),
                            cost: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    HistoryEventType::ItemUsed { item_effect: __self_0 } => {
                        HistoryEventType::ItemUsed {
                            item_effect: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    HistoryEventType::UpgradeSelected { upgrade: __self_0 } => {
                        HistoryEventType::UpgradeSelected {
                            upgrade: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    HistoryEventType::UpgradePurchased {
                        upgrade: __self_0,
                        cost: __self_1,
                    } => {
                        HistoryEventType::UpgradePurchased {
                            upgrade: ::core::clone::Clone::clone(__self_0),
                            cost: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    HistoryEventType::ContractPurchased {
                        contract: __self_0,
                        cost: __self_1,
                    } => {
                        HistoryEventType::ContractPurchased {
                            contract: ::core::clone::Clone::clone(__self_0),
                            cost: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                }
            }
        }
        impl bincode::Encode for HistoryEventType {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::TowerPlaced { tower_kind, rank, suit, left_top } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(tower_kind, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                        bincode::Encode::encode(left_top, encoder)?;
                    }
                    Self::DamageTaken { amount } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::ItemPurchased { item, cost } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(item, encoder)?;
                        bincode::Encode::encode(cost, encoder)?;
                    }
                    Self::ItemUsed { item_effect } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(item_effect, encoder)?;
                    }
                    Self::UpgradeSelected { upgrade } => {
                        bincode::Encode::encode(&4u32, encoder)?;
                        bincode::Encode::encode(upgrade, encoder)?;
                    }
                    Self::UpgradePurchased { upgrade, cost } => {
                        bincode::Encode::encode(&5u32, encoder)?;
                        bincode::Encode::encode(upgrade, encoder)?;
                        bincode::Encode::encode(cost, encoder)?;
                    }
                    Self::ContractPurchased { contract, cost } => {
                        bincode::Encode::encode(&6u32, encoder)?;
                        bincode::Encode::encode(contract, encoder)?;
                        bincode::Encode::encode(cost, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for HistoryEventType {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::TowerPlaced {
                            tower_kind: bincode::Decode::decode(decoder)?,
                            rank: bincode::Decode::decode(decoder)?,
                            suit: bincode::Decode::decode(decoder)?,
                            left_top: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::DamageTaken {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => {
                        Ok(Self::ItemPurchased {
                            item: bincode::Decode::decode(decoder)?,
                            cost: bincode::Decode::decode(decoder)?,
                        })
                    }
                    3u32 => {
                        Ok(Self::ItemUsed {
                            item_effect: bincode::Decode::decode(decoder)?,
                        })
                    }
                    4u32 => {
                        Ok(Self::UpgradeSelected {
                            upgrade: bincode::Decode::decode(decoder)?,
                        })
                    }
                    5u32 => {
                        Ok(Self::UpgradePurchased {
                            upgrade: bincode::Decode::decode(decoder)?,
                            cost: bincode::Decode::decode(decoder)?,
                        })
                    }
                    6u32 => {
                        Ok(Self::ContractPurchased {
                            contract: bincode::Decode::decode(decoder)?,
                            cost: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 6u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for HistoryEventType {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::TowerPlaced { tower_kind, rank, suit, left_top } => {
                        buf.write_string("TowerPlaced");
                        buf.write_string("tower_kind");
                        tower_kind.serialize_without_name(buf);
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                        buf.write_string("left_top");
                        left_top.serialize_without_name(buf);
                    }
                    Self::DamageTaken { amount } => {
                        buf.write_string("DamageTaken");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::ItemPurchased { item, cost } => {
                        buf.write_string("ItemPurchased");
                        buf.write_string("item");
                        item.serialize_without_name(buf);
                        buf.write_string("cost");
                        cost.serialize_without_name(buf);
                    }
                    Self::ItemUsed { item_effect } => {
                        buf.write_string("ItemUsed");
                        buf.write_string("item_effect");
                        item_effect.serialize_without_name(buf);
                    }
                    Self::UpgradeSelected { upgrade } => {
                        buf.write_string("UpgradeSelected");
                        buf.write_string("upgrade");
                        upgrade.serialize_without_name(buf);
                    }
                    Self::UpgradePurchased { upgrade, cost } => {
                        buf.write_string("UpgradePurchased");
                        buf.write_string("upgrade");
                        upgrade.serialize_without_name(buf);
                        buf.write_string("cost");
                        cost.serialize_without_name(buf);
                    }
                    Self::ContractPurchased { contract, cost } => {
                        buf.write_string("ContractPurchased");
                        buf.write_string("contract");
                        contract.serialize_without_name(buf);
                        buf.write_string("cost");
                        cost.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for HistoryEventType {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "TowerPlaced" => {
                        let field_name = buf.read_name("tower_kind")?;
                        let tower_kind = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("left_top")?;
                        let left_top = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TowerPlaced {
                            tower_kind,
                            rank,
                            suit,
                            left_top,
                        })
                    }
                    "DamageTaken" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DamageTaken { amount })
                    }
                    "ItemPurchased" => {
                        let field_name = buf.read_name("item")?;
                        let item = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("cost")?;
                        let cost = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::ItemPurchased { item, cost })
                    }
                    "ItemUsed" => {
                        let field_name = buf.read_name("item_effect")?;
                        let item_effect = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::ItemUsed { item_effect })
                    }
                    "UpgradeSelected" => {
                        let field_name = buf.read_name("upgrade")?;
                        let upgrade = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::UpgradeSelected { upgrade })
                    }
                    "UpgradePurchased" => {
                        let field_name = buf.read_name("upgrade")?;
                        let upgrade = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("cost")?;
                        let cost = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::UpgradePurchased {
                            upgrade,
                            cost,
                        })
                    }
                    "ContractPurchased" => {
                        let field_name = buf.read_name("contract")?;
                        let contract = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("cost")?;
                        let cost = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::ContractPurchased {
                            contract,
                            cost,
                        })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl PlayHistory {
            pub fn new() -> Self {
                Self { events: Vec::new() }
            }
        }
        impl GameState {
            pub fn record_event(&mut self, event_type: HistoryEventType) {
                self.play_history
                    .events
                    .push(HistoryEvent {
                        stage: self.stage,
                        timestamp: self.now(),
                        event_type,
                    });
            }
        }
    }
    pub mod projectile {
        use super::*;
        use std::sync::atomic::{AtomicUsize, Ordering};
        pub struct Projectile {
            pub xy: MapCoordF32,
            pub kind: ProjectileKind,
            pub velocity: Velocity,
            pub target_indicator: ProjectileTargetIndicator,
            pub damage: f32,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Projectile {
            #[inline]
            fn clone(&self) -> Projectile {
                Projectile {
                    xy: ::core::clone::Clone::clone(&self.xy),
                    kind: ::core::clone::Clone::clone(&self.kind),
                    velocity: ::core::clone::Clone::clone(&self.velocity),
                    target_indicator: ::core::clone::Clone::clone(
                        &self.target_indicator,
                    ),
                    damage: ::core::clone::Clone::clone(&self.damage),
                }
            }
        }
        impl bincode::Encode for Projectile {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.xy, encoder)?;
                bincode::Encode::encode(&self.kind, encoder)?;
                bincode::Encode::encode(&self.velocity, encoder)?;
                bincode::Encode::encode(&self.target_indicator, encoder)?;
                bincode::Encode::encode(&self.damage, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Projectile {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    xy: bincode::Decode::decode(decoder)?,
                    kind: bincode::Decode::decode(decoder)?,
                    velocity: bincode::Decode::decode(decoder)?,
                    target_indicator: bincode::Decode::decode(decoder)?,
                    damage: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Projectile {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("xy");
                self.xy.serialize_without_name(buf);
                buf.write_string("kind");
                self.kind.serialize_without_name(buf);
                buf.write_string("velocity");
                self.velocity.serialize_without_name(buf);
                buf.write_string("target_indicator");
                self.target_indicator.serialize_without_name(buf);
                buf.write_string("damage");
                self.damage.serialize_without_name(buf);
            }
        }
        impl Deserialize for Projectile {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("xy")?;
                let xy = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("kind")?;
                let kind = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("velocity")?;
                let velocity = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("target_indicator")?;
                let target_indicator = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("damage")?;
                let damage = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    xy,
                    kind,
                    velocity,
                    target_indicator,
                    damage,
                })
            }
        }
        impl Projectile {
            pub(crate) fn move_by(&mut self, dt: Duration, dest_xy: MapCoordF32) {
                self.xy += (dest_xy - self.xy).normalize() * (self.velocity * dt);
            }
        }
        impl Component for &Projectile {
            fn render(self, ctx: &RenderCtx) {
                let projectile_wh = TILE_PX_SIZE
                    * match self.kind {
                        ProjectileKind::Ball => Wh::new(0.1, 0.1),
                    };
                let path = Path::new()
                    .add_oval(
                        Rect::from_xy_wh(projectile_wh.to_xy() * -0.5, projectile_wh),
                    );
                let paint = Paint::new(Color::GREEN);
                ctx.translate(TILE_PX_SIZE.to_xy() * 0.5).add(namui::path(path, paint));
            }
        }
        pub enum ProjectileKind {
            Ball,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ProjectileKind {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "Ball")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ProjectileKind {
            #[inline]
            fn clone(&self) -> ProjectileKind {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ProjectileKind {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ProjectileKind {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ProjectileKind {
            #[inline]
            fn eq(&self, other: &ProjectileKind) -> bool {
                true
            }
        }
        impl bincode::Encode for ProjectileKind {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Ball => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for ProjectileKind {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Ball),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 0u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for ProjectileKind {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Ball => {
                        buf.write_string("Ball");
                    }
                }
            }
        }
        impl Deserialize for ProjectileKind {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Ball" => Ok(Self::Ball),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub struct ProjectileTargetIndicator {
            id: usize,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ProjectileTargetIndicator {
            #[inline]
            fn clone(&self) -> ProjectileTargetIndicator {
                let _: ::core::clone::AssertParamIsClone<usize>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ProjectileTargetIndicator {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ProjectileTargetIndicator {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ProjectileTargetIndicator {
            #[inline]
            fn eq(&self, other: &ProjectileTargetIndicator) -> bool {
                self.id == other.id
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ProjectileTargetIndicator {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<usize>;
            }
        }
        impl bincode::Encode for ProjectileTargetIndicator {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.id, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for ProjectileTargetIndicator {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    id: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for ProjectileTargetIndicator {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("id");
                self.id.serialize_without_name(buf);
            }
        }
        impl Deserialize for ProjectileTargetIndicator {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("id")?;
                let id = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { id })
            }
        }
        impl Default for ProjectileTargetIndicator {
            fn default() -> Self {
                Self::new()
            }
        }
        impl ProjectileTargetIndicator {
            pub fn new() -> Self {
                static ID: AtomicUsize = AtomicUsize::new(0);
                Self {
                    id: ID.fetch_add(1, Ordering::Relaxed),
                }
            }
        }
    }
    mod render {
        use super::*;
        pub struct RenderGameState<'a> {
            pub game_state: &'a GameState,
        }
        impl Component for RenderGameState<'_> {
            fn render(self, ctx: &RenderCtx) {
                ctx.add(tick::Ticker);
                ctx.scale(Xy::single(self.game_state.camera.zoom_level))
                    .translate(
                        TILE_PX_SIZE.to_xy() * self.game_state.camera.left_top * -1.0,
                    )
                    .compose(|ctx| {
                        ctx.add((render_tower_info_popup, self.game_state));
                        ctx.add((render_cursor_preview, self.game_state));
                        ctx.add((render_field_particles, self.game_state));
                        ctx.add((render_projectiles, self.game_state));
                        ctx.add((render_monsters, self.game_state));
                        ctx.add((render_route_guide, self.game_state));
                        ctx.add((render_towers, self.game_state));
                        ctx.add((render_grid, self.game_state));
                        ctx.add((render_backgrounds, self.game_state));
                    });
            }
        }
        impl GameState {
            fn render_stuffs<'a, C, MapCoord, MapAxis>(
                &self,
                ctx: &ComposeCtx,
                stuffs: impl Iterator<Item = (MapCoord, C)>,
            )
            where
                C: 'a + Component,
                MapCoord: AsRef<Xy<MapAxis>>,
                MapAxis: Ratio + std::fmt::Debug + Clone + Copy,
            {
                let camera = &self.camera;
                let screen_rect = Rect::from_xy_wh(
                    camera.left_top,
                    {
                        let screen_size = namui::screen::size();
                        Wh::new(
                            screen_size.width.as_i32().as_f32()
                                / TILE_PX_SIZE.width.as_f32(),
                            screen_size.height.as_i32().as_f32()
                                / TILE_PX_SIZE.height.as_f32(),
                        ) / camera.zoom_level
                    },
                );
                for (xy, stuff) in stuffs {
                    let xy = *xy.as_ref();
                    if screen_rect.right() < xy.x.as_f32()
                        || screen_rect.bottom() < xy.y.as_f32()
                    {
                        continue;
                    }
                    let px_xy = TILE_PX_SIZE.to_xy() * xy.map(|t| t.as_f32());
                    ctx.translate(px_xy)
                        .compose(move |ctx| {
                            let rendering_tree = ctx.ghost_add("", stuff);
                            let Some(bounding_box) = rendering_tree.bounding_box() else {
                                return;
                            };
                            let local_right = bounding_box.right() / TILE_PX_SIZE.width;
                            let local_bottom = bounding_box.bottom()
                                / TILE_PX_SIZE.height;
                            if xy.x.as_f32() + local_right < screen_rect.left()
                                || xy.y.as_f32() + local_bottom < screen_rect.top()
                            {
                                return;
                            }
                            ctx.add(rendering_tree);
                        });
                }
            }
        }
        fn render_grid(ctx: &RenderCtx, game_state: &GameState) {
            let _towers = &game_state.towers;
            let mut path = Path::new();
            for x in 0..MAP_SIZE.width + 1 {
                let x = (x.as_f32() * TILE_PX_SIZE.width.as_f32()).px();
                path = path.move_to(x, 0.px());
                path = path
                    .line_to(
                        x,
                        (MAP_SIZE.height.as_f32() * TILE_PX_SIZE.height.as_f32()).px(),
                    );
            }
            for y in 0..MAP_SIZE.height + 1 {
                let y = (y.as_f32() * TILE_PX_SIZE.height.as_f32()).px();
                path = path.move_to(0.px(), y);
                path = path
                    .line_to(
                        (MAP_SIZE.width.as_f32() * TILE_PX_SIZE.width.as_f32()).px(),
                        y,
                    );
            }
            let paint = Paint::new(Color::grayscale_alpha_f01(1.0, 0.5))
                .set_style(PaintStyle::Stroke)
                .set_stroke_width(2.px())
                .set_stroke_cap(StrokeCap::Round);
            ctx.add(namui::path(path, paint))
                .attach_event(|event| {
                    if let Event::MouseDown { event } = event {
                        if event.button != Some(MouseButton::Left) {
                            return;
                        }
                        if !event.is_local_xy_in() {
                            return;
                        }
                        let local_xy = event.local_xy();
                        let tile_x = (local_xy.x / TILE_PX_SIZE.width).floor() as usize;
                        let tile_y = (local_xy.y / TILE_PX_SIZE.height).floor() as usize;
                        mutate_game_state(move |game_state| {
                            let tower_at_position = game_state
                                .towers
                                .find_by_xy(MapCoord::new(tile_x, tile_y));
                            if tower_at_position.is_none() {
                                game_state.set_selected_tower(None);
                            }
                        });
                    }
                });
        }
        fn render_backgrounds(ctx: &RenderCtx, game_state: &GameState) {
            let camera = &game_state.camera;
            let screen_rect = Rect::from_xy_wh(
                camera.left_top,
                {
                    let screen_size = namui::screen::size();
                    Wh::new(
                        screen_size.width.as_i32().as_f32()
                            / TILE_PX_SIZE.width.as_f32(),
                        screen_size.height.as_i32().as_f32()
                            / TILE_PX_SIZE.height.as_f32(),
                    ) / camera.zoom_level
                },
            );
            for background in game_state.backgrounds.iter() {
                let xy = background.coord;
                if screen_rect.right() < xy.x || screen_rect.bottom() < xy.y {
                    continue;
                }
                let px_xy = Xy::new(
                    px(xy.x * TILE_PX_SIZE.width.as_f32()),
                    px(xy.y * TILE_PX_SIZE.height.as_f32()),
                );
                ctx.translate(px_xy)
                    .compose({
                        let background = *background;
                        move |ctx| {
                            let rendering_tree = ctx.ghost_add("", &background);
                            let Some(bounding_box) = rendering_tree.bounding_box() else {
                                return;
                            };
                            let local_right = bounding_box.right() / TILE_PX_SIZE.width;
                            let local_bottom = bounding_box.bottom()
                                / TILE_PX_SIZE.height;
                            if xy.x + local_right < screen_rect.left()
                                || xy.y + local_bottom < screen_rect.top()
                            {
                                return;
                            }
                            ctx.add(rendering_tree);
                            ctx.add(
                                    rect(RectParam {
                                        rect: bounding_box,
                                        style: RectStyle {
                                            fill: Some(RectFill {
                                                color: Color::TRANSPARENT,
                                            }),
                                            ..Default::default()
                                        },
                                    }),
                                )
                                .attach_event(|event| {
                                    if let Event::MouseDown { event } = event {
                                        if event.button != Some(MouseButton::Left) {
                                            return;
                                        }
                                        if !event.is_local_xy_in() {
                                            return;
                                        }
                                        mutate_game_state(|game_state| {
                                            game_state.set_selected_tower(None);
                                        });
                                    }
                                });
                        }
                    });
            }
        }
        fn render_projectiles(ctx: &RenderCtx, game_state: &GameState) {
            game_state
                .render_stuffs(
                    ctx,
                    game_state
                        .projectiles
                        .iter()
                        .map(|projectile| (projectile.xy, projectile)),
                );
        }
        fn render_towers(ctx: &RenderCtx, game_state: &GameState) {
            let camera = &game_state.camera;
            let screen_rect = {
                let screen_size = namui::screen::size();
                Rect::from_xy_wh(
                    camera.left_top,
                    {
                        Wh::new(
                            screen_size.width.as_i32().as_f32()
                                / TILE_PX_SIZE.width.as_f32(),
                            screen_size.height.as_i32().as_f32()
                                / TILE_PX_SIZE.height.as_f32(),
                        ) / camera.zoom_level
                    },
                )
            };
            for tower in game_state.towers.iter() {
                let tower_xy = tower.left_top.map(|t| t.as_f32());
                if screen_rect.right() < tower_xy.x || screen_rect.bottom() < tower_xy.y
                {
                    continue;
                }
                let px_xy = TILE_PX_SIZE.to_xy() * tower_xy;
                ctx.translate(px_xy)
                    .compose(move |ctx| {
                        ctx.add(tower);
                        let tower_size = 128.0;
                        ctx.add(
                                namui::rect(RectParam {
                                    rect: Rect::from_xy_wh(
                                        Xy::zero(),
                                        Wh::new(tower_size.px(), tower_size.px()),
                                    ),
                                    style: RectStyle {
                                        fill: Some(RectFill {
                                            color: Color::TRANSPARENT,
                                        }),
                                        ..Default::default()
                                    },
                                }),
                            )
                            .attach_event({
                                let tower_id = tower.id();
                                let tower_kind = tower.kind;
                                move |event| {
                                    let Event::MouseDown { event } = event else {
                                        return;
                                    };
                                    if event.button != Some(MouseButton::Left) {
                                        return;
                                    }
                                    if !event.is_local_xy_in() {
                                        return;
                                    }
                                    if tower_kind
                                        == crate::game_state::tower::TowerKind::Barricade
                                    {
                                        return;
                                    }
                                    event.stop_propagation();
                                    mutate_game_state(move |game_state| {
                                        game_state.set_selected_tower(Some(tower_id));
                                    });
                                }
                            });
                    });
            }
        }
        fn render_tower_info_popup(ctx: &RenderCtx, game_state: &GameState) {
            use crate::game_state::tower_info_popup::TowerInfoPopup;
            for tower in game_state.towers.iter() {
                if let Some(popup_state) = game_state
                    .ui_state
                    .get_popup_state(tower.id()) && popup_state.is_visible()
                {
                    let popup_scale = popup_state.scale;
                    let popup_opacity = popup_state.opacity;
                    if popup_scale > 0.01 && popup_opacity > 0.01 {
                        let px_xy = TILE_PX_SIZE.to_xy()
                            * tower.left_top.map(|t| t as f32)
                            + Xy::new(TILE_PX_SIZE.width, 0.px());
                        ctx.translate(px_xy)
                            .scale(
                                Xy::single(popup_scale / game_state.camera.zoom_level),
                            )
                            .add(TowerInfoPopup { tower });
                    }
                }
            }
        }
        fn render_monsters(ctx: &RenderCtx, game_state: &GameState) {
            game_state
                .render_stuffs(
                    ctx,
                    game_state
                        .monsters
                        .iter()
                        .map(|monster| (monster.move_on_route.xy(), monster)),
                );
        }
        fn render_cursor_preview(ctx: &RenderCtx, game_state: &GameState) {
            ctx.add(game_state.cursor_preview.render());
            if let crate::game_state::GameFlow::PlacingTower { hand } = &game_state.flow
            {
                let selected_slot_ids = hand.selected_slot_ids();
                if let Some(&selected_slot_id) = selected_slot_ids.first()
                    && let Some(tower_template) = hand.get_item(selected_slot_id)
                {
                    ctx.add(crate::game_state::cursor_preview::tower::TowerCursorPreview {
                        tower_template,
                        map_coord: game_state.cursor_preview.map_coord,
                        placing_tower_slot_id: selected_slot_id,
                    });
                }
            }
        }
        fn render_field_particles(ctx: &RenderCtx, game_state: &GameState) {
            game_state.field_particle_system_manager.render(ctx, game_state.now());
        }
    }
    pub mod stage_modifiers {
        //! Stage-wide transient & persistent modifiers extracted from former contract::mod.rs
        //!
        //! Responsibility:
        //! - Aggregate per-stage combat/economy multipliers
        //! - Track additive adjustments (bonus/penalty pairs) with net delta helpers
        //! - Maintain reroll health costs
        //! - Maintain temporary restrictions (disabled ranks/suits, purchase/use flags)
        //! - Keep certain grants (barricade cards) persistent across stage resets
        //!
        //! Lifecycle:
        //! - Call `reset_stage_state` at stage start; this resets transient categories but leaves `StageGrants` intact
        //! - Call `clear_stage_grants` only when you intentionally want to drop persistent grants
        //!
        //! Design Notes:
        //! - Internally grouped into small structs for clarity & future serialization friendliness
        //! - Net delta helpers return signed difference (bonus - penalty) for quick UI display / logic
        //! - All multipliers are multiplicative stacks (default 1.0)
        //!
        //! Future Ideas:
        //! - Consider serde derives if saving mid-run is needed
        //! - Add incremental (additive) shield / barricade accumulation helpers
        //! - Introduce a generic stacking abstraction if new modifier categories grow
        use crate::card::{Rank, Suit};
        use crate::*;
        pub struct Multipliers {
            pub damage: f32,
            pub attack_speed: f32,
            pub range: f32,
            pub damage_reduction: f32,
            pub incoming_damage: f32,
            pub gold_gain: f32,
            pub enemy_health: f32,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Multipliers {
            #[inline]
            fn clone(&self) -> Multipliers {
                Multipliers {
                    damage: ::core::clone::Clone::clone(&self.damage),
                    attack_speed: ::core::clone::Clone::clone(&self.attack_speed),
                    range: ::core::clone::Clone::clone(&self.range),
                    damage_reduction: ::core::clone::Clone::clone(
                        &self.damage_reduction,
                    ),
                    incoming_damage: ::core::clone::Clone::clone(&self.incoming_damage),
                    gold_gain: ::core::clone::Clone::clone(&self.gold_gain),
                    enemy_health: ::core::clone::Clone::clone(&self.enemy_health),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Multipliers {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "damage",
                    "attack_speed",
                    "range",
                    "damage_reduction",
                    "incoming_damage",
                    "gold_gain",
                    "enemy_health",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.damage,
                    &self.attack_speed,
                    &self.range,
                    &self.damage_reduction,
                    &self.incoming_damage,
                    &self.gold_gain,
                    &&self.enemy_health,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Multipliers",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Multipliers {
            #[inline]
            fn default() -> Multipliers {
                Multipliers {
                    damage: ::core::default::Default::default(),
                    attack_speed: ::core::default::Default::default(),
                    range: ::core::default::Default::default(),
                    damage_reduction: ::core::default::Default::default(),
                    incoming_damage: ::core::default::Default::default(),
                    gold_gain: ::core::default::Default::default(),
                    enemy_health: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for Multipliers {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.damage, encoder)?;
                bincode::Encode::encode(&self.attack_speed, encoder)?;
                bincode::Encode::encode(&self.range, encoder)?;
                bincode::Encode::encode(&self.damage_reduction, encoder)?;
                bincode::Encode::encode(&self.incoming_damage, encoder)?;
                bincode::Encode::encode(&self.gold_gain, encoder)?;
                bincode::Encode::encode(&self.enemy_health, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Multipliers {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    damage: bincode::Decode::decode(decoder)?,
                    attack_speed: bincode::Decode::decode(decoder)?,
                    range: bincode::Decode::decode(decoder)?,
                    damage_reduction: bincode::Decode::decode(decoder)?,
                    incoming_damage: bincode::Decode::decode(decoder)?,
                    gold_gain: bincode::Decode::decode(decoder)?,
                    enemy_health: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Multipliers {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("damage");
                self.damage.serialize_without_name(buf);
                buf.write_string("attack_speed");
                self.attack_speed.serialize_without_name(buf);
                buf.write_string("range");
                self.range.serialize_without_name(buf);
                buf.write_string("damage_reduction");
                self.damage_reduction.serialize_without_name(buf);
                buf.write_string("incoming_damage");
                self.incoming_damage.serialize_without_name(buf);
                buf.write_string("gold_gain");
                self.gold_gain.serialize_without_name(buf);
                buf.write_string("enemy_health");
                self.enemy_health.serialize_without_name(buf);
            }
        }
        impl Deserialize for Multipliers {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("damage")?;
                let damage = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("attack_speed")?;
                let attack_speed = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("range")?;
                let range = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("damage_reduction")?;
                let damage_reduction = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("incoming_damage")?;
                let incoming_damage = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("gold_gain")?;
                let gold_gain = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("enemy_health")?;
                let enemy_health = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    damage,
                    attack_speed,
                    range,
                    damage_reduction,
                    incoming_damage,
                    gold_gain,
                    enemy_health,
                })
            }
        }
        pub struct Adjustments {
            pub card_selection_hand_max_slots_bonus: usize,
            pub card_selection_hand_max_slots_penalty: usize,
            pub card_selection_hand_max_rerolls_bonus: usize,
            pub card_selection_hand_max_rerolls_penalty: usize,
            pub shop_max_rerolls_bonus: usize,
            pub shop_max_rerolls_penalty: usize,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Adjustments {
            #[inline]
            fn clone(&self) -> Adjustments {
                Adjustments {
                    card_selection_hand_max_slots_bonus: ::core::clone::Clone::clone(
                        &self.card_selection_hand_max_slots_bonus,
                    ),
                    card_selection_hand_max_slots_penalty: ::core::clone::Clone::clone(
                        &self.card_selection_hand_max_slots_penalty,
                    ),
                    card_selection_hand_max_rerolls_bonus: ::core::clone::Clone::clone(
                        &self.card_selection_hand_max_rerolls_bonus,
                    ),
                    card_selection_hand_max_rerolls_penalty: ::core::clone::Clone::clone(
                        &self.card_selection_hand_max_rerolls_penalty,
                    ),
                    shop_max_rerolls_bonus: ::core::clone::Clone::clone(
                        &self.shop_max_rerolls_bonus,
                    ),
                    shop_max_rerolls_penalty: ::core::clone::Clone::clone(
                        &self.shop_max_rerolls_penalty,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Adjustments {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "card_selection_hand_max_slots_bonus",
                    "card_selection_hand_max_slots_penalty",
                    "card_selection_hand_max_rerolls_bonus",
                    "card_selection_hand_max_rerolls_penalty",
                    "shop_max_rerolls_bonus",
                    "shop_max_rerolls_penalty",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.card_selection_hand_max_slots_bonus,
                    &self.card_selection_hand_max_slots_penalty,
                    &self.card_selection_hand_max_rerolls_bonus,
                    &self.card_selection_hand_max_rerolls_penalty,
                    &self.shop_max_rerolls_bonus,
                    &&self.shop_max_rerolls_penalty,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Adjustments",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Adjustments {
            #[inline]
            fn default() -> Adjustments {
                Adjustments {
                    card_selection_hand_max_slots_bonus: ::core::default::Default::default(),
                    card_selection_hand_max_slots_penalty: ::core::default::Default::default(),
                    card_selection_hand_max_rerolls_bonus: ::core::default::Default::default(),
                    card_selection_hand_max_rerolls_penalty: ::core::default::Default::default(),
                    shop_max_rerolls_bonus: ::core::default::Default::default(),
                    shop_max_rerolls_penalty: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for Adjustments {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(
                    &self.card_selection_hand_max_slots_bonus,
                    encoder,
                )?;
                bincode::Encode::encode(
                    &self.card_selection_hand_max_slots_penalty,
                    encoder,
                )?;
                bincode::Encode::encode(
                    &self.card_selection_hand_max_rerolls_bonus,
                    encoder,
                )?;
                bincode::Encode::encode(
                    &self.card_selection_hand_max_rerolls_penalty,
                    encoder,
                )?;
                bincode::Encode::encode(&self.shop_max_rerolls_bonus, encoder)?;
                bincode::Encode::encode(&self.shop_max_rerolls_penalty, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Adjustments {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    card_selection_hand_max_slots_bonus: bincode::Decode::decode(
                        decoder,
                    )?,
                    card_selection_hand_max_slots_penalty: bincode::Decode::decode(
                        decoder,
                    )?,
                    card_selection_hand_max_rerolls_bonus: bincode::Decode::decode(
                        decoder,
                    )?,
                    card_selection_hand_max_rerolls_penalty: bincode::Decode::decode(
                        decoder,
                    )?,
                    shop_max_rerolls_bonus: bincode::Decode::decode(decoder)?,
                    shop_max_rerolls_penalty: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Adjustments {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("card_selection_hand_max_slots_bonus");
                self.card_selection_hand_max_slots_bonus.serialize_without_name(buf);
                buf.write_string("card_selection_hand_max_slots_penalty");
                self.card_selection_hand_max_slots_penalty.serialize_without_name(buf);
                buf.write_string("card_selection_hand_max_rerolls_bonus");
                self.card_selection_hand_max_rerolls_bonus.serialize_without_name(buf);
                buf.write_string("card_selection_hand_max_rerolls_penalty");
                self.card_selection_hand_max_rerolls_penalty.serialize_without_name(buf);
                buf.write_string("shop_max_rerolls_bonus");
                self.shop_max_rerolls_bonus.serialize_without_name(buf);
                buf.write_string("shop_max_rerolls_penalty");
                self.shop_max_rerolls_penalty.serialize_without_name(buf);
            }
        }
        impl Deserialize for Adjustments {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("card_selection_hand_max_slots_bonus")?;
                let card_selection_hand_max_slots_bonus = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("card_selection_hand_max_slots_penalty")?;
                let card_selection_hand_max_slots_penalty = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("card_selection_hand_max_rerolls_bonus")?;
                let card_selection_hand_max_rerolls_bonus = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf
                    .read_name("card_selection_hand_max_rerolls_penalty")?;
                let card_selection_hand_max_rerolls_penalty = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("shop_max_rerolls_bonus")?;
                let shop_max_rerolls_bonus = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("shop_max_rerolls_penalty")?;
                let shop_max_rerolls_penalty = Deserialize::deserialize_without_name(
                    buf,
                )?;
                Ok(Self {
                    card_selection_hand_max_slots_bonus,
                    card_selection_hand_max_slots_penalty,
                    card_selection_hand_max_rerolls_bonus,
                    card_selection_hand_max_rerolls_penalty,
                    shop_max_rerolls_bonus,
                    shop_max_rerolls_penalty,
                })
            }
        }
        pub struct RerollCosts {
            pub card_selection_hand_reroll_health_cost: usize,
            pub shop_reroll_health_cost: usize,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RerollCosts {
            #[inline]
            fn clone(&self) -> RerollCosts {
                RerollCosts {
                    card_selection_hand_reroll_health_cost: ::core::clone::Clone::clone(
                        &self.card_selection_hand_reroll_health_cost,
                    ),
                    shop_reroll_health_cost: ::core::clone::Clone::clone(
                        &self.shop_reroll_health_cost,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RerollCosts {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "RerollCosts",
                    "card_selection_hand_reroll_health_cost",
                    &self.card_selection_hand_reroll_health_cost,
                    "shop_reroll_health_cost",
                    &&self.shop_reroll_health_cost,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RerollCosts {
            #[inline]
            fn default() -> RerollCosts {
                RerollCosts {
                    card_selection_hand_reroll_health_cost: ::core::default::Default::default(),
                    shop_reroll_health_cost: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for RerollCosts {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(
                    &self.card_selection_hand_reroll_health_cost,
                    encoder,
                )?;
                bincode::Encode::encode(&self.shop_reroll_health_cost, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for RerollCosts {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    card_selection_hand_reroll_health_cost: bincode::Decode::decode(
                        decoder,
                    )?,
                    shop_reroll_health_cost: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for RerollCosts {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("card_selection_hand_reroll_health_cost");
                self.card_selection_hand_reroll_health_cost.serialize_without_name(buf);
                buf.write_string("shop_reroll_health_cost");
                self.shop_reroll_health_cost.serialize_without_name(buf);
            }
        }
        impl Deserialize for RerollCosts {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf
                    .read_name("card_selection_hand_reroll_health_cost")?;
                let card_selection_hand_reroll_health_cost = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("shop_reroll_health_cost")?;
                let shop_reroll_health_cost = Deserialize::deserialize_without_name(
                    buf,
                )?;
                Ok(Self {
                    card_selection_hand_reroll_health_cost,
                    shop_reroll_health_cost,
                })
            }
        }
        pub struct Restrictions {
            pub disable_item_and_upgrade_purchases: bool,
            pub disable_item_use: bool,
            pub disabled_ranks: Vec<Rank>,
            pub disabled_suits: Vec<Suit>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Restrictions {
            #[inline]
            fn clone(&self) -> Restrictions {
                Restrictions {
                    disable_item_and_upgrade_purchases: ::core::clone::Clone::clone(
                        &self.disable_item_and_upgrade_purchases,
                    ),
                    disable_item_use: ::core::clone::Clone::clone(
                        &self.disable_item_use,
                    ),
                    disabled_ranks: ::core::clone::Clone::clone(&self.disabled_ranks),
                    disabled_suits: ::core::clone::Clone::clone(&self.disabled_suits),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Restrictions {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "Restrictions",
                    "disable_item_and_upgrade_purchases",
                    &self.disable_item_and_upgrade_purchases,
                    "disable_item_use",
                    &self.disable_item_use,
                    "disabled_ranks",
                    &self.disabled_ranks,
                    "disabled_suits",
                    &&self.disabled_suits,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Restrictions {
            #[inline]
            fn default() -> Restrictions {
                Restrictions {
                    disable_item_and_upgrade_purchases: ::core::default::Default::default(),
                    disable_item_use: ::core::default::Default::default(),
                    disabled_ranks: ::core::default::Default::default(),
                    disabled_suits: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for Restrictions {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(
                    &self.disable_item_and_upgrade_purchases,
                    encoder,
                )?;
                bincode::Encode::encode(&self.disable_item_use, encoder)?;
                bincode::Encode::encode(&self.disabled_ranks, encoder)?;
                bincode::Encode::encode(&self.disabled_suits, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Restrictions {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    disable_item_and_upgrade_purchases: bincode::Decode::decode(
                        decoder,
                    )?,
                    disable_item_use: bincode::Decode::decode(decoder)?,
                    disabled_ranks: bincode::Decode::decode(decoder)?,
                    disabled_suits: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Restrictions {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("disable_item_and_upgrade_purchases");
                self.disable_item_and_upgrade_purchases.serialize_without_name(buf);
                buf.write_string("disable_item_use");
                self.disable_item_use.serialize_without_name(buf);
                buf.write_string("disabled_ranks");
                self.disabled_ranks.serialize_without_name(buf);
                buf.write_string("disabled_suits");
                self.disabled_suits.serialize_without_name(buf);
            }
        }
        impl Deserialize for Restrictions {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("disable_item_and_upgrade_purchases")?;
                let disable_item_and_upgrade_purchases = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("disable_item_use")?;
                let disable_item_use = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("disabled_ranks")?;
                let disabled_ranks = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("disabled_suits")?;
                let disabled_suits = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    disable_item_and_upgrade_purchases,
                    disable_item_use,
                    disabled_ranks,
                    disabled_suits,
                })
            }
        }
        pub struct StageGrants {
            pub barricade_cards_per_stage: usize,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StageGrants {
            #[inline]
            fn clone(&self) -> StageGrants {
                StageGrants {
                    barricade_cards_per_stage: ::core::clone::Clone::clone(
                        &self.barricade_cards_per_stage,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for StageGrants {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "StageGrants",
                    "barricade_cards_per_stage",
                    &&self.barricade_cards_per_stage,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for StageGrants {
            #[inline]
            fn default() -> StageGrants {
                StageGrants {
                    barricade_cards_per_stage: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for StageGrants {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.barricade_cards_per_stage, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for StageGrants {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    barricade_cards_per_stage: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for StageGrants {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("barricade_cards_per_stage");
                self.barricade_cards_per_stage.serialize_without_name(buf);
            }
        }
        impl Deserialize for StageGrants {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("barricade_cards_per_stage")?;
                let barricade_cards_per_stage = Deserialize::deserialize_without_name(
                    buf,
                )?;
                Ok(Self { barricade_cards_per_stage })
            }
        }
        pub struct StageModifiers {
            multipliers: Multipliers,
            adjustments: Adjustments,
            reroll_costs: RerollCosts,
            restrictions: Restrictions,
            stage_grants: StageGrants,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StageModifiers {
            #[inline]
            fn clone(&self) -> StageModifiers {
                StageModifiers {
                    multipliers: ::core::clone::Clone::clone(&self.multipliers),
                    adjustments: ::core::clone::Clone::clone(&self.adjustments),
                    reroll_costs: ::core::clone::Clone::clone(&self.reroll_costs),
                    restrictions: ::core::clone::Clone::clone(&self.restrictions),
                    stage_grants: ::core::clone::Clone::clone(&self.stage_grants),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for StageModifiers {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "StageModifiers",
                    "multipliers",
                    &self.multipliers,
                    "adjustments",
                    &self.adjustments,
                    "reroll_costs",
                    &self.reroll_costs,
                    "restrictions",
                    &self.restrictions,
                    "stage_grants",
                    &&self.stage_grants,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for StageModifiers {
            #[inline]
            fn default() -> StageModifiers {
                StageModifiers {
                    multipliers: ::core::default::Default::default(),
                    adjustments: ::core::default::Default::default(),
                    reroll_costs: ::core::default::Default::default(),
                    restrictions: ::core::default::Default::default(),
                    stage_grants: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for StageModifiers {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.multipliers, encoder)?;
                bincode::Encode::encode(&self.adjustments, encoder)?;
                bincode::Encode::encode(&self.reroll_costs, encoder)?;
                bincode::Encode::encode(&self.restrictions, encoder)?;
                bincode::Encode::encode(&self.stage_grants, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for StageModifiers {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    multipliers: bincode::Decode::decode(decoder)?,
                    adjustments: bincode::Decode::decode(decoder)?,
                    reroll_costs: bincode::Decode::decode(decoder)?,
                    restrictions: bincode::Decode::decode(decoder)?,
                    stage_grants: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for StageModifiers {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("multipliers");
                self.multipliers.serialize_without_name(buf);
                buf.write_string("adjustments");
                self.adjustments.serialize_without_name(buf);
                buf.write_string("reroll_costs");
                self.reroll_costs.serialize_without_name(buf);
                buf.write_string("restrictions");
                self.restrictions.serialize_without_name(buf);
                buf.write_string("stage_grants");
                self.stage_grants.serialize_without_name(buf);
            }
        }
        impl Deserialize for StageModifiers {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("multipliers")?;
                let multipliers = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("adjustments")?;
                let adjustments = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("reroll_costs")?;
                let reroll_costs = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("restrictions")?;
                let restrictions = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("stage_grants")?;
                let stage_grants = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    multipliers,
                    adjustments,
                    reroll_costs,
                    restrictions,
                    stage_grants,
                })
            }
        }
        impl StageModifiers {
            pub fn new() -> Self {
                Self {
                    multipliers: Multipliers {
                        damage: 1.0,
                        attack_speed: 1.0,
                        range: 1.0,
                        damage_reduction: 1.0,
                        incoming_damage: 1.0,
                        gold_gain: 1.0,
                        enemy_health: 1.0,
                    },
                    adjustments: Adjustments::default(),
                    reroll_costs: RerollCosts::default(),
                    restrictions: Restrictions::default(),
                    stage_grants: StageGrants::default(),
                }
            }
            pub fn reset_stage_state(&mut self) {
                self.multipliers = Multipliers {
                    damage: 1.0,
                    attack_speed: 1.0,
                    range: 1.0,
                    damage_reduction: 1.0,
                    incoming_damage: 1.0,
                    gold_gain: 1.0,
                    enemy_health: 1.0,
                };
                self.adjustments = Adjustments::default();
                self.reroll_costs = RerollCosts::default();
                self.restrictions = Restrictions::default();
            }
            pub fn clear_stage_grants(&mut self) {
                self.stage_grants = StageGrants::default();
            }
            pub fn get_damage_multiplier(&self) -> f32 {
                self.multipliers.damage
            }
            pub fn get_attack_speed_multiplier(&self) -> f32 {
                self.multipliers.attack_speed
            }
            pub fn get_range_multiplier(&self) -> f32 {
                self.multipliers.range
            }
            pub fn get_damage_reduction_multiplier(&self) -> f32 {
                self.multipliers.damage_reduction
            }
            pub fn get_incoming_damage_multiplier(&self) -> f32 {
                self.multipliers.incoming_damage
            }
            pub fn get_gold_gain_multiplier(&self) -> f32 {
                self.multipliers.gold_gain
            }
            pub fn get_enemy_health_multiplier(&self) -> f32 {
                self.multipliers.enemy_health
            }
            pub fn get_card_selection_hand_max_slots_bonus(&self) -> usize {
                self.adjustments.card_selection_hand_max_slots_bonus
            }
            pub fn get_card_selection_hand_max_slots_penalty(&self) -> usize {
                self.adjustments.card_selection_hand_max_slots_penalty
            }
            pub fn get_card_selection_hand_max_rerolls_bonus(&self) -> usize {
                self.adjustments.card_selection_hand_max_rerolls_bonus
            }
            pub fn get_card_selection_hand_max_rerolls_penalty(&self) -> usize {
                self.adjustments.card_selection_hand_max_rerolls_penalty
            }
            pub fn get_shop_max_rerolls_bonus(&self) -> usize {
                self.adjustments.shop_max_rerolls_bonus
            }
            pub fn get_shop_max_rerolls_penalty(&self) -> usize {
                self.adjustments.shop_max_rerolls_penalty
            }
            pub fn is_item_and_upgrade_purchases_disabled(&self) -> bool {
                self.restrictions.disable_item_and_upgrade_purchases
            }
            pub fn is_item_use_disabled(&self) -> bool {
                self.restrictions.disable_item_use
            }
            pub fn get_card_selection_hand_reroll_health_cost(&self) -> usize {
                self.reroll_costs.card_selection_hand_reroll_health_cost
            }
            pub fn get_shop_reroll_health_cost(&self) -> usize {
                self.reroll_costs.shop_reroll_health_cost
            }
            pub fn get_disabled_ranks(&self) -> &Vec<Rank> {
                &self.restrictions.disabled_ranks
            }
            pub fn get_disabled_suits(&self) -> &Vec<Suit> {
                &self.restrictions.disabled_suits
            }
            pub fn get_barricade_cards_per_stage(&self) -> usize {
                self.stage_grants.barricade_cards_per_stage
            }
            pub fn get_card_selection_hand_max_slots_delta(&self) -> isize {
                self.adjustments.card_selection_hand_max_slots_bonus as isize
                    - self.adjustments.card_selection_hand_max_slots_penalty as isize
            }
            pub fn get_card_selection_hand_max_rerolls_delta(&self) -> isize {
                self.adjustments.card_selection_hand_max_rerolls_bonus as isize
                    - self.adjustments.card_selection_hand_max_rerolls_penalty as isize
            }
            pub fn get_shop_max_rerolls_delta(&self) -> isize {
                self.adjustments.shop_max_rerolls_bonus as isize
                    - self.adjustments.shop_max_rerolls_penalty as isize
            }
            pub fn apply_damage_multiplier(&mut self, m: f32) {
                self.multipliers.damage *= m;
            }
            pub fn apply_attack_speed_multiplier(&mut self, m: f32) {
                self.multipliers.attack_speed *= m;
            }
            pub fn apply_range_multiplier(&mut self, m: f32) {
                self.multipliers.range *= m;
            }
            pub fn apply_damage_reduction_multiplier(&mut self, m: f32) {
                self.multipliers.damage_reduction *= m;
            }
            pub fn apply_incoming_damage_multiplier(&mut self, m: f32) {
                self.multipliers.incoming_damage *= m;
            }
            pub fn apply_gold_gain_multiplier(&mut self, m: f32) {
                self.multipliers.gold_gain *= m;
            }
            pub fn apply_enemy_health_multiplier(&mut self, m: f32) {
                self.multipliers.enemy_health *= m;
            }
            pub fn apply_card_selection_hand_max_slots_bonus(&mut self, v: usize) {
                self.adjustments.card_selection_hand_max_slots_bonus += v;
            }
            pub fn apply_card_selection_hand_max_slots_penalty(&mut self, v: usize) {
                self.adjustments.card_selection_hand_max_slots_penalty += v;
            }
            pub fn apply_card_selection_hand_max_rerolls_bonus(&mut self, v: usize) {
                self.adjustments.card_selection_hand_max_rerolls_bonus += v;
            }
            pub fn apply_card_selection_hand_max_rerolls_penalty(&mut self, v: usize) {
                self.adjustments.card_selection_hand_max_rerolls_penalty += v;
            }
            pub fn apply_shop_max_rerolls_bonus(&mut self, v: usize) {
                self.adjustments.shop_max_rerolls_bonus += v;
            }
            pub fn apply_shop_max_rerolls_penalty(&mut self, v: usize) {
                self.adjustments.shop_max_rerolls_penalty += v;
            }
            pub fn disable_item_and_upgrade_purchases(&mut self) {
                self.restrictions.disable_item_and_upgrade_purchases = true;
            }
            pub fn disable_item_use(&mut self) {
                self.restrictions.disable_item_use = true;
            }
            pub fn apply_card_selection_hand_reroll_health_cost(&mut self, v: usize) {
                self.reroll_costs.card_selection_hand_reroll_health_cost += v;
            }
            pub fn apply_shop_reroll_health_cost(&mut self, v: usize) {
                self.reroll_costs.shop_reroll_health_cost += v;
            }
            pub fn disable_rank(&mut self, rank: Rank) {
                if !self.restrictions.disabled_ranks.contains(&rank) {
                    self.restrictions.disabled_ranks.push(rank);
                }
            }
            pub fn is_rank_disabled(&self, rank: Rank) -> bool {
                self.restrictions.disabled_ranks.contains(&rank)
            }
            pub fn disable_suit(&mut self, suit: Suit) {
                if !self.restrictions.disabled_suits.contains(&suit) {
                    self.restrictions.disabled_suits.push(suit);
                }
            }
            pub fn is_suit_disabled(&self, suit: Suit) -> bool {
                self.restrictions.disabled_suits.contains(&suit)
            }
            pub fn set_barricade_cards_per_stage(&mut self, c: usize) {
                self.stage_grants.barricade_cards_per_stage = c;
            }
        }
    }
    mod start_confirm_modal {
        use crate::game_state::{force_start, set_modal, use_game_state};
        use crate::icon::{Icon, IconKind, IconSize};
        use crate::l10n::ui::StartConfirmModalText;
        use crate::theme::button::{Button, ButtonColor, ButtonVariant};
        use crate::theme::{palette, typography::{self, headline, paragraph}};
        use namui::*;
        use namui_prebuilt::{simple_rect, table};
        const TITLE_HEIGHT: Px = px(36.);
        const PADDING: Px = px(16.);
        pub struct StartConfirmModal;
        impl Component for StartConfirmModal {
            fn render(self, ctx: &RenderCtx) {
                let screen_wh = screen::size().into_type::<Px>();
                let game_state = use_game_state(ctx);
                let modal_wh = Wh::new(320.px(), 180.px());
                let modal_xy = ((screen_wh - modal_wh) * 0.5).to_xy();
                ctx.compose(|ctx| {
                        let ctx = ctx.translate(modal_xy);
                        ctx.compose(|ctx| {
                            table::vertical([
                                table::fixed(
                                    TITLE_HEIGHT,
                                    table::horizontal([
                                        table::fixed(PADDING, |_, _| {}),
                                        table::ratio(
                                            1,
                                            |wh, ctx| {
                                                ctx.add(
                                                    headline(
                                                            game_state
                                                                .text()
                                                                .start_confirm_modal(StartConfirmModalText::Title),
                                                        )
                                                        .size(typography::FontSize::Medium)
                                                        .align(typography::TextAlign::LeftCenter {
                                                            height: wh.height,
                                                        })
                                                        .build(),
                                                );
                                            },
                                        ),
                                        table::fixed(
                                            48.px(),
                                            |wh, ctx| {
                                                ctx.add(
                                                    Button::new(
                                                            wh,
                                                            &|| set_modal(None),
                                                            &|wh, _text_color, ctx| {
                                                                ctx.add(
                                                                    Icon::new(IconKind::Reject).size(IconSize::Large).wh(wh),
                                                                );
                                                            },
                                                        )
                                                        .variant(ButtonVariant::Text),
                                                );
                                            },
                                        ),
                                    ]),
                                ),
                                table::ratio(
                                    1,
                                    table::padding(
                                        PADDING,
                                        |wh, ctx| {
                                            ctx.add(
                                                paragraph(
                                                        game_state
                                                            .text()
                                                            .start_confirm_modal(StartConfirmModalText::Message),
                                                    )
                                                    .align(typography::TextAlign::Center {
                                                        wh,
                                                    })
                                                    .build(),
                                            );
                                        },
                                    ),
                                ),
                                table::fixed(
                                    64.px(),
                                    table::padding(
                                        PADDING,
                                        table::horizontal([
                                            table::ratio(
                                                1,
                                                |wh, ctx| {
                                                    ctx.add(
                                                        Button::new(
                                                                wh,
                                                                &|| set_modal(None),
                                                                &|wh, text_color, ctx| {
                                                                    ctx.add(
                                                                        paragraph(
                                                                                game_state
                                                                                    .text()
                                                                                    .start_confirm_modal(StartConfirmModalText::No),
                                                                            )
                                                                            .color(text_color)
                                                                            .align(typography::TextAlign::Center {
                                                                                wh,
                                                                            })
                                                                            .build(),
                                                                    );
                                                                },
                                                            )
                                                            .variant(ButtonVariant::Outlined),
                                                    );
                                                },
                                            ),
                                            table::fixed(PADDING, |_, _| {}),
                                            table::ratio(
                                                1,
                                                |wh, ctx| {
                                                    ctx.add(
                                                        Button::new(
                                                                wh,
                                                                &|| {
                                                                    set_modal(None);
                                                                    force_start();
                                                                },
                                                                &|wh, text_color, ctx| {
                                                                    ctx.add(
                                                                        paragraph(
                                                                                game_state
                                                                                    .text()
                                                                                    .start_confirm_modal(StartConfirmModalText::Yes),
                                                                            )
                                                                            .color(text_color)
                                                                            .align(typography::TextAlign::Center {
                                                                                wh,
                                                                            })
                                                                            .build(),
                                                                    );
                                                                },
                                                            )
                                                            .variant(ButtonVariant::Contained)
                                                            .color(ButtonColor::Primary),
                                                    );
                                                },
                                            ),
                                        ]),
                                    ),
                                ),
                            ])(modal_wh, ctx);
                        });
                        ctx.add(
                            rect(RectParam {
                                rect: Wh::new(modal_wh.width, TITLE_HEIGHT).to_rect(),
                                style: RectStyle {
                                    stroke: None,
                                    fill: Some(RectFill {
                                        color: palette::SURFACE_CONTAINER,
                                    }),
                                    round: Some(RectRound {
                                        radius: palette::ROUND,
                                    }),
                                },
                            }),
                        );
                        ctx.add(
                            rect(RectParam {
                                rect: modal_wh.to_rect(),
                                style: RectStyle {
                                    stroke: None,
                                    fill: Some(RectFill {
                                        color: palette::SURFACE,
                                    }),
                                    round: Some(RectRound {
                                        radius: palette::ROUND,
                                    }),
                                },
                            }),
                        );
                    })
                    .attach_event(|event| {
                        match event {
                            Event::MouseDown { event }
                            | Event::MouseMove { event }
                            | Event::MouseUp { event } => {
                                if !event.is_local_xy_in() {
                                    return;
                                }
                                event.stop_propagation();
                            }
                            Event::Wheel { event } => {
                                if !event.is_local_xy_in() {
                                    return;
                                }
                                event.stop_propagation();
                            }
                            _ => {}
                        };
                    });
                ctx.add(
                    simple_rect(
                            screen_wh,
                            Color::TRANSPARENT,
                            0.px(),
                            Color::from_u8(0, 0, 0, 128),
                        )
                        .attach_event(|event| {
                            let Event::MouseDown { event } = event else {
                                return;
                            };
                            set_modal(None);
                            event.stop_propagation();
                        }),
                );
            }
        }
    }
    mod tick {
        use super::*;
        const TICK_MAX_DURATION: Duration = Duration::from_millis(16);
        pub struct Ticker;
        impl Component for Ticker {
            fn render(self, ctx: &RenderCtx) {
                ctx.interval(
                    "game state tick",
                    TICK_MAX_DURATION,
                    |real_dt| {
                        mutate_game_state(move |game_state| {
                            let mut scaled_dt = real_dt
                                * game_state.fast_forward_multiplier.time_scale().get()
                                    as i32;
                            while scaled_dt.as_millis() > 0 {
                                let tick_dt = scaled_dt.min(TICK_MAX_DURATION);
                                scaled_dt -= tick_dt;
                                game_state.game_now += tick_dt;
                                tick(game_state, tick_dt, game_state.game_now);
                            }
                        });
                    },
                );
            }
        }
        fn tick(game_state: &mut GameState, dt: Duration, now: Instant) {
            game_state.flow.update();
            flow::contract::update_contract_flow(game_state);
            monster_spawn::tick(game_state, now);
            tower::tower_cooldown_tick(game_state, dt);
            tower::tower_animation_tick(game_state, now);
            monster::monster_animation_tick(game_state, dt);
            game_state.ui_state.tick(now);
            if game_state.ui_state.should_cleanup(now) {
                game_state.cleanup_unused_tower_popup_states();
            }
            monster::remove_monster_finished_status_effects(game_state, now);
            tower::remove_tower_finished_status_effects(game_state, now);
            user_status_effect::remove_user_finished_status_effects(game_state, now);
            field_particle::remove_finished_field_particle_systems(game_state, now);
            monster::activate_monster_skills(game_state, now);
            tower::activate_tower_skills(game_state, now);
            monster::move_monsters(game_state, dt);
            move_projectiles(game_state, dt);
            shoot_projectiles(game_state);
            check_defense_end(game_state);
        }
        fn move_projectiles(game_state: &mut GameState, dt: Duration) {
            let GameState { projectiles, monsters, .. } = game_state;
            let mut total_earn_gold = 0;
            let mut damage_emitters = Vec::new();
            projectiles
                .retain_mut(|projectile| {
                    let start_xy = projectile.xy;
                    let Some(monster_index) = monsters
                        .iter()
                        .position(|monster| {
                            monster.projectile_target_indicator
                                == projectile.target_indicator
                        }) else {
                        return false;
                    };
                    let monster = &mut monsters[monster_index];
                    let monster_xy = monster.move_on_route.xy();
                    if (monster_xy - start_xy).length() > projectile.velocity * dt {
                        projectile.move_by(dt, monster_xy);
                        return true;
                    }
                    let damage = projectile.damage;
                    monster.get_damage(damage);
                    if damage > 0.0 {
                        damage_emitters
                            .push(
                                field_particle::emitter::DamageTextEmitter::new(
                                    monster_xy,
                                    damage,
                                ),
                            );
                    }
                    if monster.dead() {
                        let earn = monster.reward
                            + game_state.upgrade_state.gold_earn_plus;
                        let earn = (earn as f32
                            * game_state.stage_modifiers.get_gold_gain_multiplier())
                            as usize;
                        total_earn_gold += earn;
                        monsters.swap_remove(monster_index);
                    }
                    false
                });
            emit_damage_text_particles(game_state, damage_emitters);
            if total_earn_gold > 0 {
                game_state.earn_gold(total_earn_gold);
            }
        }
        fn emit_damage_text_particles(
            game_state: &mut GameState,
            emitters: Vec<field_particle::emitter::DamageTextEmitter>,
        ) {
            if !emitters.is_empty() {
                let field_emitters = emitters
                    .into_iter()
                    .map(|emitter| field_particle::FieldParticleEmitter::DamageText {
                        emitter,
                    })
                    .collect::<Vec<_>>();
                game_state.field_particle_system_manager.add_emitters(field_emitters);
            }
        }
        fn shoot_projectiles(game_state: &mut GameState) {
            let now = game_state.now();
            let GameState { towers, upgrade_state, .. } = game_state;
            let projectiles = towers
                .iter_mut()
                .filter_map(|tower| {
                    if tower.in_cooltime() {
                        return None;
                    }
                    if game_state
                        .stage_modifiers
                        .get_disabled_ranks()
                        .contains(&tower.rank())
                    {
                        return None;
                    }
                    if game_state
                        .stage_modifiers
                        .get_disabled_suits()
                        .contains(&tower.suit())
                    {
                        return None;
                    }
                    let tower_upgrades = upgrade_state.tower_upgrades(tower);
                    let attack_range_radius = tower
                        .attack_range_radius(
                            &tower_upgrades,
                            game_state.stage_modifiers.get_range_multiplier(),
                        );
                    let target = game_state
                        .monsters
                        .iter()
                        .find(|monster| {
                            (monster.move_on_route.xy()
                                - tower.left_top.map(|t| t as f32))
                                .length() < attack_range_radius
                        })?;
                    let contract_multiplier = game_state
                        .stage_modifiers
                        .get_damage_multiplier();
                    Some(
                        tower
                            .shoot(
                                target.projectile_target_indicator,
                                &tower_upgrades,
                                contract_multiplier,
                                now,
                            ),
                    )
                });
            game_state.projectiles.extend(projectiles);
        }
        fn check_defense_end(game_state: &mut GameState) {
            let GameFlow::Defense = game_state.flow else {
                return;
            };
            let MonsterSpawnState::Idle = game_state.monster_spawn_state else {
                return;
            };
            if !game_state.monsters.is_empty() {
                return;
            }
            let is_boss_stage = is_boss_stage(game_state.stage);
            game_state.stage += 1;
            if game_state.stage > 50 {
                return;
            }
            if is_boss_stage {
                game_state.goto_selecting_upgrade();
            } else {
                game_state.goto_next_stage();
            }
        }
    }
    pub mod tower {
        pub mod render {
            use super::{Tower, TowerKind};
            use crate::game_state::GameState;
            use namui::*;
            pub trait TowerImage {
                fn image(self) -> Image;
            }
            impl TowerImage for (TowerKind, AnimationKind) {
                fn image(self) -> Image {
                    let (tower_kind, animation_kind) = self;
                    match tower_kind {
                        TowerKind::Barricade => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::barricade::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::barricade::IDLE1
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::barricade::IDLE1
                                }
                            }
                        }
                        TowerKind::High => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::high::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::high::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::high::ATTACK
                                }
                            }
                        }
                        TowerKind::OnePair => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::one_pair::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::one_pair::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::one_pair::ATTACK
                                }
                            }
                        }
                        TowerKind::TwoPair => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::two_pair::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::two_pair::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::two_pair::ATTACK
                                }
                            }
                        }
                        TowerKind::ThreeOfAKind => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::three_of_a_kind::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::three_of_a_kind::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::three_of_a_kind::ATTACK
                                }
                            }
                        }
                        TowerKind::Straight => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::straight::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::straight::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::straight::ATTACK
                                }
                            }
                        }
                        TowerKind::Flush => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::flush::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::flush::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::flush::ATTACK
                                }
                            }
                        }
                        TowerKind::FullHouse => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::full_house::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::full_house::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::full_house::ATTACK
                                }
                            }
                        }
                        TowerKind::FourOfAKind => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::four_of_a_kind::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::four_of_a_kind::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::four_of_a_kind::ATTACK
                                }
                            }
                        }
                        TowerKind::StraightFlush => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::straight_flush::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::straight_flush::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::straight_flush::ATTACK
                                }
                            }
                        }
                        TowerKind::RoyalFlush => {
                            match animation_kind {
                                AnimationKind::Idle1 => {
                                    crate::asset::image::tower::royal_flush::IDLE1
                                }
                                AnimationKind::Idle2 => {
                                    crate::asset::image::tower::royal_flush::IDLE2
                                }
                                AnimationKind::Attack => {
                                    crate::asset::image::tower::royal_flush::ATTACK
                                }
                            }
                        }
                    }
                }
            }
            impl Component for &Tower {
                fn render(self, ctx: &RenderCtx) {
                    let image = (self.kind, self.animation.kind).image();
                    let image_wh = image.info().wh();
                    let scale = Xy::new(
                        1.0 + self.animation.y_ratio_offset * -0.5,
                        1.0 + self.animation.y_ratio_offset,
                    );
                    ctx.translate((image_wh.width * 0.5, image_wh.height))
                        .scale(scale)
                        .add(
                            namui::image(ImageParam {
                                rect: Rect::from_xy_wh(
                                    Xy::new(-image_wh.width * 0.5, -image_wh.height),
                                    image.info().wh(),
                                ),
                                image,
                                style: ImageStyle {
                                    fit: ImageFit::None,
                                    paint: None,
                                },
                            }),
                        );
                }
            }
            pub fn tower_animation_tick(game_state: &mut GameState, now: Instant) {
                const STIFFNESS: f32 = -1500.0;
                const DAMPING: f32 = -10.0;
                game_state
                    .towers
                    .iter_mut()
                    .for_each(|tower| {
                        let Tower { animation, template, .. } = tower;
                        let kind = template.kind;
                        if let TowerKind::Barricade = kind {
                            return;
                        }
                        let delta_time = (now - animation.tick_at).as_secs_f32();
                        animation.tick_at = now;
                        if now - animation.transited_at > animation.duration() {
                            animation
                                .transition(
                                    match animation.kind {
                                        AnimationKind::Idle1 => AnimationKind::Idle2,
                                        AnimationKind::Idle2 => AnimationKind::Idle1,
                                        AnimationKind::Attack => AnimationKind::Idle1,
                                    },
                                    now,
                                );
                        }
                        let transit_force_expired = animation
                            .transit_force
                            .is_some_and(|transit_force| transit_force.end_at < now);
                        let transit_force = animation
                            .transit_force
                            .map(|transit_force| transit_force.force)
                            .unwrap_or(0.0);
                        let spring_force = STIFFNESS * animation.y_ratio_offset;
                        let damping_force = DAMPING * animation.y_ratio_velocity;
                        let acceleration = spring_force + damping_force + transit_force;
                        animation.y_ratio_velocity += acceleration * delta_time;
                        animation.y_ratio_offset
                            += animation.y_ratio_velocity * delta_time;
                        if transit_force_expired {
                            animation.transit_force = None;
                        }
                    });
            }
            pub(super) struct Animation {
                kind: AnimationKind,
                transited_at: Instant,
                transit_force: Option<TransitForce>,
                tick_at: Instant,
                y_ratio_offset: f32,
                y_ratio_velocity: f32,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Animation {
                #[inline]
                fn clone(&self) -> Animation {
                    Animation {
                        kind: ::core::clone::Clone::clone(&self.kind),
                        transited_at: ::core::clone::Clone::clone(&self.transited_at),
                        transit_force: ::core::clone::Clone::clone(&self.transit_force),
                        tick_at: ::core::clone::Clone::clone(&self.tick_at),
                        y_ratio_offset: ::core::clone::Clone::clone(
                            &self.y_ratio_offset,
                        ),
                        y_ratio_velocity: ::core::clone::Clone::clone(
                            &self.y_ratio_velocity,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Animation {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Animation {
                #[inline]
                fn eq(&self, other: &Animation) -> bool {
                    self.y_ratio_offset == other.y_ratio_offset
                        && self.y_ratio_velocity == other.y_ratio_velocity
                        && self.kind == other.kind
                        && self.transited_at == other.transited_at
                        && self.transit_force == other.transit_force
                        && self.tick_at == other.tick_at
                }
            }
            impl bincode::Encode for Animation {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.kind, encoder)?;
                    bincode::Encode::encode(&self.transited_at, encoder)?;
                    bincode::Encode::encode(&self.transit_force, encoder)?;
                    bincode::Encode::encode(&self.tick_at, encoder)?;
                    bincode::Encode::encode(&self.y_ratio_offset, encoder)?;
                    bincode::Encode::encode(&self.y_ratio_velocity, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for Animation {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        kind: bincode::Decode::decode(decoder)?,
                        transited_at: bincode::Decode::decode(decoder)?,
                        transit_force: bincode::Decode::decode(decoder)?,
                        tick_at: bincode::Decode::decode(decoder)?,
                        y_ratio_offset: bincode::Decode::decode(decoder)?,
                        y_ratio_velocity: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for Animation {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("kind");
                    self.kind.serialize_without_name(buf);
                    buf.write_string("transited_at");
                    self.transited_at.serialize_without_name(buf);
                    buf.write_string("transit_force");
                    self.transit_force.serialize_without_name(buf);
                    buf.write_string("tick_at");
                    self.tick_at.serialize_without_name(buf);
                    buf.write_string("y_ratio_offset");
                    self.y_ratio_offset.serialize_without_name(buf);
                    buf.write_string("y_ratio_velocity");
                    self.y_ratio_velocity.serialize_without_name(buf);
                }
            }
            impl Deserialize for Animation {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("kind")?;
                    let kind = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("transited_at")?;
                    let transited_at = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("transit_force")?;
                    let transit_force = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("tick_at")?;
                    let tick_at = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("y_ratio_offset")?;
                    let y_ratio_offset = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("y_ratio_velocity")?;
                    let y_ratio_velocity = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self {
                        kind,
                        transited_at,
                        transit_force,
                        tick_at,
                        y_ratio_offset,
                        y_ratio_velocity,
                    })
                }
            }
            impl Animation {
                pub(super) fn new(now: Instant) -> Self {
                    Self {
                        kind: AnimationKind::Idle1,
                        transited_at: now,
                        transit_force: None,
                        tick_at: now,
                        y_ratio_offset: 0.0,
                        y_ratio_velocity: 0.0,
                    }
                }
                pub(super) fn transition(&mut self, kind: AnimationKind, now: Instant) {
                    const IDLE_TRANSIT_FORCE: f32 = -100.0;
                    const ATTACK_TRANSIT_FORCE: f32 = -500.0;
                    const FORCE_DURATION: Duration = Duration::from_millis(33);
                    if let AnimationKind::Attack = kind {
                        self.transit_force = Some(TransitForce {
                            force: ATTACK_TRANSIT_FORCE,
                            end_at: now + FORCE_DURATION,
                        });
                    } else if let AnimationKind::Attack = self.kind {} else {
                        self.transit_force = Some(TransitForce {
                            force: IDLE_TRANSIT_FORCE,
                            end_at: now + FORCE_DURATION,
                        });
                    }
                    self.kind = kind;
                    self.transited_at = now;
                }
                fn duration(&self) -> Duration {
                    self.kind.duration()
                }
            }
            struct TransitForce {
                force: f32,
                end_at: Instant,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TransitForce {
                #[inline]
                fn clone(&self) -> TransitForce {
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    let _: ::core::clone::AssertParamIsClone<Instant>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for TransitForce {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TransitForce {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TransitForce {
                #[inline]
                fn eq(&self, other: &TransitForce) -> bool {
                    self.force == other.force && self.end_at == other.end_at
                }
            }
            impl bincode::Encode for TransitForce {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.force, encoder)?;
                    bincode::Encode::encode(&self.end_at, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for TransitForce {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        force: bincode::Decode::decode(decoder)?,
                        end_at: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for TransitForce {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("force");
                    self.force.serialize_without_name(buf);
                    buf.write_string("end_at");
                    self.end_at.serialize_without_name(buf);
                }
            }
            impl Deserialize for TransitForce {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("force")?;
                    let force = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("end_at")?;
                    let end_at = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self { force, end_at })
                }
            }
            pub enum AnimationKind {
                Idle1,
                Idle2,
                Attack,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for AnimationKind {
                #[inline]
                fn clone(&self) -> AnimationKind {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for AnimationKind {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for AnimationKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for AnimationKind {
                #[inline]
                fn eq(&self, other: &AnimationKind) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            impl bincode::Encode for AnimationKind {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::Idle1 => {
                            bincode::Encode::encode(&0u32, encoder)?;
                        }
                        Self::Idle2 => {
                            bincode::Encode::encode(&1u32, encoder)?;
                        }
                        Self::Attack => {
                            bincode::Encode::encode(&2u32, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for AnimationKind {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => Ok(Self::Idle1),
                        1u32 => Ok(Self::Idle2),
                        2u32 => Ok(Self::Attack),
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 2u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for AnimationKind {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::Idle1 => {
                            buf.write_string("Idle1");
                        }
                        Self::Idle2 => {
                            buf.write_string("Idle2");
                        }
                        Self::Attack => {
                            buf.write_string("Attack");
                        }
                    }
                }
            }
            impl Deserialize for AnimationKind {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "Idle1" => Ok(Self::Idle1),
                        "Idle2" => Ok(Self::Idle2),
                        "Attack" => Ok(Self::Attack),
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            impl AnimationKind {
                fn duration(&self) -> Duration {
                    match self {
                        Self::Idle1 => Duration::from_millis(1500),
                        Self::Idle2 => Duration::from_millis(1500),
                        Self::Attack => Duration::from_millis(333),
                    }
                }
            }
        }
        mod skill {
            use super::*;
            use std::ops::Deref;
            pub struct TowerSkillTemplate {
                pub kind: TowerSkillKind,
                pub cooldown: Duration,
                pub duration: Duration,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for TowerSkillTemplate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "TowerSkillTemplate",
                        "kind",
                        &self.kind,
                        "cooldown",
                        &self.cooldown,
                        "duration",
                        &&self.duration,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TowerSkillTemplate {
                #[inline]
                fn clone(&self) -> TowerSkillTemplate {
                    let _: ::core::clone::AssertParamIsClone<TowerSkillKind>;
                    let _: ::core::clone::AssertParamIsClone<Duration>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for TowerSkillTemplate {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TowerSkillTemplate {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TowerSkillTemplate {
                #[inline]
                fn eq(&self, other: &TowerSkillTemplate) -> bool {
                    self.kind == other.kind && self.cooldown == other.cooldown
                        && self.duration == other.duration
                }
            }
            impl bincode::Encode for TowerSkillTemplate {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.kind, encoder)?;
                    bincode::Encode::encode(&self.cooldown, encoder)?;
                    bincode::Encode::encode(&self.duration, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for TowerSkillTemplate {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        kind: bincode::Decode::decode(decoder)?,
                        cooldown: bincode::Decode::decode(decoder)?,
                        duration: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for TowerSkillTemplate {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("kind");
                    self.kind.serialize_without_name(buf);
                    buf.write_string("cooldown");
                    self.cooldown.serialize_without_name(buf);
                    buf.write_string("duration");
                    self.duration.serialize_without_name(buf);
                }
            }
            impl Deserialize for TowerSkillTemplate {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("kind")?;
                    let kind = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("cooldown")?;
                    let cooldown = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("duration")?;
                    let duration = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self { kind, cooldown, duration })
                }
            }
            impl TowerSkillTemplate {
                pub fn new_passive(kind: TowerSkillKind) -> Self {
                    Self {
                        kind,
                        cooldown: Duration::from_secs(1),
                        duration: Duration::from_secs(1),
                    }
                }
            }
            pub struct TowerSkill {
                pub last_used_at: Instant,
                pub template: TowerSkillTemplate,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TowerSkill {
                #[inline]
                fn clone(&self) -> TowerSkill {
                    TowerSkill {
                        last_used_at: ::core::clone::Clone::clone(&self.last_used_at),
                        template: ::core::clone::Clone::clone(&self.template),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TowerSkill {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TowerSkill {
                #[inline]
                fn eq(&self, other: &TowerSkill) -> bool {
                    self.last_used_at == other.last_used_at
                        && self.template == other.template
                }
            }
            impl bincode::Encode for TowerSkill {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.last_used_at, encoder)?;
                    bincode::Encode::encode(&self.template, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for TowerSkill {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        last_used_at: bincode::Decode::decode(decoder)?,
                        template: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for TowerSkill {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("last_used_at");
                    self.last_used_at.serialize_without_name(buf);
                    buf.write_string("template");
                    self.template.serialize_without_name(buf);
                }
            }
            impl Deserialize for TowerSkill {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("last_used_at")?;
                    let last_used_at = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("template")?;
                    let template = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self { last_used_at, template })
                }
            }
            impl TowerSkill {
                pub fn new(template: TowerSkillTemplate, now: Instant) -> Self {
                    Self {
                        last_used_at: now,
                        template,
                    }
                }
            }
            impl Deref for TowerSkill {
                type Target = TowerSkillTemplate;
                fn deref(&self) -> &Self::Target {
                    &self.template
                }
            }
            pub enum TowerSkillKind {
                NearbyTowerDamageMul { mul: f32, range_radius: f32 },
                NearbyTowerDamageAdd { add: f32, range_radius: f32 },
                NearbyTowerAttackSpeedAdd { add: f32, range_radius: f32 },
                NearbyTowerAttackSpeedMul { mul: f32, range_radius: f32 },
                NearbyTowerAttackRangeAdd { add: f32, range_radius: f32 },
                NearbyMonsterSpeedMul { mul: f32, range_radius: f32 },
                MoneyIncomeAdd { add: u32 },
                TopCardBonus { rank: Rank, bonus_damage: usize },
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TowerSkillKind {
                #[inline]
                fn clone(&self) -> TowerSkillKind {
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    let _: ::core::clone::AssertParamIsClone<Rank>;
                    let _: ::core::clone::AssertParamIsClone<usize>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for TowerSkillKind {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TowerSkillKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TowerSkillKind {
                #[inline]
                fn eq(&self, other: &TowerSkillKind) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                        && match (self, other) {
                            (
                                TowerSkillKind::NearbyTowerDamageMul {
                                    mul: __self_0,
                                    range_radius: __self_1,
                                },
                                TowerSkillKind::NearbyTowerDamageMul {
                                    mul: __arg1_0,
                                    range_radius: __arg1_1,
                                },
                            ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                            (
                                TowerSkillKind::NearbyTowerDamageAdd {
                                    add: __self_0,
                                    range_radius: __self_1,
                                },
                                TowerSkillKind::NearbyTowerDamageAdd {
                                    add: __arg1_0,
                                    range_radius: __arg1_1,
                                },
                            ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                            (
                                TowerSkillKind::NearbyTowerAttackSpeedAdd {
                                    add: __self_0,
                                    range_radius: __self_1,
                                },
                                TowerSkillKind::NearbyTowerAttackSpeedAdd {
                                    add: __arg1_0,
                                    range_radius: __arg1_1,
                                },
                            ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                            (
                                TowerSkillKind::NearbyTowerAttackSpeedMul {
                                    mul: __self_0,
                                    range_radius: __self_1,
                                },
                                TowerSkillKind::NearbyTowerAttackSpeedMul {
                                    mul: __arg1_0,
                                    range_radius: __arg1_1,
                                },
                            ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                            (
                                TowerSkillKind::NearbyTowerAttackRangeAdd {
                                    add: __self_0,
                                    range_radius: __self_1,
                                },
                                TowerSkillKind::NearbyTowerAttackRangeAdd {
                                    add: __arg1_0,
                                    range_radius: __arg1_1,
                                },
                            ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                            (
                                TowerSkillKind::NearbyMonsterSpeedMul {
                                    mul: __self_0,
                                    range_radius: __self_1,
                                },
                                TowerSkillKind::NearbyMonsterSpeedMul {
                                    mul: __arg1_0,
                                    range_radius: __arg1_1,
                                },
                            ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                            (
                                TowerSkillKind::MoneyIncomeAdd { add: __self_0 },
                                TowerSkillKind::MoneyIncomeAdd { add: __arg1_0 },
                            ) => __self_0 == __arg1_0,
                            (
                                TowerSkillKind::TopCardBonus {
                                    rank: __self_0,
                                    bonus_damage: __self_1,
                                },
                                TowerSkillKind::TopCardBonus {
                                    rank: __arg1_0,
                                    bonus_damage: __arg1_1,
                                },
                            ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for TowerSkillKind {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        TowerSkillKind::NearbyTowerDamageMul {
                            mul: __self_0,
                            range_radius: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "NearbyTowerDamageMul",
                                "mul",
                                __self_0,
                                "range_radius",
                                &__self_1,
                            )
                        }
                        TowerSkillKind::NearbyTowerDamageAdd {
                            add: __self_0,
                            range_radius: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "NearbyTowerDamageAdd",
                                "add",
                                __self_0,
                                "range_radius",
                                &__self_1,
                            )
                        }
                        TowerSkillKind::NearbyTowerAttackSpeedAdd {
                            add: __self_0,
                            range_radius: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "NearbyTowerAttackSpeedAdd",
                                "add",
                                __self_0,
                                "range_radius",
                                &__self_1,
                            )
                        }
                        TowerSkillKind::NearbyTowerAttackSpeedMul {
                            mul: __self_0,
                            range_radius: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "NearbyTowerAttackSpeedMul",
                                "mul",
                                __self_0,
                                "range_radius",
                                &__self_1,
                            )
                        }
                        TowerSkillKind::NearbyTowerAttackRangeAdd {
                            add: __self_0,
                            range_radius: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "NearbyTowerAttackRangeAdd",
                                "add",
                                __self_0,
                                "range_radius",
                                &__self_1,
                            )
                        }
                        TowerSkillKind::NearbyMonsterSpeedMul {
                            mul: __self_0,
                            range_radius: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "NearbyMonsterSpeedMul",
                                "mul",
                                __self_0,
                                "range_radius",
                                &__self_1,
                            )
                        }
                        TowerSkillKind::MoneyIncomeAdd { add: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "MoneyIncomeAdd",
                                "add",
                                &__self_0,
                            )
                        }
                        TowerSkillKind::TopCardBonus {
                            rank: __self_0,
                            bonus_damage: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "TopCardBonus",
                                "rank",
                                __self_0,
                                "bonus_damage",
                                &__self_1,
                            )
                        }
                    }
                }
            }
            impl bincode::Encode for TowerSkillKind {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::NearbyTowerDamageMul { mul, range_radius } => {
                            bincode::Encode::encode(&0u32, encoder)?;
                            bincode::Encode::encode(mul, encoder)?;
                            bincode::Encode::encode(range_radius, encoder)?;
                        }
                        Self::NearbyTowerDamageAdd { add, range_radius } => {
                            bincode::Encode::encode(&1u32, encoder)?;
                            bincode::Encode::encode(add, encoder)?;
                            bincode::Encode::encode(range_radius, encoder)?;
                        }
                        Self::NearbyTowerAttackSpeedAdd { add, range_radius } => {
                            bincode::Encode::encode(&2u32, encoder)?;
                            bincode::Encode::encode(add, encoder)?;
                            bincode::Encode::encode(range_radius, encoder)?;
                        }
                        Self::NearbyTowerAttackSpeedMul { mul, range_radius } => {
                            bincode::Encode::encode(&3u32, encoder)?;
                            bincode::Encode::encode(mul, encoder)?;
                            bincode::Encode::encode(range_radius, encoder)?;
                        }
                        Self::NearbyTowerAttackRangeAdd { add, range_radius } => {
                            bincode::Encode::encode(&4u32, encoder)?;
                            bincode::Encode::encode(add, encoder)?;
                            bincode::Encode::encode(range_radius, encoder)?;
                        }
                        Self::NearbyMonsterSpeedMul { mul, range_radius } => {
                            bincode::Encode::encode(&5u32, encoder)?;
                            bincode::Encode::encode(mul, encoder)?;
                            bincode::Encode::encode(range_radius, encoder)?;
                        }
                        Self::MoneyIncomeAdd { add } => {
                            bincode::Encode::encode(&6u32, encoder)?;
                            bincode::Encode::encode(add, encoder)?;
                        }
                        Self::TopCardBonus { rank, bonus_damage } => {
                            bincode::Encode::encode(&7u32, encoder)?;
                            bincode::Encode::encode(rank, encoder)?;
                            bincode::Encode::encode(bonus_damage, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for TowerSkillKind {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => {
                            Ok(Self::NearbyTowerDamageMul {
                                mul: bincode::Decode::decode(decoder)?,
                                range_radius: bincode::Decode::decode(decoder)?,
                            })
                        }
                        1u32 => {
                            Ok(Self::NearbyTowerDamageAdd {
                                add: bincode::Decode::decode(decoder)?,
                                range_radius: bincode::Decode::decode(decoder)?,
                            })
                        }
                        2u32 => {
                            Ok(Self::NearbyTowerAttackSpeedAdd {
                                add: bincode::Decode::decode(decoder)?,
                                range_radius: bincode::Decode::decode(decoder)?,
                            })
                        }
                        3u32 => {
                            Ok(Self::NearbyTowerAttackSpeedMul {
                                mul: bincode::Decode::decode(decoder)?,
                                range_radius: bincode::Decode::decode(decoder)?,
                            })
                        }
                        4u32 => {
                            Ok(Self::NearbyTowerAttackRangeAdd {
                                add: bincode::Decode::decode(decoder)?,
                                range_radius: bincode::Decode::decode(decoder)?,
                            })
                        }
                        5u32 => {
                            Ok(Self::NearbyMonsterSpeedMul {
                                mul: bincode::Decode::decode(decoder)?,
                                range_radius: bincode::Decode::decode(decoder)?,
                            })
                        }
                        6u32 => {
                            Ok(Self::MoneyIncomeAdd {
                                add: bincode::Decode::decode(decoder)?,
                            })
                        }
                        7u32 => {
                            Ok(Self::TopCardBonus {
                                rank: bincode::Decode::decode(decoder)?,
                                bonus_damage: bincode::Decode::decode(decoder)?,
                            })
                        }
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 7u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for TowerSkillKind {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::NearbyTowerDamageMul { mul, range_radius } => {
                            buf.write_string("NearbyTowerDamageMul");
                            buf.write_string("mul");
                            mul.serialize_without_name(buf);
                            buf.write_string("range_radius");
                            range_radius.serialize_without_name(buf);
                        }
                        Self::NearbyTowerDamageAdd { add, range_radius } => {
                            buf.write_string("NearbyTowerDamageAdd");
                            buf.write_string("add");
                            add.serialize_without_name(buf);
                            buf.write_string("range_radius");
                            range_radius.serialize_without_name(buf);
                        }
                        Self::NearbyTowerAttackSpeedAdd { add, range_radius } => {
                            buf.write_string("NearbyTowerAttackSpeedAdd");
                            buf.write_string("add");
                            add.serialize_without_name(buf);
                            buf.write_string("range_radius");
                            range_radius.serialize_without_name(buf);
                        }
                        Self::NearbyTowerAttackSpeedMul { mul, range_radius } => {
                            buf.write_string("NearbyTowerAttackSpeedMul");
                            buf.write_string("mul");
                            mul.serialize_without_name(buf);
                            buf.write_string("range_radius");
                            range_radius.serialize_without_name(buf);
                        }
                        Self::NearbyTowerAttackRangeAdd { add, range_radius } => {
                            buf.write_string("NearbyTowerAttackRangeAdd");
                            buf.write_string("add");
                            add.serialize_without_name(buf);
                            buf.write_string("range_radius");
                            range_radius.serialize_without_name(buf);
                        }
                        Self::NearbyMonsterSpeedMul { mul, range_radius } => {
                            buf.write_string("NearbyMonsterSpeedMul");
                            buf.write_string("mul");
                            mul.serialize_without_name(buf);
                            buf.write_string("range_radius");
                            range_radius.serialize_without_name(buf);
                        }
                        Self::MoneyIncomeAdd { add } => {
                            buf.write_string("MoneyIncomeAdd");
                            buf.write_string("add");
                            add.serialize_without_name(buf);
                        }
                        Self::TopCardBonus { rank, bonus_damage } => {
                            buf.write_string("TopCardBonus");
                            buf.write_string("rank");
                            rank.serialize_without_name(buf);
                            buf.write_string("bonus_damage");
                            bonus_damage.serialize_without_name(buf);
                        }
                    }
                }
            }
            impl Deserialize for TowerSkillKind {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "NearbyTowerDamageMul" => {
                            let field_name = buf.read_name("mul")?;
                            let mul = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("range_radius")?;
                            let range_radius = Deserialize::deserialize_without_name(
                                buf,
                            )?;
                            Ok(Self::NearbyTowerDamageMul {
                                mul,
                                range_radius,
                            })
                        }
                        "NearbyTowerDamageAdd" => {
                            let field_name = buf.read_name("add")?;
                            let add = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("range_radius")?;
                            let range_radius = Deserialize::deserialize_without_name(
                                buf,
                            )?;
                            Ok(Self::NearbyTowerDamageAdd {
                                add,
                                range_radius,
                            })
                        }
                        "NearbyTowerAttackSpeedAdd" => {
                            let field_name = buf.read_name("add")?;
                            let add = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("range_radius")?;
                            let range_radius = Deserialize::deserialize_without_name(
                                buf,
                            )?;
                            Ok(Self::NearbyTowerAttackSpeedAdd {
                                add,
                                range_radius,
                            })
                        }
                        "NearbyTowerAttackSpeedMul" => {
                            let field_name = buf.read_name("mul")?;
                            let mul = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("range_radius")?;
                            let range_radius = Deserialize::deserialize_without_name(
                                buf,
                            )?;
                            Ok(Self::NearbyTowerAttackSpeedMul {
                                mul,
                                range_radius,
                            })
                        }
                        "NearbyTowerAttackRangeAdd" => {
                            let field_name = buf.read_name("add")?;
                            let add = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("range_radius")?;
                            let range_radius = Deserialize::deserialize_without_name(
                                buf,
                            )?;
                            Ok(Self::NearbyTowerAttackRangeAdd {
                                add,
                                range_radius,
                            })
                        }
                        "NearbyMonsterSpeedMul" => {
                            let field_name = buf.read_name("mul")?;
                            let mul = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("range_radius")?;
                            let range_radius = Deserialize::deserialize_without_name(
                                buf,
                            )?;
                            Ok(Self::NearbyMonsterSpeedMul {
                                mul,
                                range_radius,
                            })
                        }
                        "MoneyIncomeAdd" => {
                            let field_name = buf.read_name("add")?;
                            let add = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::MoneyIncomeAdd { add })
                        }
                        "TopCardBonus" => {
                            let field_name = buf.read_name("rank")?;
                            let rank = Deserialize::deserialize_without_name(buf)?;
                            let field_name = buf.read_name("bonus_damage")?;
                            let bonus_damage = Deserialize::deserialize_without_name(
                                buf,
                            )?;
                            Ok(Self::TopCardBonus {
                                rank,
                                bonus_damage,
                            })
                        }
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            pub struct TowerStatusEffect {
                pub kind: TowerStatusEffectKind,
                pub end_at: TowerStatusEffectEnd,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for TowerStatusEffect {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "TowerStatusEffect",
                        "kind",
                        &self.kind,
                        "end_at",
                        &&self.end_at,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TowerStatusEffect {
                #[inline]
                fn clone(&self) -> TowerStatusEffect {
                    TowerStatusEffect {
                        kind: ::core::clone::Clone::clone(&self.kind),
                        end_at: ::core::clone::Clone::clone(&self.end_at),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TowerStatusEffect {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TowerStatusEffect {
                #[inline]
                fn eq(&self, other: &TowerStatusEffect) -> bool {
                    self.kind == other.kind && self.end_at == other.end_at
                }
            }
            impl bincode::Encode for TowerStatusEffect {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    bincode::Encode::encode(&self.kind, encoder)?;
                    bincode::Encode::encode(&self.end_at, encoder)?;
                    Ok(())
                }
            }
            impl bincode::Decode<()> for TowerStatusEffect {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    Ok(Self {
                        kind: bincode::Decode::decode(decoder)?,
                        end_at: bincode::Decode::decode(decoder)?,
                    })
                }
            }
            impl Serialize for TowerStatusEffect {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    buf.write_string("kind");
                    self.kind.serialize_without_name(buf);
                    buf.write_string("end_at");
                    self.end_at.serialize_without_name(buf);
                }
            }
            impl Deserialize for TowerStatusEffect {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let field_name = buf.read_name("kind")?;
                    let kind = Deserialize::deserialize_without_name(buf)?;
                    let field_name = buf.read_name("end_at")?;
                    let end_at = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self { kind, end_at })
                }
            }
            pub enum TowerStatusEffectKind {
                DamageMul { mul: f32 },
                DamageAdd { add: f32 },
                AttackSpeedMul { mul: f32 },
                AttackSpeedAdd { add: f32 },
                AttackRangeAdd { add: f32 },
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TowerStatusEffectKind {
                #[inline]
                fn clone(&self) -> TowerStatusEffectKind {
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for TowerStatusEffectKind {}
            #[automatically_derived]
            impl ::core::fmt::Debug for TowerStatusEffectKind {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        TowerStatusEffectKind::DamageMul { mul: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "DamageMul",
                                "mul",
                                &__self_0,
                            )
                        }
                        TowerStatusEffectKind::DamageAdd { add: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "DamageAdd",
                                "add",
                                &__self_0,
                            )
                        }
                        TowerStatusEffectKind::AttackSpeedMul { mul: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "AttackSpeedMul",
                                "mul",
                                &__self_0,
                            )
                        }
                        TowerStatusEffectKind::AttackSpeedAdd { add: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "AttackSpeedAdd",
                                "add",
                                &__self_0,
                            )
                        }
                        TowerStatusEffectKind::AttackRangeAdd { add: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "AttackRangeAdd",
                                "add",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TowerStatusEffectKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TowerStatusEffectKind {
                #[inline]
                fn eq(&self, other: &TowerStatusEffectKind) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                        && match (self, other) {
                            (
                                TowerStatusEffectKind::DamageMul { mul: __self_0 },
                                TowerStatusEffectKind::DamageMul { mul: __arg1_0 },
                            ) => __self_0 == __arg1_0,
                            (
                                TowerStatusEffectKind::DamageAdd { add: __self_0 },
                                TowerStatusEffectKind::DamageAdd { add: __arg1_0 },
                            ) => __self_0 == __arg1_0,
                            (
                                TowerStatusEffectKind::AttackSpeedMul { mul: __self_0 },
                                TowerStatusEffectKind::AttackSpeedMul { mul: __arg1_0 },
                            ) => __self_0 == __arg1_0,
                            (
                                TowerStatusEffectKind::AttackSpeedAdd { add: __self_0 },
                                TowerStatusEffectKind::AttackSpeedAdd { add: __arg1_0 },
                            ) => __self_0 == __arg1_0,
                            (
                                TowerStatusEffectKind::AttackRangeAdd { add: __self_0 },
                                TowerStatusEffectKind::AttackRangeAdd { add: __arg1_0 },
                            ) => __self_0 == __arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            impl bincode::Encode for TowerStatusEffectKind {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::DamageMul { mul } => {
                            bincode::Encode::encode(&0u32, encoder)?;
                            bincode::Encode::encode(mul, encoder)?;
                        }
                        Self::DamageAdd { add } => {
                            bincode::Encode::encode(&1u32, encoder)?;
                            bincode::Encode::encode(add, encoder)?;
                        }
                        Self::AttackSpeedMul { mul } => {
                            bincode::Encode::encode(&2u32, encoder)?;
                            bincode::Encode::encode(mul, encoder)?;
                        }
                        Self::AttackSpeedAdd { add } => {
                            bincode::Encode::encode(&3u32, encoder)?;
                            bincode::Encode::encode(add, encoder)?;
                        }
                        Self::AttackRangeAdd { add } => {
                            bincode::Encode::encode(&4u32, encoder)?;
                            bincode::Encode::encode(add, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for TowerStatusEffectKind {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => {
                            Ok(Self::DamageMul {
                                mul: bincode::Decode::decode(decoder)?,
                            })
                        }
                        1u32 => {
                            Ok(Self::DamageAdd {
                                add: bincode::Decode::decode(decoder)?,
                            })
                        }
                        2u32 => {
                            Ok(Self::AttackSpeedMul {
                                mul: bincode::Decode::decode(decoder)?,
                            })
                        }
                        3u32 => {
                            Ok(Self::AttackSpeedAdd {
                                add: bincode::Decode::decode(decoder)?,
                            })
                        }
                        4u32 => {
                            Ok(Self::AttackRangeAdd {
                                add: bincode::Decode::decode(decoder)?,
                            })
                        }
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 4u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for TowerStatusEffectKind {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::DamageMul { mul } => {
                            buf.write_string("DamageMul");
                            buf.write_string("mul");
                            mul.serialize_without_name(buf);
                        }
                        Self::DamageAdd { add } => {
                            buf.write_string("DamageAdd");
                            buf.write_string("add");
                            add.serialize_without_name(buf);
                        }
                        Self::AttackSpeedMul { mul } => {
                            buf.write_string("AttackSpeedMul");
                            buf.write_string("mul");
                            mul.serialize_without_name(buf);
                        }
                        Self::AttackSpeedAdd { add } => {
                            buf.write_string("AttackSpeedAdd");
                            buf.write_string("add");
                            add.serialize_without_name(buf);
                        }
                        Self::AttackRangeAdd { add } => {
                            buf.write_string("AttackRangeAdd");
                            buf.write_string("add");
                            add.serialize_without_name(buf);
                        }
                    }
                }
            }
            impl Deserialize for TowerStatusEffectKind {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "DamageMul" => {
                            let field_name = buf.read_name("mul")?;
                            let mul = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::DamageMul { mul })
                        }
                        "DamageAdd" => {
                            let field_name = buf.read_name("add")?;
                            let add = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::DamageAdd { add })
                        }
                        "AttackSpeedMul" => {
                            let field_name = buf.read_name("mul")?;
                            let mul = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::AttackSpeedMul { mul })
                        }
                        "AttackSpeedAdd" => {
                            let field_name = buf.read_name("add")?;
                            let add = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::AttackSpeedAdd { add })
                        }
                        "AttackRangeAdd" => {
                            let field_name = buf.read_name("add")?;
                            let add = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::AttackRangeAdd { add })
                        }
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            pub enum TowerStatusEffectEnd {
                Time { end_at: Instant },
                NeverEnd,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for TowerStatusEffectEnd {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        TowerStatusEffectEnd::Time { end_at: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "Time",
                                "end_at",
                                &__self_0,
                            )
                        }
                        TowerStatusEffectEnd::NeverEnd => {
                            ::core::fmt::Formatter::write_str(f, "NeverEnd")
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TowerStatusEffectEnd {
                #[inline]
                fn clone(&self) -> TowerStatusEffectEnd {
                    match self {
                        TowerStatusEffectEnd::Time { end_at: __self_0 } => {
                            TowerStatusEffectEnd::Time {
                                end_at: ::core::clone::Clone::clone(__self_0),
                            }
                        }
                        TowerStatusEffectEnd::NeverEnd => TowerStatusEffectEnd::NeverEnd,
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TowerStatusEffectEnd {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TowerStatusEffectEnd {
                #[inline]
                fn eq(&self, other: &TowerStatusEffectEnd) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                        && match (self, other) {
                            (
                                TowerStatusEffectEnd::Time { end_at: __self_0 },
                                TowerStatusEffectEnd::Time { end_at: __arg1_0 },
                            ) => __self_0 == __arg1_0,
                            _ => true,
                        }
                }
            }
            impl bincode::Encode for TowerStatusEffectEnd {
                fn encode<__E: bincode::enc::Encoder>(
                    &self,
                    encoder: &mut __E,
                ) -> core::result::Result<(), bincode::error::EncodeError> {
                    match self {
                        Self::Time { end_at } => {
                            bincode::Encode::encode(&0u32, encoder)?;
                            bincode::Encode::encode(end_at, encoder)?;
                        }
                        Self::NeverEnd => {
                            bincode::Encode::encode(&1u32, encoder)?;
                        }
                    }
                    Ok(())
                }
            }
            impl bincode::Decode<()> for TowerStatusEffectEnd {
                fn decode<__D: bincode::de::Decoder<Context = ()>>(
                    decoder: &mut __D,
                ) -> core::result::Result<Self, bincode::error::DecodeError> {
                    let discriminant: u32 = bincode::Decode::decode(decoder)?;
                    match discriminant {
                        0u32 => {
                            Ok(Self::Time {
                                end_at: bincode::Decode::decode(decoder)?,
                            })
                        }
                        1u32 => Ok(Self::NeverEnd),
                        _ => {
                            Err(bincode::error::DecodeError::UnexpectedVariant {
                                type_name: core::any::type_name::<Self>(),
                                allowed: &bincode::error::AllowedEnumVariants::Range {
                                    min: 0,
                                    max: 1u32,
                                },
                                found: discriminant,
                            })
                        }
                    }
                }
            }
            impl Serialize for TowerStatusEffectEnd {
                fn serialize(&self, buf: &mut Vec<u8>) {
                    buf.write_string(std::any::type_name::<Self>());
                    self.serialize_without_name(buf);
                }
                fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                    match self {
                        Self::Time { end_at } => {
                            buf.write_string("Time");
                            buf.write_string("end_at");
                            end_at.serialize_without_name(buf);
                        }
                        Self::NeverEnd => {
                            buf.write_string("NeverEnd");
                        }
                    }
                }
            }
            impl Deserialize for TowerStatusEffectEnd {
                fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                    buf.read_name(std::any::type_name::<Self>())?;
                    Self::deserialize_without_name(buf)
                }
                fn deserialize_without_name(
                    buf: &mut &[u8],
                ) -> Result<Self, DeserializeError> {
                    let variant_name = buf.read_string();
                    match variant_name.as_ref() {
                        "Time" => {
                            let field_name = buf.read_name("end_at")?;
                            let end_at = Deserialize::deserialize_without_name(buf)?;
                            Ok(Self::Time { end_at })
                        }
                        "NeverEnd" => Ok(Self::NeverEnd),
                        _ => {
                            Err(DeserializeError::InvalidEnumVariant {
                                expected: std::any::type_name::<Self>().to_string(),
                                actual: variant_name,
                            })
                        }
                    }
                }
            }
            pub fn remove_tower_finished_status_effects(
                game_state: &mut GameState,
                now: Instant,
            ) {
                for tower in game_state.towers.iter_mut() {
                    tower
                        .status_effects
                        .retain(|e| match e.end_at {
                            TowerStatusEffectEnd::Time { end_at } => now < end_at,
                            TowerStatusEffectEnd::NeverEnd => true,
                        });
                }
            }
            pub fn activate_tower_skills(game_state: &mut GameState, now: Instant) {
                let mut activated_skills = ::alloc::vec::Vec::new();
                for tower in game_state.towers.iter_mut() {
                    for skill in tower.skills.iter_mut() {
                        if now < skill.last_used_at + skill.cooldown {
                            continue;
                        }
                        skill.last_used_at = now;
                        activated_skills.push((tower.id, skill.template));
                    }
                }
                for (tower_id, skill) in activated_skills {
                    let caster_xy = game_state
                        .towers
                        .iter()
                        .find(|m| m.id == tower_id)
                        .unwrap()
                        .center_xy_f32();
                    let mut on_nearby_towers = |
                        range_radius: f32,
                        effect: TowerStatusEffect|
                    {
                        for tower in game_state.towers.iter_mut() {
                            if caster_xy.distance(tower.center_xy_f32()) <= range_radius
                            {
                                tower.status_effects.push(effect.clone());
                            }
                        }
                    };
                    let mut on_nearby_monsters = |
                        range_radius: f32,
                        effect: MonsterStatusEffect|
                    {
                        for monster in game_state.monsters.iter_mut() {
                            if caster_xy.distance(monster.xy()) <= range_radius {
                                monster.status_effects.push(effect.clone());
                            }
                        }
                    };
                    match skill.kind {
                        TowerSkillKind::NearbyTowerDamageMul { mul, range_radius } => {
                            on_nearby_towers(
                                range_radius,
                                TowerStatusEffect {
                                    kind: TowerStatusEffectKind::DamageMul {
                                        mul,
                                    },
                                    end_at: TowerStatusEffectEnd::Time {
                                        end_at: now + skill.duration,
                                    },
                                },
                            );
                        }
                        TowerSkillKind::NearbyTowerDamageAdd { add, range_radius } => {
                            on_nearby_towers(
                                range_radius,
                                TowerStatusEffect {
                                    kind: TowerStatusEffectKind::DamageAdd {
                                        add,
                                    },
                                    end_at: TowerStatusEffectEnd::Time {
                                        end_at: now + skill.duration,
                                    },
                                },
                            );
                        }
                        TowerSkillKind::NearbyTowerAttackSpeedAdd {
                            add,
                            range_radius,
                        } => {
                            on_nearby_towers(
                                range_radius,
                                TowerStatusEffect {
                                    kind: TowerStatusEffectKind::AttackSpeedAdd {
                                        add,
                                    },
                                    end_at: TowerStatusEffectEnd::Time {
                                        end_at: now + skill.duration,
                                    },
                                },
                            );
                        }
                        TowerSkillKind::NearbyTowerAttackSpeedMul {
                            mul,
                            range_radius,
                        } => {
                            on_nearby_towers(
                                range_radius,
                                TowerStatusEffect {
                                    kind: TowerStatusEffectKind::AttackSpeedMul {
                                        mul,
                                    },
                                    end_at: TowerStatusEffectEnd::Time {
                                        end_at: now + skill.duration,
                                    },
                                },
                            );
                        }
                        TowerSkillKind::NearbyTowerAttackRangeAdd {
                            add,
                            range_radius,
                        } => {
                            on_nearby_towers(
                                range_radius,
                                TowerStatusEffect {
                                    kind: TowerStatusEffectKind::AttackRangeAdd {
                                        add,
                                    },
                                    end_at: TowerStatusEffectEnd::Time {
                                        end_at: now + skill.duration,
                                    },
                                },
                            );
                        }
                        TowerSkillKind::NearbyMonsterSpeedMul { mul, range_radius } => {
                            on_nearby_monsters(
                                range_radius,
                                MonsterStatusEffect {
                                    kind: MonsterStatusEffectKind::SpeedMul {
                                        mul,
                                    },
                                    end_at: now + skill.duration,
                                },
                            );
                        }
                        TowerSkillKind::MoneyIncomeAdd { .. } => {}
                        TowerSkillKind::TopCardBonus { .. } => {}
                    }
                }
            }
        }
        use super::{upgrade::TowerUpgradeState, *};
        use crate::card::{Rank, Suit};
        use crate::l10n::tower::TowerKindText;
        use namui::*;
        use render::Animation;
        pub use render::{AnimationKind, tower_animation_tick};
        pub use skill::*;
        use std::{ops::Deref, sync::atomic::{AtomicUsize, Ordering}};
        pub struct Tower {
            id: usize,
            pub left_top: MapCoord,
            cooldown: Duration,
            template: TowerTemplate,
            pub status_effects: Vec<TowerStatusEffect>,
            pub skills: Vec<TowerSkill>,
            pub(self) animation: Animation,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Tower {
            #[inline]
            fn clone(&self) -> Tower {
                Tower {
                    id: ::core::clone::Clone::clone(&self.id),
                    left_top: ::core::clone::Clone::clone(&self.left_top),
                    cooldown: ::core::clone::Clone::clone(&self.cooldown),
                    template: ::core::clone::Clone::clone(&self.template),
                    status_effects: ::core::clone::Clone::clone(&self.status_effects),
                    skills: ::core::clone::Clone::clone(&self.skills),
                    animation: ::core::clone::Clone::clone(&self.animation),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Tower {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Tower {
            #[inline]
            fn eq(&self, other: &Tower) -> bool {
                self.id == other.id && self.left_top == other.left_top
                    && self.cooldown == other.cooldown && self.template == other.template
                    && self.status_effects == other.status_effects
                    && self.skills == other.skills && self.animation == other.animation
            }
        }
        impl bincode::Encode for Tower {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.id, encoder)?;
                bincode::Encode::encode(&self.left_top, encoder)?;
                bincode::Encode::encode(&self.cooldown, encoder)?;
                bincode::Encode::encode(&self.template, encoder)?;
                bincode::Encode::encode(&self.status_effects, encoder)?;
                bincode::Encode::encode(&self.skills, encoder)?;
                bincode::Encode::encode(&self.animation, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Tower {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    id: bincode::Decode::decode(decoder)?,
                    left_top: bincode::Decode::decode(decoder)?,
                    cooldown: bincode::Decode::decode(decoder)?,
                    template: bincode::Decode::decode(decoder)?,
                    status_effects: bincode::Decode::decode(decoder)?,
                    skills: bincode::Decode::decode(decoder)?,
                    animation: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Tower {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("id");
                self.id.serialize_without_name(buf);
                buf.write_string("left_top");
                self.left_top.serialize_without_name(buf);
                buf.write_string("cooldown");
                self.cooldown.serialize_without_name(buf);
                buf.write_string("template");
                self.template.serialize_without_name(buf);
                buf.write_string("status_effects");
                self.status_effects.serialize_without_name(buf);
                buf.write_string("skills");
                self.skills.serialize_without_name(buf);
                buf.write_string("animation");
                self.animation.serialize_without_name(buf);
            }
        }
        impl Deserialize for Tower {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("id")?;
                let id = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("left_top")?;
                let left_top = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("cooldown")?;
                let cooldown = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("template")?;
                let template = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("status_effects")?;
                let status_effects = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("skills")?;
                let skills = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("animation")?;
                let animation = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    id,
                    left_top,
                    cooldown,
                    template,
                    status_effects,
                    skills,
                    animation,
                })
            }
        }
        impl Tower {
            pub fn new(
                template: &TowerTemplate,
                left_top: MapCoord,
                now: Instant,
            ) -> Self {
                static ID: AtomicUsize = AtomicUsize::new(0);
                Self {
                    id: ID.fetch_add(1, Ordering::Relaxed),
                    left_top,
                    cooldown: Duration::from_secs(0),
                    template: template.clone(),
                    status_effects: ::alloc::vec::Vec::new(),
                    skills: ::alloc::vec::Vec::new(),
                    animation: Animation::new(now),
                }
            }
            pub fn in_cooltime(&self) -> bool {
                self.cooldown > Duration::from_secs(0)
            }
            pub fn shoot(
                &mut self,
                target_indicator: ProjectileTargetIndicator,
                tower_upgrade_states: &[TowerUpgradeState],
                contract_multiplier: f32,
                now: Instant,
            ) -> Projectile {
                self.cooldown = self.shoot_interval;
                self.animation.transition(AnimationKind::Attack, now);
                Projectile {
                    kind: self.projectile_kind,
                    xy: self.left_top.map(|t| t as f32 + 0.5),
                    velocity: self.projectile_speed,
                    target_indicator,
                    damage: self
                        .calculate_projectile_damage(
                            tower_upgrade_states,
                            contract_multiplier,
                        ),
                }
            }
            fn center_xy(&self) -> MapCoord {
                self.left_top + MapCoord::new(1, 1)
            }
            pub fn center_xy_f32(&self) -> MapCoordF32 {
                self.center_xy().map(|t| t as f32)
            }
            pub fn id(&self) -> usize {
                self.id
            }
            pub fn rank(&self) -> Rank {
                self.template.rank
            }
            pub fn suit(&self) -> Suit {
                self.template.suit
            }
            pub fn calculate_projectile_damage(
                &self,
                tower_upgrade_states: &[TowerUpgradeState],
                contract_multiplier: f32,
            ) -> f32 {
                let mut damage = self.default_damage;
                self.status_effects
                    .iter()
                    .for_each(|status_effect| {
                        if let TowerStatusEffectKind::DamageAdd { add } = status_effect
                            .kind
                        {
                            damage += add;
                        }
                    });
                tower_upgrade_states
                    .iter()
                    .for_each(|tower_upgrade_state| {
                        damage += tower_upgrade_state.damage_plus;
                    });
                if damage < 0.0 {
                    return 0.0;
                }
                self.status_effects
                    .iter()
                    .for_each(|status_effect| {
                        if let TowerStatusEffectKind::DamageMul { mul } = status_effect
                            .kind
                        {
                            damage *= mul;
                        }
                    });
                tower_upgrade_states
                    .iter()
                    .for_each(|tower_upgrade_state| {
                        damage *= tower_upgrade_state.damage_multiplier;
                    });
                damage *= contract_multiplier;
                damage
            }
            pub(crate) fn attack_range_radius(
                &self,
                tower_upgrade_states: &[TowerUpgradeState],
                contract_range_multiplier: f32,
            ) -> f32 {
                if self.kind == TowerKind::Barricade {
                    return 0.0;
                }
                let base_range = self
                    .status_effects
                    .iter()
                    .fold(
                        self.default_attack_range_radius,
                        |attack_range_radius, status_effect| {
                            if let TowerStatusEffectKind::AttackRangeAdd { add } = status_effect
                                .kind
                            {
                                attack_range_radius + add
                            } else {
                                attack_range_radius
                            }
                        },
                    )
                    + tower_upgrade_states
                        .iter()
                        .fold(
                            0.0,
                            |r, tower_upgrade_state| {
                                r + tower_upgrade_state.range_plus
                            },
                        );
                base_range * contract_range_multiplier
            }
        }
        impl Deref for Tower {
            type Target = TowerTemplate;
            fn deref(&self) -> &Self::Target {
                &self.template
            }
        }
        pub struct TowerTemplate {
            pub kind: TowerKind,
            pub shoot_interval: Duration,
            pub default_attack_range_radius: f32,
            pub projectile_kind: ProjectileKind,
            pub projectile_speed: Velocity,
            pub default_damage: f32,
            pub suit: Suit,
            pub rank: Rank,
            pub skill_templates: Vec<TowerSkillTemplate>,
            pub default_status_effects: Vec<TowerStatusEffect>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TowerTemplate {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "kind",
                    "shoot_interval",
                    "default_attack_range_radius",
                    "projectile_kind",
                    "projectile_speed",
                    "default_damage",
                    "suit",
                    "rank",
                    "skill_templates",
                    "default_status_effects",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.kind,
                    &self.shoot_interval,
                    &self.default_attack_range_radius,
                    &self.projectile_kind,
                    &self.projectile_speed,
                    &self.default_damage,
                    &self.suit,
                    &self.rank,
                    &self.skill_templates,
                    &&self.default_status_effects,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "TowerTemplate",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TowerTemplate {
            #[inline]
            fn clone(&self) -> TowerTemplate {
                TowerTemplate {
                    kind: ::core::clone::Clone::clone(&self.kind),
                    shoot_interval: ::core::clone::Clone::clone(&self.shoot_interval),
                    default_attack_range_radius: ::core::clone::Clone::clone(
                        &self.default_attack_range_radius,
                    ),
                    projectile_kind: ::core::clone::Clone::clone(&self.projectile_kind),
                    projectile_speed: ::core::clone::Clone::clone(
                        &self.projectile_speed,
                    ),
                    default_damage: ::core::clone::Clone::clone(&self.default_damage),
                    suit: ::core::clone::Clone::clone(&self.suit),
                    rank: ::core::clone::Clone::clone(&self.rank),
                    skill_templates: ::core::clone::Clone::clone(&self.skill_templates),
                    default_status_effects: ::core::clone::Clone::clone(
                        &self.default_status_effects,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TowerTemplate {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TowerTemplate {
            #[inline]
            fn eq(&self, other: &TowerTemplate) -> bool {
                self.default_attack_range_radius == other.default_attack_range_radius
                    && self.default_damage == other.default_damage
                    && self.kind == other.kind
                    && self.shoot_interval == other.shoot_interval
                    && self.projectile_kind == other.projectile_kind
                    && self.projectile_speed == other.projectile_speed
                    && self.suit == other.suit && self.rank == other.rank
                    && self.skill_templates == other.skill_templates
                    && self.default_status_effects == other.default_status_effects
            }
        }
        impl bincode::Encode for TowerTemplate {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.kind, encoder)?;
                bincode::Encode::encode(&self.shoot_interval, encoder)?;
                bincode::Encode::encode(&self.default_attack_range_radius, encoder)?;
                bincode::Encode::encode(&self.projectile_kind, encoder)?;
                bincode::Encode::encode(&self.projectile_speed, encoder)?;
                bincode::Encode::encode(&self.default_damage, encoder)?;
                bincode::Encode::encode(&self.suit, encoder)?;
                bincode::Encode::encode(&self.rank, encoder)?;
                bincode::Encode::encode(&self.skill_templates, encoder)?;
                bincode::Encode::encode(&self.default_status_effects, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for TowerTemplate {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    kind: bincode::Decode::decode(decoder)?,
                    shoot_interval: bincode::Decode::decode(decoder)?,
                    default_attack_range_radius: bincode::Decode::decode(decoder)?,
                    projectile_kind: bincode::Decode::decode(decoder)?,
                    projectile_speed: bincode::Decode::decode(decoder)?,
                    default_damage: bincode::Decode::decode(decoder)?,
                    suit: bincode::Decode::decode(decoder)?,
                    rank: bincode::Decode::decode(decoder)?,
                    skill_templates: bincode::Decode::decode(decoder)?,
                    default_status_effects: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for TowerTemplate {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("kind");
                self.kind.serialize_without_name(buf);
                buf.write_string("shoot_interval");
                self.shoot_interval.serialize_without_name(buf);
                buf.write_string("default_attack_range_radius");
                self.default_attack_range_radius.serialize_without_name(buf);
                buf.write_string("projectile_kind");
                self.projectile_kind.serialize_without_name(buf);
                buf.write_string("projectile_speed");
                self.projectile_speed.serialize_without_name(buf);
                buf.write_string("default_damage");
                self.default_damage.serialize_without_name(buf);
                buf.write_string("suit");
                self.suit.serialize_without_name(buf);
                buf.write_string("rank");
                self.rank.serialize_without_name(buf);
                buf.write_string("skill_templates");
                self.skill_templates.serialize_without_name(buf);
                buf.write_string("default_status_effects");
                self.default_status_effects.serialize_without_name(buf);
            }
        }
        impl Deserialize for TowerTemplate {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("kind")?;
                let kind = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("shoot_interval")?;
                let shoot_interval = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("default_attack_range_radius")?;
                let default_attack_range_radius = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("projectile_kind")?;
                let projectile_kind = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("projectile_speed")?;
                let projectile_speed = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("default_damage")?;
                let default_damage = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("suit")?;
                let suit = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("rank")?;
                let rank = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("skill_templates")?;
                let skill_templates = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("default_status_effects")?;
                let default_status_effects = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    kind,
                    shoot_interval,
                    default_attack_range_radius,
                    projectile_kind,
                    projectile_speed,
                    default_damage,
                    suit,
                    rank,
                    skill_templates,
                    default_status_effects,
                })
            }
        }
        impl TowerTemplate {
            pub fn new(kind: TowerKind, suit: Suit, rank: Rank) -> Self {
                Self {
                    kind,
                    shoot_interval: kind.shoot_interval(),
                    default_attack_range_radius: kind.default_attack_range_radius(),
                    projectile_kind: ProjectileKind::Ball,
                    projectile_speed: Per::new(48.0, 1.sec()),
                    default_damage: kind.default_damage() as f32,
                    suit,
                    rank,
                    skill_templates: kind.skill_templates(),
                    default_status_effects: ::alloc::vec::Vec::new(),
                }
            }
            pub fn barricade() -> Self {
                Self::new(TowerKind::Barricade, Suit::Spades, Rank::Ace)
            }
        }
        impl PartialOrd for TowerTemplate {
            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                Some(
                    self
                        .kind
                        .cmp(&other.kind)
                        .then_with(|| self.suit.cmp(&other.suit))
                        .then_with(|| self.rank.cmp(&other.rank)),
                )
            }
        }
        pub enum TowerKind {
            Barricade,
            High,
            OnePair,
            TwoPair,
            ThreeOfAKind,
            Straight,
            Flush,
            FullHouse,
            FourOfAKind,
            StraightFlush,
            RoyalFlush,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TowerKind {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TowerKind::Barricade => "Barricade",
                        TowerKind::High => "High",
                        TowerKind::OnePair => "OnePair",
                        TowerKind::TwoPair => "TwoPair",
                        TowerKind::ThreeOfAKind => "ThreeOfAKind",
                        TowerKind::Straight => "Straight",
                        TowerKind::Flush => "Flush",
                        TowerKind::FullHouse => "FullHouse",
                        TowerKind::FourOfAKind => "FourOfAKind",
                        TowerKind::StraightFlush => "StraightFlush",
                        TowerKind::RoyalFlush => "RoyalFlush",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TowerKind {
            #[inline]
            fn clone(&self) -> TowerKind {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TowerKind {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TowerKind {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TowerKind {
            #[inline]
            fn eq(&self, other: &TowerKind) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TowerKind {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for TowerKind {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TowerKind,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for TowerKind {
            #[inline]
            fn cmp(&self, other: &TowerKind) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TowerKind {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        impl bincode::Encode for TowerKind {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Barricade => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::High => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::OnePair => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::TwoPair => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                    Self::ThreeOfAKind => {
                        bincode::Encode::encode(&4u32, encoder)?;
                    }
                    Self::Straight => {
                        bincode::Encode::encode(&5u32, encoder)?;
                    }
                    Self::Flush => {
                        bincode::Encode::encode(&6u32, encoder)?;
                    }
                    Self::FullHouse => {
                        bincode::Encode::encode(&7u32, encoder)?;
                    }
                    Self::FourOfAKind => {
                        bincode::Encode::encode(&8u32, encoder)?;
                    }
                    Self::StraightFlush => {
                        bincode::Encode::encode(&9u32, encoder)?;
                    }
                    Self::RoyalFlush => {
                        bincode::Encode::encode(&10u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for TowerKind {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Barricade),
                    1u32 => Ok(Self::High),
                    2u32 => Ok(Self::OnePair),
                    3u32 => Ok(Self::TwoPair),
                    4u32 => Ok(Self::ThreeOfAKind),
                    5u32 => Ok(Self::Straight),
                    6u32 => Ok(Self::Flush),
                    7u32 => Ok(Self::FullHouse),
                    8u32 => Ok(Self::FourOfAKind),
                    9u32 => Ok(Self::StraightFlush),
                    10u32 => Ok(Self::RoyalFlush),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 10u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for TowerKind {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Barricade => {
                        buf.write_string("Barricade");
                    }
                    Self::High => {
                        buf.write_string("High");
                    }
                    Self::OnePair => {
                        buf.write_string("OnePair");
                    }
                    Self::TwoPair => {
                        buf.write_string("TwoPair");
                    }
                    Self::ThreeOfAKind => {
                        buf.write_string("ThreeOfAKind");
                    }
                    Self::Straight => {
                        buf.write_string("Straight");
                    }
                    Self::Flush => {
                        buf.write_string("Flush");
                    }
                    Self::FullHouse => {
                        buf.write_string("FullHouse");
                    }
                    Self::FourOfAKind => {
                        buf.write_string("FourOfAKind");
                    }
                    Self::StraightFlush => {
                        buf.write_string("StraightFlush");
                    }
                    Self::RoyalFlush => {
                        buf.write_string("RoyalFlush");
                    }
                }
            }
        }
        impl Deserialize for TowerKind {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Barricade" => Ok(Self::Barricade),
                    "High" => Ok(Self::High),
                    "OnePair" => Ok(Self::OnePair),
                    "TwoPair" => Ok(Self::TwoPair),
                    "ThreeOfAKind" => Ok(Self::ThreeOfAKind),
                    "Straight" => Ok(Self::Straight),
                    "Flush" => Ok(Self::Flush),
                    "FullHouse" => Ok(Self::FullHouse),
                    "FourOfAKind" => Ok(Self::FourOfAKind),
                    "StraightFlush" => Ok(Self::StraightFlush),
                    "RoyalFlush" => Ok(Self::RoyalFlush),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl TowerKind {
            pub fn shoot_interval(&self) -> Duration {
                match self {
                    Self::Barricade => 1.sec(),
                    Self::High => 1.sec(),
                    Self::OnePair => 1.sec(),
                    Self::TwoPair => 1.sec(),
                    Self::ThreeOfAKind => 1.sec(),
                    Self::Straight => 1.sec(),
                    Self::Flush => 0.5.sec(),
                    Self::FullHouse => 1.sec(),
                    Self::FourOfAKind => 1.sec(),
                    Self::StraightFlush => 0.5.sec(),
                    Self::RoyalFlush => 0.33.sec(),
                }
            }
            pub fn default_attack_range_radius(&self) -> f32 {
                match self {
                    Self::Barricade => 5.0,
                    Self::High => 8.0,
                    Self::OnePair => 8.0,
                    Self::TwoPair => 10.0,
                    Self::ThreeOfAKind => 10.0,
                    Self::Straight => 12.0,
                    Self::Flush => 13.0,
                    Self::FullHouse => 15.0,
                    Self::FourOfAKind => 15.0,
                    Self::StraightFlush => 18.0,
                    Self::RoyalFlush => 20.0,
                }
            }
            pub fn default_damage(&self) -> usize {
                match self {
                    Self::Barricade => 0,
                    Self::High => 5,
                    Self::OnePair => 25,
                    Self::TwoPair => 50,
                    Self::ThreeOfAKind => 125,
                    Self::Straight => 250,
                    Self::Flush => 375,
                    Self::FullHouse => 1000,
                    Self::FourOfAKind => 1250,
                    Self::StraightFlush => 7500,
                    Self::RoyalFlush => 15000,
                }
            }
            pub fn skill_templates(&self) -> Vec<TowerSkillTemplate> {
                match self {
                    Self::Barricade => ::alloc::vec::Vec::new(),
                    Self::High => ::alloc::vec::Vec::new(),
                    Self::OnePair => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                TowerSkillTemplate::new_passive(TowerSkillKind::MoneyIncomeAdd {
                                    add: 1,
                                }),
                            ]),
                        )
                    }
                    Self::TwoPair => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                TowerSkillTemplate::new_passive(TowerSkillKind::MoneyIncomeAdd {
                                    add: 2,
                                }),
                            ]),
                        )
                    }
                    Self::ThreeOfAKind => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                TowerSkillTemplate::new_passive(TowerSkillKind::NearbyMonsterSpeedMul {
                                    mul: 0.9,
                                    range_radius: 5.0,
                                }),
                            ]),
                        )
                    }
                    Self::Straight => ::alloc::vec::Vec::new(),
                    Self::Flush => ::alloc::vec::Vec::new(),
                    Self::FullHouse => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                TowerSkillTemplate::new_passive(TowerSkillKind::NearbyTowerAttackSpeedMul {
                                    mul: 2.0,
                                    range_radius: 2.0,
                                }),
                            ]),
                        )
                    }
                    Self::FourOfAKind => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                TowerSkillTemplate::new_passive(TowerSkillKind::NearbyMonsterSpeedMul {
                                    mul: 0.75,
                                    range_radius: 4.0,
                                }),
                            ]),
                        )
                    }
                    Self::StraightFlush => ::alloc::vec::Vec::new(),
                    Self::RoyalFlush => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                TowerSkillTemplate::new_passive(TowerSkillKind::NearbyTowerDamageMul {
                                    mul: 2.0,
                                    range_radius: 6.0,
                                }),
                            ]),
                        )
                    }
                }
            }
            pub fn is_low_card_tower(&self) -> bool {
                #[allow(non_exhaustive_omitted_patterns)]
                match self {
                    Self::High | Self::OnePair | Self::ThreeOfAKind => true,
                    _ => false,
                }
            }
            pub fn to_text(self) -> TowerKindText {
                match self {
                    Self::Barricade => TowerKindText::Barricade,
                    Self::High => TowerKindText::High,
                    Self::OnePair => TowerKindText::OnePair,
                    Self::TwoPair => TowerKindText::TwoPair,
                    Self::ThreeOfAKind => TowerKindText::ThreeOfAKind,
                    Self::Straight => TowerKindText::Straight,
                    Self::Flush => TowerKindText::Flush,
                    Self::FullHouse => TowerKindText::FullHouse,
                    Self::FourOfAKind => TowerKindText::FourOfAKind,
                    Self::StraightFlush => TowerKindText::StraightFlush,
                    Self::RoyalFlush => TowerKindText::RoyalFlush,
                }
            }
        }
        pub fn tower_cooldown_tick(game_state: &mut GameState, dt: Duration) {
            let attack_speed_multiplier = game_state
                .stage_modifiers
                .get_attack_speed_multiplier();
            game_state
                .towers
                .iter_mut()
                .for_each(|tower| {
                    if tower.cooldown == Duration::from_secs(0) {
                        return;
                    }
                    let tower_upgrades = game_state.upgrade_state.tower_upgrades(tower);
                    let mut time_multiple = 1.0;
                    tower
                        .status_effects
                        .iter()
                        .for_each(|status_effect| {
                            if let TowerStatusEffectKind::AttackSpeedAdd { add } = status_effect
                                .kind
                            {
                                time_multiple += add;
                            }
                        });
                    tower_upgrades
                        .iter()
                        .for_each(|tower_upgrade_state| {
                            time_multiple += tower_upgrade_state.speed_plus;
                        });
                    if time_multiple == 0.0 {
                        return;
                    }
                    tower
                        .status_effects
                        .iter()
                        .for_each(|status_effect| {
                            if let TowerStatusEffectKind::AttackSpeedMul { mul } = status_effect
                                .kind
                            {
                                time_multiple *= mul;
                            }
                        });
                    tower_upgrades
                        .iter()
                        .for_each(|tower_upgrade_state| {
                            time_multiple *= tower_upgrade_state.speed_multiplier;
                        });
                    time_multiple *= attack_speed_multiplier;
                    let cooldown_sub = dt * time_multiple;
                    if tower.cooldown < cooldown_sub {
                        tower.cooldown = Duration::from_secs(0);
                    } else {
                        tower.cooldown -= cooldown_sub;
                    }
                });
        }
    }
    mod tower_info_popup {
        use super::{Tower, mutate_game_state};
        use crate::flow_ui::TowerPreviewContent;
        use crate::theme::{
            button::{Button, ButtonColor, ButtonVariant},
            palette, typography::{FontSize, TextAlign, paragraph},
        };
        use namui::*;
        use namui_prebuilt::table;
        const BUBBLE_PADDING: Px = px(12.);
        const BUBBLE_WIDTH: Px = px(280.);
        const BUBBLE_HEIGHT: Px = px(200.);
        pub struct TowerInfoPopup<'a> {
            pub tower: &'a Tower,
        }
        impl Component for TowerInfoPopup<'_> {
            fn render(self, ctx: &RenderCtx) {
                let Self { tower } = self;
                ctx.translate((-BUBBLE_WIDTH * 0.5, -BUBBLE_HEIGHT))
                    .compose(|ctx| {
                        ctx.compose(|ctx| {
                            table::padding(
                                BUBBLE_PADDING,
                                |wh, ctx| {
                                    table::vertical([
                                        table::ratio(
                                            1.0,
                                            |wh, ctx| {
                                                ctx.add(TowerPreviewContent {
                                                    wh,
                                                    tower_template: tower,
                                                });
                                            },
                                        ),
                                        table::fixed(
                                            36.px(),
                                            |wh, ctx| {
                                                let tower_id = tower.id();
                                                ctx.add(
                                                    Button::new(
                                                            wh,
                                                            &move || {
                                                                mutate_game_state(move |game_state| {
                                                                    game_state.towers.remove_tower(tower_id);
                                                                });
                                                            },
                                                            &|wh, text_color, ctx| {
                                                                ctx.add(
                                                                    paragraph("철거".to_string())
                                                                        .size(FontSize::Medium)
                                                                        .align(TextAlign::Center { wh })
                                                                        .color(text_color)
                                                                        .max_width(wh.width)
                                                                        .build(),
                                                                );
                                                            },
                                                        )
                                                        .variant(ButtonVariant::Contained)
                                                        .color(ButtonColor::Error),
                                                );
                                            },
                                        ),
                                    ])(wh, ctx);
                                },
                            )(Wh::new(BUBBLE_WIDTH, BUBBLE_HEIGHT), ctx);
                        });
                        ctx.add(
                            rect(RectParam {
                                rect: Wh::new(BUBBLE_WIDTH, BUBBLE_HEIGHT).to_rect(),
                                style: RectStyle {
                                    fill: Some(RectFill {
                                        color: palette::SURFACE_CONTAINER_HIGHEST,
                                    }),
                                    stroke: Some(RectStroke {
                                        color: palette::OUTLINE,
                                        width: 1.px(),
                                        border_position: BorderPosition::Inside,
                                    }),
                                    round: Some(RectRound {
                                        radius: palette::ROUND,
                                    }),
                                },
                            }),
                        );
                    })
                    .attach_event(|event| {
                        if let Event::MouseDown { event } = event
                            && let Some(MouseButton::Left) = event.button
                            && event.is_local_xy_in()
                        {
                            event.stop_propagation();
                        }
                    });
            }
        }
    }
    mod ui_state {
        use namui::*;
        use std::collections::HashMap;
        pub struct TowerInfoSpringState {
            pub scale: f32,
            pub scale_velocity: f32,
            pub opacity: f32,
            pub opacity_velocity: f32,
            pub target_scale: f32,
            pub target_opacity: f32,
            pub last_tick: Instant,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TowerInfoSpringState {
            #[inline]
            fn clone(&self) -> TowerInfoSpringState {
                TowerInfoSpringState {
                    scale: ::core::clone::Clone::clone(&self.scale),
                    scale_velocity: ::core::clone::Clone::clone(&self.scale_velocity),
                    opacity: ::core::clone::Clone::clone(&self.opacity),
                    opacity_velocity: ::core::clone::Clone::clone(
                        &self.opacity_velocity,
                    ),
                    target_scale: ::core::clone::Clone::clone(&self.target_scale),
                    target_opacity: ::core::clone::Clone::clone(&self.target_opacity),
                    last_tick: ::core::clone::Clone::clone(&self.last_tick),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TowerInfoSpringState {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TowerInfoSpringState {
            #[inline]
            fn eq(&self, other: &TowerInfoSpringState) -> bool {
                self.scale == other.scale && self.scale_velocity == other.scale_velocity
                    && self.opacity == other.opacity
                    && self.opacity_velocity == other.opacity_velocity
                    && self.target_scale == other.target_scale
                    && self.target_opacity == other.target_opacity
                    && self.last_tick == other.last_tick
            }
        }
        impl bincode::Encode for TowerInfoSpringState {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.scale, encoder)?;
                bincode::Encode::encode(&self.scale_velocity, encoder)?;
                bincode::Encode::encode(&self.opacity, encoder)?;
                bincode::Encode::encode(&self.opacity_velocity, encoder)?;
                bincode::Encode::encode(&self.target_scale, encoder)?;
                bincode::Encode::encode(&self.target_opacity, encoder)?;
                bincode::Encode::encode(&self.last_tick, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for TowerInfoSpringState {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    scale: bincode::Decode::decode(decoder)?,
                    scale_velocity: bincode::Decode::decode(decoder)?,
                    opacity: bincode::Decode::decode(decoder)?,
                    opacity_velocity: bincode::Decode::decode(decoder)?,
                    target_scale: bincode::Decode::decode(decoder)?,
                    target_opacity: bincode::Decode::decode(decoder)?,
                    last_tick: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for TowerInfoSpringState {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("scale");
                self.scale.serialize_without_name(buf);
                buf.write_string("scale_velocity");
                self.scale_velocity.serialize_without_name(buf);
                buf.write_string("opacity");
                self.opacity.serialize_without_name(buf);
                buf.write_string("opacity_velocity");
                self.opacity_velocity.serialize_without_name(buf);
                buf.write_string("target_scale");
                self.target_scale.serialize_without_name(buf);
                buf.write_string("target_opacity");
                self.target_opacity.serialize_without_name(buf);
                buf.write_string("last_tick");
                self.last_tick.serialize_without_name(buf);
            }
        }
        impl Deserialize for TowerInfoSpringState {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("scale")?;
                let scale = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("scale_velocity")?;
                let scale_velocity = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("opacity")?;
                let opacity = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("opacity_velocity")?;
                let opacity_velocity = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("target_scale")?;
                let target_scale = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("target_opacity")?;
                let target_opacity = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("last_tick")?;
                let last_tick = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    scale,
                    scale_velocity,
                    opacity,
                    opacity_velocity,
                    target_scale,
                    target_opacity,
                    last_tick,
                })
            }
        }
        impl TowerInfoSpringState {
            pub fn new(now: Instant) -> Self {
                Self {
                    scale: 0.0,
                    scale_velocity: 0.0,
                    opacity: 0.0,
                    opacity_velocity: 0.0,
                    target_scale: 0.0,
                    target_opacity: 0.0,
                    last_tick: now,
                }
            }
            pub fn show(&mut self) {
                self.target_scale = 1.0;
                self.target_opacity = 1.0;
            }
            pub fn hide(&mut self) {
                self.target_scale = 0.0;
                self.target_opacity = 0.0;
            }
            pub fn tick(&mut self, now: Instant) {
                const STIFFNESS: f32 = 300.0;
                const DAMPING: f32 = 20.0;
                let delta_time = (now - self.last_tick).as_secs_f32().min(0.016);
                self.last_tick = now;
                let scale_force = STIFFNESS * (self.target_scale - self.scale);
                let scale_damping = -DAMPING * self.scale_velocity;
                let scale_acceleration = scale_force + scale_damping;
                self.scale_velocity += scale_acceleration * delta_time;
                self.scale += self.scale_velocity * delta_time;
                let opacity_force = STIFFNESS * (self.target_opacity - self.opacity);
                let opacity_damping = -DAMPING * self.opacity_velocity;
                let opacity_acceleration = opacity_force + opacity_damping;
                self.opacity_velocity += opacity_acceleration * delta_time;
                self.opacity += self.opacity_velocity * delta_time;
                self.scale = self.scale.max(0.0);
                self.opacity = self.opacity.clamp(0.0, 1.0);
            }
            pub fn is_visible(&self) -> bool {
                self.opacity > 0.01 || self.target_opacity > 0.0
            }
        }
        /// UI 관련 상태를 관리하는 별도 구조체
        pub struct UIState {
            pub tower_popup_states: HashMap<usize, TowerInfoSpringState>,
            pub selected_tower_id: Option<usize>,
            last_cleanup_time: Instant,
        }
        impl bincode::Encode for UIState {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.tower_popup_states, encoder)?;
                bincode::Encode::encode(&self.selected_tower_id, encoder)?;
                bincode::Encode::encode(&self.last_cleanup_time, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for UIState {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    tower_popup_states: bincode::Decode::decode(decoder)?,
                    selected_tower_id: bincode::Decode::decode(decoder)?,
                    last_cleanup_time: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for UIState {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("tower_popup_states");
                self.tower_popup_states.serialize_without_name(buf);
                buf.write_string("selected_tower_id");
                self.selected_tower_id.serialize_without_name(buf);
                buf.write_string("last_cleanup_time");
                self.last_cleanup_time.serialize_without_name(buf);
            }
        }
        impl Deserialize for UIState {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("tower_popup_states")?;
                let tower_popup_states = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("selected_tower_id")?;
                let selected_tower_id = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("last_cleanup_time")?;
                let last_cleanup_time = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    tower_popup_states,
                    selected_tower_id,
                    last_cleanup_time,
                })
            }
        }
        impl UIState {
            pub fn new() -> Self {
                Self {
                    tower_popup_states: HashMap::new(),
                    selected_tower_id: None,
                    last_cleanup_time: Instant::now(),
                }
            }
            pub fn ensure_tower_popup_state(&mut self, tower_id: usize, now: Instant) {
                self.tower_popup_states
                    .entry(tower_id)
                    .or_insert_with(|| TowerInfoSpringState::new(now));
            }
            pub fn set_selected_tower(&mut self, tower_id: Option<usize>, now: Instant) {
                if self.selected_tower_id == tower_id {
                    return;
                }
                if let Some(prev_id) = self.selected_tower_id
                    && let Some(popup_state) = self.tower_popup_states.get_mut(&prev_id)
                {
                    popup_state.hide();
                }
                if let Some(new_id) = tower_id {
                    self.ensure_tower_popup_state(new_id, now);
                    if let Some(popup_state) = self.tower_popup_states.get_mut(&new_id) {
                        popup_state.show();
                    }
                }
                self.selected_tower_id = tower_id;
            }
            pub fn tick(&mut self, now: Instant) {
                for popup_state in self.tower_popup_states.values_mut() {
                    popup_state.tick(now);
                }
                if (now - self.last_cleanup_time) > Duration::from_secs(5) {
                    self.last_cleanup_time = now;
                }
            }
            pub fn cleanup_unused_states(
                &mut self,
                existing_tower_ids: &std::collections::HashSet<usize>,
            ) {
                self.tower_popup_states
                    .retain(|&tower_id, _| existing_tower_ids.contains(&tower_id));
                if let Some(selected_id) = self.selected_tower_id
                    && !existing_tower_ids.contains(&selected_id)
                {
                    self.selected_tower_id = None;
                }
            }
            pub fn get_popup_state(
                &self,
                tower_id: usize,
            ) -> Option<&TowerInfoSpringState> {
                self.tower_popup_states.get(&tower_id)
            }
            pub fn should_cleanup(&self, now: Instant) -> bool {
                (now - self.last_cleanup_time) > Duration::from_secs(5)
            }
        }
        impl Default for UIState {
            fn default() -> Self {
                Self::new()
            }
        }
    }
    pub mod upgrade {
        mod display {
            use super::UpgradeKind;
            use crate::l10n::upgrade::UpgradeKindText;
            impl UpgradeKind {
                pub fn name(&self, text_manager: &crate::l10n::TextManager) -> String {
                    text_manager.upgrade_kind(UpgradeKindText::Name(self))
                }
                pub fn description(
                    &self,
                    text_manager: &crate::l10n::TextManager,
                ) -> String {
                    text_manager.upgrade_kind(UpgradeKindText::Description(self))
                }
            }
        }
        mod generation {
            mod upgrade_candidate_table {
                use super::*;
                use crate::{
                    card::{REVERSED_RANKS, SUITS},
                    game_state::{GameState, tower::TowerKind},
                    rarity::Rarity,
                };
                use rand::{Rng, seq::SliceRandom, thread_rng};
                type KindGen = fn(rarity: Rarity) -> UpgradeKind;
                pub struct CandidateRow {
                    pub weight: f32,
                    pub kind_gen: KindGen,
                }
                pub fn generate_upgrade_candidate_table(
                    game_state: &GameState,
                    rarity: Rarity,
                ) -> Vec<CandidateRow> {
                    let upgrade_state = &game_state.upgrade_state;
                    {
                        let mut upgrade_candidate_table = Vec::with_capacity(64);
                        let mut candidate_table_push = |
                            kind_gen: KindGen,
                            current_and_max: Option<(usize, usize)>,
                            weights: (usize, usize, usize, usize)|
                        {
                            let weight = {
                                if let Some((current, max)) = current_and_max
                                    && current >= max
                                {
                                    0.0
                                } else {
                                    match rarity {
                                        Rarity::Common => weights.0 as f32,
                                        Rarity::Rare => weights.1 as f32,
                                        Rarity::Epic => weights.2 as f32,
                                        Rarity::Legendary => weights.3 as f32,
                                    }
                                }
                            };
                            upgrade_candidate_table
                                .push(CandidateRow { weight, kind_gen })
                        };
                        candidate_table_push(
                            |_rarity| UpgradeKind::GoldEarnPlus,
                            Some((upgrade_state.gold_earn_plus, MAX_GOLD_EARN_PLUS)),
                            (10, 50, 50, 100),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RankAttackDamagePlus {
                                rank: *REVERSED_RANKS.choose(&mut thread_rng()).unwrap(),
                                damage_plus: rarity_gen(
                                    rarity,
                                    (10.0..100.0, 50.0..750.0, 500.0..1500.0, 1250.0..2500.0),
                                ),
                            },
                            None,
                            (38, 75, 75, 75),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RankAttackDamageMultiply {
                                rank: *REVERSED_RANKS.choose(&mut thread_rng()).unwrap(),
                                damage_multiplier: rarity_gen(
                                    rarity,
                                    (1.2..1.5, 1.3..1.75, 1.5..2.5, 2.0..3.5),
                                ),
                            },
                            None,
                            (19, 38, 38, 38),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RankAttackSpeedPlus {
                                rank: *REVERSED_RANKS.choose(&mut thread_rng()).unwrap(),
                                speed_plus: rarity_gen(
                                    rarity,
                                    (0.2..0.4, 0.2..0.6, 0.4..1.0, 0.5..1.5),
                                ),
                            },
                            None,
                            (30, 60, 60, 60),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RankAttackSpeedMultiply {
                                rank: *REVERSED_RANKS.choose(&mut thread_rng()).unwrap(),
                                speed_multiplier: rarity_gen(
                                    rarity,
                                    (1.1..1.2, 1.2..1.5, 1.5..1.75, 1.75..2.0),
                                ),
                            },
                            None,
                            (15, 30, 30, 30),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RankAttackRangePlus {
                                rank: *REVERSED_RANKS.choose(&mut thread_rng()).unwrap(),
                                range_plus: rarity_gen(
                                    rarity,
                                    (1.5..2.5, 2.0..4.0, 3.0..5.0, 3.0..6.0),
                                ),
                            },
                            None,
                            (8, 15, 15, 15),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::SuitAttackDamagePlus {
                                suit: *SUITS.choose(&mut thread_rng()).unwrap(),
                                damage_plus: rarity_gen(
                                    rarity,
                                    (10.0..50.0, 50.0..250.0, 250.0..1000.0, 1000.0..2500.0),
                                ),
                            },
                            None,
                            (13, 25, 25, 25),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::SuitAttackDamageMultiply {
                                suit: *SUITS.choose(&mut thread_rng()).unwrap(),
                                damage_multiplier: rarity_gen(
                                    rarity,
                                    (1.1..1.25, 1.15..1.5, 1.25..1.75, 1.5..3.5),
                                ),
                            },
                            None,
                            (6, 13, 13, 13),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::SuitAttackSpeedPlus {
                                suit: *SUITS.choose(&mut thread_rng()).unwrap(),
                                speed_plus: rarity_gen(
                                    rarity,
                                    (0.1..0.25, 0.25..0.5, 0.5..0.75, 0.75..1.0),
                                ),
                            },
                            None,
                            (10, 20, 20, 20),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::SuitAttackSpeedMultiply {
                                suit: *SUITS.choose(&mut thread_rng()).unwrap(),
                                speed_multiplier: rarity_gen(
                                    rarity,
                                    (1.1..1.2, 1.2..1.5, 1.5..1.75, 1.75..2.0),
                                ),
                            },
                            None,
                            (5, 10, 10, 10),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::SuitAttackRangePlus {
                                suit: *SUITS.choose(&mut thread_rng()).unwrap(),
                                range_plus: rarity_gen(
                                    rarity,
                                    (1.5..2.5, 2.0..4.0, 3.0..5.0, 3.0..6.0),
                                ),
                            },
                            None,
                            (3, 5, 5, 5),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::HandAttackDamagePlus {
                                tower_kind: get_tower_kind_with_weight(
                                    &[11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 6.0, 6.0, 3.0, 2.0],
                                ),
                                damage_plus: rarity_gen(
                                    rarity,
                                    (10.0..100.0, 100.0..500.0, 500.0..2000.0, 2000.0..5000.0),
                                ),
                            },
                            None,
                            (50, 100, 100, 50),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::HandAttackDamageMultiply {
                                tower_kind: get_tower_kind_with_weight(
                                    &[11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 6.0, 6.0, 3.0, 2.0],
                                ),
                                damage_multiplier: rarity_gen(
                                    rarity,
                                    (1.2..1.5, 1.3..1.75, 1.5..2.5, 2.0..4.0),
                                ),
                            },
                            None,
                            (25, 50, 50, 25),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::HandAttackSpeedPlus {
                                tower_kind: get_tower_kind_with_weight(
                                    &[11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 6.0, 6.0, 3.0, 2.0],
                                ),
                                speed_plus: rarity_gen(
                                    rarity,
                                    (0.2..0.4, 0.2..0.6, 0.4..1.0, 0.5..1.5),
                                ),
                            },
                            None,
                            (40, 80, 80, 40),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::HandAttackSpeedMultiply {
                                tower_kind: get_tower_kind_with_weight(
                                    &[11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 6.0, 6.0, 3.0, 2.0],
                                ),
                                speed_multiplier: rarity_gen(
                                    rarity,
                                    (1.2..1.4, 1.2..1.6, 1.4..2.0, 1.5..2.0),
                                ),
                            },
                            None,
                            (20, 40, 40, 20),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::HandAttackRangePlus {
                                tower_kind: get_tower_kind_with_weight(
                                    &[11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 6.0, 6.0, 3.0, 2.0],
                                ),
                                range_plus: rarity_gen(
                                    rarity,
                                    (1.5..2.5, 2.0..5.0, 4.0..8.0, 6.0..10.0),
                                ),
                            },
                            None,
                            (10, 20, 20, 10),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::ShopSlotExpansion,
                            Some((upgrade_state.shop_slot_expand, MAX_SHOP_SLOT_EXPAND)),
                            (10, 50, 50, 100),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::QuestSlotExpansion,
                            Some((
                                upgrade_state.quest_slot_expand,
                                MAX_QUEST_SLOT_EXPAND,
                            )),
                            (10, 50, 50, 100),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::QuestBoardExpansion,
                            Some((
                                upgrade_state.quest_board_slot_expand,
                                MAX_QUEST_BOARD_SLOT_EXPAND,
                            )),
                            (10, 50, 50, 100),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::RerollCountPlus,
                            Some((
                                upgrade_state.reroll_chance_plus,
                                MAX_REROLL_CHANCE_PLUS,
                            )),
                            (5, 10, 50, 100),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::LowCardTowerDamagePlus {
                                damage_plus: rarity_gen(
                                    rarity,
                                    (10.0..100.0, 100.0..500.0, 500.0..2000.0, 2000.0..5000.0),
                                ),
                            },
                            None,
                            (50, 100, 100, 50),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::LowCardTowerDamageMultiply {
                                damage_multiplier: rarity_gen(
                                    rarity,
                                    (1.2..1.5, 1.3..1.75, 1.5..2.5, 2.0..4.0),
                                ),
                            },
                            None,
                            (25, 50, 50, 25),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::LowCardTowerAttackSpeedPlus {
                                speed_plus: rarity_gen(
                                    rarity,
                                    (0.2..0.4, 0.2..0.6, 0.4..1.0, 0.5..1.5),
                                ),
                            },
                            None,
                            (40, 80, 80, 40),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::LowCardTowerAttackSpeedMultiply {
                                speed_multiplier: rarity_gen(
                                    rarity,
                                    (1.2..1.4, 1.2..1.6, 1.4..2.0, 1.5..2.0),
                                ),
                            },
                            None,
                            (20, 40, 40, 20),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::LowCardTowerAttackRangePlus {
                                range_plus: rarity_gen(
                                    rarity,
                                    (1.5..2.5, 2.0..5.0, 4.0..8.0, 6.0..10.0),
                                ),
                            },
                            None,
                            (10, 20, 20, 10),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::ShopItemPriceMinus,
                            Some((
                                upgrade_state.shop_item_price_minus,
                                MAX_SHOP_ITEM_PRICE_MINUS_UPGRADE,
                            )),
                            (10, 10, 10, 10),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::ShopRefreshPlus,
                            Some((
                                upgrade_state.shop_refresh_chance_plus,
                                MAX_SHOP_REFRESH_CHANCE_PLUS,
                            )),
                            (10, 50, 50, 10),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::QuestBoardRefreshPlus,
                            Some((
                                upgrade_state.quest_board_refresh_chance_plus,
                                MAX_QUEST_BOARD_REFRESH_CHANCE_PLUS,
                            )),
                            (10, 50, 50, 10),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::NoRerollTowerAttackDamagePlus {
                                damage_plus: rarity_gen(
                                    rarity,
                                    (10.0..100.0, 100.0..500.0, 500.0..2000.0, 2000.0..5000.0),
                                ),
                            },
                            None,
                            (40, 50, 100, 100),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::NoRerollTowerAttackDamageMultiply {
                                damage_multiplier: rarity_gen(
                                    rarity,
                                    (1.2..1.5, 1.3..1.75, 1.5..2.5, 2.0..4.0),
                                ),
                            },
                            None,
                            (20, 25, 50, 50),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::NoRerollTowerAttackSpeedPlus {
                                speed_plus: rarity_gen(
                                    rarity,
                                    (0.2..0.4, 0.2..0.6, 0.4..1.0, 0.5..1.5),
                                ),
                            },
                            None,
                            (30, 40, 80, 80),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::NoRerollTowerAttackSpeedMultiply {
                                speed_multiplier: rarity_gen(
                                    rarity,
                                    (1.2..1.4, 1.2..1.6, 1.4..2.0, 1.5..2.0),
                                ),
                            },
                            None,
                            (15, 20, 40, 40),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::NoRerollTowerAttackRangePlus {
                                range_plus: rarity_gen(
                                    rarity,
                                    (1.5..2.5, 2.0..5.0, 4.0..8.0, 6.0..10.0),
                                ),
                            },
                            None,
                            (15, 25, 30, 30),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::EvenOddTowerAttackDamagePlus {
                                even: thread_rng().gen_bool(0.5),
                                damage_plus: rarity_gen(
                                    rarity,
                                    (5.0..25.0, 25.0..150.0, 100.0..500.0, 250.0..1500.0),
                                ),
                            },
                            None,
                            (30, 40, 50, 100),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::EvenOddTowerAttackDamageMultiply {
                                even: thread_rng().gen_bool(0.5),
                                damage_multiplier: rarity_gen(
                                    rarity,
                                    (1.1..1.2, 1.2..1.4, 1.4..1.5, 1.5..1.6),
                                ),
                            },
                            None,
                            (15, 20, 25, 50),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::EvenOddTowerAttackSpeedPlus {
                                even: thread_rng().gen_bool(0.5),
                                speed_plus: rarity_gen(
                                    rarity,
                                    (0.1..0.15, 0.15..0.2, 0.2..0.25, 0.25..0.3),
                                ),
                            },
                            None,
                            (20, 30, 40, 80),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::EvenOddTowerAttackSpeedMultiply {
                                even: thread_rng().gen_bool(0.5),
                                speed_multiplier: rarity_gen(
                                    rarity,
                                    (1.1..1.15, 1.15..1.2, 1.2..1.25, 1.25..1.3),
                                ),
                            },
                            None,
                            (10, 15, 20, 40),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::EvenOddTowerAttackRangePlus {
                                even: thread_rng().gen_bool(0.5),
                                range_plus: rarity_gen(
                                    rarity,
                                    (0.5..1.5, 1.0..2.0, 1.5..2.5, 1.5..3.0),
                                ),
                            },
                            None,
                            (5, 10, 15, 25),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                                face: thread_rng().gen_bool(0.5),
                                damage_plus: rarity_gen(
                                    rarity,
                                    (5.0..25.0, 25.0..150.0, 100.0..500.0, 250.0..1500.0),
                                ),
                            },
                            None,
                            (30, 40, 50, 100),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                                face: thread_rng().gen_bool(0.5),
                                damage_multiplier: rarity_gen(
                                    rarity,
                                    (1.1..1.2, 1.2..1.4, 1.4..1.5, 1.5..1.6),
                                ),
                            },
                            None,
                            (15, 20, 25, 50),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                                face: thread_rng().gen_bool(0.5),
                                speed_plus: rarity_gen(
                                    rarity,
                                    (0.1..0.15, 0.15..0.2, 0.2..0.25, 0.25..0.3),
                                ),
                            },
                            None,
                            (20, 30, 40, 80),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                                face: thread_rng().gen_bool(0.5),
                                speed_multiplier: rarity_gen(
                                    rarity,
                                    (1.1..1.15, 1.15..1.2, 1.2..1.25, 1.25..1.3),
                                ),
                            },
                            None,
                            (10, 15, 20, 40),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                                face: thread_rng().gen_bool(0.5),
                                range_plus: rarity_gen(
                                    rarity,
                                    (0.5..1.5, 1.0..2.0, 1.5..2.5, 1.5..3.0),
                                ),
                            },
                            None,
                            (5, 10, 15, 20),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::ShortenStraightFlushTo4Cards,
                            Some((
                                upgrade_state.shorten_straight_flush_to_4_cards as usize,
                                1,
                            )),
                            (5, 10, 20, 25),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::SkipRankForStraight,
                            Some((upgrade_state.skip_rank_for_straight as usize, 1)),
                            (5, 10, 20, 25),
                        );
                        candidate_table_push(
                            |_rarity| UpgradeKind::TreatSuitsAsSame,
                            Some((upgrade_state.treat_suits_as_same as usize, 1)),
                            (5, 10, 20, 25),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RerollTowerAttackDamagePlus {
                                damage_plus: rarity_gen(
                                    rarity,
                                    (5.0..15.0, 10.0..100.0, 75.0..250.0, 200.0..1000.0),
                                ),
                            },
                            None,
                            (30, 40, 50, 100),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RerollTowerAttackDamageMultiply {
                                damage_multiplier: rarity_gen(
                                    rarity,
                                    (1.1..1.15, 1.15..1.25, 1.25..1.35, 1.35..1.5),
                                ),
                            },
                            None,
                            (15, 20, 25, 50),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RerollTowerAttackSpeedPlus {
                                speed_plus: rarity_gen(
                                    rarity,
                                    (0.1..0.15, 0.15..0.2, 0.2..0.25, 0.25..0.3),
                                ),
                            },
                            None,
                            (20, 30, 40, 80),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RerollTowerAttackSpeedMultiply {
                                speed_multiplier: rarity_gen(
                                    rarity,
                                    (1.1..1.15, 1.15..1.2, 1.2..1.25, 1.25..1.3),
                                ),
                            },
                            None,
                            (10, 15, 20, 40),
                        );
                        candidate_table_push(
                            |rarity| UpgradeKind::RerollTowerAttackRangePlus {
                                range_plus: rarity_gen(
                                    rarity,
                                    (0.5..1.5, 1.0..2.0, 1.5..2.5, 1.5..3.0),
                                ),
                            },
                            None,
                            (5, 10, 15, 20),
                        );
                        upgrade_candidate_table
                    }
                }
                fn get_tower_kind_with_weight(weights: &[f32; 10]) -> TowerKind {
                    const TOWER_KINDS: [TowerKind; 10] = [
                        TowerKind::High,
                        TowerKind::OnePair,
                        TowerKind::TwoPair,
                        TowerKind::ThreeOfAKind,
                        TowerKind::Straight,
                        TowerKind::Flush,
                        TowerKind::FullHouse,
                        TowerKind::FourOfAKind,
                        TowerKind::StraightFlush,
                        TowerKind::RoyalFlush,
                    ];
                    *TOWER_KINDS
                        .iter()
                        .zip(weights)
                        .collect::<Vec<_>>()
                        .choose_weighted(&mut thread_rng(), |x| x.1)
                        .unwrap()
                        .0
                }
                fn rarity_gen(
                    rarity: Rarity,
                    ranges: (
                        std::ops::Range<f32>,
                        std::ops::Range<f32>,
                        std::ops::Range<f32>,
                        std::ops::Range<f32>,
                    ),
                ) -> f32 {
                    thread_rng()
                        .gen_range(
                            match rarity {
                                Rarity::Common => ranges.0,
                                Rarity::Rare => ranges.1,
                                Rarity::Epic => ranges.2,
                                Rarity::Legendary => ranges.3,
                            },
                        )
                }
                use candidate_table;
            }
            use super::*;
            use crate::{
                game_state::{GameState, level_rarity_weight::RarityGenerationOption},
                rarity::Rarity,
            };
            use rand::{Rng, seq::SliceRandom, thread_rng};
            use upgrade_candidate_table::generate_upgrade_candidate_table;
            pub fn generate_upgrades_for_boss_reward(
                game_state: &GameState,
                amount: usize,
            ) -> Vec<Upgrade> {
                let rarities = (0..amount)
                    .map(|_| {
                        game_state
                            .generate_rarity(RarityGenerationOption {
                                no_common: true,
                            })
                    });
                rarities.map(|rarity| generate_upgrade(game_state, rarity)).collect()
            }
            pub fn generate_upgrade(game_state: &GameState, rarity: Rarity) -> Upgrade {
                let upgrade_candidates = generate_upgrade_candidate_table(
                    game_state,
                    rarity,
                );
                let candidate = upgrade_candidates
                    .choose_weighted(&mut rand::thread_rng(), |x| x.weight)
                    .unwrap();
                let kind = (candidate.kind_gen)(rarity);
                let value = thread_rng().gen_range(0.0..=1.0);
                Upgrade {
                    kind,
                    rarity,
                    value: value.into(),
                }
            }
        }
        mod thumbnail {
            pub mod upgrade_rendering {
                use crate::{
                    game_state::upgrade::UpgradeKind, icon::{Icon, IconKind, IconSize},
                    thumbnail::{
                        ThumbnailComposer, constants::OVERLAY_SIZE_RATIO,
                        overlay_rendering::OverlayPosition,
                    },
                };
                use namui::*;
                impl UpgradeKind {
                    pub fn thumbnail(&self, width_height: Wh<Px>) -> RenderingTree {
                        match self {
                            UpgradeKind::GoldEarnPlus => {
                                ThumbnailComposer::new(width_height)
                                    .with_icon_base(IconKind::Gold)
                                    .add_plus_overlay()
                                    .build()
                            }
                            UpgradeKind::RankAttackDamagePlus { rank, .. } => {
                                create_rank_stat_upgrade_thumbnail(
                                    width_height,
                                    *rank,
                                    StatType::Damage,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::RankAttackDamageMultiply { rank, .. } => {
                                create_rank_stat_upgrade_thumbnail(
                                    width_height,
                                    *rank,
                                    StatType::Damage,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::RankAttackSpeedPlus { rank, .. } => {
                                create_rank_stat_upgrade_thumbnail(
                                    width_height,
                                    *rank,
                                    StatType::Speed,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::RankAttackSpeedMultiply { rank, .. } => {
                                create_rank_stat_upgrade_thumbnail(
                                    width_height,
                                    *rank,
                                    StatType::Speed,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::RankAttackRangePlus { rank, .. } => {
                                create_rank_stat_upgrade_thumbnail(
                                    width_height,
                                    *rank,
                                    StatType::Range,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::SuitAttackDamagePlus { suit, .. } => {
                                create_suit_stat_upgrade_thumbnail(
                                    width_height,
                                    *suit,
                                    StatType::Damage,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::SuitAttackDamageMultiply { suit, .. } => {
                                create_suit_stat_upgrade_thumbnail(
                                    width_height,
                                    *suit,
                                    StatType::Damage,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::SuitAttackSpeedPlus { suit, .. } => {
                                create_suit_stat_upgrade_thumbnail(
                                    width_height,
                                    *suit,
                                    StatType::Speed,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::SuitAttackSpeedMultiply { suit, .. } => {
                                create_suit_stat_upgrade_thumbnail(
                                    width_height,
                                    *suit,
                                    StatType::Speed,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::SuitAttackRangePlus { suit, .. } => {
                                create_suit_stat_upgrade_thumbnail(
                                    width_height,
                                    *suit,
                                    StatType::Range,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::HandAttackDamagePlus { tower_kind, .. } => {
                                create_hand_stat_upgrade_thumbnail(
                                    width_height,
                                    *tower_kind,
                                    StatType::Damage,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::HandAttackDamageMultiply { tower_kind, .. } => {
                                create_hand_stat_upgrade_thumbnail(
                                    width_height,
                                    *tower_kind,
                                    StatType::Damage,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::HandAttackSpeedPlus { tower_kind, .. } => {
                                create_hand_stat_upgrade_thumbnail(
                                    width_height,
                                    *tower_kind,
                                    StatType::Speed,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::HandAttackSpeedMultiply { tower_kind, .. } => {
                                create_hand_stat_upgrade_thumbnail(
                                    width_height,
                                    *tower_kind,
                                    StatType::Speed,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::HandAttackRangePlus { tower_kind, .. } => {
                                create_hand_stat_upgrade_thumbnail(
                                    width_height,
                                    *tower_kind,
                                    StatType::Range,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::ShopSlotExpansion => {
                                ThumbnailComposer::new(width_height)
                                    .with_icon_base(IconKind::Shop)
                                    .add_expansion_indicator("+")
                                    .build()
                            }
                            UpgradeKind::QuestSlotExpansion => {
                                ThumbnailComposer::new(width_height)
                                    .with_icon_base(IconKind::Quest)
                                    .add_expansion_indicator("+")
                                    .build()
                            }
                            UpgradeKind::QuestBoardExpansion => {
                                ThumbnailComposer::new(width_height)
                                    .with_icon_base(IconKind::Quest)
                                    .add_expansion_indicator("Board")
                                    .build()
                            }
                            UpgradeKind::RerollCountPlus => {
                                ThumbnailComposer::new(width_height)
                                    .with_icon_base(IconKind::Refresh)
                                    .add_plus_overlay()
                                    .build()
                            }
                            UpgradeKind::LowCardTowerDamagePlus { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::LowCard,
                                    StatType::Damage,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::LowCardTowerDamageMultiply { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::LowCard,
                                    StatType::Damage,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::LowCardTowerAttackSpeedPlus { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::LowCard,
                                    StatType::Speed,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::LowCardTowerAttackSpeedMultiply { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::LowCard,
                                    StatType::Speed,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::LowCardTowerAttackRangePlus { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::LowCard,
                                    StatType::Range,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::ShopItemPriceMinus => {
                                Icon::new(IconKind::Shop)
                                    .wh(width_height)
                                    .size(IconSize::Custom {
                                        size: width_height.width,
                                    })
                                    .to_rendering_tree()
                            }
                            UpgradeKind::ShopRefreshPlus => {
                                ThumbnailComposer::new(width_height)
                                    .with_icon_base(IconKind::Shop)
                                    .add_reroll_indicator()
                                    .build()
                            }
                            UpgradeKind::QuestBoardRefreshPlus => {
                                ThumbnailComposer::new(width_height)
                                    .with_icon_base(IconKind::Quest)
                                    .add_reroll_indicator()
                                    .build()
                            }
                            UpgradeKind::NoRerollTowerAttackDamagePlus { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::NoReroll,
                                    StatType::Damage,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::NoRerollTowerAttackDamageMultiply { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::NoReroll,
                                    StatType::Damage,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::NoRerollTowerAttackSpeedPlus { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::NoReroll,
                                    StatType::Speed,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::NoRerollTowerAttackSpeedMultiply { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::NoReroll,
                                    StatType::Speed,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::NoRerollTowerAttackRangePlus { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::NoReroll,
                                    StatType::Range,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::EvenOddTowerAttackDamagePlus { even, .. } => {
                                create_even_odd_stat_upgrade_thumbnail(
                                    width_height,
                                    *even,
                                    StatType::Damage,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::EvenOddTowerAttackDamageMultiply {
                                even,
                                ..
                            } => {
                                create_even_odd_stat_upgrade_thumbnail(
                                    width_height,
                                    *even,
                                    StatType::Damage,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::EvenOddTowerAttackSpeedPlus { even, .. } => {
                                create_even_odd_stat_upgrade_thumbnail(
                                    width_height,
                                    *even,
                                    StatType::Speed,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::EvenOddTowerAttackSpeedMultiply { even, .. } => {
                                create_even_odd_stat_upgrade_thumbnail(
                                    width_height,
                                    *even,
                                    StatType::Speed,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::EvenOddTowerAttackRangePlus { even, .. } => {
                                create_even_odd_stat_upgrade_thumbnail(
                                    width_height,
                                    *even,
                                    StatType::Range,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                                face,
                                ..
                            } => {
                                create_face_number_stat_upgrade_thumbnail(
                                    width_height,
                                    *face,
                                    StatType::Damage,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                                face,
                                ..
                            } => {
                                create_face_number_stat_upgrade_thumbnail(
                                    width_height,
                                    *face,
                                    StatType::Damage,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                                face,
                                ..
                            } => {
                                create_face_number_stat_upgrade_thumbnail(
                                    width_height,
                                    *face,
                                    StatType::Speed,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                                face,
                                ..
                            } => {
                                create_face_number_stat_upgrade_thumbnail(
                                    width_height,
                                    *face,
                                    StatType::Speed,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                                face,
                                ..
                            } => {
                                create_face_number_stat_upgrade_thumbnail(
                                    width_height,
                                    *face,
                                    StatType::Range,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::ShortenStraightFlushTo4Cards => {
                                ThumbnailComposer::new(width_height)
                                    .with_default_tower()
                                    .add_shortcut_indicator("4")
                                    .build()
                            }
                            UpgradeKind::SkipRankForStraight => {
                                ThumbnailComposer::new(width_height)
                                    .with_default_tower()
                                    .add_skip_indicator()
                                    .build()
                            }
                            UpgradeKind::TreatSuitsAsSame => {
                                ThumbnailComposer::new(width_height)
                                    .with_default_tower()
                                    .add_same_suits_indicator()
                                    .build()
                            }
                            UpgradeKind::RerollTowerAttackDamagePlus { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::Reroll,
                                    StatType::Damage,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::RerollTowerAttackDamageMultiply { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::Reroll,
                                    StatType::Damage,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::RerollTowerAttackSpeedPlus { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::Reroll,
                                    StatType::Speed,
                                    OperationType::Plus,
                                )
                            }
                            UpgradeKind::RerollTowerAttackSpeedMultiply { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::Reroll,
                                    StatType::Speed,
                                    OperationType::Multiply,
                                )
                            }
                            UpgradeKind::RerollTowerAttackRangePlus { .. } => {
                                create_condition_stat_upgrade_thumbnail(
                                    width_height,
                                    ConditionType::Reroll,
                                    StatType::Range,
                                    OperationType::Plus,
                                )
                            }
                        }
                    }
                }
                enum StatType {
                    Damage,
                    Speed,
                    Range,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for StatType {
                    #[inline]
                    fn clone(&self) -> StatType {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for StatType {}
                impl bincode::Encode for StatType {
                    fn encode<__E: bincode::enc::Encoder>(
                        &self,
                        encoder: &mut __E,
                    ) -> core::result::Result<(), bincode::error::EncodeError> {
                        match self {
                            Self::Damage => {
                                bincode::Encode::encode(&0u32, encoder)?;
                            }
                            Self::Speed => {
                                bincode::Encode::encode(&1u32, encoder)?;
                            }
                            Self::Range => {
                                bincode::Encode::encode(&2u32, encoder)?;
                            }
                        }
                        Ok(())
                    }
                }
                impl bincode::Decode<()> for StatType {
                    fn decode<__D: bincode::de::Decoder<Context = ()>>(
                        decoder: &mut __D,
                    ) -> core::result::Result<Self, bincode::error::DecodeError> {
                        let discriminant: u32 = bincode::Decode::decode(decoder)?;
                        match discriminant {
                            0u32 => Ok(Self::Damage),
                            1u32 => Ok(Self::Speed),
                            2u32 => Ok(Self::Range),
                            _ => {
                                Err(bincode::error::DecodeError::UnexpectedVariant {
                                    type_name: core::any::type_name::<Self>(),
                                    allowed: &bincode::error::AllowedEnumVariants::Range {
                                        min: 0,
                                        max: 2u32,
                                    },
                                    found: discriminant,
                                })
                            }
                        }
                    }
                }
                impl Serialize for StatType {
                    fn serialize(&self, buf: &mut Vec<u8>) {
                        buf.write_string(std::any::type_name::<Self>());
                        self.serialize_without_name(buf);
                    }
                    fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                        match self {
                            Self::Damage => {
                                buf.write_string("Damage");
                            }
                            Self::Speed => {
                                buf.write_string("Speed");
                            }
                            Self::Range => {
                                buf.write_string("Range");
                            }
                        }
                    }
                }
                impl Deserialize for StatType {
                    fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                        buf.read_name(std::any::type_name::<Self>())?;
                        Self::deserialize_without_name(buf)
                    }
                    fn deserialize_without_name(
                        buf: &mut &[u8],
                    ) -> Result<Self, DeserializeError> {
                        let variant_name = buf.read_string();
                        match variant_name.as_ref() {
                            "Damage" => Ok(Self::Damage),
                            "Speed" => Ok(Self::Speed),
                            "Range" => Ok(Self::Range),
                            _ => {
                                Err(DeserializeError::InvalidEnumVariant {
                                    expected: std::any::type_name::<Self>().to_string(),
                                    actual: variant_name,
                                })
                            }
                        }
                    }
                }
                impl StatType {
                    fn to_icon_kind(self) -> IconKind {
                        match self {
                            StatType::Damage => IconKind::AttackDamage,
                            StatType::Speed => IconKind::AttackSpeed,
                            StatType::Range => IconKind::AttackRange,
                        }
                    }
                }
                enum OperationType {
                    Plus,
                    Multiply,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for OperationType {
                    #[inline]
                    fn clone(&self) -> OperationType {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for OperationType {}
                impl bincode::Encode for OperationType {
                    fn encode<__E: bincode::enc::Encoder>(
                        &self,
                        encoder: &mut __E,
                    ) -> core::result::Result<(), bincode::error::EncodeError> {
                        match self {
                            Self::Plus => {
                                bincode::Encode::encode(&0u32, encoder)?;
                            }
                            Self::Multiply => {
                                bincode::Encode::encode(&1u32, encoder)?;
                            }
                        }
                        Ok(())
                    }
                }
                impl bincode::Decode<()> for OperationType {
                    fn decode<__D: bincode::de::Decoder<Context = ()>>(
                        decoder: &mut __D,
                    ) -> core::result::Result<Self, bincode::error::DecodeError> {
                        let discriminant: u32 = bincode::Decode::decode(decoder)?;
                        match discriminant {
                            0u32 => Ok(Self::Plus),
                            1u32 => Ok(Self::Multiply),
                            _ => {
                                Err(bincode::error::DecodeError::UnexpectedVariant {
                                    type_name: core::any::type_name::<Self>(),
                                    allowed: &bincode::error::AllowedEnumVariants::Range {
                                        min: 0,
                                        max: 1u32,
                                    },
                                    found: discriminant,
                                })
                            }
                        }
                    }
                }
                impl Serialize for OperationType {
                    fn serialize(&self, buf: &mut Vec<u8>) {
                        buf.write_string(std::any::type_name::<Self>());
                        self.serialize_without_name(buf);
                    }
                    fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                        match self {
                            Self::Plus => {
                                buf.write_string("Plus");
                            }
                            Self::Multiply => {
                                buf.write_string("Multiply");
                            }
                        }
                    }
                }
                impl Deserialize for OperationType {
                    fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                        buf.read_name(std::any::type_name::<Self>())?;
                        Self::deserialize_without_name(buf)
                    }
                    fn deserialize_without_name(
                        buf: &mut &[u8],
                    ) -> Result<Self, DeserializeError> {
                        let variant_name = buf.read_string();
                        match variant_name.as_ref() {
                            "Plus" => Ok(Self::Plus),
                            "Multiply" => Ok(Self::Multiply),
                            _ => {
                                Err(DeserializeError::InvalidEnumVariant {
                                    expected: std::any::type_name::<Self>().to_string(),
                                    actual: variant_name,
                                })
                            }
                        }
                    }
                }
                impl OperationType {
                    fn to_icon_kind(self) -> IconKind {
                        match self {
                            OperationType::Plus => IconKind::Add,
                            OperationType::Multiply => IconKind::Multiply,
                        }
                    }
                }
                enum ConditionType {
                    LowCard,
                    NoReroll,
                    Reroll,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ConditionType {
                    #[inline]
                    fn clone(&self) -> ConditionType {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for ConditionType {}
                impl bincode::Encode for ConditionType {
                    fn encode<__E: bincode::enc::Encoder>(
                        &self,
                        encoder: &mut __E,
                    ) -> core::result::Result<(), bincode::error::EncodeError> {
                        match self {
                            Self::LowCard => {
                                bincode::Encode::encode(&0u32, encoder)?;
                            }
                            Self::NoReroll => {
                                bincode::Encode::encode(&1u32, encoder)?;
                            }
                            Self::Reroll => {
                                bincode::Encode::encode(&2u32, encoder)?;
                            }
                        }
                        Ok(())
                    }
                }
                impl bincode::Decode<()> for ConditionType {
                    fn decode<__D: bincode::de::Decoder<Context = ()>>(
                        decoder: &mut __D,
                    ) -> core::result::Result<Self, bincode::error::DecodeError> {
                        let discriminant: u32 = bincode::Decode::decode(decoder)?;
                        match discriminant {
                            0u32 => Ok(Self::LowCard),
                            1u32 => Ok(Self::NoReroll),
                            2u32 => Ok(Self::Reroll),
                            _ => {
                                Err(bincode::error::DecodeError::UnexpectedVariant {
                                    type_name: core::any::type_name::<Self>(),
                                    allowed: &bincode::error::AllowedEnumVariants::Range {
                                        min: 0,
                                        max: 2u32,
                                    },
                                    found: discriminant,
                                })
                            }
                        }
                    }
                }
                impl Serialize for ConditionType {
                    fn serialize(&self, buf: &mut Vec<u8>) {
                        buf.write_string(std::any::type_name::<Self>());
                        self.serialize_without_name(buf);
                    }
                    fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                        match self {
                            Self::LowCard => {
                                buf.write_string("LowCard");
                            }
                            Self::NoReroll => {
                                buf.write_string("NoReroll");
                            }
                            Self::Reroll => {
                                buf.write_string("Reroll");
                            }
                        }
                    }
                }
                impl Deserialize for ConditionType {
                    fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                        buf.read_name(std::any::type_name::<Self>())?;
                        Self::deserialize_without_name(buf)
                    }
                    fn deserialize_without_name(
                        buf: &mut &[u8],
                    ) -> Result<Self, DeserializeError> {
                        let variant_name = buf.read_string();
                        match variant_name.as_ref() {
                            "LowCard" => Ok(Self::LowCard),
                            "NoReroll" => Ok(Self::NoReroll),
                            "Reroll" => Ok(Self::Reroll),
                            _ => {
                                Err(DeserializeError::InvalidEnumVariant {
                                    expected: std::any::type_name::<Self>().to_string(),
                                    actual: variant_name,
                                })
                            }
                        }
                    }
                }
                fn create_rank_stat_upgrade_thumbnail(
                    width_height: Wh<Px>,
                    rank: crate::card::Rank,
                    stat_type: StatType,
                    operation_type: OperationType,
                ) -> RenderingTree {
                    ThumbnailComposer::new(width_height)
                        .with_default_tower()
                        .add_rank_overlay(rank)
                        .add_icon_overlay(
                            stat_type.to_icon_kind(),
                            OverlayPosition::BottomLeft,
                            OVERLAY_SIZE_RATIO,
                        )
                        .add_icon_overlay(
                            operation_type.to_icon_kind(),
                            OverlayPosition::TopRight,
                            OVERLAY_SIZE_RATIO,
                        )
                        .build()
                }
                fn create_suit_stat_upgrade_thumbnail(
                    width_height: Wh<Px>,
                    suit: crate::card::Suit,
                    stat_type: StatType,
                    operation_type: OperationType,
                ) -> RenderingTree {
                    ThumbnailComposer::new(width_height)
                        .with_default_tower()
                        .add_suit_overlay(suit)
                        .add_icon_overlay(
                            stat_type.to_icon_kind(),
                            OverlayPosition::BottomLeft,
                            OVERLAY_SIZE_RATIO,
                        )
                        .add_icon_overlay(
                            operation_type.to_icon_kind(),
                            OverlayPosition::TopRight,
                            OVERLAY_SIZE_RATIO,
                        )
                        .build()
                }
                fn create_hand_stat_upgrade_thumbnail(
                    width_height: Wh<Px>,
                    tower_kind: crate::game_state::tower::TowerKind,
                    stat_type: StatType,
                    operation_type: OperationType,
                ) -> RenderingTree {
                    ThumbnailComposer::new(width_height)
                        .with_tower_image(tower_kind)
                        .add_icon_overlay(
                            stat_type.to_icon_kind(),
                            OverlayPosition::BottomRight,
                            OVERLAY_SIZE_RATIO,
                        )
                        .add_icon_overlay(
                            operation_type.to_icon_kind(),
                            OverlayPosition::TopRight,
                            OVERLAY_SIZE_RATIO,
                        )
                        .build()
                }
                fn create_condition_stat_upgrade_thumbnail(
                    width_height: Wh<Px>,
                    condition_type: ConditionType,
                    stat_type: StatType,
                    operation_type: OperationType,
                ) -> RenderingTree {
                    let mut composer = ThumbnailComposer::new(width_height)
                        .with_default_tower()
                        .add_icon_overlay(
                            stat_type.to_icon_kind(),
                            OverlayPosition::BottomRight,
                            OVERLAY_SIZE_RATIO,
                        )
                        .add_icon_overlay(
                            operation_type.to_icon_kind(),
                            OverlayPosition::TopRight,
                            OVERLAY_SIZE_RATIO,
                        );
                    match condition_type {
                        ConditionType::LowCard => {
                            composer = composer.add_low_card_indicator();
                        }
                        ConditionType::NoReroll => {
                            composer = composer.add_no_reroll_indicator();
                        }
                        ConditionType::Reroll => {
                            composer = composer.add_reroll_indicator();
                        }
                    }
                    composer.build()
                }
                fn create_even_odd_stat_upgrade_thumbnail(
                    width_height: Wh<Px>,
                    is_even: bool,
                    stat_type: StatType,
                    operation_type: OperationType,
                ) -> RenderingTree {
                    ThumbnailComposer::new(width_height)
                        .with_default_tower()
                        .add_even_odd_indicator(is_even)
                        .add_icon_overlay(
                            stat_type.to_icon_kind(),
                            OverlayPosition::BottomRight,
                            OVERLAY_SIZE_RATIO,
                        )
                        .add_icon_overlay(
                            operation_type.to_icon_kind(),
                            OverlayPosition::TopRight,
                            OVERLAY_SIZE_RATIO,
                        )
                        .build()
                }
                fn create_face_number_stat_upgrade_thumbnail(
                    width_height: Wh<Px>,
                    is_face: bool,
                    stat_type: StatType,
                    operation_type: OperationType,
                ) -> RenderingTree {
                    ThumbnailComposer::new(width_height)
                        .with_default_tower()
                        .add_face_number_indicator(is_face)
                        .add_icon_overlay(
                            stat_type.to_icon_kind(),
                            OverlayPosition::BottomRight,
                            OVERLAY_SIZE_RATIO,
                        )
                        .add_icon_overlay(
                            operation_type.to_icon_kind(),
                            OverlayPosition::TopRight,
                            OVERLAY_SIZE_RATIO,
                        )
                        .build()
                }
            }
        }
        use super::tower::TowerKind;
        use crate::{
            card::{Rank, Suit},
            game_state::tower::Tower, rarity::Rarity, *,
        };
        pub use generation::*;
        use std::collections::BTreeMap;
        pub const MAX_GOLD_EARN_PLUS: usize = 16;
        pub const MAX_SHOP_SLOT_EXPAND: usize = 2;
        pub const MAX_QUEST_SLOT_EXPAND: usize = 2;
        pub const MAX_QUEST_BOARD_SLOT_EXPAND: usize = 2;
        pub const MAX_SHOP_REFRESH_CHANCE_PLUS: usize = 2;
        pub const MAX_QUEST_BOARD_REFRESH_CHANCE_PLUS: usize = 2;
        pub const MAX_REROLL_CHANCE_PLUS: usize = 2;
        pub const MAX_SHOP_ITEM_PRICE_MINUS_UPGRADE: usize = 15;
        pub struct UpgradeState {
            pub gold_earn_plus: usize,
            pub shop_slot_expand: usize,
            pub quest_slot_expand: usize,
            pub quest_board_slot_expand: usize,
            pub shop_refresh_chance_plus: usize,
            pub quest_board_refresh_chance_plus: usize,
            pub reroll_chance_plus: usize,
            pub tower_upgrade_states: BTreeMap<TowerUpgradeTarget, TowerUpgradeState>,
            pub tower_select_upgrade_states: BTreeMap<
                TowerSelectUpgradeTarget,
                TowerUpgradeState,
            >,
            pub shop_item_price_minus: usize,
            pub shorten_straight_flush_to_4_cards: bool,
            pub skip_rank_for_straight: bool,
            pub treat_suits_as_same: bool,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UpgradeState {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "gold_earn_plus",
                    "shop_slot_expand",
                    "quest_slot_expand",
                    "quest_board_slot_expand",
                    "shop_refresh_chance_plus",
                    "quest_board_refresh_chance_plus",
                    "reroll_chance_plus",
                    "tower_upgrade_states",
                    "tower_select_upgrade_states",
                    "shop_item_price_minus",
                    "shorten_straight_flush_to_4_cards",
                    "skip_rank_for_straight",
                    "treat_suits_as_same",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.gold_earn_plus,
                    &self.shop_slot_expand,
                    &self.quest_slot_expand,
                    &self.quest_board_slot_expand,
                    &self.shop_refresh_chance_plus,
                    &self.quest_board_refresh_chance_plus,
                    &self.reroll_chance_plus,
                    &self.tower_upgrade_states,
                    &self.tower_select_upgrade_states,
                    &self.shop_item_price_minus,
                    &self.shorten_straight_flush_to_4_cards,
                    &self.skip_rank_for_straight,
                    &&self.treat_suits_as_same,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "UpgradeState",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UpgradeState {
            #[inline]
            fn clone(&self) -> UpgradeState {
                UpgradeState {
                    gold_earn_plus: ::core::clone::Clone::clone(&self.gold_earn_plus),
                    shop_slot_expand: ::core::clone::Clone::clone(
                        &self.shop_slot_expand,
                    ),
                    quest_slot_expand: ::core::clone::Clone::clone(
                        &self.quest_slot_expand,
                    ),
                    quest_board_slot_expand: ::core::clone::Clone::clone(
                        &self.quest_board_slot_expand,
                    ),
                    shop_refresh_chance_plus: ::core::clone::Clone::clone(
                        &self.shop_refresh_chance_plus,
                    ),
                    quest_board_refresh_chance_plus: ::core::clone::Clone::clone(
                        &self.quest_board_refresh_chance_plus,
                    ),
                    reroll_chance_plus: ::core::clone::Clone::clone(
                        &self.reroll_chance_plus,
                    ),
                    tower_upgrade_states: ::core::clone::Clone::clone(
                        &self.tower_upgrade_states,
                    ),
                    tower_select_upgrade_states: ::core::clone::Clone::clone(
                        &self.tower_select_upgrade_states,
                    ),
                    shop_item_price_minus: ::core::clone::Clone::clone(
                        &self.shop_item_price_minus,
                    ),
                    shorten_straight_flush_to_4_cards: ::core::clone::Clone::clone(
                        &self.shorten_straight_flush_to_4_cards,
                    ),
                    skip_rank_for_straight: ::core::clone::Clone::clone(
                        &self.skip_rank_for_straight,
                    ),
                    treat_suits_as_same: ::core::clone::Clone::clone(
                        &self.treat_suits_as_same,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for UpgradeState {
            #[inline]
            fn default() -> UpgradeState {
                UpgradeState {
                    gold_earn_plus: ::core::default::Default::default(),
                    shop_slot_expand: ::core::default::Default::default(),
                    quest_slot_expand: ::core::default::Default::default(),
                    quest_board_slot_expand: ::core::default::Default::default(),
                    shop_refresh_chance_plus: ::core::default::Default::default(),
                    quest_board_refresh_chance_plus: ::core::default::Default::default(),
                    reroll_chance_plus: ::core::default::Default::default(),
                    tower_upgrade_states: ::core::default::Default::default(),
                    tower_select_upgrade_states: ::core::default::Default::default(),
                    shop_item_price_minus: ::core::default::Default::default(),
                    shorten_straight_flush_to_4_cards: ::core::default::Default::default(),
                    skip_rank_for_straight: ::core::default::Default::default(),
                    treat_suits_as_same: ::core::default::Default::default(),
                }
            }
        }
        impl bincode::Encode for UpgradeState {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.gold_earn_plus, encoder)?;
                bincode::Encode::encode(&self.shop_slot_expand, encoder)?;
                bincode::Encode::encode(&self.quest_slot_expand, encoder)?;
                bincode::Encode::encode(&self.quest_board_slot_expand, encoder)?;
                bincode::Encode::encode(&self.shop_refresh_chance_plus, encoder)?;
                bincode::Encode::encode(&self.quest_board_refresh_chance_plus, encoder)?;
                bincode::Encode::encode(&self.reroll_chance_plus, encoder)?;
                bincode::Encode::encode(&self.tower_upgrade_states, encoder)?;
                bincode::Encode::encode(&self.tower_select_upgrade_states, encoder)?;
                bincode::Encode::encode(&self.shop_item_price_minus, encoder)?;
                bincode::Encode::encode(
                    &self.shorten_straight_flush_to_4_cards,
                    encoder,
                )?;
                bincode::Encode::encode(&self.skip_rank_for_straight, encoder)?;
                bincode::Encode::encode(&self.treat_suits_as_same, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for UpgradeState {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    gold_earn_plus: bincode::Decode::decode(decoder)?,
                    shop_slot_expand: bincode::Decode::decode(decoder)?,
                    quest_slot_expand: bincode::Decode::decode(decoder)?,
                    quest_board_slot_expand: bincode::Decode::decode(decoder)?,
                    shop_refresh_chance_plus: bincode::Decode::decode(decoder)?,
                    quest_board_refresh_chance_plus: bincode::Decode::decode(decoder)?,
                    reroll_chance_plus: bincode::Decode::decode(decoder)?,
                    tower_upgrade_states: bincode::Decode::decode(decoder)?,
                    tower_select_upgrade_states: bincode::Decode::decode(decoder)?,
                    shop_item_price_minus: bincode::Decode::decode(decoder)?,
                    shorten_straight_flush_to_4_cards: bincode::Decode::decode(decoder)?,
                    skip_rank_for_straight: bincode::Decode::decode(decoder)?,
                    treat_suits_as_same: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for UpgradeState {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("gold_earn_plus");
                self.gold_earn_plus.serialize_without_name(buf);
                buf.write_string("shop_slot_expand");
                self.shop_slot_expand.serialize_without_name(buf);
                buf.write_string("quest_slot_expand");
                self.quest_slot_expand.serialize_without_name(buf);
                buf.write_string("quest_board_slot_expand");
                self.quest_board_slot_expand.serialize_without_name(buf);
                buf.write_string("shop_refresh_chance_plus");
                self.shop_refresh_chance_plus.serialize_without_name(buf);
                buf.write_string("quest_board_refresh_chance_plus");
                self.quest_board_refresh_chance_plus.serialize_without_name(buf);
                buf.write_string("reroll_chance_plus");
                self.reroll_chance_plus.serialize_without_name(buf);
                buf.write_string("tower_upgrade_states");
                self.tower_upgrade_states.serialize_without_name(buf);
                buf.write_string("tower_select_upgrade_states");
                self.tower_select_upgrade_states.serialize_without_name(buf);
                buf.write_string("shop_item_price_minus");
                self.shop_item_price_minus.serialize_without_name(buf);
                buf.write_string("shorten_straight_flush_to_4_cards");
                self.shorten_straight_flush_to_4_cards.serialize_without_name(buf);
                buf.write_string("skip_rank_for_straight");
                self.skip_rank_for_straight.serialize_without_name(buf);
                buf.write_string("treat_suits_as_same");
                self.treat_suits_as_same.serialize_without_name(buf);
            }
        }
        impl Deserialize for UpgradeState {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("gold_earn_plus")?;
                let gold_earn_plus = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("shop_slot_expand")?;
                let shop_slot_expand = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("quest_slot_expand")?;
                let quest_slot_expand = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("quest_board_slot_expand")?;
                let quest_board_slot_expand = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("shop_refresh_chance_plus")?;
                let shop_refresh_chance_plus = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("quest_board_refresh_chance_plus")?;
                let quest_board_refresh_chance_plus = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("reroll_chance_plus")?;
                let reroll_chance_plus = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("tower_upgrade_states")?;
                let tower_upgrade_states = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("tower_select_upgrade_states")?;
                let tower_select_upgrade_states = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("shop_item_price_minus")?;
                let shop_item_price_minus = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("shorten_straight_flush_to_4_cards")?;
                let shorten_straight_flush_to_4_cards = Deserialize::deserialize_without_name(
                    buf,
                )?;
                let field_name = buf.read_name("skip_rank_for_straight")?;
                let skip_rank_for_straight = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("treat_suits_as_same")?;
                let treat_suits_as_same = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    gold_earn_plus,
                    shop_slot_expand,
                    quest_slot_expand,
                    quest_board_slot_expand,
                    shop_refresh_chance_plus,
                    quest_board_refresh_chance_plus,
                    reroll_chance_plus,
                    tower_upgrade_states,
                    tower_select_upgrade_states,
                    shop_item_price_minus,
                    shorten_straight_flush_to_4_cards,
                    skip_rank_for_straight,
                    treat_suits_as_same,
                })
            }
        }
        pub struct Upgrade {
            pub kind: UpgradeKind,
            pub rarity: Rarity,
            pub value: crate::OneZero,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Upgrade {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Upgrade",
                    "kind",
                    &self.kind,
                    "rarity",
                    &self.rarity,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Upgrade {
            #[inline]
            fn clone(&self) -> Upgrade {
                let _: ::core::clone::AssertParamIsClone<UpgradeKind>;
                let _: ::core::clone::AssertParamIsClone<Rarity>;
                let _: ::core::clone::AssertParamIsClone<crate::OneZero>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Upgrade {}
        impl bincode::Encode for Upgrade {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.kind, encoder)?;
                bincode::Encode::encode(&self.rarity, encoder)?;
                bincode::Encode::encode(&self.value, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Upgrade {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    kind: bincode::Decode::decode(decoder)?,
                    rarity: bincode::Decode::decode(decoder)?,
                    value: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Upgrade {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("kind");
                self.kind.serialize_without_name(buf);
                buf.write_string("rarity");
                self.rarity.serialize_without_name(buf);
                buf.write_string("value");
                self.value.serialize_without_name(buf);
            }
        }
        impl Deserialize for Upgrade {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("kind")?;
                let kind = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("rarity")?;
                let rarity = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("value")?;
                let value = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { kind, rarity, value })
            }
        }
        impl UpgradeState {
            pub fn upgrade(&mut self, upgrade: Upgrade) {
                match upgrade.kind {
                    UpgradeKind::GoldEarnPlus => {
                        match self.gold_earn_plus {
                            0 => self.gold_earn_plus = 1,
                            1 => self.gold_earn_plus = 2,
                            2 => self.gold_earn_plus = 4,
                            4 => self.gold_earn_plus = 8,
                            8 => self.gold_earn_plus = 16,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "Invalid gold earn plus upgrade: {0}",
                                            self.gold_earn_plus,
                                        ),
                                    ),
                                );
                            }
                        }
                    }
                    UpgradeKind::RankAttackDamagePlus { rank, damage_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Rank { rank },
                            TowerUpgrade::DamagePlus {
                                damage: damage_plus,
                            },
                        );
                    }
                    UpgradeKind::RankAttackDamageMultiply {
                        rank,
                        damage_multiplier,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Rank { rank },
                            TowerUpgrade::DamageMultiplier {
                                multiplier: damage_multiplier,
                            },
                        );
                    }
                    UpgradeKind::RankAttackSpeedPlus { rank, speed_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Rank { rank },
                            TowerUpgrade::SpeedPlus {
                                speed: speed_plus,
                            },
                        );
                    }
                    UpgradeKind::RankAttackSpeedMultiply { rank, speed_multiplier } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Rank { rank },
                            TowerUpgrade::SpeedMultiplier {
                                multiplier: speed_multiplier,
                            },
                        );
                    }
                    UpgradeKind::RankAttackRangePlus { rank, range_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Rank { rank },
                            TowerUpgrade::RangePlus {
                                range: range_plus,
                            },
                        );
                    }
                    UpgradeKind::SuitAttackDamagePlus { suit, damage_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Suit { suit },
                            TowerUpgrade::DamagePlus {
                                damage: damage_plus,
                            },
                        );
                    }
                    UpgradeKind::SuitAttackDamageMultiply {
                        suit,
                        damage_multiplier,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Suit { suit },
                            TowerUpgrade::DamageMultiplier {
                                multiplier: damage_multiplier,
                            },
                        );
                    }
                    UpgradeKind::SuitAttackSpeedPlus { suit, speed_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Suit { suit },
                            TowerUpgrade::SpeedPlus {
                                speed: speed_plus,
                            },
                        );
                    }
                    UpgradeKind::SuitAttackSpeedMultiply { suit, speed_multiplier } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Suit { suit },
                            TowerUpgrade::SpeedMultiplier {
                                multiplier: speed_multiplier,
                            },
                        );
                    }
                    UpgradeKind::SuitAttackRangePlus { suit, range_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::Suit { suit },
                            TowerUpgrade::RangePlus {
                                range: range_plus,
                            },
                        );
                    }
                    UpgradeKind::HandAttackDamagePlus { tower_kind, damage_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::TowerKind {
                                tower_kind,
                            },
                            TowerUpgrade::DamagePlus {
                                damage: damage_plus,
                            },
                        );
                    }
                    UpgradeKind::HandAttackDamageMultiply {
                        tower_kind,
                        damage_multiplier,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::TowerKind {
                                tower_kind,
                            },
                            TowerUpgrade::DamageMultiplier {
                                multiplier: damage_multiplier,
                            },
                        );
                    }
                    UpgradeKind::HandAttackSpeedPlus { tower_kind, speed_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::TowerKind {
                                tower_kind,
                            },
                            TowerUpgrade::SpeedPlus {
                                speed: speed_plus,
                            },
                        );
                    }
                    UpgradeKind::HandAttackSpeedMultiply {
                        tower_kind,
                        speed_multiplier,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::TowerKind {
                                tower_kind,
                            },
                            TowerUpgrade::SpeedMultiplier {
                                multiplier: speed_multiplier,
                            },
                        );
                    }
                    UpgradeKind::HandAttackRangePlus { tower_kind, range_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::TowerKind {
                                tower_kind,
                            },
                            TowerUpgrade::RangePlus {
                                range: range_plus,
                            },
                        );
                    }
                    UpgradeKind::ShopSlotExpansion => {
                        match self.shop_slot_expand {
                            0 => self.shop_slot_expand = 1,
                            1 => self.shop_slot_expand = 2,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "Invalid shop slot upgrade: {0}",
                                            self.shop_slot_expand,
                                        ),
                                    ),
                                );
                            }
                        }
                    }
                    UpgradeKind::QuestSlotExpansion => {
                        match self.quest_slot_expand {
                            0 => self.quest_slot_expand = 1,
                            1 => self.quest_slot_expand = 2,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "Invalid quest slot upgrade: {0}",
                                            self.quest_slot_expand,
                                        ),
                                    ),
                                );
                            }
                        }
                    }
                    UpgradeKind::QuestBoardExpansion => {
                        match self.quest_board_slot_expand {
                            0 => self.quest_board_slot_expand = 1,
                            1 => self.quest_board_slot_expand = 2,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "Invalid quest board slot upgrade: {0}",
                                            self.quest_board_slot_expand,
                                        ),
                                    ),
                                );
                            }
                        }
                    }
                    UpgradeKind::RerollCountPlus => {
                        match self.reroll_chance_plus {
                            0 => self.reroll_chance_plus = 1,
                            1 => self.reroll_chance_plus = 2,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "Invalid reroll upgrade: {0}",
                                            self.reroll_chance_plus,
                                        ),
                                    ),
                                );
                            }
                        }
                    }
                    UpgradeKind::LowCardTowerDamagePlus { damage_plus } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::LowCard,
                            TowerUpgrade::DamagePlus {
                                damage: damage_plus,
                            },
                        );
                    }
                    UpgradeKind::LowCardTowerDamageMultiply { damage_multiplier } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::LowCard,
                            TowerUpgrade::DamageMultiplier {
                                multiplier: damage_multiplier,
                            },
                        );
                    }
                    UpgradeKind::LowCardTowerAttackSpeedPlus { speed_plus } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::LowCard,
                            TowerUpgrade::SpeedPlus {
                                speed: speed_plus,
                            },
                        );
                    }
                    UpgradeKind::LowCardTowerAttackSpeedMultiply {
                        speed_multiplier,
                    } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::LowCard,
                            TowerUpgrade::SpeedMultiplier {
                                multiplier: speed_multiplier,
                            },
                        );
                    }
                    UpgradeKind::LowCardTowerAttackRangePlus { range_plus } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::LowCard,
                            TowerUpgrade::RangePlus {
                                range: range_plus,
                            },
                        );
                    }
                    UpgradeKind::ShopItemPriceMinus => {
                        match self.shop_item_price_minus {
                            0 => self.shop_item_price_minus = 5,
                            5 => self.shop_item_price_minus = 10,
                            10 => self.shop_item_price_minus = 15,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "Invalid shop item price minus upgrade: {0}",
                                            self.shop_item_price_minus,
                                        ),
                                    ),
                                );
                            }
                        }
                    }
                    UpgradeKind::ShopRefreshPlus => {
                        match self.shop_refresh_chance_plus {
                            0 => self.shop_refresh_chance_plus = 1,
                            1 => self.shop_refresh_chance_plus = 2,
                            2 => self.shop_refresh_chance_plus = 3,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "Invalid shop refresh upgrade: {0}",
                                            self.shop_refresh_chance_plus,
                                        ),
                                    ),
                                );
                            }
                        }
                    }
                    UpgradeKind::QuestBoardRefreshPlus => {
                        match self.quest_board_refresh_chance_plus {
                            0 => self.quest_board_refresh_chance_plus = 1,
                            1 => self.quest_board_refresh_chance_plus = 2,
                            2 => self.quest_board_refresh_chance_plus = 3,
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!(
                                            "Invalid quest board refresh upgrade: {0}",
                                            self.quest_board_refresh_chance_plus,
                                        ),
                                    ),
                                );
                            }
                        }
                    }
                    UpgradeKind::NoRerollTowerAttackDamagePlus { damage_plus } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::NoReroll,
                            TowerUpgrade::DamagePlus {
                                damage: damage_plus,
                            },
                        );
                    }
                    UpgradeKind::NoRerollTowerAttackDamageMultiply {
                        damage_multiplier,
                    } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::NoReroll,
                            TowerUpgrade::DamageMultiplier {
                                multiplier: damage_multiplier,
                            },
                        );
                    }
                    UpgradeKind::NoRerollTowerAttackSpeedPlus { speed_plus } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::NoReroll,
                            TowerUpgrade::SpeedPlus {
                                speed: speed_plus,
                            },
                        );
                    }
                    UpgradeKind::NoRerollTowerAttackSpeedMultiply {
                        speed_multiplier,
                    } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::NoReroll,
                            TowerUpgrade::SpeedMultiplier {
                                multiplier: speed_multiplier,
                            },
                        );
                    }
                    UpgradeKind::NoRerollTowerAttackRangePlus { range_plus } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::NoReroll,
                            TowerUpgrade::RangePlus {
                                range: range_plus,
                            },
                        );
                    }
                    UpgradeKind::EvenOddTowerAttackDamagePlus { even, damage_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::EvenOdd {
                                even,
                            },
                            TowerUpgrade::DamagePlus {
                                damage: damage_plus,
                            },
                        );
                    }
                    UpgradeKind::EvenOddTowerAttackDamageMultiply {
                        even,
                        damage_multiplier,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::EvenOdd {
                                even,
                            },
                            TowerUpgrade::DamageMultiplier {
                                multiplier: damage_multiplier,
                            },
                        );
                    }
                    UpgradeKind::EvenOddTowerAttackSpeedPlus { even, speed_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::EvenOdd {
                                even,
                            },
                            TowerUpgrade::SpeedPlus {
                                speed: speed_plus,
                            },
                        );
                    }
                    UpgradeKind::EvenOddTowerAttackSpeedMultiply {
                        even,
                        speed_multiplier,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::EvenOdd {
                                even,
                            },
                            TowerUpgrade::SpeedMultiplier {
                                multiplier: speed_multiplier,
                            },
                        );
                    }
                    UpgradeKind::EvenOddTowerAttackRangePlus { even, range_plus } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::EvenOdd {
                                even,
                            },
                            TowerUpgrade::RangePlus {
                                range: range_plus,
                            },
                        );
                    }
                    UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                        face,
                        damage_plus,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::FaceNumber {
                                face,
                            },
                            TowerUpgrade::DamagePlus {
                                damage: damage_plus,
                            },
                        );
                    }
                    UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                        face,
                        damage_multiplier,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::FaceNumber {
                                face,
                            },
                            TowerUpgrade::DamageMultiplier {
                                multiplier: damage_multiplier,
                            },
                        );
                    }
                    UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                        face,
                        speed_plus,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::FaceNumber {
                                face,
                            },
                            TowerUpgrade::SpeedPlus {
                                speed: speed_plus,
                            },
                        );
                    }
                    UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                        face,
                        speed_multiplier,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::FaceNumber {
                                face,
                            },
                            TowerUpgrade::SpeedMultiplier {
                                multiplier: speed_multiplier,
                            },
                        );
                    }
                    UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                        face,
                        range_plus,
                    } => {
                        self.apply_tower_upgrade(
                            TowerUpgradeTarget::FaceNumber {
                                face,
                            },
                            TowerUpgrade::RangePlus {
                                range: range_plus,
                            },
                        );
                    }
                    UpgradeKind::ShortenStraightFlushTo4Cards => {
                        self.shorten_straight_flush_to_4_cards = true;
                    }
                    UpgradeKind::SkipRankForStraight => {
                        self.skip_rank_for_straight = true;
                    }
                    UpgradeKind::TreatSuitsAsSame => {
                        self.treat_suits_as_same = true;
                    }
                    UpgradeKind::RerollTowerAttackDamagePlus { damage_plus } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::Reroll,
                            TowerUpgrade::DamagePlus {
                                damage: damage_plus,
                            },
                        );
                    }
                    UpgradeKind::RerollTowerAttackDamageMultiply {
                        damage_multiplier,
                    } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::Reroll,
                            TowerUpgrade::DamageMultiplier {
                                multiplier: damage_multiplier,
                            },
                        );
                    }
                    UpgradeKind::RerollTowerAttackSpeedPlus { speed_plus } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::Reroll,
                            TowerUpgrade::SpeedPlus {
                                speed: speed_plus,
                            },
                        );
                    }
                    UpgradeKind::RerollTowerAttackSpeedMultiply { speed_multiplier } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::Reroll,
                            TowerUpgrade::SpeedMultiplier {
                                multiplier: speed_multiplier,
                            },
                        );
                    }
                    UpgradeKind::RerollTowerAttackRangePlus { range_plus } => {
                        self.apply_tower_select_upgrade(
                            TowerSelectUpgradeTarget::Reroll,
                            TowerUpgrade::RangePlus {
                                range: range_plus,
                            },
                        );
                    }
                }
            }
            pub fn tower_upgrades(&self, tower: &Tower) -> Vec<TowerUpgradeState> {
                [
                    TowerUpgradeTarget::Rank {
                        rank: tower.rank,
                    },
                    TowerUpgradeTarget::Suit {
                        suit: tower.suit,
                    },
                    TowerUpgradeTarget::TowerKind {
                        tower_kind: tower.kind,
                    },
                    TowerUpgradeTarget::EvenOdd {
                        even: tower.rank.is_even(),
                    },
                    TowerUpgradeTarget::FaceNumber {
                        face: tower.rank.is_face(),
                    },
                ]
                    .iter()
                    .map(|target| {
                        self.tower_upgrade_states
                            .get(target)
                            .copied()
                            .unwrap_or_default()
                    })
                    .collect::<Vec<_>>()
            }
            fn apply_tower_upgrade(
                &mut self,
                target: TowerUpgradeTarget,
                upgrade: TowerUpgrade,
            ) {
                self.tower_upgrade_states
                    .entry(target)
                    .or_default()
                    .apply_upgrade(upgrade);
            }
            fn apply_tower_select_upgrade(
                &mut self,
                target: TowerSelectUpgradeTarget,
                upgrade: TowerUpgrade,
            ) {
                self.tower_select_upgrade_states
                    .entry(target)
                    .or_default()
                    .apply_upgrade(upgrade);
            }
        }
        pub enum UpgradeKind {
            GoldEarnPlus,
            RankAttackDamagePlus { rank: Rank, damage_plus: f32 },
            RankAttackDamageMultiply { rank: Rank, damage_multiplier: f32 },
            RankAttackSpeedPlus { rank: Rank, speed_plus: f32 },
            RankAttackSpeedMultiply { rank: Rank, speed_multiplier: f32 },
            RankAttackRangePlus { rank: Rank, range_plus: f32 },
            SuitAttackDamagePlus { suit: Suit, damage_plus: f32 },
            SuitAttackDamageMultiply { suit: Suit, damage_multiplier: f32 },
            SuitAttackSpeedPlus { suit: Suit, speed_plus: f32 },
            SuitAttackSpeedMultiply { suit: Suit, speed_multiplier: f32 },
            SuitAttackRangePlus { suit: Suit, range_plus: f32 },
            HandAttackDamagePlus { tower_kind: TowerKind, damage_plus: f32 },
            HandAttackDamageMultiply { tower_kind: TowerKind, damage_multiplier: f32 },
            HandAttackSpeedPlus { tower_kind: TowerKind, speed_plus: f32 },
            HandAttackSpeedMultiply { tower_kind: TowerKind, speed_multiplier: f32 },
            HandAttackRangePlus { tower_kind: TowerKind, range_plus: f32 },
            ShopSlotExpansion,
            QuestSlotExpansion,
            QuestBoardExpansion,
            RerollCountPlus,
            LowCardTowerDamagePlus { damage_plus: f32 },
            LowCardTowerDamageMultiply { damage_multiplier: f32 },
            LowCardTowerAttackSpeedPlus { speed_plus: f32 },
            LowCardTowerAttackSpeedMultiply { speed_multiplier: f32 },
            LowCardTowerAttackRangePlus { range_plus: f32 },
            ShopItemPriceMinus,
            ShopRefreshPlus,
            QuestBoardRefreshPlus,
            NoRerollTowerAttackDamagePlus { damage_plus: f32 },
            NoRerollTowerAttackDamageMultiply { damage_multiplier: f32 },
            NoRerollTowerAttackSpeedPlus { speed_plus: f32 },
            NoRerollTowerAttackSpeedMultiply { speed_multiplier: f32 },
            NoRerollTowerAttackRangePlus { range_plus: f32 },
            EvenOddTowerAttackDamagePlus { even: bool, damage_plus: f32 },
            EvenOddTowerAttackDamageMultiply { even: bool, damage_multiplier: f32 },
            EvenOddTowerAttackSpeedPlus { even: bool, speed_plus: f32 },
            EvenOddTowerAttackSpeedMultiply { even: bool, speed_multiplier: f32 },
            EvenOddTowerAttackRangePlus { even: bool, range_plus: f32 },
            FaceNumberCardTowerAttackDamagePlus { face: bool, damage_plus: f32 },
            FaceNumberCardTowerAttackDamageMultiply {
                face: bool,
                damage_multiplier: f32,
            },
            FaceNumberCardTowerAttackSpeedPlus { face: bool, speed_plus: f32 },
            FaceNumberCardTowerAttackSpeedMultiply { face: bool, speed_multiplier: f32 },
            FaceNumberCardTowerAttackRangePlus { face: bool, range_plus: f32 },
            ShortenStraightFlushTo4Cards,
            SkipRankForStraight,
            TreatSuitsAsSame,
            RerollTowerAttackDamagePlus { damage_plus: f32 },
            RerollTowerAttackDamageMultiply { damage_multiplier: f32 },
            RerollTowerAttackSpeedPlus { speed_plus: f32 },
            RerollTowerAttackSpeedMultiply { speed_multiplier: f32 },
            RerollTowerAttackRangePlus { range_plus: f32 },
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UpgradeKind {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    UpgradeKind::GoldEarnPlus => {
                        ::core::fmt::Formatter::write_str(f, "GoldEarnPlus")
                    }
                    UpgradeKind::RankAttackDamagePlus {
                        rank: __self_0,
                        damage_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "RankAttackDamagePlus",
                            "rank",
                            __self_0,
                            "damage_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::RankAttackDamageMultiply {
                        rank: __self_0,
                        damage_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "RankAttackDamageMultiply",
                            "rank",
                            __self_0,
                            "damage_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::RankAttackSpeedPlus {
                        rank: __self_0,
                        speed_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "RankAttackSpeedPlus",
                            "rank",
                            __self_0,
                            "speed_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::RankAttackSpeedMultiply {
                        rank: __self_0,
                        speed_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "RankAttackSpeedMultiply",
                            "rank",
                            __self_0,
                            "speed_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::RankAttackRangePlus {
                        rank: __self_0,
                        range_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "RankAttackRangePlus",
                            "rank",
                            __self_0,
                            "range_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::SuitAttackDamagePlus {
                        suit: __self_0,
                        damage_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "SuitAttackDamagePlus",
                            "suit",
                            __self_0,
                            "damage_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::SuitAttackDamageMultiply {
                        suit: __self_0,
                        damage_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "SuitAttackDamageMultiply",
                            "suit",
                            __self_0,
                            "damage_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::SuitAttackSpeedPlus {
                        suit: __self_0,
                        speed_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "SuitAttackSpeedPlus",
                            "suit",
                            __self_0,
                            "speed_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::SuitAttackSpeedMultiply {
                        suit: __self_0,
                        speed_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "SuitAttackSpeedMultiply",
                            "suit",
                            __self_0,
                            "speed_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::SuitAttackRangePlus {
                        suit: __self_0,
                        range_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "SuitAttackRangePlus",
                            "suit",
                            __self_0,
                            "range_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::HandAttackDamagePlus {
                        tower_kind: __self_0,
                        damage_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "HandAttackDamagePlus",
                            "tower_kind",
                            __self_0,
                            "damage_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::HandAttackDamageMultiply {
                        tower_kind: __self_0,
                        damage_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "HandAttackDamageMultiply",
                            "tower_kind",
                            __self_0,
                            "damage_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::HandAttackSpeedPlus {
                        tower_kind: __self_0,
                        speed_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "HandAttackSpeedPlus",
                            "tower_kind",
                            __self_0,
                            "speed_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::HandAttackSpeedMultiply {
                        tower_kind: __self_0,
                        speed_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "HandAttackSpeedMultiply",
                            "tower_kind",
                            __self_0,
                            "speed_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::HandAttackRangePlus {
                        tower_kind: __self_0,
                        range_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "HandAttackRangePlus",
                            "tower_kind",
                            __self_0,
                            "range_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::ShopSlotExpansion => {
                        ::core::fmt::Formatter::write_str(f, "ShopSlotExpansion")
                    }
                    UpgradeKind::QuestSlotExpansion => {
                        ::core::fmt::Formatter::write_str(f, "QuestSlotExpansion")
                    }
                    UpgradeKind::QuestBoardExpansion => {
                        ::core::fmt::Formatter::write_str(f, "QuestBoardExpansion")
                    }
                    UpgradeKind::RerollCountPlus => {
                        ::core::fmt::Formatter::write_str(f, "RerollCountPlus")
                    }
                    UpgradeKind::LowCardTowerDamagePlus { damage_plus: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "LowCardTowerDamagePlus",
                            "damage_plus",
                            &__self_0,
                        )
                    }
                    UpgradeKind::LowCardTowerDamageMultiply {
                        damage_multiplier: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "LowCardTowerDamageMultiply",
                            "damage_multiplier",
                            &__self_0,
                        )
                    }
                    UpgradeKind::LowCardTowerAttackSpeedPlus { speed_plus: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "LowCardTowerAttackSpeedPlus",
                            "speed_plus",
                            &__self_0,
                        )
                    }
                    UpgradeKind::LowCardTowerAttackSpeedMultiply {
                        speed_multiplier: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "LowCardTowerAttackSpeedMultiply",
                            "speed_multiplier",
                            &__self_0,
                        )
                    }
                    UpgradeKind::LowCardTowerAttackRangePlus { range_plus: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "LowCardTowerAttackRangePlus",
                            "range_plus",
                            &__self_0,
                        )
                    }
                    UpgradeKind::ShopItemPriceMinus => {
                        ::core::fmt::Formatter::write_str(f, "ShopItemPriceMinus")
                    }
                    UpgradeKind::ShopRefreshPlus => {
                        ::core::fmt::Formatter::write_str(f, "ShopRefreshPlus")
                    }
                    UpgradeKind::QuestBoardRefreshPlus => {
                        ::core::fmt::Formatter::write_str(f, "QuestBoardRefreshPlus")
                    }
                    UpgradeKind::NoRerollTowerAttackDamagePlus {
                        damage_plus: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "NoRerollTowerAttackDamagePlus",
                            "damage_plus",
                            &__self_0,
                        )
                    }
                    UpgradeKind::NoRerollTowerAttackDamageMultiply {
                        damage_multiplier: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "NoRerollTowerAttackDamageMultiply",
                            "damage_multiplier",
                            &__self_0,
                        )
                    }
                    UpgradeKind::NoRerollTowerAttackSpeedPlus {
                        speed_plus: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "NoRerollTowerAttackSpeedPlus",
                            "speed_plus",
                            &__self_0,
                        )
                    }
                    UpgradeKind::NoRerollTowerAttackSpeedMultiply {
                        speed_multiplier: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "NoRerollTowerAttackSpeedMultiply",
                            "speed_multiplier",
                            &__self_0,
                        )
                    }
                    UpgradeKind::NoRerollTowerAttackRangePlus {
                        range_plus: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "NoRerollTowerAttackRangePlus",
                            "range_plus",
                            &__self_0,
                        )
                    }
                    UpgradeKind::EvenOddTowerAttackDamagePlus {
                        even: __self_0,
                        damage_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "EvenOddTowerAttackDamagePlus",
                            "even",
                            __self_0,
                            "damage_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::EvenOddTowerAttackDamageMultiply {
                        even: __self_0,
                        damage_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "EvenOddTowerAttackDamageMultiply",
                            "even",
                            __self_0,
                            "damage_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::EvenOddTowerAttackSpeedPlus {
                        even: __self_0,
                        speed_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "EvenOddTowerAttackSpeedPlus",
                            "even",
                            __self_0,
                            "speed_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::EvenOddTowerAttackSpeedMultiply {
                        even: __self_0,
                        speed_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "EvenOddTowerAttackSpeedMultiply",
                            "even",
                            __self_0,
                            "speed_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::EvenOddTowerAttackRangePlus {
                        even: __self_0,
                        range_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "EvenOddTowerAttackRangePlus",
                            "even",
                            __self_0,
                            "range_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                        face: __self_0,
                        damage_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "FaceNumberCardTowerAttackDamagePlus",
                            "face",
                            __self_0,
                            "damage_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                        face: __self_0,
                        damage_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "FaceNumberCardTowerAttackDamageMultiply",
                            "face",
                            __self_0,
                            "damage_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                        face: __self_0,
                        speed_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "FaceNumberCardTowerAttackSpeedPlus",
                            "face",
                            __self_0,
                            "speed_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                        face: __self_0,
                        speed_multiplier: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "FaceNumberCardTowerAttackSpeedMultiply",
                            "face",
                            __self_0,
                            "speed_multiplier",
                            &__self_1,
                        )
                    }
                    UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                        face: __self_0,
                        range_plus: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "FaceNumberCardTowerAttackRangePlus",
                            "face",
                            __self_0,
                            "range_plus",
                            &__self_1,
                        )
                    }
                    UpgradeKind::ShortenStraightFlushTo4Cards => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "ShortenStraightFlushTo4Cards",
                        )
                    }
                    UpgradeKind::SkipRankForStraight => {
                        ::core::fmt::Formatter::write_str(f, "SkipRankForStraight")
                    }
                    UpgradeKind::TreatSuitsAsSame => {
                        ::core::fmt::Formatter::write_str(f, "TreatSuitsAsSame")
                    }
                    UpgradeKind::RerollTowerAttackDamagePlus {
                        damage_plus: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RerollTowerAttackDamagePlus",
                            "damage_plus",
                            &__self_0,
                        )
                    }
                    UpgradeKind::RerollTowerAttackDamageMultiply {
                        damage_multiplier: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RerollTowerAttackDamageMultiply",
                            "damage_multiplier",
                            &__self_0,
                        )
                    }
                    UpgradeKind::RerollTowerAttackSpeedPlus { speed_plus: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RerollTowerAttackSpeedPlus",
                            "speed_plus",
                            &__self_0,
                        )
                    }
                    UpgradeKind::RerollTowerAttackSpeedMultiply {
                        speed_multiplier: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RerollTowerAttackSpeedMultiply",
                            "speed_multiplier",
                            &__self_0,
                        )
                    }
                    UpgradeKind::RerollTowerAttackRangePlus { range_plus: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RerollTowerAttackRangePlus",
                            "range_plus",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UpgradeKind {
            #[inline]
            fn clone(&self) -> UpgradeKind {
                let _: ::core::clone::AssertParamIsClone<Rank>;
                let _: ::core::clone::AssertParamIsClone<f32>;
                let _: ::core::clone::AssertParamIsClone<Suit>;
                let _: ::core::clone::AssertParamIsClone<TowerKind>;
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for UpgradeKind {}
        impl bincode::Encode for UpgradeKind {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::GoldEarnPlus => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::RankAttackDamagePlus { rank, damage_plus } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                        bincode::Encode::encode(damage_plus, encoder)?;
                    }
                    Self::RankAttackDamageMultiply { rank, damage_multiplier } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                        bincode::Encode::encode(damage_multiplier, encoder)?;
                    }
                    Self::RankAttackSpeedPlus { rank, speed_plus } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                        bincode::Encode::encode(speed_plus, encoder)?;
                    }
                    Self::RankAttackSpeedMultiply { rank, speed_multiplier } => {
                        bincode::Encode::encode(&4u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                        bincode::Encode::encode(speed_multiplier, encoder)?;
                    }
                    Self::RankAttackRangePlus { rank, range_plus } => {
                        bincode::Encode::encode(&5u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                        bincode::Encode::encode(range_plus, encoder)?;
                    }
                    Self::SuitAttackDamagePlus { suit, damage_plus } => {
                        bincode::Encode::encode(&6u32, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                        bincode::Encode::encode(damage_plus, encoder)?;
                    }
                    Self::SuitAttackDamageMultiply { suit, damage_multiplier } => {
                        bincode::Encode::encode(&7u32, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                        bincode::Encode::encode(damage_multiplier, encoder)?;
                    }
                    Self::SuitAttackSpeedPlus { suit, speed_plus } => {
                        bincode::Encode::encode(&8u32, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                        bincode::Encode::encode(speed_plus, encoder)?;
                    }
                    Self::SuitAttackSpeedMultiply { suit, speed_multiplier } => {
                        bincode::Encode::encode(&9u32, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                        bincode::Encode::encode(speed_multiplier, encoder)?;
                    }
                    Self::SuitAttackRangePlus { suit, range_plus } => {
                        bincode::Encode::encode(&10u32, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                        bincode::Encode::encode(range_plus, encoder)?;
                    }
                    Self::HandAttackDamagePlus { tower_kind, damage_plus } => {
                        bincode::Encode::encode(&11u32, encoder)?;
                        bincode::Encode::encode(tower_kind, encoder)?;
                        bincode::Encode::encode(damage_plus, encoder)?;
                    }
                    Self::HandAttackDamageMultiply { tower_kind, damage_multiplier } => {
                        bincode::Encode::encode(&12u32, encoder)?;
                        bincode::Encode::encode(tower_kind, encoder)?;
                        bincode::Encode::encode(damage_multiplier, encoder)?;
                    }
                    Self::HandAttackSpeedPlus { tower_kind, speed_plus } => {
                        bincode::Encode::encode(&13u32, encoder)?;
                        bincode::Encode::encode(tower_kind, encoder)?;
                        bincode::Encode::encode(speed_plus, encoder)?;
                    }
                    Self::HandAttackSpeedMultiply { tower_kind, speed_multiplier } => {
                        bincode::Encode::encode(&14u32, encoder)?;
                        bincode::Encode::encode(tower_kind, encoder)?;
                        bincode::Encode::encode(speed_multiplier, encoder)?;
                    }
                    Self::HandAttackRangePlus { tower_kind, range_plus } => {
                        bincode::Encode::encode(&15u32, encoder)?;
                        bincode::Encode::encode(tower_kind, encoder)?;
                        bincode::Encode::encode(range_plus, encoder)?;
                    }
                    Self::ShopSlotExpansion => {
                        bincode::Encode::encode(&16u32, encoder)?;
                    }
                    Self::QuestSlotExpansion => {
                        bincode::Encode::encode(&17u32, encoder)?;
                    }
                    Self::QuestBoardExpansion => {
                        bincode::Encode::encode(&18u32, encoder)?;
                    }
                    Self::RerollCountPlus => {
                        bincode::Encode::encode(&19u32, encoder)?;
                    }
                    Self::LowCardTowerDamagePlus { damage_plus } => {
                        bincode::Encode::encode(&20u32, encoder)?;
                        bincode::Encode::encode(damage_plus, encoder)?;
                    }
                    Self::LowCardTowerDamageMultiply { damage_multiplier } => {
                        bincode::Encode::encode(&21u32, encoder)?;
                        bincode::Encode::encode(damage_multiplier, encoder)?;
                    }
                    Self::LowCardTowerAttackSpeedPlus { speed_plus } => {
                        bincode::Encode::encode(&22u32, encoder)?;
                        bincode::Encode::encode(speed_plus, encoder)?;
                    }
                    Self::LowCardTowerAttackSpeedMultiply { speed_multiplier } => {
                        bincode::Encode::encode(&23u32, encoder)?;
                        bincode::Encode::encode(speed_multiplier, encoder)?;
                    }
                    Self::LowCardTowerAttackRangePlus { range_plus } => {
                        bincode::Encode::encode(&24u32, encoder)?;
                        bincode::Encode::encode(range_plus, encoder)?;
                    }
                    Self::ShopItemPriceMinus => {
                        bincode::Encode::encode(&25u32, encoder)?;
                    }
                    Self::ShopRefreshPlus => {
                        bincode::Encode::encode(&26u32, encoder)?;
                    }
                    Self::QuestBoardRefreshPlus => {
                        bincode::Encode::encode(&27u32, encoder)?;
                    }
                    Self::NoRerollTowerAttackDamagePlus { damage_plus } => {
                        bincode::Encode::encode(&28u32, encoder)?;
                        bincode::Encode::encode(damage_plus, encoder)?;
                    }
                    Self::NoRerollTowerAttackDamageMultiply { damage_multiplier } => {
                        bincode::Encode::encode(&29u32, encoder)?;
                        bincode::Encode::encode(damage_multiplier, encoder)?;
                    }
                    Self::NoRerollTowerAttackSpeedPlus { speed_plus } => {
                        bincode::Encode::encode(&30u32, encoder)?;
                        bincode::Encode::encode(speed_plus, encoder)?;
                    }
                    Self::NoRerollTowerAttackSpeedMultiply { speed_multiplier } => {
                        bincode::Encode::encode(&31u32, encoder)?;
                        bincode::Encode::encode(speed_multiplier, encoder)?;
                    }
                    Self::NoRerollTowerAttackRangePlus { range_plus } => {
                        bincode::Encode::encode(&32u32, encoder)?;
                        bincode::Encode::encode(range_plus, encoder)?;
                    }
                    Self::EvenOddTowerAttackDamagePlus { even, damage_plus } => {
                        bincode::Encode::encode(&33u32, encoder)?;
                        bincode::Encode::encode(even, encoder)?;
                        bincode::Encode::encode(damage_plus, encoder)?;
                    }
                    Self::EvenOddTowerAttackDamageMultiply {
                        even,
                        damage_multiplier,
                    } => {
                        bincode::Encode::encode(&34u32, encoder)?;
                        bincode::Encode::encode(even, encoder)?;
                        bincode::Encode::encode(damage_multiplier, encoder)?;
                    }
                    Self::EvenOddTowerAttackSpeedPlus { even, speed_plus } => {
                        bincode::Encode::encode(&35u32, encoder)?;
                        bincode::Encode::encode(even, encoder)?;
                        bincode::Encode::encode(speed_plus, encoder)?;
                    }
                    Self::EvenOddTowerAttackSpeedMultiply { even, speed_multiplier } => {
                        bincode::Encode::encode(&36u32, encoder)?;
                        bincode::Encode::encode(even, encoder)?;
                        bincode::Encode::encode(speed_multiplier, encoder)?;
                    }
                    Self::EvenOddTowerAttackRangePlus { even, range_plus } => {
                        bincode::Encode::encode(&37u32, encoder)?;
                        bincode::Encode::encode(even, encoder)?;
                        bincode::Encode::encode(range_plus, encoder)?;
                    }
                    Self::FaceNumberCardTowerAttackDamagePlus { face, damage_plus } => {
                        bincode::Encode::encode(&38u32, encoder)?;
                        bincode::Encode::encode(face, encoder)?;
                        bincode::Encode::encode(damage_plus, encoder)?;
                    }
                    Self::FaceNumberCardTowerAttackDamageMultiply {
                        face,
                        damage_multiplier,
                    } => {
                        bincode::Encode::encode(&39u32, encoder)?;
                        bincode::Encode::encode(face, encoder)?;
                        bincode::Encode::encode(damage_multiplier, encoder)?;
                    }
                    Self::FaceNumberCardTowerAttackSpeedPlus { face, speed_plus } => {
                        bincode::Encode::encode(&40u32, encoder)?;
                        bincode::Encode::encode(face, encoder)?;
                        bincode::Encode::encode(speed_plus, encoder)?;
                    }
                    Self::FaceNumberCardTowerAttackSpeedMultiply {
                        face,
                        speed_multiplier,
                    } => {
                        bincode::Encode::encode(&41u32, encoder)?;
                        bincode::Encode::encode(face, encoder)?;
                        bincode::Encode::encode(speed_multiplier, encoder)?;
                    }
                    Self::FaceNumberCardTowerAttackRangePlus { face, range_plus } => {
                        bincode::Encode::encode(&42u32, encoder)?;
                        bincode::Encode::encode(face, encoder)?;
                        bincode::Encode::encode(range_plus, encoder)?;
                    }
                    Self::ShortenStraightFlushTo4Cards => {
                        bincode::Encode::encode(&43u32, encoder)?;
                    }
                    Self::SkipRankForStraight => {
                        bincode::Encode::encode(&44u32, encoder)?;
                    }
                    Self::TreatSuitsAsSame => {
                        bincode::Encode::encode(&45u32, encoder)?;
                    }
                    Self::RerollTowerAttackDamagePlus { damage_plus } => {
                        bincode::Encode::encode(&46u32, encoder)?;
                        bincode::Encode::encode(damage_plus, encoder)?;
                    }
                    Self::RerollTowerAttackDamageMultiply { damage_multiplier } => {
                        bincode::Encode::encode(&47u32, encoder)?;
                        bincode::Encode::encode(damage_multiplier, encoder)?;
                    }
                    Self::RerollTowerAttackSpeedPlus { speed_plus } => {
                        bincode::Encode::encode(&48u32, encoder)?;
                        bincode::Encode::encode(speed_plus, encoder)?;
                    }
                    Self::RerollTowerAttackSpeedMultiply { speed_multiplier } => {
                        bincode::Encode::encode(&49u32, encoder)?;
                        bincode::Encode::encode(speed_multiplier, encoder)?;
                    }
                    Self::RerollTowerAttackRangePlus { range_plus } => {
                        bincode::Encode::encode(&50u32, encoder)?;
                        bincode::Encode::encode(range_plus, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for UpgradeKind {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::GoldEarnPlus),
                    1u32 => {
                        Ok(Self::RankAttackDamagePlus {
                            rank: bincode::Decode::decode(decoder)?,
                            damage_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => {
                        Ok(Self::RankAttackDamageMultiply {
                            rank: bincode::Decode::decode(decoder)?,
                            damage_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    3u32 => {
                        Ok(Self::RankAttackSpeedPlus {
                            rank: bincode::Decode::decode(decoder)?,
                            speed_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    4u32 => {
                        Ok(Self::RankAttackSpeedMultiply {
                            rank: bincode::Decode::decode(decoder)?,
                            speed_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    5u32 => {
                        Ok(Self::RankAttackRangePlus {
                            rank: bincode::Decode::decode(decoder)?,
                            range_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    6u32 => {
                        Ok(Self::SuitAttackDamagePlus {
                            suit: bincode::Decode::decode(decoder)?,
                            damage_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    7u32 => {
                        Ok(Self::SuitAttackDamageMultiply {
                            suit: bincode::Decode::decode(decoder)?,
                            damage_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    8u32 => {
                        Ok(Self::SuitAttackSpeedPlus {
                            suit: bincode::Decode::decode(decoder)?,
                            speed_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    9u32 => {
                        Ok(Self::SuitAttackSpeedMultiply {
                            suit: bincode::Decode::decode(decoder)?,
                            speed_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    10u32 => {
                        Ok(Self::SuitAttackRangePlus {
                            suit: bincode::Decode::decode(decoder)?,
                            range_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    11u32 => {
                        Ok(Self::HandAttackDamagePlus {
                            tower_kind: bincode::Decode::decode(decoder)?,
                            damage_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    12u32 => {
                        Ok(Self::HandAttackDamageMultiply {
                            tower_kind: bincode::Decode::decode(decoder)?,
                            damage_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    13u32 => {
                        Ok(Self::HandAttackSpeedPlus {
                            tower_kind: bincode::Decode::decode(decoder)?,
                            speed_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    14u32 => {
                        Ok(Self::HandAttackSpeedMultiply {
                            tower_kind: bincode::Decode::decode(decoder)?,
                            speed_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    15u32 => {
                        Ok(Self::HandAttackRangePlus {
                            tower_kind: bincode::Decode::decode(decoder)?,
                            range_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    16u32 => Ok(Self::ShopSlotExpansion),
                    17u32 => Ok(Self::QuestSlotExpansion),
                    18u32 => Ok(Self::QuestBoardExpansion),
                    19u32 => Ok(Self::RerollCountPlus),
                    20u32 => {
                        Ok(Self::LowCardTowerDamagePlus {
                            damage_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    21u32 => {
                        Ok(Self::LowCardTowerDamageMultiply {
                            damage_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    22u32 => {
                        Ok(Self::LowCardTowerAttackSpeedPlus {
                            speed_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    23u32 => {
                        Ok(Self::LowCardTowerAttackSpeedMultiply {
                            speed_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    24u32 => {
                        Ok(Self::LowCardTowerAttackRangePlus {
                            range_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    25u32 => Ok(Self::ShopItemPriceMinus),
                    26u32 => Ok(Self::ShopRefreshPlus),
                    27u32 => Ok(Self::QuestBoardRefreshPlus),
                    28u32 => {
                        Ok(Self::NoRerollTowerAttackDamagePlus {
                            damage_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    29u32 => {
                        Ok(Self::NoRerollTowerAttackDamageMultiply {
                            damage_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    30u32 => {
                        Ok(Self::NoRerollTowerAttackSpeedPlus {
                            speed_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    31u32 => {
                        Ok(Self::NoRerollTowerAttackSpeedMultiply {
                            speed_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    32u32 => {
                        Ok(Self::NoRerollTowerAttackRangePlus {
                            range_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    33u32 => {
                        Ok(Self::EvenOddTowerAttackDamagePlus {
                            even: bincode::Decode::decode(decoder)?,
                            damage_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    34u32 => {
                        Ok(Self::EvenOddTowerAttackDamageMultiply {
                            even: bincode::Decode::decode(decoder)?,
                            damage_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    35u32 => {
                        Ok(Self::EvenOddTowerAttackSpeedPlus {
                            even: bincode::Decode::decode(decoder)?,
                            speed_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    36u32 => {
                        Ok(Self::EvenOddTowerAttackSpeedMultiply {
                            even: bincode::Decode::decode(decoder)?,
                            speed_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    37u32 => {
                        Ok(Self::EvenOddTowerAttackRangePlus {
                            even: bincode::Decode::decode(decoder)?,
                            range_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    38u32 => {
                        Ok(Self::FaceNumberCardTowerAttackDamagePlus {
                            face: bincode::Decode::decode(decoder)?,
                            damage_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    39u32 => {
                        Ok(Self::FaceNumberCardTowerAttackDamageMultiply {
                            face: bincode::Decode::decode(decoder)?,
                            damage_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    40u32 => {
                        Ok(Self::FaceNumberCardTowerAttackSpeedPlus {
                            face: bincode::Decode::decode(decoder)?,
                            speed_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    41u32 => {
                        Ok(Self::FaceNumberCardTowerAttackSpeedMultiply {
                            face: bincode::Decode::decode(decoder)?,
                            speed_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    42u32 => {
                        Ok(Self::FaceNumberCardTowerAttackRangePlus {
                            face: bincode::Decode::decode(decoder)?,
                            range_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    43u32 => Ok(Self::ShortenStraightFlushTo4Cards),
                    44u32 => Ok(Self::SkipRankForStraight),
                    45u32 => Ok(Self::TreatSuitsAsSame),
                    46u32 => {
                        Ok(Self::RerollTowerAttackDamagePlus {
                            damage_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    47u32 => {
                        Ok(Self::RerollTowerAttackDamageMultiply {
                            damage_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    48u32 => {
                        Ok(Self::RerollTowerAttackSpeedPlus {
                            speed_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    49u32 => {
                        Ok(Self::RerollTowerAttackSpeedMultiply {
                            speed_multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    50u32 => {
                        Ok(Self::RerollTowerAttackRangePlus {
                            range_plus: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 50u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for UpgradeKind {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::GoldEarnPlus => {
                        buf.write_string("GoldEarnPlus");
                    }
                    Self::RankAttackDamagePlus { rank, damage_plus } => {
                        buf.write_string("RankAttackDamagePlus");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                        buf.write_string("damage_plus");
                        damage_plus.serialize_without_name(buf);
                    }
                    Self::RankAttackDamageMultiply { rank, damage_multiplier } => {
                        buf.write_string("RankAttackDamageMultiply");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                        buf.write_string("damage_multiplier");
                        damage_multiplier.serialize_without_name(buf);
                    }
                    Self::RankAttackSpeedPlus { rank, speed_plus } => {
                        buf.write_string("RankAttackSpeedPlus");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                        buf.write_string("speed_plus");
                        speed_plus.serialize_without_name(buf);
                    }
                    Self::RankAttackSpeedMultiply { rank, speed_multiplier } => {
                        buf.write_string("RankAttackSpeedMultiply");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                        buf.write_string("speed_multiplier");
                        speed_multiplier.serialize_without_name(buf);
                    }
                    Self::RankAttackRangePlus { rank, range_plus } => {
                        buf.write_string("RankAttackRangePlus");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                        buf.write_string("range_plus");
                        range_plus.serialize_without_name(buf);
                    }
                    Self::SuitAttackDamagePlus { suit, damage_plus } => {
                        buf.write_string("SuitAttackDamagePlus");
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                        buf.write_string("damage_plus");
                        damage_plus.serialize_without_name(buf);
                    }
                    Self::SuitAttackDamageMultiply { suit, damage_multiplier } => {
                        buf.write_string("SuitAttackDamageMultiply");
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                        buf.write_string("damage_multiplier");
                        damage_multiplier.serialize_without_name(buf);
                    }
                    Self::SuitAttackSpeedPlus { suit, speed_plus } => {
                        buf.write_string("SuitAttackSpeedPlus");
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                        buf.write_string("speed_plus");
                        speed_plus.serialize_without_name(buf);
                    }
                    Self::SuitAttackSpeedMultiply { suit, speed_multiplier } => {
                        buf.write_string("SuitAttackSpeedMultiply");
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                        buf.write_string("speed_multiplier");
                        speed_multiplier.serialize_without_name(buf);
                    }
                    Self::SuitAttackRangePlus { suit, range_plus } => {
                        buf.write_string("SuitAttackRangePlus");
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                        buf.write_string("range_plus");
                        range_plus.serialize_without_name(buf);
                    }
                    Self::HandAttackDamagePlus { tower_kind, damage_plus } => {
                        buf.write_string("HandAttackDamagePlus");
                        buf.write_string("tower_kind");
                        tower_kind.serialize_without_name(buf);
                        buf.write_string("damage_plus");
                        damage_plus.serialize_without_name(buf);
                    }
                    Self::HandAttackDamageMultiply { tower_kind, damage_multiplier } => {
                        buf.write_string("HandAttackDamageMultiply");
                        buf.write_string("tower_kind");
                        tower_kind.serialize_without_name(buf);
                        buf.write_string("damage_multiplier");
                        damage_multiplier.serialize_without_name(buf);
                    }
                    Self::HandAttackSpeedPlus { tower_kind, speed_plus } => {
                        buf.write_string("HandAttackSpeedPlus");
                        buf.write_string("tower_kind");
                        tower_kind.serialize_without_name(buf);
                        buf.write_string("speed_plus");
                        speed_plus.serialize_without_name(buf);
                    }
                    Self::HandAttackSpeedMultiply { tower_kind, speed_multiplier } => {
                        buf.write_string("HandAttackSpeedMultiply");
                        buf.write_string("tower_kind");
                        tower_kind.serialize_without_name(buf);
                        buf.write_string("speed_multiplier");
                        speed_multiplier.serialize_without_name(buf);
                    }
                    Self::HandAttackRangePlus { tower_kind, range_plus } => {
                        buf.write_string("HandAttackRangePlus");
                        buf.write_string("tower_kind");
                        tower_kind.serialize_without_name(buf);
                        buf.write_string("range_plus");
                        range_plus.serialize_without_name(buf);
                    }
                    Self::ShopSlotExpansion => {
                        buf.write_string("ShopSlotExpansion");
                    }
                    Self::QuestSlotExpansion => {
                        buf.write_string("QuestSlotExpansion");
                    }
                    Self::QuestBoardExpansion => {
                        buf.write_string("QuestBoardExpansion");
                    }
                    Self::RerollCountPlus => {
                        buf.write_string("RerollCountPlus");
                    }
                    Self::LowCardTowerDamagePlus { damage_plus } => {
                        buf.write_string("LowCardTowerDamagePlus");
                        buf.write_string("damage_plus");
                        damage_plus.serialize_without_name(buf);
                    }
                    Self::LowCardTowerDamageMultiply { damage_multiplier } => {
                        buf.write_string("LowCardTowerDamageMultiply");
                        buf.write_string("damage_multiplier");
                        damage_multiplier.serialize_without_name(buf);
                    }
                    Self::LowCardTowerAttackSpeedPlus { speed_plus } => {
                        buf.write_string("LowCardTowerAttackSpeedPlus");
                        buf.write_string("speed_plus");
                        speed_plus.serialize_without_name(buf);
                    }
                    Self::LowCardTowerAttackSpeedMultiply { speed_multiplier } => {
                        buf.write_string("LowCardTowerAttackSpeedMultiply");
                        buf.write_string("speed_multiplier");
                        speed_multiplier.serialize_without_name(buf);
                    }
                    Self::LowCardTowerAttackRangePlus { range_plus } => {
                        buf.write_string("LowCardTowerAttackRangePlus");
                        buf.write_string("range_plus");
                        range_plus.serialize_without_name(buf);
                    }
                    Self::ShopItemPriceMinus => {
                        buf.write_string("ShopItemPriceMinus");
                    }
                    Self::ShopRefreshPlus => {
                        buf.write_string("ShopRefreshPlus");
                    }
                    Self::QuestBoardRefreshPlus => {
                        buf.write_string("QuestBoardRefreshPlus");
                    }
                    Self::NoRerollTowerAttackDamagePlus { damage_plus } => {
                        buf.write_string("NoRerollTowerAttackDamagePlus");
                        buf.write_string("damage_plus");
                        damage_plus.serialize_without_name(buf);
                    }
                    Self::NoRerollTowerAttackDamageMultiply { damage_multiplier } => {
                        buf.write_string("NoRerollTowerAttackDamageMultiply");
                        buf.write_string("damage_multiplier");
                        damage_multiplier.serialize_without_name(buf);
                    }
                    Self::NoRerollTowerAttackSpeedPlus { speed_plus } => {
                        buf.write_string("NoRerollTowerAttackSpeedPlus");
                        buf.write_string("speed_plus");
                        speed_plus.serialize_without_name(buf);
                    }
                    Self::NoRerollTowerAttackSpeedMultiply { speed_multiplier } => {
                        buf.write_string("NoRerollTowerAttackSpeedMultiply");
                        buf.write_string("speed_multiplier");
                        speed_multiplier.serialize_without_name(buf);
                    }
                    Self::NoRerollTowerAttackRangePlus { range_plus } => {
                        buf.write_string("NoRerollTowerAttackRangePlus");
                        buf.write_string("range_plus");
                        range_plus.serialize_without_name(buf);
                    }
                    Self::EvenOddTowerAttackDamagePlus { even, damage_plus } => {
                        buf.write_string("EvenOddTowerAttackDamagePlus");
                        buf.write_string("even");
                        even.serialize_without_name(buf);
                        buf.write_string("damage_plus");
                        damage_plus.serialize_without_name(buf);
                    }
                    Self::EvenOddTowerAttackDamageMultiply {
                        even,
                        damage_multiplier,
                    } => {
                        buf.write_string("EvenOddTowerAttackDamageMultiply");
                        buf.write_string("even");
                        even.serialize_without_name(buf);
                        buf.write_string("damage_multiplier");
                        damage_multiplier.serialize_without_name(buf);
                    }
                    Self::EvenOddTowerAttackSpeedPlus { even, speed_plus } => {
                        buf.write_string("EvenOddTowerAttackSpeedPlus");
                        buf.write_string("even");
                        even.serialize_without_name(buf);
                        buf.write_string("speed_plus");
                        speed_plus.serialize_without_name(buf);
                    }
                    Self::EvenOddTowerAttackSpeedMultiply { even, speed_multiplier } => {
                        buf.write_string("EvenOddTowerAttackSpeedMultiply");
                        buf.write_string("even");
                        even.serialize_without_name(buf);
                        buf.write_string("speed_multiplier");
                        speed_multiplier.serialize_without_name(buf);
                    }
                    Self::EvenOddTowerAttackRangePlus { even, range_plus } => {
                        buf.write_string("EvenOddTowerAttackRangePlus");
                        buf.write_string("even");
                        even.serialize_without_name(buf);
                        buf.write_string("range_plus");
                        range_plus.serialize_without_name(buf);
                    }
                    Self::FaceNumberCardTowerAttackDamagePlus { face, damage_plus } => {
                        buf.write_string("FaceNumberCardTowerAttackDamagePlus");
                        buf.write_string("face");
                        face.serialize_without_name(buf);
                        buf.write_string("damage_plus");
                        damage_plus.serialize_without_name(buf);
                    }
                    Self::FaceNumberCardTowerAttackDamageMultiply {
                        face,
                        damage_multiplier,
                    } => {
                        buf.write_string("FaceNumberCardTowerAttackDamageMultiply");
                        buf.write_string("face");
                        face.serialize_without_name(buf);
                        buf.write_string("damage_multiplier");
                        damage_multiplier.serialize_without_name(buf);
                    }
                    Self::FaceNumberCardTowerAttackSpeedPlus { face, speed_plus } => {
                        buf.write_string("FaceNumberCardTowerAttackSpeedPlus");
                        buf.write_string("face");
                        face.serialize_without_name(buf);
                        buf.write_string("speed_plus");
                        speed_plus.serialize_without_name(buf);
                    }
                    Self::FaceNumberCardTowerAttackSpeedMultiply {
                        face,
                        speed_multiplier,
                    } => {
                        buf.write_string("FaceNumberCardTowerAttackSpeedMultiply");
                        buf.write_string("face");
                        face.serialize_without_name(buf);
                        buf.write_string("speed_multiplier");
                        speed_multiplier.serialize_without_name(buf);
                    }
                    Self::FaceNumberCardTowerAttackRangePlus { face, range_plus } => {
                        buf.write_string("FaceNumberCardTowerAttackRangePlus");
                        buf.write_string("face");
                        face.serialize_without_name(buf);
                        buf.write_string("range_plus");
                        range_plus.serialize_without_name(buf);
                    }
                    Self::ShortenStraightFlushTo4Cards => {
                        buf.write_string("ShortenStraightFlushTo4Cards");
                    }
                    Self::SkipRankForStraight => {
                        buf.write_string("SkipRankForStraight");
                    }
                    Self::TreatSuitsAsSame => {
                        buf.write_string("TreatSuitsAsSame");
                    }
                    Self::RerollTowerAttackDamagePlus { damage_plus } => {
                        buf.write_string("RerollTowerAttackDamagePlus");
                        buf.write_string("damage_plus");
                        damage_plus.serialize_without_name(buf);
                    }
                    Self::RerollTowerAttackDamageMultiply { damage_multiplier } => {
                        buf.write_string("RerollTowerAttackDamageMultiply");
                        buf.write_string("damage_multiplier");
                        damage_multiplier.serialize_without_name(buf);
                    }
                    Self::RerollTowerAttackSpeedPlus { speed_plus } => {
                        buf.write_string("RerollTowerAttackSpeedPlus");
                        buf.write_string("speed_plus");
                        speed_plus.serialize_without_name(buf);
                    }
                    Self::RerollTowerAttackSpeedMultiply { speed_multiplier } => {
                        buf.write_string("RerollTowerAttackSpeedMultiply");
                        buf.write_string("speed_multiplier");
                        speed_multiplier.serialize_without_name(buf);
                    }
                    Self::RerollTowerAttackRangePlus { range_plus } => {
                        buf.write_string("RerollTowerAttackRangePlus");
                        buf.write_string("range_plus");
                        range_plus.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for UpgradeKind {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "GoldEarnPlus" => Ok(Self::GoldEarnPlus),
                    "RankAttackDamagePlus" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_plus")?;
                        let damage_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RankAttackDamagePlus {
                            rank,
                            damage_plus,
                        })
                    }
                    "RankAttackDamageMultiply" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_multiplier")?;
                        let damage_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::RankAttackDamageMultiply {
                            rank,
                            damage_multiplier,
                        })
                    }
                    "RankAttackSpeedPlus" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_plus")?;
                        let speed_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RankAttackSpeedPlus {
                            rank,
                            speed_plus,
                        })
                    }
                    "RankAttackSpeedMultiply" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_multiplier")?;
                        let speed_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::RankAttackSpeedMultiply {
                            rank,
                            speed_multiplier,
                        })
                    }
                    "RankAttackRangePlus" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_plus")?;
                        let range_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RankAttackRangePlus {
                            rank,
                            range_plus,
                        })
                    }
                    "SuitAttackDamagePlus" => {
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_plus")?;
                        let damage_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SuitAttackDamagePlus {
                            suit,
                            damage_plus,
                        })
                    }
                    "SuitAttackDamageMultiply" => {
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_multiplier")?;
                        let damage_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::SuitAttackDamageMultiply {
                            suit,
                            damage_multiplier,
                        })
                    }
                    "SuitAttackSpeedPlus" => {
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_plus")?;
                        let speed_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SuitAttackSpeedPlus {
                            suit,
                            speed_plus,
                        })
                    }
                    "SuitAttackSpeedMultiply" => {
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_multiplier")?;
                        let speed_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::SuitAttackSpeedMultiply {
                            suit,
                            speed_multiplier,
                        })
                    }
                    "SuitAttackRangePlus" => {
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_plus")?;
                        let range_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SuitAttackRangePlus {
                            suit,
                            range_plus,
                        })
                    }
                    "HandAttackDamagePlus" => {
                        let field_name = buf.read_name("tower_kind")?;
                        let tower_kind = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_plus")?;
                        let damage_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::HandAttackDamagePlus {
                            tower_kind,
                            damage_plus,
                        })
                    }
                    "HandAttackDamageMultiply" => {
                        let field_name = buf.read_name("tower_kind")?;
                        let tower_kind = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_multiplier")?;
                        let damage_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::HandAttackDamageMultiply {
                            tower_kind,
                            damage_multiplier,
                        })
                    }
                    "HandAttackSpeedPlus" => {
                        let field_name = buf.read_name("tower_kind")?;
                        let tower_kind = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_plus")?;
                        let speed_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::HandAttackSpeedPlus {
                            tower_kind,
                            speed_plus,
                        })
                    }
                    "HandAttackSpeedMultiply" => {
                        let field_name = buf.read_name("tower_kind")?;
                        let tower_kind = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_multiplier")?;
                        let speed_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::HandAttackSpeedMultiply {
                            tower_kind,
                            speed_multiplier,
                        })
                    }
                    "HandAttackRangePlus" => {
                        let field_name = buf.read_name("tower_kind")?;
                        let tower_kind = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_plus")?;
                        let range_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::HandAttackRangePlus {
                            tower_kind,
                            range_plus,
                        })
                    }
                    "ShopSlotExpansion" => Ok(Self::ShopSlotExpansion),
                    "QuestSlotExpansion" => Ok(Self::QuestSlotExpansion),
                    "QuestBoardExpansion" => Ok(Self::QuestBoardExpansion),
                    "RerollCountPlus" => Ok(Self::RerollCountPlus),
                    "LowCardTowerDamagePlus" => {
                        let field_name = buf.read_name("damage_plus")?;
                        let damage_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::LowCardTowerDamagePlus {
                            damage_plus,
                        })
                    }
                    "LowCardTowerDamageMultiply" => {
                        let field_name = buf.read_name("damage_multiplier")?;
                        let damage_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::LowCardTowerDamageMultiply {
                            damage_multiplier,
                        })
                    }
                    "LowCardTowerAttackSpeedPlus" => {
                        let field_name = buf.read_name("speed_plus")?;
                        let speed_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::LowCardTowerAttackSpeedPlus {
                            speed_plus,
                        })
                    }
                    "LowCardTowerAttackSpeedMultiply" => {
                        let field_name = buf.read_name("speed_multiplier")?;
                        let speed_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::LowCardTowerAttackSpeedMultiply {
                            speed_multiplier,
                        })
                    }
                    "LowCardTowerAttackRangePlus" => {
                        let field_name = buf.read_name("range_plus")?;
                        let range_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::LowCardTowerAttackRangePlus {
                            range_plus,
                        })
                    }
                    "ShopItemPriceMinus" => Ok(Self::ShopItemPriceMinus),
                    "ShopRefreshPlus" => Ok(Self::ShopRefreshPlus),
                    "QuestBoardRefreshPlus" => Ok(Self::QuestBoardRefreshPlus),
                    "NoRerollTowerAttackDamagePlus" => {
                        let field_name = buf.read_name("damage_plus")?;
                        let damage_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::NoRerollTowerAttackDamagePlus {
                            damage_plus,
                        })
                    }
                    "NoRerollTowerAttackDamageMultiply" => {
                        let field_name = buf.read_name("damage_multiplier")?;
                        let damage_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::NoRerollTowerAttackDamageMultiply {
                            damage_multiplier,
                        })
                    }
                    "NoRerollTowerAttackSpeedPlus" => {
                        let field_name = buf.read_name("speed_plus")?;
                        let speed_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::NoRerollTowerAttackSpeedPlus {
                            speed_plus,
                        })
                    }
                    "NoRerollTowerAttackSpeedMultiply" => {
                        let field_name = buf.read_name("speed_multiplier")?;
                        let speed_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::NoRerollTowerAttackSpeedMultiply {
                            speed_multiplier,
                        })
                    }
                    "NoRerollTowerAttackRangePlus" => {
                        let field_name = buf.read_name("range_plus")?;
                        let range_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::NoRerollTowerAttackRangePlus {
                            range_plus,
                        })
                    }
                    "EvenOddTowerAttackDamagePlus" => {
                        let field_name = buf.read_name("even")?;
                        let even = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_plus")?;
                        let damage_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::EvenOddTowerAttackDamagePlus {
                            even,
                            damage_plus,
                        })
                    }
                    "EvenOddTowerAttackDamageMultiply" => {
                        let field_name = buf.read_name("even")?;
                        let even = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_multiplier")?;
                        let damage_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::EvenOddTowerAttackDamageMultiply {
                            even,
                            damage_multiplier,
                        })
                    }
                    "EvenOddTowerAttackSpeedPlus" => {
                        let field_name = buf.read_name("even")?;
                        let even = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_plus")?;
                        let speed_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::EvenOddTowerAttackSpeedPlus {
                            even,
                            speed_plus,
                        })
                    }
                    "EvenOddTowerAttackSpeedMultiply" => {
                        let field_name = buf.read_name("even")?;
                        let even = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_multiplier")?;
                        let speed_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::EvenOddTowerAttackSpeedMultiply {
                            even,
                            speed_multiplier,
                        })
                    }
                    "EvenOddTowerAttackRangePlus" => {
                        let field_name = buf.read_name("even")?;
                        let even = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_plus")?;
                        let range_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::EvenOddTowerAttackRangePlus {
                            even,
                            range_plus,
                        })
                    }
                    "FaceNumberCardTowerAttackDamagePlus" => {
                        let field_name = buf.read_name("face")?;
                        let face = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_plus")?;
                        let damage_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::FaceNumberCardTowerAttackDamagePlus {
                            face,
                            damage_plus,
                        })
                    }
                    "FaceNumberCardTowerAttackDamageMultiply" => {
                        let field_name = buf.read_name("face")?;
                        let face = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("damage_multiplier")?;
                        let damage_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::FaceNumberCardTowerAttackDamageMultiply {
                            face,
                            damage_multiplier,
                        })
                    }
                    "FaceNumberCardTowerAttackSpeedPlus" => {
                        let field_name = buf.read_name("face")?;
                        let face = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_plus")?;
                        let speed_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::FaceNumberCardTowerAttackSpeedPlus {
                            face,
                            speed_plus,
                        })
                    }
                    "FaceNumberCardTowerAttackSpeedMultiply" => {
                        let field_name = buf.read_name("face")?;
                        let face = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("speed_multiplier")?;
                        let speed_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::FaceNumberCardTowerAttackSpeedMultiply {
                            face,
                            speed_multiplier,
                        })
                    }
                    "FaceNumberCardTowerAttackRangePlus" => {
                        let field_name = buf.read_name("face")?;
                        let face = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_plus")?;
                        let range_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::FaceNumberCardTowerAttackRangePlus {
                            face,
                            range_plus,
                        })
                    }
                    "ShortenStraightFlushTo4Cards" => {
                        Ok(Self::ShortenStraightFlushTo4Cards)
                    }
                    "SkipRankForStraight" => Ok(Self::SkipRankForStraight),
                    "TreatSuitsAsSame" => Ok(Self::TreatSuitsAsSame),
                    "RerollTowerAttackDamagePlus" => {
                        let field_name = buf.read_name("damage_plus")?;
                        let damage_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RerollTowerAttackDamagePlus {
                            damage_plus,
                        })
                    }
                    "RerollTowerAttackDamageMultiply" => {
                        let field_name = buf.read_name("damage_multiplier")?;
                        let damage_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::RerollTowerAttackDamageMultiply {
                            damage_multiplier,
                        })
                    }
                    "RerollTowerAttackSpeedPlus" => {
                        let field_name = buf.read_name("speed_plus")?;
                        let speed_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RerollTowerAttackSpeedPlus {
                            speed_plus,
                        })
                    }
                    "RerollTowerAttackSpeedMultiply" => {
                        let field_name = buf.read_name("speed_multiplier")?;
                        let speed_multiplier = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::RerollTowerAttackSpeedMultiply {
                            speed_multiplier,
                        })
                    }
                    "RerollTowerAttackRangePlus" => {
                        let field_name = buf.read_name("range_plus")?;
                        let range_plus = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RerollTowerAttackRangePlus {
                            range_plus,
                        })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub enum TowerUpgradeTarget {
            Rank { rank: Rank },
            Suit { suit: Suit },
            TowerKind { tower_kind: TowerKind },
            EvenOdd { even: bool },
            FaceNumber { face: bool },
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TowerUpgradeTarget {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TowerUpgradeTarget {
            #[inline]
            fn eq(&self, other: &TowerUpgradeTarget) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            TowerUpgradeTarget::Rank { rank: __self_0 },
                            TowerUpgradeTarget::Rank { rank: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            TowerUpgradeTarget::Suit { suit: __self_0 },
                            TowerUpgradeTarget::Suit { suit: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            TowerUpgradeTarget::TowerKind { tower_kind: __self_0 },
                            TowerUpgradeTarget::TowerKind { tower_kind: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            TowerUpgradeTarget::EvenOdd { even: __self_0 },
                            TowerUpgradeTarget::EvenOdd { even: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        (
                            TowerUpgradeTarget::FaceNumber { face: __self_0 },
                            TowerUpgradeTarget::FaceNumber { face: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TowerUpgradeTarget {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Rank>;
                let _: ::core::cmp::AssertParamIsEq<Suit>;
                let _: ::core::cmp::AssertParamIsEq<TowerKind>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TowerUpgradeTarget {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state);
                match self {
                    TowerUpgradeTarget::Rank { rank: __self_0 } => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    TowerUpgradeTarget::Suit { suit: __self_0 } => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    TowerUpgradeTarget::TowerKind { tower_kind: __self_0 } => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    TowerUpgradeTarget::EvenOdd { even: __self_0 } => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    TowerUpgradeTarget::FaceNumber { face: __self_0 } => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TowerUpgradeTarget {
            #[inline]
            fn clone(&self) -> TowerUpgradeTarget {
                let _: ::core::clone::AssertParamIsClone<Rank>;
                let _: ::core::clone::AssertParamIsClone<Suit>;
                let _: ::core::clone::AssertParamIsClone<TowerKind>;
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TowerUpgradeTarget {}
        #[automatically_derived]
        impl ::core::fmt::Debug for TowerUpgradeTarget {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TowerUpgradeTarget::Rank { rank: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Rank",
                            "rank",
                            &__self_0,
                        )
                    }
                    TowerUpgradeTarget::Suit { suit: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Suit",
                            "suit",
                            &__self_0,
                        )
                    }
                    TowerUpgradeTarget::TowerKind { tower_kind: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "TowerKind",
                            "tower_kind",
                            &__self_0,
                        )
                    }
                    TowerUpgradeTarget::EvenOdd { even: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "EvenOdd",
                            "even",
                            &__self_0,
                        )
                    }
                    TowerUpgradeTarget::FaceNumber { face: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "FaceNumber",
                            "face",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for TowerUpgradeTarget {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TowerUpgradeTarget,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (
                        TowerUpgradeTarget::Rank { rank: __self_0 },
                        TowerUpgradeTarget::Rank { rank: __arg1_0 },
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        TowerUpgradeTarget::Suit { suit: __self_0 },
                        TowerUpgradeTarget::Suit { suit: __arg1_0 },
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        TowerUpgradeTarget::TowerKind { tower_kind: __self_0 },
                        TowerUpgradeTarget::TowerKind { tower_kind: __arg1_0 },
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        TowerUpgradeTarget::EvenOdd { even: __self_0 },
                        TowerUpgradeTarget::EvenOdd { even: __arg1_0 },
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        TowerUpgradeTarget::FaceNumber { face: __self_0 },
                        TowerUpgradeTarget::FaceNumber { face: __arg1_0 },
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    _ => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &__self_discr,
                            &__arg1_discr,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for TowerUpgradeTarget {
            #[inline]
            fn cmp(&self, other: &TowerUpgradeTarget) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (
                                TowerUpgradeTarget::Rank { rank: __self_0 },
                                TowerUpgradeTarget::Rank { rank: __arg1_0 },
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                TowerUpgradeTarget::Suit { suit: __self_0 },
                                TowerUpgradeTarget::Suit { suit: __arg1_0 },
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                TowerUpgradeTarget::TowerKind { tower_kind: __self_0 },
                                TowerUpgradeTarget::TowerKind { tower_kind: __arg1_0 },
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                TowerUpgradeTarget::EvenOdd { even: __self_0 },
                                TowerUpgradeTarget::EvenOdd { even: __arg1_0 },
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                TowerUpgradeTarget::FaceNumber { face: __self_0 },
                                TowerUpgradeTarget::FaceNumber { face: __arg1_0 },
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        impl bincode::Encode for TowerUpgradeTarget {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Rank { rank } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                    }
                    Self::Suit { suit } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                    }
                    Self::TowerKind { tower_kind } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(tower_kind, encoder)?;
                    }
                    Self::EvenOdd { even } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(even, encoder)?;
                    }
                    Self::FaceNumber { face } => {
                        bincode::Encode::encode(&4u32, encoder)?;
                        bincode::Encode::encode(face, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for TowerUpgradeTarget {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::Rank {
                            rank: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::Suit {
                            suit: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => {
                        Ok(Self::TowerKind {
                            tower_kind: bincode::Decode::decode(decoder)?,
                        })
                    }
                    3u32 => {
                        Ok(Self::EvenOdd {
                            even: bincode::Decode::decode(decoder)?,
                        })
                    }
                    4u32 => {
                        Ok(Self::FaceNumber {
                            face: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 4u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for TowerUpgradeTarget {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Rank { rank } => {
                        buf.write_string("Rank");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                    }
                    Self::Suit { suit } => {
                        buf.write_string("Suit");
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                    }
                    Self::TowerKind { tower_kind } => {
                        buf.write_string("TowerKind");
                        buf.write_string("tower_kind");
                        tower_kind.serialize_without_name(buf);
                    }
                    Self::EvenOdd { even } => {
                        buf.write_string("EvenOdd");
                        buf.write_string("even");
                        even.serialize_without_name(buf);
                    }
                    Self::FaceNumber { face } => {
                        buf.write_string("FaceNumber");
                        buf.write_string("face");
                        face.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for TowerUpgradeTarget {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Rank" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Rank { rank })
                    }
                    "Suit" => {
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Suit { suit })
                    }
                    "TowerKind" => {
                        let field_name = buf.read_name("tower_kind")?;
                        let tower_kind = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TowerKind { tower_kind })
                    }
                    "EvenOdd" => {
                        let field_name = buf.read_name("even")?;
                        let even = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::EvenOdd { even })
                    }
                    "FaceNumber" => {
                        let field_name = buf.read_name("face")?;
                        let face = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::FaceNumber { face })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub enum TowerUpgrade {
            DamagePlus { damage: f32 },
            DamageMultiplier { multiplier: f32 },
            SpeedPlus { speed: f32 },
            SpeedMultiplier { multiplier: f32 },
            RangePlus { range: f32 },
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TowerUpgrade {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TowerUpgrade::DamagePlus { damage: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DamagePlus",
                            "damage",
                            &__self_0,
                        )
                    }
                    TowerUpgrade::DamageMultiplier { multiplier: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DamageMultiplier",
                            "multiplier",
                            &__self_0,
                        )
                    }
                    TowerUpgrade::SpeedPlus { speed: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "SpeedPlus",
                            "speed",
                            &__self_0,
                        )
                    }
                    TowerUpgrade::SpeedMultiplier { multiplier: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "SpeedMultiplier",
                            "multiplier",
                            &__self_0,
                        )
                    }
                    TowerUpgrade::RangePlus { range: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RangePlus",
                            "range",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TowerUpgrade {
            #[inline]
            fn clone(&self) -> TowerUpgrade {
                let _: ::core::clone::AssertParamIsClone<f32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TowerUpgrade {}
        impl bincode::Encode for TowerUpgrade {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::DamagePlus { damage } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(damage, encoder)?;
                    }
                    Self::DamageMultiplier { multiplier } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(multiplier, encoder)?;
                    }
                    Self::SpeedPlus { speed } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(speed, encoder)?;
                    }
                    Self::SpeedMultiplier { multiplier } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(multiplier, encoder)?;
                    }
                    Self::RangePlus { range } => {
                        bincode::Encode::encode(&4u32, encoder)?;
                        bincode::Encode::encode(range, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for TowerUpgrade {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::DamagePlus {
                            damage: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::DamageMultiplier {
                            multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => {
                        Ok(Self::SpeedPlus {
                            speed: bincode::Decode::decode(decoder)?,
                        })
                    }
                    3u32 => {
                        Ok(Self::SpeedMultiplier {
                            multiplier: bincode::Decode::decode(decoder)?,
                        })
                    }
                    4u32 => {
                        Ok(Self::RangePlus {
                            range: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 4u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for TowerUpgrade {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::DamagePlus { damage } => {
                        buf.write_string("DamagePlus");
                        buf.write_string("damage");
                        damage.serialize_without_name(buf);
                    }
                    Self::DamageMultiplier { multiplier } => {
                        buf.write_string("DamageMultiplier");
                        buf.write_string("multiplier");
                        multiplier.serialize_without_name(buf);
                    }
                    Self::SpeedPlus { speed } => {
                        buf.write_string("SpeedPlus");
                        buf.write_string("speed");
                        speed.serialize_without_name(buf);
                    }
                    Self::SpeedMultiplier { multiplier } => {
                        buf.write_string("SpeedMultiplier");
                        buf.write_string("multiplier");
                        multiplier.serialize_without_name(buf);
                    }
                    Self::RangePlus { range } => {
                        buf.write_string("RangePlus");
                        buf.write_string("range");
                        range.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for TowerUpgrade {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "DamagePlus" => {
                        let field_name = buf.read_name("damage")?;
                        let damage = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DamagePlus { damage })
                    }
                    "DamageMultiplier" => {
                        let field_name = buf.read_name("multiplier")?;
                        let multiplier = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DamageMultiplier {
                            multiplier,
                        })
                    }
                    "SpeedPlus" => {
                        let field_name = buf.read_name("speed")?;
                        let speed = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SpeedPlus { speed })
                    }
                    "SpeedMultiplier" => {
                        let field_name = buf.read_name("multiplier")?;
                        let multiplier = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SpeedMultiplier {
                            multiplier,
                        })
                    }
                    "RangePlus" => {
                        let field_name = buf.read_name("range")?;
                        let range = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RangePlus { range })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub struct TowerUpgradeState {
            pub damage_plus: f32,
            pub damage_multiplier: f32,
            pub speed_plus: f32,
            pub speed_multiplier: f32,
            pub range_plus: f32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TowerUpgradeState {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "TowerUpgradeState",
                    "damage_plus",
                    &self.damage_plus,
                    "damage_multiplier",
                    &self.damage_multiplier,
                    "speed_plus",
                    &self.speed_plus,
                    "speed_multiplier",
                    &self.speed_multiplier,
                    "range_plus",
                    &&self.range_plus,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TowerUpgradeState {
            #[inline]
            fn clone(&self) -> TowerUpgradeState {
                let _: ::core::clone::AssertParamIsClone<f32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TowerUpgradeState {}
        impl bincode::Encode for TowerUpgradeState {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.damage_plus, encoder)?;
                bincode::Encode::encode(&self.damage_multiplier, encoder)?;
                bincode::Encode::encode(&self.speed_plus, encoder)?;
                bincode::Encode::encode(&self.speed_multiplier, encoder)?;
                bincode::Encode::encode(&self.range_plus, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for TowerUpgradeState {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    damage_plus: bincode::Decode::decode(decoder)?,
                    damage_multiplier: bincode::Decode::decode(decoder)?,
                    speed_plus: bincode::Decode::decode(decoder)?,
                    speed_multiplier: bincode::Decode::decode(decoder)?,
                    range_plus: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for TowerUpgradeState {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("damage_plus");
                self.damage_plus.serialize_without_name(buf);
                buf.write_string("damage_multiplier");
                self.damage_multiplier.serialize_without_name(buf);
                buf.write_string("speed_plus");
                self.speed_plus.serialize_without_name(buf);
                buf.write_string("speed_multiplier");
                self.speed_multiplier.serialize_without_name(buf);
                buf.write_string("range_plus");
                self.range_plus.serialize_without_name(buf);
            }
        }
        impl Deserialize for TowerUpgradeState {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("damage_plus")?;
                let damage_plus = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("damage_multiplier")?;
                let damage_multiplier = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("speed_plus")?;
                let speed_plus = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("speed_multiplier")?;
                let speed_multiplier = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("range_plus")?;
                let range_plus = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    damage_plus,
                    damage_multiplier,
                    speed_plus,
                    speed_multiplier,
                    range_plus,
                })
            }
        }
        impl TowerUpgradeState {
            fn apply_upgrade(&mut self, upgrade: TowerUpgrade) {
                match upgrade {
                    TowerUpgrade::DamagePlus { damage } => self.damage_plus += damage,
                    TowerUpgrade::DamageMultiplier { multiplier } => {
                        self.damage_multiplier *= multiplier;
                    }
                    TowerUpgrade::SpeedPlus { speed } => self.speed_plus += speed,
                    TowerUpgrade::SpeedMultiplier { multiplier } => {
                        self.speed_multiplier *= multiplier;
                    }
                    TowerUpgrade::RangePlus { range } => self.range_plus += range,
                }
            }
        }
        impl Default for TowerUpgradeState {
            fn default() -> Self {
                TowerUpgradeState {
                    damage_plus: 0.0,
                    damage_multiplier: 1.0,
                    speed_plus: 0.0,
                    speed_multiplier: 1.0,
                    range_plus: 0.0,
                }
            }
        }
        pub enum TowerSelectUpgradeTarget {
            LowCard,
            NoReroll,
            Reroll,
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TowerSelectUpgradeTarget {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TowerSelectUpgradeTarget {
            #[inline]
            fn eq(&self, other: &TowerSelectUpgradeTarget) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TowerSelectUpgradeTarget {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TowerSelectUpgradeTarget {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TowerSelectUpgradeTarget {
            #[inline]
            fn clone(&self) -> TowerSelectUpgradeTarget {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TowerSelectUpgradeTarget {}
        #[automatically_derived]
        impl ::core::fmt::Debug for TowerSelectUpgradeTarget {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TowerSelectUpgradeTarget::LowCard => "LowCard",
                        TowerSelectUpgradeTarget::NoReroll => "NoReroll",
                        TowerSelectUpgradeTarget::Reroll => "Reroll",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for TowerSelectUpgradeTarget {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TowerSelectUpgradeTarget,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for TowerSelectUpgradeTarget {
            #[inline]
            fn cmp(&self, other: &TowerSelectUpgradeTarget) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        impl bincode::Encode for TowerSelectUpgradeTarget {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::LowCard => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::NoReroll => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::Reroll => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for TowerSelectUpgradeTarget {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::LowCard),
                    1u32 => Ok(Self::NoReroll),
                    2u32 => Ok(Self::Reroll),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 2u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for TowerSelectUpgradeTarget {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::LowCard => {
                        buf.write_string("LowCard");
                    }
                    Self::NoReroll => {
                        buf.write_string("NoReroll");
                    }
                    Self::Reroll => {
                        buf.write_string("Reroll");
                    }
                }
            }
        }
        impl Deserialize for TowerSelectUpgradeTarget {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "LowCard" => Ok(Self::LowCard),
                    "NoReroll" => Ok(Self::NoReroll),
                    "Reroll" => Ok(Self::Reroll),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        /// Equal to or less than the number of cards in the hand.
        pub const LOW_CARD_COUNT: usize = 3;
    }
    mod user_status_effect {
        use namui::*;
        use super::GameState;
        pub struct UserStatusEffect {
            pub kind: UserStatusEffectKind,
            pub end_at: Instant,
        }
        impl bincode::Encode for UserStatusEffect {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.kind, encoder)?;
                bincode::Encode::encode(&self.end_at, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for UserStatusEffect {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    kind: bincode::Decode::decode(decoder)?,
                    end_at: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for UserStatusEffect {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("kind");
                self.kind.serialize_without_name(buf);
                buf.write_string("end_at");
                self.end_at.serialize_without_name(buf);
            }
        }
        impl Deserialize for UserStatusEffect {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("kind")?;
                let kind = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("end_at")?;
                let end_at = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { kind, end_at })
            }
        }
        pub enum UserStatusEffectKind {
            DamageReduction { damage_multiply: f32 },
        }
        impl bincode::Encode for UserStatusEffectKind {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::DamageReduction { damage_multiply } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(damage_multiply, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for UserStatusEffectKind {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::DamageReduction {
                            damage_multiply: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 0u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for UserStatusEffectKind {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::DamageReduction { damage_multiply } => {
                        buf.write_string("DamageReduction");
                        buf.write_string("damage_multiply");
                        damage_multiply.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for UserStatusEffectKind {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "DamageReduction" => {
                        let field_name = buf.read_name("damage_multiply")?;
                        let damage_multiply = Deserialize::deserialize_without_name(
                            buf,
                        )?;
                        Ok(Self::DamageReduction {
                            damage_multiply,
                        })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub fn remove_user_finished_status_effects(
            game_state: &mut GameState,
            now: Instant,
        ) {
            game_state.user_status_effects.retain(|e| now < e.end_at);
        }
    }
    use crate::game_state::stage_modifiers::StageModifiers;
    use crate::hand::HandSlotId;
    use crate::route::*;
    use crate::*;
    use background::{Background, generate_backgrounds};
    use camera::*;
    use cursor_preview::CursorPreview;
    use fast_forward::FastForwardMultiplier;
    use flow::GameFlow;
    use item::{Effect, Item};
    pub use level_rarity_weight::level_rarity_weight;
    pub use modal::Modal;
    pub use monster::*;
    use monster_spawn::*;
    use namui::*;
    use placed_towers::PlacedTowers;
    use play_history::PlayHistory;
    use projectile::*;
    pub use render::*;
    use std::num::NonZeroUsize;
    use std::sync::Arc;
    use tower::*;
    pub use ui_state::UIState;
    use upgrade::UpgradeState;
    use user_status_effect::UserStatusEffect;
    /// The size of a tile in pixels, with zoom level 1.0.
    pub const TILE_PX_SIZE: Wh<Px> = Wh::new(px(128.0), px(128.0));
    pub const MAP_SIZE: Wh<BlockUnit> = Wh::new(48, 48);
    pub const TRAVEL_POINTS: [MapCoord; 7] = [
        MapCoord::new(6, 0),
        MapCoord::new(6, 23),
        MapCoord::new(41, 23),
        MapCoord::new(41, 6),
        MapCoord::new(24, 6),
        MapCoord::new(24, 41),
        MapCoord::new(47, 41),
    ];
    pub const MAX_HP: f32 = 100.0;
    pub const MAX_INVENTORY_SLOT: usize = 9;
    pub struct GameState {
        pub monsters: Vec<Monster>,
        pub towers: PlacedTowers,
        pub camera: Camera,
        pub route: Arc<Route>,
        pub backgrounds: Vec<Background>,
        pub upgrade_state: UpgradeState,
        pub flow: GameFlow,
        /// one-based
        pub stage: usize,
        pub left_reroll_chance: usize,
        monster_spawn_state: MonsterSpawnState,
        pub projectiles: Vec<Projectile>,
        pub items: Vec<item::Item>,
        pub gold: usize,
        pub cursor_preview: CursorPreview,
        pub hp: f32,
        pub shield: f32,
        pub user_status_effects: Vec<UserStatusEffect>,
        pub left_shop_refresh_chance: usize,
        pub left_quest_board_refresh_chance: usize,
        pub item_used: bool,
        pub level: NonZeroUsize,
        game_now: Instant,
        pub fast_forward_multiplier: FastForwardMultiplier,
        pub rerolled_count: usize,
        pub field_particle_system_manager: field_particle::FieldParticleSystemManager,
        pub locale: crate::l10n::Locale,
        pub play_history: PlayHistory,
        pub opened_modal: Option<Modal>,
        pub contracts: Vec<contract::Contract>,
        pub stage_modifiers: StageModifiers,
        pub ui_state: UIState,
    }
    impl bincode::Encode for GameState {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            bincode::Encode::encode(&self.monsters, encoder)?;
            bincode::Encode::encode(&self.towers, encoder)?;
            bincode::Encode::encode(&self.camera, encoder)?;
            bincode::Encode::encode(&self.route, encoder)?;
            bincode::Encode::encode(&self.backgrounds, encoder)?;
            bincode::Encode::encode(&self.upgrade_state, encoder)?;
            bincode::Encode::encode(&self.flow, encoder)?;
            bincode::Encode::encode(&self.stage, encoder)?;
            bincode::Encode::encode(&self.left_reroll_chance, encoder)?;
            bincode::Encode::encode(&self.monster_spawn_state, encoder)?;
            bincode::Encode::encode(&self.projectiles, encoder)?;
            bincode::Encode::encode(&self.items, encoder)?;
            bincode::Encode::encode(&self.gold, encoder)?;
            bincode::Encode::encode(&self.cursor_preview, encoder)?;
            bincode::Encode::encode(&self.hp, encoder)?;
            bincode::Encode::encode(&self.shield, encoder)?;
            bincode::Encode::encode(&self.user_status_effects, encoder)?;
            bincode::Encode::encode(&self.left_shop_refresh_chance, encoder)?;
            bincode::Encode::encode(&self.left_quest_board_refresh_chance, encoder)?;
            bincode::Encode::encode(&self.item_used, encoder)?;
            bincode::Encode::encode(&self.level, encoder)?;
            bincode::Encode::encode(&self.game_now, encoder)?;
            bincode::Encode::encode(&self.fast_forward_multiplier, encoder)?;
            bincode::Encode::encode(&self.rerolled_count, encoder)?;
            bincode::Encode::encode(&self.field_particle_system_manager, encoder)?;
            bincode::Encode::encode(&self.locale, encoder)?;
            bincode::Encode::encode(&self.play_history, encoder)?;
            bincode::Encode::encode(&self.opened_modal, encoder)?;
            bincode::Encode::encode(&self.contracts, encoder)?;
            bincode::Encode::encode(&self.stage_modifiers, encoder)?;
            bincode::Encode::encode(&self.ui_state, encoder)?;
            Ok(())
        }
    }
    impl bincode::Decode<()> for GameState {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            Ok(Self {
                monsters: bincode::Decode::decode(decoder)?,
                towers: bincode::Decode::decode(decoder)?,
                camera: bincode::Decode::decode(decoder)?,
                route: bincode::Decode::decode(decoder)?,
                backgrounds: bincode::Decode::decode(decoder)?,
                upgrade_state: bincode::Decode::decode(decoder)?,
                flow: bincode::Decode::decode(decoder)?,
                stage: bincode::Decode::decode(decoder)?,
                left_reroll_chance: bincode::Decode::decode(decoder)?,
                monster_spawn_state: bincode::Decode::decode(decoder)?,
                projectiles: bincode::Decode::decode(decoder)?,
                items: bincode::Decode::decode(decoder)?,
                gold: bincode::Decode::decode(decoder)?,
                cursor_preview: bincode::Decode::decode(decoder)?,
                hp: bincode::Decode::decode(decoder)?,
                shield: bincode::Decode::decode(decoder)?,
                user_status_effects: bincode::Decode::decode(decoder)?,
                left_shop_refresh_chance: bincode::Decode::decode(decoder)?,
                left_quest_board_refresh_chance: bincode::Decode::decode(decoder)?,
                item_used: bincode::Decode::decode(decoder)?,
                level: bincode::Decode::decode(decoder)?,
                game_now: bincode::Decode::decode(decoder)?,
                fast_forward_multiplier: bincode::Decode::decode(decoder)?,
                rerolled_count: bincode::Decode::decode(decoder)?,
                field_particle_system_manager: bincode::Decode::decode(decoder)?,
                locale: bincode::Decode::decode(decoder)?,
                play_history: bincode::Decode::decode(decoder)?,
                opened_modal: bincode::Decode::decode(decoder)?,
                contracts: bincode::Decode::decode(decoder)?,
                stage_modifiers: bincode::Decode::decode(decoder)?,
                ui_state: bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl Serialize for GameState {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            buf.write_string("monsters");
            self.monsters.serialize_without_name(buf);
            buf.write_string("towers");
            self.towers.serialize_without_name(buf);
            buf.write_string("camera");
            self.camera.serialize_without_name(buf);
            buf.write_string("route");
            self.route.serialize_without_name(buf);
            buf.write_string("backgrounds");
            self.backgrounds.serialize_without_name(buf);
            buf.write_string("upgrade_state");
            self.upgrade_state.serialize_without_name(buf);
            buf.write_string("flow");
            self.flow.serialize_without_name(buf);
            buf.write_string("stage");
            self.stage.serialize_without_name(buf);
            buf.write_string("left_reroll_chance");
            self.left_reroll_chance.serialize_without_name(buf);
            buf.write_string("monster_spawn_state");
            self.monster_spawn_state.serialize_without_name(buf);
            buf.write_string("projectiles");
            self.projectiles.serialize_without_name(buf);
            buf.write_string("items");
            self.items.serialize_without_name(buf);
            buf.write_string("gold");
            self.gold.serialize_without_name(buf);
            buf.write_string("cursor_preview");
            self.cursor_preview.serialize_without_name(buf);
            buf.write_string("hp");
            self.hp.serialize_without_name(buf);
            buf.write_string("shield");
            self.shield.serialize_without_name(buf);
            buf.write_string("user_status_effects");
            self.user_status_effects.serialize_without_name(buf);
            buf.write_string("left_shop_refresh_chance");
            self.left_shop_refresh_chance.serialize_without_name(buf);
            buf.write_string("left_quest_board_refresh_chance");
            self.left_quest_board_refresh_chance.serialize_without_name(buf);
            buf.write_string("item_used");
            self.item_used.serialize_without_name(buf);
            buf.write_string("level");
            self.level.serialize_without_name(buf);
            buf.write_string("game_now");
            self.game_now.serialize_without_name(buf);
            buf.write_string("fast_forward_multiplier");
            self.fast_forward_multiplier.serialize_without_name(buf);
            buf.write_string("rerolled_count");
            self.rerolled_count.serialize_without_name(buf);
            buf.write_string("field_particle_system_manager");
            self.field_particle_system_manager.serialize_without_name(buf);
            buf.write_string("locale");
            self.locale.serialize_without_name(buf);
            buf.write_string("play_history");
            self.play_history.serialize_without_name(buf);
            buf.write_string("opened_modal");
            self.opened_modal.serialize_without_name(buf);
            buf.write_string("contracts");
            self.contracts.serialize_without_name(buf);
            buf.write_string("stage_modifiers");
            self.stage_modifiers.serialize_without_name(buf);
            buf.write_string("ui_state");
            self.ui_state.serialize_without_name(buf);
        }
    }
    impl Deserialize for GameState {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let field_name = buf.read_name("monsters")?;
            let monsters = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("towers")?;
            let towers = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("camera")?;
            let camera = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("route")?;
            let route = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("backgrounds")?;
            let backgrounds = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("upgrade_state")?;
            let upgrade_state = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("flow")?;
            let flow = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("stage")?;
            let stage = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("left_reroll_chance")?;
            let left_reroll_chance = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("monster_spawn_state")?;
            let monster_spawn_state = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("projectiles")?;
            let projectiles = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("items")?;
            let items = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("gold")?;
            let gold = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("cursor_preview")?;
            let cursor_preview = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("hp")?;
            let hp = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("shield")?;
            let shield = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("user_status_effects")?;
            let user_status_effects = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("left_shop_refresh_chance")?;
            let left_shop_refresh_chance = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("left_quest_board_refresh_chance")?;
            let left_quest_board_refresh_chance = Deserialize::deserialize_without_name(
                buf,
            )?;
            let field_name = buf.read_name("item_used")?;
            let item_used = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("level")?;
            let level = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("game_now")?;
            let game_now = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("fast_forward_multiplier")?;
            let fast_forward_multiplier = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("rerolled_count")?;
            let rerolled_count = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("field_particle_system_manager")?;
            let field_particle_system_manager = Deserialize::deserialize_without_name(
                buf,
            )?;
            let field_name = buf.read_name("locale")?;
            let locale = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("play_history")?;
            let play_history = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("opened_modal")?;
            let opened_modal = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("contracts")?;
            let contracts = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("stage_modifiers")?;
            let stage_modifiers = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("ui_state")?;
            let ui_state = Deserialize::deserialize_without_name(buf)?;
            Ok(Self {
                monsters,
                towers,
                camera,
                route,
                backgrounds,
                upgrade_state,
                flow,
                stage,
                left_reroll_chance,
                monster_spawn_state,
                projectiles,
                items,
                gold,
                cursor_preview,
                hp,
                shield,
                user_status_effects,
                left_shop_refresh_chance,
                left_quest_board_refresh_chance,
                item_used,
                level,
                game_now,
                fast_forward_multiplier,
                rerolled_count,
                field_particle_system_manager,
                locale,
                play_history,
                opened_modal,
                contracts,
                stage_modifiers,
                ui_state,
            })
        }
    }
    impl GameState {
        /// 현대적인 텍스트 매니저 반환
        pub fn text(&self) -> crate::l10n::TextManager {
            crate::l10n::TextManager::new(self.locale)
        }
        pub fn in_even_stage(&self) -> bool {
            #[allow(non_exhaustive_omitted_patterns)]
            match self.stage % 2 {
                0 => true,
                _ => false,
            }
        }
        pub fn max_shop_slot(&self) -> usize {
            self.upgrade_state.shop_slot_expand + 2
        }
        pub fn max_quest_slot(&self) -> usize {
            self.upgrade_state.quest_slot_expand + 3
        }
        pub fn max_quest_board_slot(&self) -> usize {
            self.upgrade_state.quest_board_slot_expand + 1
        }
        pub fn max_shop_refresh_chance(&self) -> usize {
            (self.upgrade_state.shop_refresh_chance_plus + 1
                + self.stage_modifiers.get_shop_max_rerolls_bonus())
                .saturating_sub(self.stage_modifiers.get_shop_max_rerolls_penalty())
        }
        pub fn max_quest_board_refresh_chance(&self) -> usize {
            self.upgrade_state.quest_board_refresh_chance_plus + 1
        }
        pub fn max_reroll_chance(&self) -> usize {
            (self.upgrade_state.reroll_chance_plus + 1
                + self.stage_modifiers.get_card_selection_hand_max_rerolls_bonus())
                .saturating_sub(
                    self.stage_modifiers.get_card_selection_hand_max_rerolls_penalty(),
                )
        }
        pub fn rerolled(&self) -> bool {
            self.rerolled_count > 0
        }
        pub fn now(&self) -> Instant {
            self.game_now
        }
        pub fn level_up_cost(&self) -> usize {
            match self.level.get() {
                1 => 25,
                2 => 50,
                3 => 75,
                4 => 100,
                5 => 150,
                6 => 200,
                7 => 300,
                8 => 500,
                9 => 750,
                10 => 0,
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!(
                                "Level up cost not defined for level {0}",
                                self.level,
                            ),
                        ),
                    );
                }
            }
        }
        pub fn calculate_tower_damage(&self, tower: &tower::Tower) -> f32 {
            let tower_upgrade_states = self.upgrade_state.tower_upgrades(tower);
            let contract_multiplier: f32 = self.stage_modifiers.get_damage_multiplier();
            tower.calculate_projectile_damage(&tower_upgrade_states, contract_multiplier)
        }
        pub fn set_selected_tower(&mut self, tower_id: Option<usize>) {
            self.ui_state.set_selected_tower(tower_id, self.now());
        }
        pub fn cleanup_unused_tower_popup_states(&mut self) {
            let existing_tower_ids: std::collections::HashSet<usize> = self
                .towers
                .iter()
                .map(|tower| tower.id())
                .collect();
            self.ui_state.cleanup_unused_states(&existing_tower_ids);
        }
    }
    pub struct FloorTile {
        pub coord: MapCoord,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FloorTile {
        #[inline]
        fn clone(&self) -> FloorTile {
            let _: ::core::clone::AssertParamIsClone<MapCoord>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FloorTile {}
    impl bincode::Encode for FloorTile {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            bincode::Encode::encode(&self.coord, encoder)?;
            Ok(())
        }
    }
    impl bincode::Decode<()> for FloorTile {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            Ok(Self {
                coord: bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl Serialize for FloorTile {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            buf.write_string("coord");
            self.coord.serialize_without_name(buf);
        }
    }
    impl Deserialize for FloorTile {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let field_name = buf.read_name("coord")?;
            let coord = Deserialize::deserialize_without_name(buf)?;
            Ok(Self { coord })
        }
    }
    impl Component for &FloorTile {
        fn render(self, ctx: &RenderCtx) {
            ctx.add(
                simple_rect(TILE_PX_SIZE, palette::OUTLINE, 1.px(), Color::TRANSPARENT),
            );
        }
    }
    static GAME_STATE_ATOM: Atom<GameState> = Atom::uninitialized();
    pub fn init_game_state<'a>(ctx: &'a RenderCtx) -> Sig<'a, GameState> {
        ctx.init_atom(
                &GAME_STATE_ATOM,
                || {
                    let mut game_state = GameState {
                        monsters: Default::default(),
                        towers: Default::default(),
                        camera: Camera::new(),
                        route: calculate_routes(&[], &TRAVEL_POINTS, MAP_SIZE).unwrap(),
                        backgrounds: generate_backgrounds(),
                        upgrade_state: Default::default(),
                        flow: GameFlow::Defense,
                        stage: 1,
                        left_reroll_chance: 1,
                        monster_spawn_state: MonsterSpawnState::Idle,
                        projectiles: Default::default(),
                        items: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                Item {
                                    effect: Effect::ExtraReroll,
                                    rarity: rarity::Rarity::Epic,
                                    value: 0.5.into(),
                                },
                                Item {
                                    effect: Effect::ExtraReroll,
                                    rarity: rarity::Rarity::Epic,
                                    value: 0.5.into(),
                                },
                                Item {
                                    effect: Effect::Heal { amount: 20.0 },
                                    rarity: rarity::Rarity::Epic,
                                    value: 0.0.into(),
                                },
                            ]),
                        ),
                        gold: 100,
                        cursor_preview: Default::default(),
                        hp: 100.0,
                        shield: 0.0,
                        user_status_effects: Default::default(),
                        left_shop_refresh_chance: 0,
                        left_quest_board_refresh_chance: 0,
                        item_used: false,
                        level: NonZeroUsize::new(1).unwrap(),
                        game_now: Instant::now(),
                        fast_forward_multiplier: Default::default(),
                        rerolled_count: 0,
                        field_particle_system_manager: field_particle::FieldParticleSystemManager::default(),
                        locale: crate::l10n::Locale::KOREAN,
                        play_history: PlayHistory::new(),
                        opened_modal: None,
                        contracts: ::alloc::vec::Vec::new(),
                        stage_modifiers: StageModifiers::new(),
                        ui_state: UIState::new(),
                    };
                    game_state.goto_next_stage();
                    game_state
                },
            )
            .0
    }
    pub fn use_game_state<'a>(ctx: &'a RenderCtx) -> Sig<'a, GameState> {
        ctx.atom(&GAME_STATE_ATOM).0
    }
    pub fn mutate_game_state(f: impl FnOnce(&mut GameState) + Send + Sync + 'static) {
        GAME_STATE_ATOM.mutate(f);
    }
    pub fn set_modal(modal: Option<Modal>) {
        mutate_game_state(|game_state| {
            game_state.opened_modal = modal;
        });
    }
    pub fn force_start() {
        mutate_game_state(|game_state| {
            game_state.goto_defense();
        });
    }
    pub fn is_boss_stage(stage: usize) -> bool {
        #[allow(non_exhaustive_omitted_patterns)]
        match stage {
            15 | 25 | 30 | 35 | 40 | 45 | 46 | 47 | 48 | 49 | 50 => true,
            _ => false,
        }
    }
    /// Make sure that the tower can be placed at the given coord.
    pub fn place_tower(tower: Tower, placing_tower_slot_id: HandSlotId) {
        crate::game_state::mutate_game_state(move |game_state| {
            game_state.place_tower(tower);
            let GameFlow::PlacingTower { hand } = &mut game_state.flow else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            hand.delete_slots(&[placing_tower_slot_id]);
            if let Some(first_slot_id) = hand.get_slot_id_by_index(0)
                && hand.get_item(first_slot_id).is_some()
            {
                hand.select_slot(first_slot_id);
            }
            if hand.is_empty() {
                game_state.goto_defense();
            }
        });
    }
}
mod hand {
    mod hand_slot {
        use super::*;
        use crate::{card::Card, game_state::tower::TowerTemplate};
        use namui::*;
        use std::{any::Any, sync::atomic::AtomicUsize};
        static HAND_SLOT_ID: AtomicUsize = AtomicUsize::new(0);
        pub struct HandSlotId(usize);
        #[automatically_derived]
        impl ::core::fmt::Debug for HandSlotId {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "HandSlotId",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for HandSlotId {
            #[inline]
            fn clone(&self) -> HandSlotId {
                let _: ::core::clone::AssertParamIsClone<usize>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for HandSlotId {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for HandSlotId {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for HandSlotId {
            #[inline]
            fn eq(&self, other: &HandSlotId) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for HandSlotId {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<usize>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for HandSlotId {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for HandSlotId {
            #[inline]
            fn partial_cmp(
                &self,
                other: &HandSlotId,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for HandSlotId {
            #[inline]
            fn cmp(&self, other: &HandSlotId) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        impl bincode::Encode for HandSlotId {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.0, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for HandSlotId {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self(bincode::Decode::decode(decoder)?))
            }
        }
        impl Serialize for HandSlotId {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                self.0.serialize_without_name(buf);
            }
        }
        impl Deserialize for HandSlotId {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field0 = Deserialize::deserialize_without_name(buf)?;
                Ok(Self(field0))
            }
        }
        impl HandSlotId {
            pub fn new() -> Self {
                let id = HAND_SLOT_ID.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
                Self(id)
            }
        }
        impl Default for HandSlotId {
            fn default() -> Self {
                Self::new()
            }
        }
        impl From<HandSlotId> for AddKey {
            fn from(val: HandSlotId) -> Self {
                AddKey::U128(val.0 as u128)
            }
        }
        pub(super) struct ExitAnimation {
            pub start_time: Instant,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ExitAnimation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ExitAnimation",
                    "start_time",
                    &&self.start_time,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExitAnimation {
            #[inline]
            fn clone(&self) -> ExitAnimation {
                let _: ::core::clone::AssertParamIsClone<Instant>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ExitAnimation {}
        impl bincode::Encode for ExitAnimation {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.start_time, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for ExitAnimation {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    start_time: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for ExitAnimation {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("start_time");
                self.start_time.serialize_without_name(buf);
            }
        }
        impl Deserialize for ExitAnimation {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("start_time")?;
                let start_time = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { start_time })
            }
        }
        impl ExitAnimation {
            pub fn new(start_time: Instant) -> Self {
                Self { start_time }
            }
            pub fn is_complete(&self, current_time: Instant) -> bool {
                let elapsed = (current_time - self.start_time).as_secs_f32();
                elapsed >= 0.5
            }
        }
        pub(super) struct HandSlot<Item: State> {
            pub id: HandSlotId,
            pub item: Item,
            pub selected: bool,
            pub xy: Xy<Px>,
            pub exit_animation: Option<ExitAnimation>,
        }
        #[automatically_derived]
        impl<Item: ::core::clone::Clone + State> ::core::clone::Clone
        for HandSlot<Item> {
            #[inline]
            fn clone(&self) -> HandSlot<Item> {
                HandSlot {
                    id: ::core::clone::Clone::clone(&self.id),
                    item: ::core::clone::Clone::clone(&self.item),
                    selected: ::core::clone::Clone::clone(&self.selected),
                    xy: ::core::clone::Clone::clone(&self.xy),
                    exit_animation: ::core::clone::Clone::clone(&self.exit_animation),
                }
            }
        }
        #[automatically_derived]
        impl<Item: ::core::fmt::Debug + State> ::core::fmt::Debug for HandSlot<Item> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "HandSlot",
                    "id",
                    &self.id,
                    "item",
                    &self.item,
                    "selected",
                    &self.selected,
                    "xy",
                    &self.xy,
                    "exit_animation",
                    &&self.exit_animation,
                )
            }
        }
        impl<Item: State> bincode::Encode for HandSlot<Item> {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.id, encoder)?;
                bincode::Encode::encode(&self.item, encoder)?;
                bincode::Encode::encode(&self.selected, encoder)?;
                bincode::Encode::encode(&self.xy, encoder)?;
                bincode::Encode::encode(&self.exit_animation, encoder)?;
                Ok(())
            }
        }
        impl<Item: State> bincode::Decode<()> for HandSlot<Item> {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    id: bincode::Decode::decode(decoder)?,
                    item: bincode::Decode::decode(decoder)?,
                    selected: bincode::Decode::decode(decoder)?,
                    xy: bincode::Decode::decode(decoder)?,
                    exit_animation: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<Item: State> Serialize for HandSlot<Item> {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("id");
                self.id.serialize_without_name(buf);
                buf.write_string("item");
                self.item.serialize_without_name(buf);
                buf.write_string("selected");
                self.selected.serialize_without_name(buf);
                buf.write_string("xy");
                self.xy.serialize_without_name(buf);
                buf.write_string("exit_animation");
                self.exit_animation.serialize_without_name(buf);
            }
        }
        impl<Item: State> Deserialize for HandSlot<Item> {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("id")?;
                let id = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("item")?;
                let item = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("selected")?;
                let selected = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("xy")?;
                let xy = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("exit_animation")?;
                let exit_animation = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    id,
                    item,
                    selected,
                    xy,
                    exit_animation,
                })
            }
        }
        impl<Item: State> HandSlot<Item> {
            pub fn new(item: Item) -> Self {
                Self {
                    id: HandSlotId::new(),
                    item,
                    selected: false,
                    xy: HAND_WH.to_xy(),
                    exit_animation: None,
                }
            }
            pub fn set_xy(&mut self, xy: Xy<Px>) {
                self.xy = xy;
            }
            pub fn start_exit_animation(&mut self, now: Instant) {
                self.exit_animation = Some(ExitAnimation::new(now));
            }
            pub fn is_exit_animation_complete(&self, now: Instant) -> bool {
                if let Some(exit_anim) = self.exit_animation {
                    exit_anim.is_complete(now)
                } else {
                    false
                }
            }
        }
        impl<Item> Component for &HandSlot<Item>
        where
            Item: State + Any,
        {
            fn render(self, ctx: &RenderCtx) {
                let (target_xy, target_scale) = if self.exit_animation.is_some() {
                    (Xy::new(self.xy.x, HAND_WH.height), Xy::single(0.0))
                } else {
                    let xy = match self.selected {
                        true => self.xy - Xy::new(px(0.0), px(32.0)),
                        false => self.xy,
                    };
                    let scale = match self.selected {
                        true => Xy::single(1.05),
                        false => Xy::single(1.0),
                    };
                    (xy, scale)
                };
                let animated_xy = xy_with_spring(ctx, target_xy, HAND_WH.to_xy());
                let animated_scale = xy_with_spring(ctx, target_scale, Xy::single(1.0));
                let half_slot_xy = HAND_SLOT_WH.to_xy() * 0.5;
                let ctx = ctx
                    .translate(animated_xy)
                    .translate(half_slot_xy)
                    .scale(animated_scale)
                    .translate(-half_slot_xy);
                if let Some(card) = (&self.item as &dyn Any).downcast_ref::<Card>() {
                    ctx.add(RenderCard {
                        wh: HAND_SLOT_WH,
                        card,
                    });
                } else if let Some(tower_template) = (&self.item as &dyn Any)
                    .downcast_ref::<TowerTemplate>()
                {
                    ctx.add(RenderTower {
                        wh: HAND_SLOT_WH,
                        tower_template,
                    });
                } else {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!(
                                    "Invalid item type: {0}",
                                    std::any::type_name::<Item>(),
                                ),
                            ),
                        );
                    };
                }
            }
        }
    }
    mod render_card {
        use super::*;
        use crate::{
            card::{Card, FaceCardImage, Rank},
            icon::{Icon, IconKind, IconSize},
        };
        use namui::*;
        pub(super) struct RenderCard<'a> {
            pub wh: Wh<Px>,
            pub card: &'a Card,
        }
        impl Component for RenderCard<'_> {
            fn render(self, ctx: &RenderCtx) {
                let Self { wh, card } = self;
                render_top_left_rank_and_suit(ctx, card.rank, card.suit);
                if !card.rank.is_face() {
                    self.render_center_suits(ctx, wh, card);
                } else {
                    self.render_face_card(ctx, wh, card);
                }
                render_background_rect(ctx, wh);
            }
        }
        impl<'a> RenderCard<'a> {
            fn render_center_suits(&self, ctx: &RenderCtx, wh: Wh<Px>, card: &'a Card) {
                let center_area = Rect::Xywh {
                    x: px(36.0),
                    y: px(36.0),
                    width: wh.width - px(72.0),
                    height: wh.height - px(72.0),
                };
                let suit_positions = self
                    .get_suit_positions_for_rank(card.rank, center_area);
                let suit_size = px(24.0);
                let ctx = ctx.translate(center_area.xy() - Xy::single(suit_size * 0.5));
                for position in suit_positions {
                    ctx.translate(position)
                        .add(
                            Icon::new(IconKind::Suit { suit: card.suit })
                                .wh(Wh::new(suit_size, suit_size))
                                .size(IconSize::Custom {
                                    size: suit_size,
                                }),
                        );
                }
            }
            fn render_face_card(&self, ctx: &RenderCtx, wh: Wh<Px>, card: &'a Card) {
                let center_area = Rect::Xywh {
                    x: px(12.0),
                    y: px(12.0),
                    width: wh.width - px(24.0),
                    height: wh.height - px(24.0),
                };
                let face_image = (card.rank, card.suit).image();
                ctx.add(
                    image(ImageParam {
                        image: face_image,
                        rect: center_area,
                        style: ImageStyle {
                            fit: ImageFit::Contain,
                            paint: None,
                        },
                    }),
                );
            }
            fn get_suit_positions_for_rank(
                &self,
                rank: Rank,
                center_area: Rect<Px>,
            ) -> Vec<Xy<Px>> {
                let left_x = px(0.0);
                let center_x = center_area.width() * 0.5;
                let right_x = center_area.width();
                let y0 = px(0.0);
                let y1 = center_area.height() * 0.16665;
                let y2 = center_area.height() * 0.25;
                let y3 = center_area.height() * 0.33333;
                let y4 = center_area.height() * 0.5;
                let y5 = center_area.height() * 0.66666;
                let y6 = center_area.height() * 0.75;
                let y7 = center_area.height() * 0.83331;
                let y8 = center_area.height();
                match rank {
                    Rank::Seven => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                Xy::new(left_x, y0),
                                Xy::new(right_x, y0),
                                Xy::new(center_x, y2),
                                Xy::new(left_x, y4),
                                Xy::new(right_x, y4),
                                Xy::new(left_x, y8),
                                Xy::new(right_x, y8),
                            ]),
                        )
                    }
                    Rank::Eight => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                Xy::new(left_x, y0),
                                Xy::new(right_x, y0),
                                Xy::new(center_x, y2),
                                Xy::new(left_x, y4),
                                Xy::new(right_x, y4),
                                Xy::new(center_x, y6),
                                Xy::new(left_x, y8),
                                Xy::new(right_x, y8),
                            ]),
                        )
                    }
                    Rank::Nine => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                Xy::new(left_x, y0),
                                Xy::new(right_x, y0),
                                Xy::new(left_x, y3),
                                Xy::new(right_x, y3),
                                Xy::new(center_x, y4),
                                Xy::new(left_x, y5),
                                Xy::new(right_x, y5),
                                Xy::new(left_x, y8),
                                Xy::new(right_x, y8),
                            ]),
                        )
                    }
                    Rank::Ten => {
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                Xy::new(left_x, y0),
                                Xy::new(right_x, y0),
                                Xy::new(center_x, y1),
                                Xy::new(left_x, y3),
                                Xy::new(right_x, y3),
                                Xy::new(left_x, y5),
                                Xy::new(right_x, y5),
                                Xy::new(center_x, y7),
                                Xy::new(left_x, y8),
                                Xy::new(right_x, y8),
                            ]),
                        )
                    }
                    Rank::Ace => {
                        <[_]>::into_vec(::alloc::boxed::box_new([Xy::new(center_x, y4)]))
                    }
                    Rank::Jack | Rank::Queen | Rank::King => ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    mod render_tower {
        use super::*;
        use crate::game_state::tower::{
            AnimationKind, TowerKind, TowerTemplate,
            render::TowerImage as TowerImageTrait,
        };
        use namui::*;
        pub(super) struct RenderTower<'a> {
            pub wh: Wh<Px>,
            pub tower_template: &'a TowerTemplate,
        }
        impl Component for RenderTower<'_> {
            fn render(self, ctx: &RenderCtx) {
                let Self { wh, tower_template } = self;
                let tower_image = (tower_template.kind, AnimationKind::Idle1).image();
                if tower_template.kind != TowerKind::Barricade {
                    render_top_left_rank_and_suit(
                        ctx,
                        tower_template.rank,
                        tower_template.suit,
                    );
                }
                ctx.add(
                    image(ImageParam {
                        rect: wh.to_rect(),
                        image: tower_image,
                        style: ImageStyle {
                            fit: ImageFit::Contain,
                            paint: None,
                        },
                    }),
                );
                render_background_rect(ctx, wh);
            }
        }
    }
    pub mod shared {
        use crate::{
            card::{Rank, Suit},
            icon::{Icon, IconKind, IconSize},
            theme::{palette, typography::{FontSize, TextAlign, headline}},
        };
        use namui::*;
        /// suit에 따른 색상을 반환하는 헬퍼 함수
        pub fn get_suit_color(suit: Suit) -> Color {
            match suit {
                Suit::Spades | Suit::Clubs => Color::BLACK,
                Suit::Hearts | Suit::Diamonds => palette::RED,
            }
        }
        /// 좌상단에 rank와 suit를 수직 배치로 렌더링
        pub(super) fn render_top_left_rank_and_suit(
            ctx: &RenderCtx,
            rank: Rank,
            suit: Suit,
        ) {
            let padding = px(4.0);
            let rank_font_size = FontSize::Small;
            let icon_wh = Wh::new(20.px(), 12.px());
            let text_color = get_suit_color(suit);
            let ctx = ctx.translate(Xy::new(padding, padding));
            ctx.add(
                headline(rank.to_string())
                    .size(rank_font_size)
                    .color(text_color)
                    .align(TextAlign::Center { wh: icon_wh })
                    .build(),
            );
            ctx.translate(Xy::new(0.px(), icon_wh.height + padding))
                .add(
                    Icon::new(IconKind::Suit { suit })
                        .wh(icon_wh)
                        .size(IconSize::Custom {
                            size: icon_wh.height,
                        }),
                );
        }
        /// 카드/타워 배경 rect를 렌더링
        pub(super) fn render_background_rect(ctx: &RenderCtx, wh: Wh<Px>) {
            ctx.add(
                rect(RectParam {
                    rect: wh.to_rect(),
                    style: RectStyle {
                        stroke: Some(RectStroke {
                            color: palette::OUTLINE,
                            width: 4.px(),
                            border_position: BorderPosition::Inside,
                        }),
                        fill: Some(RectFill { color: Color::WHITE }),
                        round: Some(RectRound {
                            radius: palette::ROUND,
                        }),
                    },
                }),
            );
        }
    }
    mod xy_with_spring {
        use namui::*;
        use std::ops::{Add, Mul, Sub};
        const SPRING_STRENGTH: f32 = 350.0;
        const DAMPING: f32 = 25.0;
        const SNAP_THRESHOLD: f32 = 0.5;
        const VELOCITY_THRESHOLD: f32 = 0.5;
        const MAX_DELTA_TIME: f32 = 1.0 / 30.0;
        const MIN_DELTA_TIME: f32 = 0.001;
        const SNAP_THRESHOLD_SQ: f32 = SNAP_THRESHOLD * SNAP_THRESHOLD;
        const VELOCITY_THRESHOLD_SQ: f32 = VELOCITY_THRESHOLD * VELOCITY_THRESHOLD;
        const NEG_DAMPING: f32 = -DAMPING;
        pub fn xy_with_spring<T>(
            ctx: &RenderCtx,
            target_xy: Xy<T>,
            initial_xy: Xy<T>,
        ) -> Xy<T>
        where
            T: Copy + Add<Output = T> + Sub<Output = T> + Mul<f32, Output = T>
                + PartialEq + std::fmt::Debug + Send + Sync + 'static + State,
            T: From<f32> + Into<f32>,
        {
            let now = Instant::now();
            let (context, set_context) = ctx
                .state(|| SpringAnimationContext {
                    last_tick_at: now,
                    velocity: Xy::new(0.0.into(), 0.0.into()),
                    position: initial_xy,
                });
            let mut delta_time = (now - context.last_tick_at).as_secs_f32();
            if delta_time < MIN_DELTA_TIME {
                return context.position;
            }
            delta_time = delta_time.min(MAX_DELTA_TIME);
            let displacement = target_xy - context.position;
            let displacement_x_f32: f32 = displacement.x.into();
            let displacement_y_f32: f32 = displacement.y.into();
            let velocity_x_f32: f32 = context.velocity.x.into();
            let velocity_y_f32: f32 = context.velocity.y.into();
            let displacement_magnitude_sq = displacement_x_f32 * displacement_x_f32
                + displacement_y_f32 * displacement_y_f32;
            if displacement_magnitude_sq < SNAP_THRESHOLD_SQ {
                let velocity_magnitude_sq = velocity_x_f32 * velocity_x_f32
                    + velocity_y_f32 * velocity_y_f32;
                if velocity_magnitude_sq < VELOCITY_THRESHOLD_SQ {
                    set_context
                        .mutate(move |ctx| {
                            ctx.last_tick_at = now;
                            ctx.velocity = Xy::new(0.0.into(), 0.0.into());
                            ctx.position = target_xy;
                        });
                    return target_xy;
                }
            }
            let spring_force = displacement * SPRING_STRENGTH;
            let damping_force = context.velocity * NEG_DAMPING;
            let total_force = spring_force + damping_force;
            let new_velocity = context.velocity + total_force * delta_time;
            let new_position = context.position + new_velocity * delta_time;
            set_context
                .mutate(move |ctx| {
                    ctx.last_tick_at = now;
                    ctx.velocity = new_velocity;
                    ctx.position = new_position;
                });
            new_position
        }
        struct SpringAnimationContext<T: std::fmt::Debug + State> {
            last_tick_at: Instant,
            velocity: Xy<T>,
            position: Xy<T>,
        }
        impl<T: std::fmt::Debug + State> bincode::Encode for SpringAnimationContext<T> {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.last_tick_at, encoder)?;
                bincode::Encode::encode(&self.velocity, encoder)?;
                bincode::Encode::encode(&self.position, encoder)?;
                Ok(())
            }
        }
        impl<T: std::fmt::Debug + State> bincode::Decode<()>
        for SpringAnimationContext<T> {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    last_tick_at: bincode::Decode::decode(decoder)?,
                    velocity: bincode::Decode::decode(decoder)?,
                    position: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl<T: std::fmt::Debug + State> Serialize for SpringAnimationContext<T> {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("last_tick_at");
                self.last_tick_at.serialize_without_name(buf);
                buf.write_string("velocity");
                self.velocity.serialize_without_name(buf);
                buf.write_string("position");
                self.position.serialize_without_name(buf);
            }
        }
        impl<T: std::fmt::Debug + State> Deserialize for SpringAnimationContext<T> {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("last_tick_at")?;
                let last_tick_at = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("velocity")?;
                let velocity = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("position")?;
                let position = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    last_tick_at,
                    velocity,
                    position,
                })
            }
        }
    }
    use hand_slot::HandSlot;
    pub use hand_slot::HandSlotId;
    use namui::*;
    use render_card::RenderCard;
    use render_tower::RenderTower;
    use shared::*;
    use std::{any::Any, cmp::Ordering, fmt::Debug};
    pub use xy_with_spring::xy_with_spring;
    pub const HAND_SLOT_WH: Wh<Px> = Wh::new(px(112.), px(152.));
    pub const HAND_WH: Wh<Px> = Wh::new(px(600.), px(160.));
    const DEFAULT_SLOT_GAP: Px = px(8.0);
    pub struct Hand<Item: State + Debug> {
        slots: Vec<HandSlot<Item>>,
    }
    #[automatically_derived]
    impl<Item: ::core::default::Default + State + Debug> ::core::default::Default
    for Hand<Item> {
        #[inline]
        fn default() -> Hand<Item> {
            Hand {
                slots: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl<Item: ::core::clone::Clone + State + Debug> ::core::clone::Clone
    for Hand<Item> {
        #[inline]
        fn clone(&self) -> Hand<Item> {
            Hand {
                slots: ::core::clone::Clone::clone(&self.slots),
            }
        }
    }
    #[automatically_derived]
    impl<Item: ::core::fmt::Debug + State + Debug> ::core::fmt::Debug for Hand<Item> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Hand",
                "slots",
                &&self.slots,
            )
        }
    }
    impl<Item: State + Debug> bincode::Encode for Hand<Item> {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            bincode::Encode::encode(&self.slots, encoder)?;
            Ok(())
        }
    }
    impl<Item: State + Debug> bincode::Decode<()> for Hand<Item> {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            Ok(Self {
                slots: bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl<Item: State + Debug> Serialize for Hand<Item> {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            buf.write_string("slots");
            self.slots.serialize_without_name(buf);
        }
    }
    impl<Item: State + Debug> Deserialize for Hand<Item> {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let field_name = buf.read_name("slots")?;
            let slots = Deserialize::deserialize_without_name(buf)?;
            Ok(Self { slots })
        }
    }
    impl<Item: State + PartialOrd + Debug> Hand<Item> {
        pub fn new(items: impl IntoIterator<Item = Item>) -> Self {
            let slots = items.into_iter().map(|item| HandSlot::new(item)).collect();
            let mut hand = Self { slots };
            hand.calculate_slot_xy();
            hand
        }
        pub fn delete_slots(&mut self, ids: &[HandSlotId]) {
            let now = Instant::now();
            for slot in self.slots.iter_mut() {
                if ids.contains(&slot.id) {
                    slot.start_exit_animation(now);
                    slot.selected = false;
                }
            }
            self.calculate_slot_xy();
        }
        pub fn remove_completed_exit_animations(&mut self) {
            let now = Instant::now();
            let has_completed_animations = self
                .slots
                .iter()
                .any(|slot| slot.is_exit_animation_complete(now));
            if has_completed_animations {
                self.slots.retain(|slot| !slot.is_exit_animation_complete(now));
            }
        }
        pub fn update(&mut self) {
            self.remove_completed_exit_animations();
        }
        pub fn active_slot_ids(&self) -> Vec<HandSlotId> {
            self.active_slots().map(|slot| slot.id).collect()
        }
        pub fn selected_slot_ids(&self) -> Vec<HandSlotId> {
            self.active_slots()
                .filter_map(|slot| match slot.selected {
                    true => Some(slot.id),
                    false => None,
                })
                .collect()
        }
        pub fn select_slot(&mut self, id: HandSlotId) {
            if let Some(slot) = self.find_slot_by_id_mut(id) {
                if slot.exit_animation.is_some() {
                    return;
                }
                slot.selected = true;
            }
        }
        pub fn deselect_slot(&mut self, id: HandSlotId) {
            if let Some(slot) = self.find_slot_by_id_mut(id) {
                slot.selected = false;
            }
        }
        pub fn get_slot_id_by_index(&self, index: usize) -> Option<HandSlotId> {
            self.slots.get(index).map(|slot| slot.id)
        }
        pub fn is_empty(&self) -> bool {
            self.active_slots().next().is_none()
        }
        pub fn get_items(&self, slot_ids: &[HandSlotId]) -> impl Iterator<Item = &Item> {
            slot_ids
                .iter()
                .map(|id| &self.slots.iter().find(|slot| slot.id == *id).unwrap().item)
        }
        pub fn push(&mut self, item: Item) {
            self.slots.push(HandSlot::new(item));
            self.calculate_slot_xy();
        }
        fn sort_slots(&mut self) {
            self.slots
                .sort_by(|a, b| {
                    match (a.exit_animation.is_some(), b.exit_animation.is_some()) {
                        (true, false) => return Ordering::Greater,
                        (false, true) => return Ordering::Less,
                        _ => {}
                    }
                    a.item.partial_cmp(&b.item).unwrap().reverse()
                });
        }
        fn calculate_layout(slot_count: f32) -> (Px, Px) {
            let slot_width = HAND_SLOT_WH.width;
            let hand_width = HAND_WH.width;
            let total_width_with_default_gap = slot_width * slot_count
                + DEFAULT_SLOT_GAP * (slot_count - 1.0);
            let gap = if total_width_with_default_gap > hand_width {
                (hand_width - slot_width * slot_count) / (slot_count - 1.0)
            } else {
                DEFAULT_SLOT_GAP
            };
            let total_width = slot_width * slot_count + gap * (slot_count - 1.0);
            let start_x = (hand_width - total_width) / 2.0;
            (start_x, gap)
        }
        fn calculate_slot_xy(&mut self) {
            self.sort_slots();
            let active_slots: Vec<(usize, &mut HandSlot<Item>)> = self
                .slots
                .iter_mut()
                .enumerate()
                .filter(|(_, slot)| slot.exit_animation.is_none())
                .collect();
            let slot_count = active_slots.len();
            if slot_count == 0 {
                return;
            }
            let (start_x, gap) = Self::calculate_layout(slot_count as f32);
            let slot_width = HAND_SLOT_WH.width;
            for (active_index, (_, slot)) in active_slots.into_iter().enumerate() {
                let x = start_x + (slot_width + gap) * active_index as f32;
                let y = (HAND_WH.height - HAND_SLOT_WH.height) / 2.0;
                slot.set_xy(Xy { x, y });
            }
        }
        fn find_slot_by_id_mut(
            &mut self,
            id: HandSlotId,
        ) -> Option<&mut HandSlot<Item>> {
            self.slots.iter_mut().find(|slot| slot.id == id)
        }
        fn active_slots(&self) -> impl Iterator<Item = &HandSlot<Item>> {
            self.slots.iter().filter(|slot| slot.exit_animation.is_none())
        }
        pub fn get_item(&self, slot_id: HandSlotId) -> Option<&Item> {
            self.slots.iter().find(|slot| slot.id == slot_id).map(|slot| &slot.item)
        }
    }
    pub struct HandComponent<'a, Item: State + Debug> {
        pub hand: &'a Hand<Item>,
        pub on_click: &'a dyn Fn(HandSlotId),
    }
    impl<'a, Item> Component for HandComponent<'a, Item>
    where
        Item: State + Debug + Any,
    {
        fn render(self, ctx: &RenderCtx) {
            let HandComponent { hand, on_click } = self;
            for slot in &hand.slots {
                ctx.mouse_cursor(MouseCursor::Standard(StandardCursor::Pointer))
                    .add_with_key(slot.id, slot)
                    .attach_event(|event| {
                        let Event::MouseDown { event } = event else {
                            return;
                        };
                        if !event.is_local_xy_in() {
                            return;
                        }
                        event.stop_propagation();
                        (on_click)(slot.id);
                    });
            }
        }
    }
}
mod icon {
    mod component {
        use crate::icon::Icon;
        use namui::*;
        impl Component for Icon {
            fn render(self, ctx: &RenderCtx) {
                let Self { kind, size, attributes, wh, opacity } = self;
                let icon_size = size.px();
                let icon_wh = Wh {
                    width: icon_size,
                    height: icon_size,
                };
                let icon_xy = Xy::new(
                    (wh.width - icon_wh.width) / 2.0,
                    (wh.height - icon_wh.height) / 2.0,
                );
                let rect = Rect::from_xy_wh(icon_xy, icon_wh);
                let image = kind.image();
                let paint = if opacity < 1.0 {
                    Some(Paint::new(Color::from_f01(1.0, 1.0, 1.0, opacity)))
                } else {
                    None
                };
                for attribute in attributes {
                    let attribute_image = attribute.icon_kind.image();
                    let attribute_render_rect = attribute.attribute_render_rect(rect);
                    ctx.add(
                        namui::image(ImageParam {
                            rect: attribute_render_rect,
                            image: attribute_image,
                            style: ImageStyle {
                                fit: ImageFit::Contain,
                                paint: paint.clone(),
                            },
                        }),
                    );
                }
                ctx.add(
                    namui::image(ImageParam {
                        rect,
                        image,
                        style: ImageStyle {
                            fit: ImageFit::Contain,
                            paint,
                        },
                    }),
                );
            }
        }
    }
    mod rendering_tree {
        use crate::icon::Icon;
        use namui::*;
        use namui_prebuilt::simple_rect;
        impl Icon {
            pub fn to_rendering_tree(&self) -> RenderingTree {
                let Self { kind, size, attributes, wh, opacity } = self;
                let icon_size = size.px();
                let icon_wh = Wh {
                    width: icon_size,
                    height: icon_size,
                };
                let icon_xy = Xy::new(
                    (wh.width - icon_wh.width) / 2.0,
                    (wh.height - icon_wh.height) / 2.0,
                );
                let rect = Rect::from_xy_wh(icon_xy, icon_wh);
                let mut rendering_trees = Vec::new();
                for attribute in attributes {
                    let attribute_image = attribute.icon_kind.image();
                    let attribute_render_rect = attribute.attribute_render_rect(rect);
                    let paint = if *opacity < 1.0 {
                        Some(Paint::new(Color::from_f01(1.0, 1.0, 1.0, *opacity)))
                    } else {
                        None
                    };
                    rendering_trees
                        .push(
                            namui::image(ImageParam {
                                rect: attribute_render_rect,
                                image: attribute_image,
                                style: ImageStyle {
                                    fit: ImageFit::Contain,
                                    paint: paint.clone(),
                                },
                            }),
                        );
                }
                let image = kind.image();
                let paint = if *opacity < 1.0 {
                    Some(Paint::new(Color::from_f01(1.0, 1.0, 1.0, *opacity)))
                } else {
                    None
                };
                rendering_trees
                    .push(
                        namui::image(ImageParam {
                            rect,
                            image,
                            style: ImageStyle {
                                fit: ImageFit::Contain,
                                paint,
                            },
                        }),
                    );
                rendering_trees
                    .push(
                        simple_rect(*wh, Color::TRANSPARENT, 0.px(), Color::TRANSPARENT),
                    );
                namui::render(rendering_trees)
            }
        }
    }
    pub mod rich_text {
        use crate::icon::{
            Icon, IconAttribute, IconAttributePosition, IconKind, IconSize,
        };
        use namui::*;
        pub enum IconParseError {
            Format,
            Kind,
            Size,
            Dimensions,
            Opacity,
            Attribute,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IconParseError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        IconParseError::Format => "Format",
                        IconParseError::Kind => "Kind",
                        IconParseError::Size => "Size",
                        IconParseError::Dimensions => "Dimensions",
                        IconParseError::Opacity => "Opacity",
                        IconParseError::Attribute => "Attribute",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IconParseError {
            #[inline]
            fn clone(&self) -> IconParseError {
                match self {
                    IconParseError::Format => IconParseError::Format,
                    IconParseError::Kind => IconParseError::Kind,
                    IconParseError::Size => IconParseError::Size,
                    IconParseError::Dimensions => IconParseError::Dimensions,
                    IconParseError::Opacity => IconParseError::Opacity,
                    IconParseError::Attribute => IconParseError::Attribute,
                }
            }
        }
        impl bincode::Encode for IconParseError {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Format => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Kind => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::Size => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::Dimensions => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                    Self::Opacity => {
                        bincode::Encode::encode(&4u32, encoder)?;
                    }
                    Self::Attribute => {
                        bincode::Encode::encode(&5u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for IconParseError {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Format),
                    1u32 => Ok(Self::Kind),
                    2u32 => Ok(Self::Size),
                    3u32 => Ok(Self::Dimensions),
                    4u32 => Ok(Self::Opacity),
                    5u32 => Ok(Self::Attribute),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 5u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for IconParseError {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Format => {
                        buf.write_string("Format");
                    }
                    Self::Kind => {
                        buf.write_string("Kind");
                    }
                    Self::Size => {
                        buf.write_string("Size");
                    }
                    Self::Dimensions => {
                        buf.write_string("Dimensions");
                    }
                    Self::Opacity => {
                        buf.write_string("Opacity");
                    }
                    Self::Attribute => {
                        buf.write_string("Attribute");
                    }
                }
            }
        }
        impl Deserialize for IconParseError {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Format" => Ok(Self::Format),
                    "Kind" => Ok(Self::Kind),
                    "Size" => Ok(Self::Size),
                    "Dimensions" => Ok(Self::Dimensions),
                    "Opacity" => Ok(Self::Opacity),
                    "Attribute" => Ok(Self::Attribute),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl Icon {
            pub fn as_tag(&self) -> String {
                let Self { kind, size, attributes, wh, opacity } = self;
                let kind_part = kind.asset_id();
                let size_part = size.px().as_f32().to_string();
                let width_part = wh.width.as_f32().to_string();
                let height_part = wh.height.as_f32().to_string();
                let opacity_part = opacity.to_string();
                let attr_part = if attributes.is_empty() {
                    String::new()
                } else {
                    let attr_strings: Vec<String> = attributes
                        .iter()
                        .map(|attr| ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}_{1}",
                                    attr.icon_kind.asset_id(),
                                    attr.position.as_str(),
                                ),
                            )
                        }))
                        .collect();
                    attr_strings.join(",")
                };
                if attr_part.is_empty() {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "icon<{0}:{1}:{2}:{3}:{4}>",
                                kind_part,
                                size_part,
                                width_part,
                                height_part,
                                opacity_part,
                            ),
                        )
                    })
                } else {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "icon<{0}:{1}:{2}:{3}:{4}:{5}>",
                                kind_part,
                                size_part,
                                width_part,
                                height_part,
                                opacity_part,
                                attr_part,
                            ),
                        )
                    })
                }
            }
            pub fn from_tag(tag: &str) -> Result<Self, IconParseError> {
                if !tag.starts_with("icon<") || !tag.ends_with(">") {
                    return Err(IconParseError::Format);
                }
                let content = &tag[5..tag.len() - 1];
                let parts: Vec<&str> = content.split(':').collect();
                if parts.len() < 5 {
                    return Err(IconParseError::Format);
                }
                let kind = IconKind::from_asset_id(parts[0])
                    .ok_or(IconParseError::Kind)?;
                let size_value = parts[1]
                    .parse::<f32>()
                    .map_err(|_| IconParseError::Size)?;
                let size = IconSize::Custom {
                    size: px(size_value),
                };
                let width = parts[2]
                    .parse::<f32>()
                    .map_err(|_| IconParseError::Dimensions)?;
                let height = parts[3]
                    .parse::<f32>()
                    .map_err(|_| IconParseError::Dimensions)?;
                let wh = Wh {
                    width: px(width),
                    height: px(height),
                };
                let opacity = parts[4]
                    .parse::<f32>()
                    .map_err(|_| IconParseError::Opacity)?;
                let mut attributes = Vec::new();
                if parts.len() > 5 {
                    let attr_content = parts[5];
                    if !attr_content.is_empty() {
                        let attr_items: Vec<&str> = attr_content.split(',').collect();
                        for attr_item in attr_items {
                            let position_parts = [
                                "_top_left",
                                "_top_right",
                                "_bottom_left",
                                "_bottom_right",
                                "_center",
                            ];
                            let mut found_position = None;
                            let mut attr_kind_str = attr_item;
                            for &pos_suffix in &position_parts {
                                if attr_item.ends_with(pos_suffix) {
                                    found_position = Some(&pos_suffix[1..]);
                                    attr_kind_str = attr_item.strip_suffix(pos_suffix).unwrap();
                                    break;
                                }
                            }
                            if let Some(pos_str) = found_position {
                                let attr_kind = IconKind::from_asset_id(attr_kind_str)
                                    .ok_or(IconParseError::Attribute)?;
                                let attr_position = IconAttributePosition::from_str(pos_str)
                                    .ok_or(IconParseError::Attribute)?;
                                attributes
                                    .push(IconAttribute {
                                        icon_kind: attr_kind,
                                        position: attr_position,
                                    });
                            } else {
                                return Err(IconParseError::Attribute);
                            }
                        }
                    }
                }
                Ok(Icon {
                    kind,
                    size,
                    attributes,
                    wh,
                    opacity,
                })
            }
            /// Regular expression pattern for matching icon tags
            pub fn tag_regex_pattern() -> &'static str {
                r"icon<[^:>]+:[0-9]+(?:\.[0-9]+)?:[0-9]+(?:\.[0-9]+)?:[0-9]+(?:\.[0-9]+)?:[0-9]+(?:\.[0-9]+)?(?::[^>]*(?:_(?:top_left|top_right|bottom_left|bottom_right|center)(?:,[^>]*_(?:top_left|top_right|bottom_left|bottom_right|center))*)?)?>"
            }
            /// Check if a string matches the icon tag format using regex
            pub fn is_valid_tag_format(tag: &str) -> bool {
                if !tag.starts_with("icon<") || !tag.ends_with(">") || tag.len() <= 6 {
                    return false;
                }
                let content = &tag[5..tag.len() - 1];
                let parts: Vec<&str> = content.split(':').collect();
                if parts.len() < 5 {
                    return false;
                }
                for part in parts.iter().take(5).skip(1) {
                    if part.parse::<f32>().is_err() {
                        return false;
                    }
                }
                if parts.len() > 5 {
                    let attr_content = parts[5];
                    if !attr_content.is_empty() {
                        let attr_items: Vec<&str> = attr_content.split(',').collect();
                        let position_suffixes = [
                            "_top_left",
                            "_top_right",
                            "_bottom_left",
                            "_bottom_right",
                            "_center",
                        ];
                        for attr_item in attr_items {
                            let has_valid_position = position_suffixes
                                .iter()
                                .any(|&suffix| attr_item.ends_with(suffix));
                            if !has_valid_position {
                                return false;
                            }
                        }
                    }
                }
                true
            }
            /// Create regex handlers for icon pattern matching in rich text
            pub fn create_icon_regex_handlers() -> Vec<
                namui_prebuilt::rich_text::RegexHandler,
            > {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        namui_prebuilt::rich_text::RegexHandler::new(
                                r"icon<[^>]+>",
                                Box::new(move |matched_text| {
                                    if let Ok(icon) = Icon::from_tag(matched_text) {
                                        icon.to_rendering_tree()
                                    } else {
                                        Self::render_icon_error_fallback(matched_text)
                                    }
                                }),
                            )
                            .unwrap_or_else(|_| {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "Failed to create regex handler for icon tag\n",
                                        ),
                                    );
                                };
                                namui_prebuilt::rich_text::RegexHandler::new(
                                        r"icon<[^>]+>",
                                        Box::new(|_| RenderingTree::Empty),
                                    )
                                    .unwrap()
                            }),
                    ]),
                )
            }
            /// Render a fallback error icon when parsing fails
            pub fn render_icon_error_fallback(_matched_text: &str) -> RenderingTree {
                namui::rect(RectParam {
                    rect: Rect::Xywh {
                        x: 0.px(),
                        y: 0.px(),
                        width: 16.px(),
                        height: 16.px(),
                    },
                    style: RectStyle {
                        fill: Some(RectFill {
                            color: Color::from_u8(0, 0, 0, 32),
                        }),
                        stroke: None,
                        ..Default::default()
                    },
                })
            }
        }
    }
    use crate::{card::Suit, rarity::Rarity, theme::palette};
    use namui::*;
    pub enum IconKind {
        Accept,
        AttackDamage,
        AttackRange,
        AttackSpeed,
        Config,
        EnemyBoss,
        EnemyNamed,
        EnemyNormal,
        Gold,
        Health,
        Invincible,
        Item,
        Level,
        Lock,
        MoveSpeed,
        Quest,
        Refresh,
        Reject,
        Shield,
        Shop,
        Speaker,
        Suit { suit: Suit },
        Up,
        Down,
        Card,
        New,
        Add,
        Multiply,
        Rarity { rarity: Rarity },
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IconKind {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                IconKind::Accept => ::core::fmt::Formatter::write_str(f, "Accept"),
                IconKind::AttackDamage => {
                    ::core::fmt::Formatter::write_str(f, "AttackDamage")
                }
                IconKind::AttackRange => {
                    ::core::fmt::Formatter::write_str(f, "AttackRange")
                }
                IconKind::AttackSpeed => {
                    ::core::fmt::Formatter::write_str(f, "AttackSpeed")
                }
                IconKind::Config => ::core::fmt::Formatter::write_str(f, "Config"),
                IconKind::EnemyBoss => ::core::fmt::Formatter::write_str(f, "EnemyBoss"),
                IconKind::EnemyNamed => {
                    ::core::fmt::Formatter::write_str(f, "EnemyNamed")
                }
                IconKind::EnemyNormal => {
                    ::core::fmt::Formatter::write_str(f, "EnemyNormal")
                }
                IconKind::Gold => ::core::fmt::Formatter::write_str(f, "Gold"),
                IconKind::Health => ::core::fmt::Formatter::write_str(f, "Health"),
                IconKind::Invincible => {
                    ::core::fmt::Formatter::write_str(f, "Invincible")
                }
                IconKind::Item => ::core::fmt::Formatter::write_str(f, "Item"),
                IconKind::Level => ::core::fmt::Formatter::write_str(f, "Level"),
                IconKind::Lock => ::core::fmt::Formatter::write_str(f, "Lock"),
                IconKind::MoveSpeed => ::core::fmt::Formatter::write_str(f, "MoveSpeed"),
                IconKind::Quest => ::core::fmt::Formatter::write_str(f, "Quest"),
                IconKind::Refresh => ::core::fmt::Formatter::write_str(f, "Refresh"),
                IconKind::Reject => ::core::fmt::Formatter::write_str(f, "Reject"),
                IconKind::Shield => ::core::fmt::Formatter::write_str(f, "Shield"),
                IconKind::Shop => ::core::fmt::Formatter::write_str(f, "Shop"),
                IconKind::Speaker => ::core::fmt::Formatter::write_str(f, "Speaker"),
                IconKind::Suit { suit: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Suit",
                        "suit",
                        &__self_0,
                    )
                }
                IconKind::Up => ::core::fmt::Formatter::write_str(f, "Up"),
                IconKind::Down => ::core::fmt::Formatter::write_str(f, "Down"),
                IconKind::Card => ::core::fmt::Formatter::write_str(f, "Card"),
                IconKind::New => ::core::fmt::Formatter::write_str(f, "New"),
                IconKind::Add => ::core::fmt::Formatter::write_str(f, "Add"),
                IconKind::Multiply => ::core::fmt::Formatter::write_str(f, "Multiply"),
                IconKind::Rarity { rarity: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Rarity",
                        "rarity",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IconKind {
        #[inline]
        fn clone(&self) -> IconKind {
            let _: ::core::clone::AssertParamIsClone<Suit>;
            let _: ::core::clone::AssertParamIsClone<Rarity>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for IconKind {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IconKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IconKind {
        #[inline]
        fn eq(&self, other: &IconKind) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        IconKind::Suit { suit: __self_0 },
                        IconKind::Suit { suit: __arg1_0 },
                    ) => __self_0 == __arg1_0,
                    (
                        IconKind::Rarity { rarity: __self_0 },
                        IconKind::Rarity { rarity: __arg1_0 },
                    ) => __self_0 == __arg1_0,
                    _ => true,
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for IconKind {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Suit>;
            let _: ::core::cmp::AssertParamIsEq<Rarity>;
        }
    }
    impl bincode::Encode for IconKind {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            match self {
                Self::Accept => {
                    bincode::Encode::encode(&0u32, encoder)?;
                }
                Self::AttackDamage => {
                    bincode::Encode::encode(&1u32, encoder)?;
                }
                Self::AttackRange => {
                    bincode::Encode::encode(&2u32, encoder)?;
                }
                Self::AttackSpeed => {
                    bincode::Encode::encode(&3u32, encoder)?;
                }
                Self::Config => {
                    bincode::Encode::encode(&4u32, encoder)?;
                }
                Self::EnemyBoss => {
                    bincode::Encode::encode(&5u32, encoder)?;
                }
                Self::EnemyNamed => {
                    bincode::Encode::encode(&6u32, encoder)?;
                }
                Self::EnemyNormal => {
                    bincode::Encode::encode(&7u32, encoder)?;
                }
                Self::Gold => {
                    bincode::Encode::encode(&8u32, encoder)?;
                }
                Self::Health => {
                    bincode::Encode::encode(&9u32, encoder)?;
                }
                Self::Invincible => {
                    bincode::Encode::encode(&10u32, encoder)?;
                }
                Self::Item => {
                    bincode::Encode::encode(&11u32, encoder)?;
                }
                Self::Level => {
                    bincode::Encode::encode(&12u32, encoder)?;
                }
                Self::Lock => {
                    bincode::Encode::encode(&13u32, encoder)?;
                }
                Self::MoveSpeed => {
                    bincode::Encode::encode(&14u32, encoder)?;
                }
                Self::Quest => {
                    bincode::Encode::encode(&15u32, encoder)?;
                }
                Self::Refresh => {
                    bincode::Encode::encode(&16u32, encoder)?;
                }
                Self::Reject => {
                    bincode::Encode::encode(&17u32, encoder)?;
                }
                Self::Shield => {
                    bincode::Encode::encode(&18u32, encoder)?;
                }
                Self::Shop => {
                    bincode::Encode::encode(&19u32, encoder)?;
                }
                Self::Speaker => {
                    bincode::Encode::encode(&20u32, encoder)?;
                }
                Self::Suit { suit } => {
                    bincode::Encode::encode(&21u32, encoder)?;
                    bincode::Encode::encode(suit, encoder)?;
                }
                Self::Up => {
                    bincode::Encode::encode(&22u32, encoder)?;
                }
                Self::Down => {
                    bincode::Encode::encode(&23u32, encoder)?;
                }
                Self::Card => {
                    bincode::Encode::encode(&24u32, encoder)?;
                }
                Self::New => {
                    bincode::Encode::encode(&25u32, encoder)?;
                }
                Self::Add => {
                    bincode::Encode::encode(&26u32, encoder)?;
                }
                Self::Multiply => {
                    bincode::Encode::encode(&27u32, encoder)?;
                }
                Self::Rarity { rarity } => {
                    bincode::Encode::encode(&28u32, encoder)?;
                    bincode::Encode::encode(rarity, encoder)?;
                }
            }
            Ok(())
        }
    }
    impl bincode::Decode<()> for IconKind {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            let discriminant: u32 = bincode::Decode::decode(decoder)?;
            match discriminant {
                0u32 => Ok(Self::Accept),
                1u32 => Ok(Self::AttackDamage),
                2u32 => Ok(Self::AttackRange),
                3u32 => Ok(Self::AttackSpeed),
                4u32 => Ok(Self::Config),
                5u32 => Ok(Self::EnemyBoss),
                6u32 => Ok(Self::EnemyNamed),
                7u32 => Ok(Self::EnemyNormal),
                8u32 => Ok(Self::Gold),
                9u32 => Ok(Self::Health),
                10u32 => Ok(Self::Invincible),
                11u32 => Ok(Self::Item),
                12u32 => Ok(Self::Level),
                13u32 => Ok(Self::Lock),
                14u32 => Ok(Self::MoveSpeed),
                15u32 => Ok(Self::Quest),
                16u32 => Ok(Self::Refresh),
                17u32 => Ok(Self::Reject),
                18u32 => Ok(Self::Shield),
                19u32 => Ok(Self::Shop),
                20u32 => Ok(Self::Speaker),
                21u32 => {
                    Ok(Self::Suit {
                        suit: bincode::Decode::decode(decoder)?,
                    })
                }
                22u32 => Ok(Self::Up),
                23u32 => Ok(Self::Down),
                24u32 => Ok(Self::Card),
                25u32 => Ok(Self::New),
                26u32 => Ok(Self::Add),
                27u32 => Ok(Self::Multiply),
                28u32 => {
                    Ok(Self::Rarity {
                        rarity: bincode::Decode::decode(decoder)?,
                    })
                }
                _ => {
                    Err(bincode::error::DecodeError::UnexpectedVariant {
                        type_name: core::any::type_name::<Self>(),
                        allowed: &bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 28u32,
                        },
                        found: discriminant,
                    })
                }
            }
        }
    }
    impl Serialize for IconKind {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            match self {
                Self::Accept => {
                    buf.write_string("Accept");
                }
                Self::AttackDamage => {
                    buf.write_string("AttackDamage");
                }
                Self::AttackRange => {
                    buf.write_string("AttackRange");
                }
                Self::AttackSpeed => {
                    buf.write_string("AttackSpeed");
                }
                Self::Config => {
                    buf.write_string("Config");
                }
                Self::EnemyBoss => {
                    buf.write_string("EnemyBoss");
                }
                Self::EnemyNamed => {
                    buf.write_string("EnemyNamed");
                }
                Self::EnemyNormal => {
                    buf.write_string("EnemyNormal");
                }
                Self::Gold => {
                    buf.write_string("Gold");
                }
                Self::Health => {
                    buf.write_string("Health");
                }
                Self::Invincible => {
                    buf.write_string("Invincible");
                }
                Self::Item => {
                    buf.write_string("Item");
                }
                Self::Level => {
                    buf.write_string("Level");
                }
                Self::Lock => {
                    buf.write_string("Lock");
                }
                Self::MoveSpeed => {
                    buf.write_string("MoveSpeed");
                }
                Self::Quest => {
                    buf.write_string("Quest");
                }
                Self::Refresh => {
                    buf.write_string("Refresh");
                }
                Self::Reject => {
                    buf.write_string("Reject");
                }
                Self::Shield => {
                    buf.write_string("Shield");
                }
                Self::Shop => {
                    buf.write_string("Shop");
                }
                Self::Speaker => {
                    buf.write_string("Speaker");
                }
                Self::Suit { suit } => {
                    buf.write_string("Suit");
                    buf.write_string("suit");
                    suit.serialize_without_name(buf);
                }
                Self::Up => {
                    buf.write_string("Up");
                }
                Self::Down => {
                    buf.write_string("Down");
                }
                Self::Card => {
                    buf.write_string("Card");
                }
                Self::New => {
                    buf.write_string("New");
                }
                Self::Add => {
                    buf.write_string("Add");
                }
                Self::Multiply => {
                    buf.write_string("Multiply");
                }
                Self::Rarity { rarity } => {
                    buf.write_string("Rarity");
                    buf.write_string("rarity");
                    rarity.serialize_without_name(buf);
                }
            }
        }
    }
    impl Deserialize for IconKind {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let variant_name = buf.read_string();
            match variant_name.as_ref() {
                "Accept" => Ok(Self::Accept),
                "AttackDamage" => Ok(Self::AttackDamage),
                "AttackRange" => Ok(Self::AttackRange),
                "AttackSpeed" => Ok(Self::AttackSpeed),
                "Config" => Ok(Self::Config),
                "EnemyBoss" => Ok(Self::EnemyBoss),
                "EnemyNamed" => Ok(Self::EnemyNamed),
                "EnemyNormal" => Ok(Self::EnemyNormal),
                "Gold" => Ok(Self::Gold),
                "Health" => Ok(Self::Health),
                "Invincible" => Ok(Self::Invincible),
                "Item" => Ok(Self::Item),
                "Level" => Ok(Self::Level),
                "Lock" => Ok(Self::Lock),
                "MoveSpeed" => Ok(Self::MoveSpeed),
                "Quest" => Ok(Self::Quest),
                "Refresh" => Ok(Self::Refresh),
                "Reject" => Ok(Self::Reject),
                "Shield" => Ok(Self::Shield),
                "Shop" => Ok(Self::Shop),
                "Speaker" => Ok(Self::Speaker),
                "Suit" => {
                    let field_name = buf.read_name("suit")?;
                    let suit = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self::Suit { suit })
                }
                "Up" => Ok(Self::Up),
                "Down" => Ok(Self::Down),
                "Card" => Ok(Self::Card),
                "New" => Ok(Self::New),
                "Add" => Ok(Self::Add),
                "Multiply" => Ok(Self::Multiply),
                "Rarity" => {
                    let field_name = buf.read_name("rarity")?;
                    let rarity = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self::Rarity { rarity })
                }
                _ => {
                    Err(DeserializeError::InvalidEnumVariant {
                        expected: std::any::type_name::<Self>().to_string(),
                        actual: variant_name,
                    })
                }
            }
        }
    }
    impl IconKind {
        pub fn image(self) -> Image {
            match self {
                IconKind::Accept => crate::asset::image::icon::ACCEPT,
                IconKind::AttackDamage => crate::asset::image::icon::ATTACK_DAMAGE,
                IconKind::AttackRange => crate::asset::image::icon::ATTACK_RANGE,
                IconKind::AttackSpeed => crate::asset::image::icon::ATTACK_SPEED,
                IconKind::Config => crate::asset::image::icon::CONFIG,
                IconKind::EnemyBoss => crate::asset::image::icon::ENEMY_BOSS,
                IconKind::EnemyNamed => crate::asset::image::icon::ENEMY_NAMED,
                IconKind::EnemyNormal => crate::asset::image::icon::ENEMY_NORMAL,
                IconKind::Gold => crate::asset::image::icon::GOLD,
                IconKind::Health => crate::asset::image::icon::HEALTH,
                IconKind::Invincible => crate::asset::image::icon::INVINCIBLE,
                IconKind::Item => crate::asset::image::icon::ITEM,
                IconKind::Level => crate::asset::image::icon::LEVEL,
                IconKind::Lock => crate::asset::image::icon::LOCK,
                IconKind::MoveSpeed => crate::asset::image::icon::MOVE_SPEED,
                IconKind::Quest => crate::asset::image::icon::QUEST,
                IconKind::Refresh => crate::asset::image::icon::REFRESH,
                IconKind::Reject => crate::asset::image::icon::REJECT,
                IconKind::Shield => crate::asset::image::icon::SHIELD,
                IconKind::Shop => crate::asset::image::icon::SHOP,
                IconKind::Speaker => crate::asset::image::icon::SPEAKER,
                IconKind::Suit { suit } => {
                    match suit {
                        Suit::Spades => crate::asset::image::icon::SUIT_SPADES,
                        Suit::Hearts => crate::asset::image::icon::SUIT_HEARTS,
                        Suit::Diamonds => crate::asset::image::icon::SUIT_DIAMONDS,
                        Suit::Clubs => crate::asset::image::icon::SUIT_CLUBS,
                    }
                }
                IconKind::Up => crate::asset::image::icon::UP,
                IconKind::Down => crate::asset::image::icon::DOWN,
                IconKind::Card => crate::asset::image::icon::CARD,
                IconKind::New => crate::asset::image::icon::NEW,
                IconKind::Add => crate::asset::image::icon::ADD,
                IconKind::Multiply => crate::asset::image::icon::MULTIPLY,
                IconKind::Rarity { rarity } => {
                    match rarity {
                        Rarity::Common => crate::asset::image::icon::RARITY_COMMON,
                        Rarity::Rare => crate::asset::image::icon::RARITY_RARE,
                        Rarity::Epic => crate::asset::image::icon::RARITY_EPIC,
                        Rarity::Legendary => crate::asset::image::icon::RARITY_LEGENDARY,
                    }
                }
            }
        }
        pub fn asset_id(&self) -> &'static str {
            match self {
                IconKind::Accept => "accept",
                IconKind::AttackDamage => "attack_damage",
                IconKind::AttackRange => "attack_range",
                IconKind::AttackSpeed => "attack_speed",
                IconKind::Config => "config",
                IconKind::EnemyBoss => "enemy_boss",
                IconKind::EnemyNamed => "enemy_named",
                IconKind::EnemyNormal => "enemy_normal",
                IconKind::Gold => "gold",
                IconKind::Health => "health",
                IconKind::Invincible => "invincible",
                IconKind::Item => "item",
                IconKind::Level => "level",
                IconKind::Lock => "lock",
                IconKind::MoveSpeed => "move_speed",
                IconKind::Quest => "quest",
                IconKind::Refresh => "refresh",
                IconKind::Reject => "reject",
                IconKind::Shield => "shield",
                IconKind::Shop => "shop",
                IconKind::Speaker => "speaker",
                IconKind::Suit { suit } => {
                    match suit {
                        Suit::Spades => "suit_spades",
                        Suit::Hearts => "suit_hearts",
                        Suit::Diamonds => "suit_diamonds",
                        Suit::Clubs => "suit_clubs",
                    }
                }
                IconKind::Up => "up",
                IconKind::Down => "down",
                IconKind::Card => "card",
                IconKind::New => "new",
                IconKind::Add => "add",
                IconKind::Multiply => "multiply",
                IconKind::Rarity { rarity } => {
                    match rarity {
                        Rarity::Common => "rarity_common",
                        Rarity::Rare => "rarity_rare",
                        Rarity::Epic => "rarity_epic",
                        Rarity::Legendary => "rarity_legendary",
                    }
                }
            }
        }
        /// Get the default color for this icon kind
        pub fn default_color(&self) -> Color {
            match self {
                IconKind::Accept => Color::from_u8(0, 255, 0, 255),
                IconKind::AttackDamage => Color::from_u8(255, 100, 100, 255),
                IconKind::AttackRange => Color::from_u8(100, 255, 100, 255),
                IconKind::AttackSpeed => Color::from_u8(100, 100, 255, 255),
                IconKind::Config => Color::from_u8(128, 128, 128, 255),
                IconKind::EnemyBoss => Color::from_u8(128, 0, 128, 255),
                IconKind::EnemyNamed => Color::from_u8(255, 165, 0, 255),
                IconKind::EnemyNormal => Color::from_u8(139, 69, 19, 255),
                IconKind::Gold => Color::from_u8(255, 215, 0, 255),
                IconKind::Health => Color::from_u8(255, 0, 0, 255),
                IconKind::Invincible => Color::from_u8(255, 255, 255, 255),
                IconKind::Item => Color::from_u8(255, 192, 203, 255),
                IconKind::Level => Color::from_u8(0, 191, 255, 255),
                IconKind::Lock => Color::from_u8(169, 169, 169, 255),
                IconKind::MoveSpeed => Color::from_u8(255, 255, 0, 255),
                IconKind::Quest => Color::from_u8(0, 255, 255, 255),
                IconKind::Refresh => Color::from_u8(124, 252, 0, 255),
                IconKind::Reject => Color::from_u8(255, 0, 0, 255),
                IconKind::Shield => Color::from_u8(0, 0, 255, 255),
                IconKind::Shop => Color::from_u8(150, 75, 0, 255),
                IconKind::Speaker => Color::from_u8(75, 0, 130, 255),
                IconKind::Suit { .. } => Color::from_u8(128, 128, 128, 255),
                IconKind::Up => Color::from_u8(0, 255, 0, 255),
                IconKind::Down => Color::from_u8(255, 0, 0, 255),
                IconKind::Card => Color::from_u8(255, 255, 255, 255),
                IconKind::New => Color::from_u8(0, 255, 0, 255),
                IconKind::Add => Color::from_u8(0, 255, 0, 255),
                IconKind::Multiply => Color::from_u8(0, 0, 255, 255),
                IconKind::Rarity { rarity } => {
                    match rarity {
                        Rarity::Common => palette::COMMON,
                        Rarity::Rare => palette::RARE,
                        Rarity::Epic => palette::EPIC,
                        Rarity::Legendary => palette::LEGENDARY,
                    }
                }
            }
        }
        pub fn from_asset_id(asset_id: &str) -> Option<Self> {
            match asset_id {
                "accept" => Some(IconKind::Accept),
                "attack_damage" => Some(IconKind::AttackDamage),
                "attack_range" => Some(IconKind::AttackRange),
                "attack_speed" => Some(IconKind::AttackSpeed),
                "config" => Some(IconKind::Config),
                "enemy_boss" => Some(IconKind::EnemyBoss),
                "enemy_named" => Some(IconKind::EnemyNamed),
                "enemy_normal" => Some(IconKind::EnemyNormal),
                "gold" => Some(IconKind::Gold),
                "health" => Some(IconKind::Health),
                "invincible" => Some(IconKind::Invincible),
                "item" => Some(IconKind::Item),
                "level" => Some(IconKind::Level),
                "lock" => Some(IconKind::Lock),
                "move_speed" => Some(IconKind::MoveSpeed),
                "quest" => Some(IconKind::Quest),
                "refresh" => Some(IconKind::Refresh),
                "reject" => Some(IconKind::Reject),
                "shield" => Some(IconKind::Shield),
                "shop" => Some(IconKind::Shop),
                "speaker" => Some(IconKind::Speaker),
                "suit_spades" => {
                    Some(IconKind::Suit {
                        suit: Suit::Spades,
                    })
                }
                "suit_hearts" => {
                    Some(IconKind::Suit {
                        suit: Suit::Hearts,
                    })
                }
                "suit_diamonds" => {
                    Some(IconKind::Suit {
                        suit: Suit::Diamonds,
                    })
                }
                "suit_clubs" => {
                    Some(IconKind::Suit {
                        suit: Suit::Clubs,
                    })
                }
                "up" => Some(IconKind::Up),
                "down" => Some(IconKind::Down),
                "card" => Some(IconKind::Card),
                "new" => Some(IconKind::New),
                "add" => Some(IconKind::Add),
                "multiply" => Some(IconKind::Multiply),
                "rarity_common" => {
                    Some(IconKind::Rarity {
                        rarity: Rarity::Common,
                    })
                }
                "rarity_rare" => {
                    Some(IconKind::Rarity {
                        rarity: Rarity::Rare,
                    })
                }
                "rarity_epic" => {
                    Some(IconKind::Rarity {
                        rarity: Rarity::Epic,
                    })
                }
                "rarity_legendary" => {
                    Some(IconKind::Rarity {
                        rarity: Rarity::Legendary,
                    })
                }
                _ => None,
            }
        }
    }
    pub struct IconAttribute {
        pub icon_kind: IconKind,
        pub position: IconAttributePosition,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IconAttribute {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "IconAttribute",
                "icon_kind",
                &self.icon_kind,
                "position",
                &&self.position,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IconAttribute {
        #[inline]
        fn clone(&self) -> IconAttribute {
            let _: ::core::clone::AssertParamIsClone<IconKind>;
            let _: ::core::clone::AssertParamIsClone<IconAttributePosition>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for IconAttribute {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IconAttribute {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IconAttribute {
        #[inline]
        fn eq(&self, other: &IconAttribute) -> bool {
            self.icon_kind == other.icon_kind && self.position == other.position
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for IconAttribute {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<IconKind>;
            let _: ::core::cmp::AssertParamIsEq<IconAttributePosition>;
        }
    }
    impl bincode::Encode for IconAttribute {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            bincode::Encode::encode(&self.icon_kind, encoder)?;
            bincode::Encode::encode(&self.position, encoder)?;
            Ok(())
        }
    }
    impl bincode::Decode<()> for IconAttribute {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            Ok(Self {
                icon_kind: bincode::Decode::decode(decoder)?,
                position: bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl Serialize for IconAttribute {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            buf.write_string("icon_kind");
            self.icon_kind.serialize_without_name(buf);
            buf.write_string("position");
            self.position.serialize_without_name(buf);
        }
    }
    impl Deserialize for IconAttribute {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let field_name = buf.read_name("icon_kind")?;
            let icon_kind = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("position")?;
            let position = Deserialize::deserialize_without_name(buf)?;
            Ok(Self { icon_kind, position })
        }
    }
    impl IconAttribute {
        pub fn new(icon_kind: IconKind) -> Self {
            IconAttribute {
                icon_kind,
                position: IconAttributePosition::TopLeft,
            }
        }
        pub fn kind(mut self, icon_kind: IconKind) -> Self {
            self.icon_kind = icon_kind;
            self
        }
        pub fn position(mut self, position: IconAttributePosition) -> Self {
            self.position = position;
            self
        }
    }
    pub enum IconAttributePosition {
        TopLeft,
        TopRight,
        BottomLeft,
        BottomRight,
        Center,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IconAttributePosition {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    IconAttributePosition::TopLeft => "TopLeft",
                    IconAttributePosition::TopRight => "TopRight",
                    IconAttributePosition::BottomLeft => "BottomLeft",
                    IconAttributePosition::BottomRight => "BottomRight",
                    IconAttributePosition::Center => "Center",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IconAttributePosition {
        #[inline]
        fn clone(&self) -> IconAttributePosition {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for IconAttributePosition {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IconAttributePosition {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IconAttributePosition {
        #[inline]
        fn eq(&self, other: &IconAttributePosition) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for IconAttributePosition {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    impl bincode::Encode for IconAttributePosition {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            match self {
                Self::TopLeft => {
                    bincode::Encode::encode(&0u32, encoder)?;
                }
                Self::TopRight => {
                    bincode::Encode::encode(&1u32, encoder)?;
                }
                Self::BottomLeft => {
                    bincode::Encode::encode(&2u32, encoder)?;
                }
                Self::BottomRight => {
                    bincode::Encode::encode(&3u32, encoder)?;
                }
                Self::Center => {
                    bincode::Encode::encode(&4u32, encoder)?;
                }
            }
            Ok(())
        }
    }
    impl bincode::Decode<()> for IconAttributePosition {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            let discriminant: u32 = bincode::Decode::decode(decoder)?;
            match discriminant {
                0u32 => Ok(Self::TopLeft),
                1u32 => Ok(Self::TopRight),
                2u32 => Ok(Self::BottomLeft),
                3u32 => Ok(Self::BottomRight),
                4u32 => Ok(Self::Center),
                _ => {
                    Err(bincode::error::DecodeError::UnexpectedVariant {
                        type_name: core::any::type_name::<Self>(),
                        allowed: &bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 4u32,
                        },
                        found: discriminant,
                    })
                }
            }
        }
    }
    impl Serialize for IconAttributePosition {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            match self {
                Self::TopLeft => {
                    buf.write_string("TopLeft");
                }
                Self::TopRight => {
                    buf.write_string("TopRight");
                }
                Self::BottomLeft => {
                    buf.write_string("BottomLeft");
                }
                Self::BottomRight => {
                    buf.write_string("BottomRight");
                }
                Self::Center => {
                    buf.write_string("Center");
                }
            }
        }
    }
    impl Deserialize for IconAttributePosition {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let variant_name = buf.read_string();
            match variant_name.as_ref() {
                "TopLeft" => Ok(Self::TopLeft),
                "TopRight" => Ok(Self::TopRight),
                "BottomLeft" => Ok(Self::BottomLeft),
                "BottomRight" => Ok(Self::BottomRight),
                "Center" => Ok(Self::Center),
                _ => {
                    Err(DeserializeError::InvalidEnumVariant {
                        expected: std::any::type_name::<Self>().to_string(),
                        actual: variant_name,
                    })
                }
            }
        }
    }
    impl IconAttributePosition {
        pub fn as_str(&self) -> &'static str {
            match self {
                IconAttributePosition::TopLeft => "top_left",
                IconAttributePosition::TopRight => "top_right",
                IconAttributePosition::BottomLeft => "bottom_left",
                IconAttributePosition::BottomRight => "bottom_right",
                IconAttributePosition::Center => "center",
            }
        }
        pub fn from_str(s: &str) -> Option<Self> {
            match s {
                "top_left" => Some(IconAttributePosition::TopLeft),
                "top_right" => Some(IconAttributePosition::TopRight),
                "bottom_left" => Some(IconAttributePosition::BottomLeft),
                "bottom_right" => Some(IconAttributePosition::BottomRight),
                "center" => Some(IconAttributePosition::Center),
                _ => None,
            }
        }
    }
    impl IconAttribute {
        pub fn attribute_render_rect(&self, icon_rect: Rect<Px>) -> Rect<Px> {
            match self.position {
                IconAttributePosition::TopLeft => {
                    let left = icon_rect.left();
                    let top = icon_rect.top();
                    let right = icon_rect.left() + icon_rect.width() * 0.5;
                    let bottom = icon_rect.top() + icon_rect.height() * 0.5;
                    Rect::Ltrb {
                        left,
                        top,
                        right,
                        bottom,
                    }
                }
                IconAttributePosition::TopRight => {
                    let left = icon_rect.left() + icon_rect.width() * 0.5;
                    let top = icon_rect.top();
                    let right = icon_rect.right();
                    let bottom = icon_rect.top() + icon_rect.height() * 0.5;
                    Rect::Ltrb {
                        left,
                        top,
                        right,
                        bottom,
                    }
                }
                IconAttributePosition::BottomLeft => {
                    let left = icon_rect.left();
                    let top = icon_rect.top() + icon_rect.height() * 0.5;
                    let right = icon_rect.left() + icon_rect.width() * 0.5;
                    let bottom = icon_rect.bottom();
                    Rect::Ltrb {
                        left,
                        top,
                        right,
                        bottom,
                    }
                }
                IconAttributePosition::BottomRight => {
                    let left = icon_rect.left() + icon_rect.width() * 0.5;
                    let top = icon_rect.top() + icon_rect.height() * 0.5;
                    let right = icon_rect.right();
                    let bottom = icon_rect.bottom();
                    Rect::Ltrb {
                        left,
                        top,
                        right,
                        bottom,
                    }
                }
                IconAttributePosition::Center => {
                    let size_factor = 0.6;
                    let width = icon_rect.width() * size_factor;
                    let height = icon_rect.height() * size_factor;
                    let left = icon_rect.left() + (icon_rect.width() - width) * 0.5;
                    let top = icon_rect.top() + (icon_rect.height() - height) * 0.5;
                    let right = left + width;
                    let bottom = top + height;
                    Rect::Ltrb {
                        left,
                        top,
                        right,
                        bottom,
                    }
                }
            }
        }
    }
    pub enum IconSize {
        Small,
        Medium,
        Large,
        Custom { size: Px },
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IconSize {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                IconSize::Small => ::core::fmt::Formatter::write_str(f, "Small"),
                IconSize::Medium => ::core::fmt::Formatter::write_str(f, "Medium"),
                IconSize::Large => ::core::fmt::Formatter::write_str(f, "Large"),
                IconSize::Custom { size: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Custom",
                        "size",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IconSize {
        #[inline]
        fn clone(&self) -> IconSize {
            let _: ::core::clone::AssertParamIsClone<Px>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for IconSize {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IconSize {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IconSize {
        #[inline]
        fn eq(&self, other: &IconSize) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        IconSize::Custom { size: __self_0 },
                        IconSize::Custom { size: __arg1_0 },
                    ) => __self_0 == __arg1_0,
                    _ => true,
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for IconSize {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Px>;
        }
    }
    impl bincode::Encode for IconSize {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            match self {
                Self::Small => {
                    bincode::Encode::encode(&0u32, encoder)?;
                }
                Self::Medium => {
                    bincode::Encode::encode(&1u32, encoder)?;
                }
                Self::Large => {
                    bincode::Encode::encode(&2u32, encoder)?;
                }
                Self::Custom { size } => {
                    bincode::Encode::encode(&3u32, encoder)?;
                    bincode::Encode::encode(size, encoder)?;
                }
            }
            Ok(())
        }
    }
    impl bincode::Decode<()> for IconSize {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            let discriminant: u32 = bincode::Decode::decode(decoder)?;
            match discriminant {
                0u32 => Ok(Self::Small),
                1u32 => Ok(Self::Medium),
                2u32 => Ok(Self::Large),
                3u32 => {
                    Ok(Self::Custom {
                        size: bincode::Decode::decode(decoder)?,
                    })
                }
                _ => {
                    Err(bincode::error::DecodeError::UnexpectedVariant {
                        type_name: core::any::type_name::<Self>(),
                        allowed: &bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 3u32,
                        },
                        found: discriminant,
                    })
                }
            }
        }
    }
    impl Serialize for IconSize {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            match self {
                Self::Small => {
                    buf.write_string("Small");
                }
                Self::Medium => {
                    buf.write_string("Medium");
                }
                Self::Large => {
                    buf.write_string("Large");
                }
                Self::Custom { size } => {
                    buf.write_string("Custom");
                    buf.write_string("size");
                    size.serialize_without_name(buf);
                }
            }
        }
    }
    impl Deserialize for IconSize {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let variant_name = buf.read_string();
            match variant_name.as_ref() {
                "Small" => Ok(Self::Small),
                "Medium" => Ok(Self::Medium),
                "Large" => Ok(Self::Large),
                "Custom" => {
                    let field_name = buf.read_name("size")?;
                    let size = Deserialize::deserialize_without_name(buf)?;
                    Ok(Self::Custom { size })
                }
                _ => {
                    Err(DeserializeError::InvalidEnumVariant {
                        expected: std::any::type_name::<Self>().to_string(),
                        actual: variant_name,
                    })
                }
            }
        }
    }
    impl IconSize {
        pub fn px(self) -> Px {
            match self {
                IconSize::Small => px(16.),
                IconSize::Medium => px(24.),
                IconSize::Large => px(36.),
                IconSize::Custom { size } => size,
            }
        }
    }
    pub struct Icon {
        pub kind: IconKind,
        pub size: IconSize,
        pub attributes: Vec<IconAttribute>,
        pub wh: Wh<Px>,
        pub opacity: f32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Icon {
        #[inline]
        fn clone(&self) -> Icon {
            Icon {
                kind: ::core::clone::Clone::clone(&self.kind),
                size: ::core::clone::Clone::clone(&self.size),
                attributes: ::core::clone::Clone::clone(&self.attributes),
                wh: ::core::clone::Clone::clone(&self.wh),
                opacity: ::core::clone::Clone::clone(&self.opacity),
            }
        }
    }
    impl bincode::Encode for Icon {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            bincode::Encode::encode(&self.kind, encoder)?;
            bincode::Encode::encode(&self.size, encoder)?;
            bincode::Encode::encode(&self.attributes, encoder)?;
            bincode::Encode::encode(&self.wh, encoder)?;
            bincode::Encode::encode(&self.opacity, encoder)?;
            Ok(())
        }
    }
    impl bincode::Decode<()> for Icon {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            Ok(Self {
                kind: bincode::Decode::decode(decoder)?,
                size: bincode::Decode::decode(decoder)?,
                attributes: bincode::Decode::decode(decoder)?,
                wh: bincode::Decode::decode(decoder)?,
                opacity: bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl Serialize for Icon {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            buf.write_string("kind");
            self.kind.serialize_without_name(buf);
            buf.write_string("size");
            self.size.serialize_without_name(buf);
            buf.write_string("attributes");
            self.attributes.serialize_without_name(buf);
            buf.write_string("wh");
            self.wh.serialize_without_name(buf);
            buf.write_string("opacity");
            self.opacity.serialize_without_name(buf);
        }
    }
    impl Deserialize for Icon {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let field_name = buf.read_name("kind")?;
            let kind = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("size")?;
            let size = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("attributes")?;
            let attributes = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("wh")?;
            let wh = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("opacity")?;
            let opacity = Deserialize::deserialize_without_name(buf)?;
            Ok(Self {
                kind,
                size,
                attributes,
                wh,
                opacity,
            })
        }
    }
    impl Default for Icon {
        fn default() -> Self {
            Icon {
                kind: IconKind::Gold,
                size: IconSize::Custom { size: px(24.0) },
                attributes: Vec::new(),
                wh: Wh {
                    width: px(24.0),
                    height: px(24.0),
                },
                opacity: 1.0,
            }
        }
    }
    impl Icon {
        pub fn new(kind: IconKind) -> Self {
            Icon { kind, ..Default::default() }
        }
        pub fn kind(mut self, kind: IconKind) -> Self {
            self.kind = kind;
            self
        }
        pub fn size(mut self, size: IconSize) -> Self {
            self.size = size;
            self
        }
        pub fn attributes(mut self, attributes: Vec<IconAttribute>) -> Self {
            self.attributes = attributes;
            self
        }
        pub fn wh(mut self, wh: Wh<Px>) -> Self {
            self.wh = wh;
            self
        }
        pub fn opacity(mut self, opacity: f32) -> Self {
            self.opacity = opacity;
            self
        }
    }
}
mod inventory {
    use crate::{
        game_state::{
            MAX_INVENTORY_SLOT, item::use_item, mutate_game_state, use_game_state,
        },
        icon::{Icon, IconKind, IconSize},
        l10n::ui::TopBarText, palette,
        theme::{
            button::Button,
            typography::{
                FontSize, HEADLINE_FONT_SIZE_LARGE, TextAlign, headline, paragraph,
            },
        },
    };
    use namui::*;
    use namui_prebuilt::{scroll_view::AutoScrollViewWithCtx, table};
    const INVENTORY_WIDTH: Px = px(240.);
    const PADDING: Px = px(4.);
    const TITLE_HEIGHT: Px = px(36.);
    pub struct Inventory {
        pub screen_wh: Wh<Px>,
    }
    impl Component for Inventory {
        fn render(self, render_ctx: &RenderCtx) {
            let game_state = use_game_state(render_ctx);
            let scroll_view = |wh: Wh<Px>, ctx: ComposeCtx| {
                ctx.clip(Path::new().add_rect(wh.to_rect()), ClipOp::Intersect)
                    .add(AutoScrollViewWithCtx {
                        wh,
                        scroll_bar_width: PADDING,
                        content: |mut ctx| {
                            let content_width = wh.width - PADDING * 2.;
                            for (item_index, item) in game_state.items.iter().enumerate()
                            {
                                let name = item.name(&game_state.text());
                                let desc = item.description(&game_state.text());
                                let content = ctx
                                    .ghost_compose(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("InventoryItemContent {0}", item_index),
                                            )
                                        }),
                                        |ctx| {
                                            table::vertical([
                                                table::fixed(
                                                    HEADLINE_FONT_SIZE_LARGE.into_px(),
                                                    table::horizontal([
                                                        table::fixed(
                                                            HEADLINE_FONT_SIZE_LARGE.into_px(),
                                                            |wh, ctx| {
                                                                ctx.add(
                                                                    Icon::new(IconKind::Rarity {
                                                                            rarity: item.rarity,
                                                                        })
                                                                        .size(IconSize::Custom { size: wh.width })
                                                                        .wh(wh),
                                                                );
                                                            },
                                                        ),
                                                        table::fixed(
                                                            HEADLINE_FONT_SIZE_LARGE.into_px(),
                                                            |wh, ctx| {
                                                                ctx.add(item.effect.thumbnail(wh));
                                                            },
                                                        ),
                                                        table::ratio(1, |_, _| {}),
                                                        table::fixed(
                                                            HEADLINE_FONT_SIZE_LARGE.into_px() * 3.0,
                                                            |wh, ctx| {
                                                                ctx.add(
                                                                    Button::new(
                                                                            wh,
                                                                            &|| {
                                                                                mutate_game_state(move |game_state| {
                                                                                    let item = game_state.items.remove(item_index);
                                                                                    use_item(game_state, &item);
                                                                                });
                                                                            },
                                                                            &|wh, color, ctx| {
                                                                                ctx.add(
                                                                                    headline(game_state.text().ui(TopBarText::Use).to_string())
                                                                                        .size(FontSize::Small)
                                                                                        .align(TextAlign::Center { wh })
                                                                                        .color(color)
                                                                                        .build(),
                                                                                );
                                                                            },
                                                                        )
                                                                        .disabled(game_state.stage_modifiers.is_item_use_disabled()),
                                                                );
                                                            },
                                                        ),
                                                    ]),
                                                ),
                                                table::fixed(PADDING * 2.0, |_, _| {}),
                                                table::fit(
                                                    table::FitAlign::LeftTop,
                                                    move |compose_ctx| {
                                                        compose_ctx
                                                            .add(
                                                                headline(name)
                                                                    .size(FontSize::Small)
                                                                    .align(TextAlign::LeftTop)
                                                                    .max_width(content_width)
                                                                    .build(),
                                                            );
                                                    },
                                                ),
                                                table::fixed(PADDING, |_, _| {}),
                                                table::fit(
                                                    table::FitAlign::LeftTop,
                                                    move |compose_ctx| {
                                                        compose_ctx
                                                            .add(
                                                                paragraph(desc.clone())
                                                                    .size(FontSize::Medium)
                                                                    .align(TextAlign::LeftTop)
                                                                    .max_width(content_width)
                                                                    .build_rich(),
                                                            );
                                                    },
                                                ),
                                            ])(Wh::new(content_width, f32::MAX.px()), ctx);
                                        },
                                    );
                                let Some(content_wh) = content
                                    .bounding_box()
                                    .map(|rect| rect.wh()) else {
                                    return;
                                };
                                let container_wh = content_wh + Wh::single(PADDING * 2.);
                                ctx.translate(Xy::single(PADDING)).add(content);
                                ctx.add(
                                    rect(RectParam {
                                        rect: container_wh.to_rect(),
                                        style: RectStyle {
                                            stroke: Some(RectStroke {
                                                color: palette::OUTLINE,
                                                width: 1.px(),
                                                border_position: BorderPosition::Inside,
                                            }),
                                            fill: Some(RectFill {
                                                color: palette::SURFACE_CONTAINER,
                                            }),
                                            round: Some(RectRound {
                                                radius: palette::ROUND,
                                            }),
                                        },
                                    }),
                                );
                                ctx = ctx.translate(Xy::new(0.px(), container_wh.height));
                            }
                        },
                    });
            };
            render_ctx
                .compose(|ctx| {
                    table::horizontal([
                        table::ratio_no_clip(1, |_, _| {}),
                        table::fixed_no_clip(
                            INVENTORY_WIDTH,
                            table::padding(
                                PADDING,
                                table::vertical([
                                    table::fixed(
                                        TITLE_HEIGHT,
                                        |wh, ctx| {
                                            ctx.add(
                                                Icon::new(IconKind::Item)
                                                    .size(IconSize::Medium)
                                                    .wh(Wh {
                                                        width: 32.px(),
                                                        height: wh.height,
                                                    }),
                                            );
                                            let text = ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "{0}/{1}",
                                                        game_state.items.len(),
                                                        MAX_INVENTORY_SLOT,
                                                    ),
                                                )
                                            });
                                            ctx.add(
                                                headline(text)
                                                    .size(FontSize::Medium)
                                                    .align(TextAlign::Center { wh })
                                                    .max_width(wh.width)
                                                    .build(),
                                            );
                                            ctx.add(
                                                rect(RectParam {
                                                    rect: wh.to_rect(),
                                                    style: RectStyle {
                                                        stroke: Some(RectStroke {
                                                            color: palette::OUTLINE,
                                                            width: 1.px(),
                                                            border_position: BorderPosition::Inside,
                                                        }),
                                                        fill: Some(RectFill {
                                                            color: palette::SURFACE_CONTAINER,
                                                        }),
                                                        round: Some(RectRound {
                                                            radius: palette::ROUND,
                                                        }),
                                                    },
                                                }),
                                            );
                                        },
                                    ),
                                    table::fixed_no_clip(PADDING, |_, _| {}),
                                    table::ratio(1, scroll_view),
                                ]),
                            ),
                        ),
                    ])(self.screen_wh, ctx);
                });
        }
    }
}
pub mod l10n {
    pub mod api {
        use super::{
            Language, Locale, LocalizedText, contract, effect, quest, tower, tower_skill,
            ui, upgrade, upgrade_board,
        };
        use crate::*;
        /// 통합 다국어 텍스트 관리자
        pub struct TextManager {
            locale: Locale,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TextManager {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "TextManager",
                    "locale",
                    &&self.locale,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TextManager {
            #[inline]
            fn clone(&self) -> TextManager {
                let _: ::core::clone::AssertParamIsClone<Locale>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TextManager {}
        impl bincode::Encode for TextManager {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.locale, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for TextManager {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    locale: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for TextManager {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("locale");
                self.locale.serialize_without_name(buf);
            }
        }
        impl Deserialize for TextManager {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("locale")?;
                let locale = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { locale })
            }
        }
        impl TextManager {
            /// 새로운 텍스트 관리자 생성
            pub const fn new(locale: Locale) -> Self {
                Self { locale }
            }
            /// 현재 언어 반환
            pub fn language(&self) -> crate::l10n::Language {
                self.locale.language
            }
            /// 한국어 텍스트 관리자
            pub const fn korean() -> Self {
                Self::new(Locale::KOREAN)
            }
            /// 영어 텍스트 관리자
            pub const fn english() -> Self {
                Self::new(Locale::ENGLISH)
            }
            /// 현재 로케일 반환
            pub const fn locale(&self) -> Locale {
                self.locale
            }
            /// 로케일 변경
            pub const fn with_locale(self, locale: Locale) -> Self {
                Self::new(locale)
            }
        }
        /// UI 텍스트 처리
        impl TextManager {
            pub fn ui(&self, text: ui::TopBarText) -> &'static str {
                match self.locale.language {
                    Language::Korean => text.to_korean(),
                    Language::English => text.to_english(),
                }
            }
            pub fn start_confirm_modal(
                &self,
                text: ui::StartConfirmModalText,
            ) -> &'static str {
                match self.locale.language {
                    Language::Korean => text.to_korean(),
                    Language::English => text.to_english(),
                }
            }
        }
        /// 퀘스트 텍스트 처리
        impl TextManager {
            pub fn quest(&self, text: quest::QuestText) -> String {
                match self.locale.language {
                    Language::Korean => text.to_korean(),
                    Language::English => text.to_english(),
                }
            }
            pub fn quest_reward(&self, text: quest::QuestRewardText) -> String {
                match self.locale.language {
                    Language::Korean => text.to_korean(),
                    Language::English => text.to_english(),
                }
            }
        }
        /// 아이템 텍스트 처리
        impl TextManager {
            pub fn effect_name(
                &self,
                effect: &crate::game_state::effect::Effect,
            ) -> String {
                effect::EffectText::Name(effect.clone()).localized_text(&self.locale)
            }
            pub fn effect_description(
                &self,
                effect: &crate::game_state::effect::Effect,
            ) -> String {
                effect::EffectText::Description(effect.clone())
                    .localized_text(&self.locale)
            }
        }
        /// 계약 텍스트 처리
        impl TextManager {
            pub fn contract(&self, text: contract::ContractText) -> String {
                match self.locale.language {
                    Language::Korean => text.to_korean(),
                    Language::English => text.to_english(),
                }
            }
        }
        /// 타워 텍스트 처리
        impl TextManager {
            pub fn tower(&self, text: tower::TowerKindText) -> &'static str {
                match self.locale.language {
                    Language::Korean => text.to_korean(),
                    Language::English => text.to_english(),
                }
            }
        }
        /// 타워 스킬 텍스트 처리
        impl TextManager {
            pub fn tower_skill(&self, text: tower_skill::TowerSkillText) -> String {
                match self.locale.language {
                    Language::Korean => text.to_korean(),
                    Language::English => text.to_english(),
                }
            }
        }
        /// 업그레이드 텍스트 처리
        impl TextManager {
            pub fn upgrade_kind(&self, text: upgrade::UpgradeKindText) -> String {
                match self.locale.language {
                    Language::Korean => text.to_korean(),
                    Language::English => text.to_english(),
                }
            }
        }
        /// 업그레이드 보드 텍스트 처리
        impl TextManager {
            pub fn upgrade_board(
                &self,
                text: upgrade_board::UpgradeBoardText,
            ) -> String {
                match self.locale.language {
                    Language::Korean => text.to_korean(),
                    Language::English => text.to_english(),
                }
            }
        }
        /// 편의성을 위한 전역 상수
        pub const KOREAN_TEXT: TextManager = TextManager::korean();
        pub const ENGLISH_TEXT: TextManager = TextManager::english();
        /// 기존 호환성을 위한 레거시 API
        pub enum LegacyLocales {
            KoKR(LegacyKoKRLocale),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LegacyLocales {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    LegacyLocales::KoKR(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "KoKR",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LegacyLocales {
            #[inline]
            fn clone(&self) -> LegacyLocales {
                match self {
                    LegacyLocales::KoKR(__self_0) => {
                        LegacyLocales::KoKR(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        impl bincode::Encode for LegacyLocales {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::KoKR(field0) => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(field0, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for LegacyLocales {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::KoKR(bincode::Decode::decode(decoder)?)),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 0u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for LegacyLocales {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::KoKR(field0) => {
                        buf.write_string("KoKR");
                        field0.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for LegacyLocales {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "KoKR" => {
                        let field0 = { Deserialize::deserialize_without_name(buf)? };
                        Ok(Self::KoKR(field0))
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub struct LegacyKoKRLocale;
        #[automatically_derived]
        impl ::core::fmt::Debug for LegacyKoKRLocale {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "LegacyKoKRLocale")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LegacyKoKRLocale {
            #[inline]
            fn clone(&self) -> LegacyKoKRLocale {
                LegacyKoKRLocale
            }
        }
        impl bincode::Encode for LegacyKoKRLocale {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                Ok(())
            }
        }
        impl bincode::Decode<()> for LegacyKoKRLocale {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self)
            }
        }
        impl Serialize for LegacyKoKRLocale {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {}
        }
        impl Deserialize for LegacyKoKRLocale {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                Ok(Self)
            }
        }
        impl LegacyKoKRLocale {
            pub const fn new() -> Self {
                Self
            }
        }
        impl Default for LegacyKoKRLocale {
            fn default() -> Self {
                Self::new()
            }
        }
        impl LegacyLocales {
            /// 텍스트 매니저로 변환
            pub fn as_text_manager(&self) -> TextManager {
                match self {
                    LegacyLocales::KoKR(_) => TextManager::korean(),
                }
            }
            /// 기존 호환성을 위한 메서드들 - 새로운 TextManager로 위임
            pub fn ui_text(&self, text: ui::TopBarText) -> &'static str {
                self.as_text_manager().ui(text)
            }
            pub fn quest_text(&self, text: &quest::QuestText) -> String {
                self.as_text_manager().quest(text.clone())
            }
            pub fn tower_kind_text(&self, text: &tower::TowerKindText) -> &'static str {
                self.as_text_manager().tower(*text)
            }
            pub fn tower_skill_text(
                &self,
                text: &tower_skill::TowerSkillText,
            ) -> String {
                self.as_text_manager().tower_skill(text.clone())
            }
            pub fn upgrade_kind_text(&self, text: upgrade::UpgradeKindText) -> String {
                self.as_text_manager().upgrade_kind(text)
            }
            pub fn upgrade_board_text(
                &self,
                text: &upgrade_board::UpgradeBoardText,
            ) -> String {
                self.as_text_manager().upgrade_board(text.clone())
            }
        }
    }
    pub mod contract {
        use super::effect::EffectText;
        use crate::game_state::contract::ContractEffect;
        pub enum ContractText<'a> {
            Risk(&'a ContractEffect),
            Reward(&'a ContractEffect),
        }
        impl<'a> ContractText<'a> {
            pub fn to_korean(&self) -> String {
                match self {
                    ContractText::Risk(ce) => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} {1} {2}",
                                    super::rich_text_helpers::contract_risk("리스크:"),
                                    phase_ko(ce),
                                    effect_suffix_ko(ce),
                                ),
                            )
                        })
                    }
                    ContractText::Reward(ce) => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} {1} {2}",
                                    super::rich_text_helpers::contract_reward("리턴:"),
                                    phase_ko(ce),
                                    effect_suffix_ko(ce),
                                ),
                            )
                        })
                    }
                }
            }
            pub fn to_english(&self) -> String {
                match self {
                    ContractText::Risk(ce) => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} {1} {2}",
                                    super::rich_text_helpers::contract_risk("Risk:"),
                                    phase_en(ce),
                                    effect_suffix_en(ce),
                                ),
                            )
                        })
                    }
                    ContractText::Reward(ce) => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} {1} {2}",
                                    super::rich_text_helpers::contract_reward("Return:"),
                                    phase_en(ce),
                                    effect_suffix_en(ce),
                                ),
                            )
                        })
                    }
                }
            }
        }
        fn phase_ko(ce: &ContractEffect) -> String {
            match ce {
                ContractEffect::OnSign { .. } => "계약 시".into(),
                ContractEffect::WhileActive { .. } => "계약 중".into(),
                ContractEffect::OnStageStart { .. } => "매 스테이지".into(),
                ContractEffect::OnExpire { .. } => "계약 종료 시".into(),
            }
        }
        fn phase_en(ce: &ContractEffect) -> String {
            match ce {
                ContractEffect::OnSign { .. } => "On sign".into(),
                ContractEffect::WhileActive { .. } => "While active".into(),
                ContractEffect::OnStageStart { .. } => "On stage start".into(),
                ContractEffect::OnExpire { .. } => "On expire".into(),
            }
        }
        fn effect_suffix_ko(ce: &ContractEffect) -> String {
            let eff = match ce {
                ContractEffect::OnSign { effect }
                | ContractEffect::WhileActive { effect }
                | ContractEffect::OnStageStart { effect }
                | ContractEffect::OnExpire { effect } => effect,
            };
            let s = EffectText::Description(eff.clone()).to_korean();
            if s.is_empty() {
                String::new()
            } else {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!(" · {0}", s))
                })
            }
        }
        fn effect_suffix_en(ce: &ContractEffect) -> String {
            let eff = match ce {
                ContractEffect::OnSign { effect }
                | ContractEffect::WhileActive { effect }
                | ContractEffect::OnStageStart { effect }
                | ContractEffect::OnExpire { effect } => effect,
            };
            let s = EffectText::Description(eff.clone()).to_english();
            if s.is_empty() {
                String::new()
            } else {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!(" · {0}", s))
                })
            }
        }
    }
    pub mod effect {
        use super::{Language, Locale, LocalizedText, rich_text_helpers::*};
        use crate::{game_state::effect::Effect, *};
        #[allow(unreachable_patterns)]
        pub enum EffectText {
            Name(Effect),
            Description(Effect),
        }
        #[automatically_derived]
        #[allow(unreachable_patterns)]
        impl ::core::clone::Clone for EffectText {
            #[inline]
            fn clone(&self) -> EffectText {
                match self {
                    EffectText::Name(__self_0) => {
                        EffectText::Name(::core::clone::Clone::clone(__self_0))
                    }
                    EffectText::Description(__self_0) => {
                        EffectText::Description(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        impl bincode::Encode for EffectText {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Name(field0) => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(field0, encoder)?;
                    }
                    Self::Description(field0) => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(field0, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for EffectText {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Name(bincode::Decode::decode(decoder)?)),
                    1u32 => Ok(Self::Description(bincode::Decode::decode(decoder)?)),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 1u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for EffectText {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Name(field0) => {
                        buf.write_string("Name");
                        field0.serialize_without_name(buf);
                    }
                    Self::Description(field0) => {
                        buf.write_string("Description");
                        field0.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for EffectText {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Name" => {
                        let field0 = { Deserialize::deserialize_without_name(buf)? };
                        Ok(Self::Name(field0))
                    }
                    "Description" => {
                        let field0 = { Deserialize::deserialize_without_name(buf)? };
                        Ok(Self::Description(field0))
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        #[allow(unreachable_patterns)]
        impl LocalizedText for EffectText {
            fn localized_text(&self, locale: &Locale) -> String {
                match locale.language {
                    Language::Korean => self.to_korean(),
                    Language::English => self.to_english(),
                }
            }
        }
        #[allow(unreachable_patterns)]
        impl EffectText {
            #[allow(unreachable_patterns)]
            pub(super) fn to_korean(&self) -> String {
                match self {
                    EffectText::Name(effect) => {
                        match effect {
                            Effect::Heal { .. } => "치유".to_string(),
                            Effect::Lottery { .. } => "복권".to_string(),
                            Effect::ExtraReroll => "추가 리롤".to_string(),
                            Effect::Shield { .. } => "방어막".to_string(),
                            Effect::EarnGold { .. } => "골드 획득".to_string(),
                            Effect::DamageReduction { .. } => "피해 감소".to_string(),
                            Effect::UserDamageReduction { .. } => {
                                "피해 감소".to_string()
                            }
                            Effect::LoseHealth { .. } => "체력 감소".to_string(),
                            Effect::LoseHealthRange { .. } => {
                                "랜덤 체력 감소".to_string()
                            }
                            Effect::LoseGoldRange { .. } => {
                                "랜덤 골드 감소".to_string()
                            }
                            Effect::LoseHealthExpire { .. } => {
                                "계약 만료 시 체력 감소".to_string()
                            }
                            Effect::LoseGoldExpire { .. } => {
                                "계약 만료 시 골드 감소".to_string()
                            }
                            Effect::LoseGold { .. } => "골드 감소".to_string(),
                            Effect::GrantUpgrade { .. } => {
                                "업그레이드 획득".to_string()
                            }
                            Effect::GrantItem { .. } => "아이템 획득".to_string(),
                            Effect::AddChallengeMonster => {
                                "도전 몬스터 추가".to_string()
                            }
                            Effect::IncreaseAllTowersDamage { .. } => {
                                "모든 타워 공격력 증가".to_string()
                            }
                            Effect::DecreaseAllTowersDamage { .. } => {
                                "모든 타워 공격력 감소".to_string()
                            }
                            Effect::IncreaseAllTowersAttackSpeed { .. } => {
                                "모든 타워 공격속도 증가".to_string()
                            }
                            Effect::IncreaseAllTowersRange { .. } => {
                                "모든 타워 사정거리 증가".to_string()
                            }
                            Effect::DecreaseIncomingDamage { .. } => {
                                "받는 피해 감소".to_string()
                            }
                            Effect::IncreaseIncomingDamage { .. } => {
                                "받는 피해 증가".to_string()
                            }
                            Effect::IncreaseCardSelectionHandMaxSlots { .. } => {
                                "카드 선택 최대 슬롯 증가".to_string()
                            }
                            Effect::IncreaseCardSelectionHandMaxRerolls { .. } => {
                                "카드 선택 최대 리롤 증가".to_string()
                            }
                            Effect::IncreaseShopMaxRerolls { .. } => {
                                "상점 최대 리롤 증가".to_string()
                            }
                            Effect::IncreaseGoldGain { .. } => {
                                "골드 획득량 증가".to_string()
                            }
                            Effect::DecreaseGoldGainPercent { .. } => {
                                "골드 획득량 감소".to_string()
                            }
                            Effect::DisableItemAndUpgradePurchases => {
                                "아이템/업그레이드 구매 불가".to_string()
                            }
                            Effect::DisableItemUse => {
                                "아이템 사용 불가".to_string()
                            }
                            Effect::DecreaseCardSelectionHandMaxSlots { .. } => {
                                "카드 선택 최대 슬롯 감소".to_string()
                            }
                            Effect::DecreaseCardSelectionHandMaxRerolls { .. } => {
                                "카드 선택 최대 리롤 감소".to_string()
                            }
                            Effect::DecreaseShopMaxRerolls { .. } => {
                                "상점 최대 리롤 감소".to_string()
                            }
                            Effect::AddCardSelectionHandRerollHealthCost { .. } => {
                                "카드 선택 리롤 체력 비용".to_string()
                            }
                            Effect::AddShopRerollHealthCost { .. } => {
                                "상점 리롤 체력 비용".to_string()
                            }
                            Effect::DecreaseEnemyHealthPercent { percentage } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("적 체력 {0}% 증가", percentage),
                                    )
                                })
                            }
                            Effect::RankTowerDisable { rank } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0} 랭크 타워 비활성화", rank),
                                    )
                                })
                            }
                            Effect::SuitTowerDisable { suit } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0} 수트 타워 비활성화", suit),
                                    )
                                })
                            }
                            Effect::AddBarricadeCardsToTowerPlacementHand { count } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "타워 설치 핸드에 바리케이드 카드 {0}장 추가",
                                            count,
                                        ),
                                    )
                                })
                            }
                            Effect::GainShield { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "보호막 {0}~{1} 획득",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::HealHealth { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "체력 {0}~{1} 회복",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::GainGold { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "골드 {0:.0}~{1:.0} 획득",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealthRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "체력 {0:.0}~{1:.0} 감소",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseGoldRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "골드 {0:.0}~{1:.0} 감소 (부족 시 체력 {2:.0}~{3:.0} 감소)",
                                            min_amount,
                                            max_amount,
                                            min_amount / 10.0,
                                            max_amount / 10.0,
                                        ),
                                    )
                                })
                            }
                        }
                    }
                    EffectText::Description(effect) => {
                        match effect {
                            Effect::Heal { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0} 체력을 회복합니다",
                                            heal_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0:.0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::Shield { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0} 피해를 흡수하는 방어막을 획득합니다",
                                            shield_value(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0:.0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::ExtraReroll => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0}을 획득합니다",
                                            special_item_text("추가 리롤"),
                                        ),
                                    )
                                })
                            }
                            Effect::EarnGold { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0} 골드를 획득합니다",
                                            gold_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::Lottery { amount, probability } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0:.0}% 확률로 {1} 골드를 획득합니다",
                                            probability * 100.0,
                                            gold_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0:.0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::DamageReduction { damage_multiply, duration } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "받는 피해를 {0} 감소시킵니다 ({1})",
                                            reduction_percentage(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0:.0}", (1.0 - damage_multiply) * 100.0),
                                                    )
                                                }),
                                            ),
                                            time_duration(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0:.1}초간", duration.as_secs_f32()),
                                                    )
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::UserDamageReduction { multiply, duration } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "받는 피해를 {0} 감소시킵니다 ({1})",
                                            reduction_percentage(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0:.0}", (1.0 - multiply) * 100.0),
                                                    )
                                                }),
                                            ),
                                            time_duration(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0:.1}초간", duration.as_secs_f32()),
                                                    )
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealth { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "체력을 {0} 잃습니다",
                                            heal_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0:.0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealthRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "체력을 {0:.0}~{1:.0}만큼 잃습니다",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseGoldRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "골드를 {0:.0}~{1:.0}만큼 잃습니다. 골드가 부족하면 체력을 {2:.0}~{3:.0}만큼 잃습니다",
                                            min_amount,
                                            max_amount,
                                            min_amount / 10.0,
                                            max_amount / 10.0,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealthExpire { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "계약 만료 시 체력을 {0:.0}~{1:.0}만큼 잃습니다",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseGoldExpire { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "계약 만료 시 골드를 {0:.0}~{1:.0}만큼 잃습니다. 골드가 부족하면 체력을 {2:.0}~{3:.0}만큼 잃습니다",
                                            min_amount,
                                            max_amount,
                                            min_amount / 10.0,
                                            max_amount / 10.0,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseGold { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "골드를 {0} 잃습니다",
                                            gold_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::GrantUpgrade { .. } => {
                                "랜덤한 업그레이드를 획득합니다".to_string()
                            }
                            Effect::GrantItem { .. } => {
                                "아이템을 획득합니다".to_string()
                            }
                            Effect::AddChallengeMonster => {
                                "다음 라운드에 도전 몬스터가 추가됩니다"
                                    .to_string()
                            }
                            Effect::IncreaseAllTowersDamage { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "모든 타워의 공격력이 {0:.0}% 증가합니다",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseAllTowersDamage { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "모든 타워의 공격력이 {0:.0}% 감소합니다",
                                            (1.0 - multiplier) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseAllTowersAttackSpeed { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "모든 타워의 공격속도가 {0:.0}% 증가합니다",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseAllTowersRange { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "모든 타워의 사정거리가 {0:.0}% 증가합니다",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseIncomingDamage { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "받는 피해가 {0:.0}% 감소합니다",
                                            (1.0 - multiplier) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseIncomingDamage { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "받는 피해가 {0:.0}% 증가합니다",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseCardSelectionHandMaxSlots { bonus } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "카드 선택 시 최대 {0}장의 카드를 받을 수 있습니다",
                                            5 + bonus,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseCardSelectionHandMaxRerolls { bonus } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "카드 선택 시 최대 {0}번 리롤할 수 있습니다",
                                            1 + bonus,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseShopMaxRerolls { bonus } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "상점 리롤 시 최대 {0}번 리롤할 수 있습니다",
                                            1 + bonus,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseGoldGain { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "골드 획득량이 {0:.0}% 증가합니다",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseGoldGainPercent { reduction_percentage } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "골드 획득량이 {0:.0}% 감소합니다",
                                            reduction_percentage * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::DisableItemAndUpgradePurchases => {
                                "아이템과 업그레이드를 구매할 수 없습니다"
                                    .to_string()
                            }
                            Effect::DisableItemUse => {
                                "아이템을 사용할 수 없습니다".to_string()
                            }
                            Effect::DecreaseCardSelectionHandMaxSlots { penalty } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "카드 선택 시 최대 슬롯이 {0}개 감소합니다",
                                            penalty,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseCardSelectionHandMaxRerolls { penalty } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "카드 선택 시 최대 리롤 횟수가 {0}회 감소합니다",
                                            penalty,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseShopMaxRerolls { penalty } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "상점 리롤 시 최대 횟수가 {0}회 감소합니다",
                                            penalty,
                                        ),
                                    )
                                })
                            }
                            Effect::AddCardSelectionHandRerollHealthCost { cost } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "카드 선택 리롤 시 체력을 {0} 잃습니다",
                                            cost,
                                        ),
                                    )
                                })
                            }
                            Effect::AddShopRerollHealthCost { cost } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "상점 리롤 시 체력을 {0} 잃습니다",
                                            cost,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseEnemyHealthPercent { percentage } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "적 체력이 {0}% 증가합니다",
                                            percentage,
                                        ),
                                    )
                                })
                            }
                            Effect::RankTowerDisable { rank } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "계약 기간 동안 {0} 랭크 타워를 사용할 수 없습니다",
                                            rank,
                                        ),
                                    )
                                })
                            }
                            Effect::SuitTowerDisable { suit } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "계약 기간 동안 {0} 수트 타워를 사용할 수 없습니다",
                                            suit,
                                        ),
                                    )
                                })
                            }
                            Effect::AddBarricadeCardsToTowerPlacementHand { count } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "타워 설치 핸드에 바리케이드 카드를 {0}장 추가합니다",
                                            count,
                                        ),
                                    )
                                })
                            }
                            Effect::GainShield { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "보호막을 {0}~{1}만큼 획득합니다",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::HealHealth { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "체력을 {0}~{1}만큼 회복합니다",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::GainGold { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "골드를 {0:.0}~{1:.0}만큼 획득합니다",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealthRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "체력을 {0:.0}~{1:.0}만큼 감소합니다",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                        }
                    }
                }
            }
            pub(super) fn to_english(&self) -> String {
                match self {
                    EffectText::Name(effect) => {
                        match effect {
                            Effect::Heal { .. } => "Heal".to_string(),
                            Effect::Lottery { .. } => "Lottery".to_string(),
                            Effect::ExtraReroll => "Extra Reroll".to_string(),
                            Effect::Shield { .. } => "Shield".to_string(),
                            Effect::EarnGold { .. } => "Gold Gain".to_string(),
                            Effect::DamageReduction { .. } => {
                                "Damage Reduction".to_string()
                            }
                            Effect::UserDamageReduction { .. } => {
                                "Damage Reduction".to_string()
                            }
                            Effect::LoseHealth { .. } => "Lose Health".to_string(),
                            Effect::LoseHealthRange { .. } => {
                                "Lose Health (Random)".to_string()
                            }
                            Effect::LoseGoldRange { .. } => {
                                "Lose Gold (Random)".to_string()
                            }
                            Effect::LoseHealthExpire { .. } => {
                                "Lose Health On Contract End".to_string()
                            }
                            Effect::LoseGoldExpire { .. } => {
                                "Lose Gold On Contract End".to_string()
                            }
                            Effect::LoseGold { .. } => "Lose Gold".to_string(),
                            Effect::GrantUpgrade { .. } => "Grant Upgrade".to_string(),
                            Effect::GrantItem { .. } => "Grant Item".to_string(),
                            Effect::AddChallengeMonster => {
                                "Add Challenge Monster".to_string()
                            }
                            Effect::IncreaseAllTowersDamage { .. } => {
                                "Increase All Towers Damage".to_string()
                            }
                            Effect::DecreaseAllTowersDamage { .. } => {
                                "Decrease All Towers Damage".to_string()
                            }
                            Effect::IncreaseAllTowersAttackSpeed { .. } => {
                                "Increase All Towers Attack Speed".to_string()
                            }
                            Effect::IncreaseAllTowersRange { .. } => {
                                "Increase All Towers Range".to_string()
                            }
                            Effect::DecreaseIncomingDamage { .. } => {
                                "Decrease Incoming Damage".to_string()
                            }
                            Effect::IncreaseIncomingDamage { .. } => {
                                "Increase Incoming Damage".to_string()
                            }
                            Effect::IncreaseCardSelectionHandMaxSlots { .. } => {
                                "Increase Card Selection Max Slots".to_string()
                            }
                            Effect::IncreaseCardSelectionHandMaxRerolls { .. } => {
                                "Increase Card Selection Max Rerolls".to_string()
                            }
                            Effect::IncreaseShopMaxRerolls { .. } => {
                                "Increase Shop Max Rerolls".to_string()
                            }
                            Effect::IncreaseGoldGain { .. } => {
                                "Increase Gold Gain".to_string()
                            }
                            Effect::DecreaseGoldGainPercent { .. } => {
                                "Decrease Gold Gain".to_string()
                            }
                            Effect::DisableItemAndUpgradePurchases => {
                                "Disable Item/Upgrade Purchases".to_string()
                            }
                            Effect::DisableItemUse => "Disable Item Use".to_string(),
                            Effect::DecreaseCardSelectionHandMaxSlots { .. } => {
                                "Decrease Card Selection Max Slots".to_string()
                            }
                            Effect::DecreaseCardSelectionHandMaxRerolls { .. } => {
                                "Decrease Card Selection Max Rerolls".to_string()
                            }
                            Effect::DecreaseShopMaxRerolls { .. } => {
                                "Decrease Shop Max Rerolls".to_string()
                            }
                            Effect::AddCardSelectionHandRerollHealthCost { .. } => {
                                "Card Selection Reroll Health Cost".to_string()
                            }
                            Effect::AddShopRerollHealthCost { .. } => {
                                "Shop Reroll Health Cost".to_string()
                            }
                            Effect::DecreaseEnemyHealthPercent { percentage } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Enemy Health +{0}%", percentage),
                                    )
                                })
                            }
                            Effect::RankTowerDisable { rank } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Disable {0} Rank Towers", rank),
                                    )
                                })
                            }
                            Effect::SuitTowerDisable { suit } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Disable {0} Suit Towers", suit),
                                    )
                                })
                            }
                            Effect::AddBarricadeCardsToTowerPlacementHand { count } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Add {0} Barricade Cards to Tower Placement Hand",
                                            count,
                                        ),
                                    )
                                })
                            }
                            Effect::GainShield { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Gain Shield ({0}~{1})",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::HealHealth { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Heal Health ({0}~{1})",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::GainGold { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Gain Gold ({0:.0}~{1:.0})",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealthRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose Health ({0:.0}~{1:.0})",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseGoldRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose Gold ({0:.0}~{1:.0}), if insufficient, lose health ({2:.0}~{3:.0})",
                                            min_amount,
                                            max_amount,
                                            min_amount / 10.0,
                                            max_amount / 10.0,
                                        ),
                                    )
                                })
                            }
                        }
                    }
                    EffectText::Description(effect) => {
                        match effect {
                            Effect::Heal { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Restores {0} health",
                                            heal_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0:.0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::Shield { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Gain a shield that absorbs {0} damage",
                                            shield_value(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0:.0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::ExtraReroll => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Gain an {0}",
                                            special_item_text("extra reroll"),
                                        ),
                                    )
                                })
                            }
                            Effect::EarnGold { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Gain {0} gold",
                                            gold_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::Lottery { amount, probability } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0:.0}% chance to gain {1} gold",
                                            probability * 100.0,
                                            gold_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0:.0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::DamageReduction { damage_multiply, duration } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Reduces damage taken by {0} for {1}",
                                            reduction_percentage(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0:.0}", (1.0 - damage_multiply) * 100.0),
                                                    )
                                                }),
                                            ),
                                            time_duration(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0:.1}s", duration.as_secs_f32()),
                                                    )
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::UserDamageReduction { multiply, duration } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Reduces damage taken by {0} for {1}",
                                            reduction_percentage(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0:.0}", (1.0 - multiply) * 100.0),
                                                    )
                                                }),
                                            ),
                                            time_duration(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0:.1}s", duration.as_secs_f32()),
                                                    )
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealth { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose {0} health",
                                            heal_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0:.0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealthRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose {0:.0}~{1:.0} health",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseGoldRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose {0:.0}~{1:.0} gold, if insufficient, lose {2:.0}~{3:.0} health",
                                            min_amount,
                                            max_amount,
                                            min_amount / 10.0,
                                            max_amount / 10.0,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealthExpire { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose {0:.0}~{1:.0} health when contract expires",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseGoldExpire { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose {0:.0}~{1:.0} gold when contract expires, if insufficient, lose {2:.0}~{3:.0} health",
                                            min_amount,
                                            max_amount,
                                            min_amount / 10.0,
                                            max_amount / 10.0,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseGold { amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose {0} gold",
                                            gold_icon(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0}", amount))
                                                }),
                                            ),
                                        ),
                                    )
                                })
                            }
                            Effect::GrantUpgrade { .. } => {
                                "Gain a random upgrade".to_string()
                            }
                            Effect::GrantItem { .. } => "Gain an item".to_string(),
                            Effect::AddChallengeMonster => {
                                "Add a challenge monster next round".to_string()
                            }
                            Effect::IncreaseAllTowersDamage { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Increase damage of all towers by {0:.0}%",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseAllTowersDamage { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Decrease damage of all towers by {0:.0}%",
                                            (1.0 - multiplier) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseAllTowersAttackSpeed { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Increase attack speed of all towers by {0:.0}%",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseAllTowersRange { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Increase range of all towers by {0:.0}%",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseIncomingDamage { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Reduce incoming damage by {0:.0}%",
                                            (1.0 - multiplier) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseIncomingDamage { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Increase incoming damage by {0:.0}%",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseCardSelectionHandMaxSlots { bonus } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Can receive up to {0} cards when selecting cards",
                                            5 + bonus,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseCardSelectionHandMaxRerolls { bonus } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Can reroll up to {0} times when selecting cards",
                                            1 + bonus,
                                        ),
                                    )
                                })
                            }
                            Effect::IncreaseShopMaxRerolls { bonus } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Can reroll shop up to {0} times", 1 + bonus),
                                    )
                                })
                            }
                            Effect::IncreaseGoldGain { multiplier } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Increase gold gain by {0:.0}%",
                                            (multiplier - 1.0) * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseGoldGainPercent { reduction_percentage } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Decrease gold gain by {0:.0}%",
                                            reduction_percentage * 100.0,
                                        ),
                                    )
                                })
                            }
                            Effect::DisableItemAndUpgradePurchases => {
                                "Cannot purchase items and upgrades".to_string()
                            }
                            Effect::DisableItemUse => "Cannot use items".to_string(),
                            Effect::DecreaseCardSelectionHandMaxSlots { penalty } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Reduce maximum card selection slots by {0}",
                                            penalty,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseCardSelectionHandMaxRerolls { penalty } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Reduce maximum card selection rerolls by {0}",
                                            penalty,
                                        ),
                                    )
                                })
                            }
                            Effect::DecreaseShopMaxRerolls { penalty } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Reduce maximum shop rerolls by {0}", penalty),
                                    )
                                })
                            }
                            Effect::AddCardSelectionHandRerollHealthCost { cost } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose {0} health when rerolling card selection",
                                            cost,
                                        ),
                                    )
                                })
                            }
                            Effect::AddShopRerollHealthCost { cost } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Lose {0} health when rerolling shop", cost),
                                    )
                                })
                            }
                            Effect::DecreaseEnemyHealthPercent { percentage } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Increase enemy health by {0}%", percentage),
                                    )
                                })
                            }
                            Effect::RankTowerDisable { rank } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Cannot use {0} rank towers during contract",
                                            rank,
                                        ),
                                    )
                                })
                            }
                            Effect::SuitTowerDisable { suit } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Cannot use {0} suit towers during contract",
                                            suit,
                                        ),
                                    )
                                })
                            }
                            Effect::AddBarricadeCardsToTowerPlacementHand { count } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Add {0} barricade cards to tower placement hand",
                                            count,
                                        ),
                                    )
                                })
                            }
                            Effect::GainShield { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Gain shield ({0}~{1})",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::HealHealth { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Heal health ({0}~{1})",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::GainGold { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Gain gold ({0:.0}~{1:.0})",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                            Effect::LoseHealthRange { min_amount, max_amount } => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Lose health ({0:.0}~{1:.0})",
                                            min_amount,
                                            max_amount,
                                        ),
                                    )
                                })
                            }
                        }
                    }
                }
            }
        }
    }
    pub mod item {}
    pub mod locale {
        use crate::*;
        pub enum Language {
            Korean,
            English,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Language {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Language::Korean => "Korean",
                        Language::English => "English",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Language {
            #[inline]
            fn clone(&self) -> Language {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Language {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Language {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Language {
            #[inline]
            fn eq(&self, other: &Language) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Language {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl bincode::Encode for Language {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Korean => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::English => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for Language {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Korean),
                    1u32 => Ok(Self::English),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 1u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for Language {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Korean => {
                        buf.write_string("Korean");
                    }
                    Self::English => {
                        buf.write_string("English");
                    }
                }
            }
        }
        impl Deserialize for Language {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Korean" => Ok(Self::Korean),
                    "English" => Ok(Self::English),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub struct Locale {
            pub language: Language,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Locale {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Locale",
                    "language",
                    &&self.language,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Locale {
            #[inline]
            fn clone(&self) -> Locale {
                let _: ::core::clone::AssertParamIsClone<Language>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Locale {}
        impl bincode::Encode for Locale {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.language, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for Locale {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    language: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for Locale {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("language");
                self.language.serialize_without_name(buf);
            }
        }
        impl Deserialize for Locale {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("language")?;
                let language = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { language })
            }
        }
        impl Locale {
            pub const KOREAN: Self = Self { language: Language::Korean };
            pub const ENGLISH: Self = Self {
                language: Language::English,
            };
        }
        impl Default for Locale {
            fn default() -> Self {
                Self::KOREAN
            }
        }
        pub trait LocalizedText {
            fn localized_text(&self, locale: &Locale) -> String;
        }
        pub trait LocalizedStaticText {
            fn localized_text(&self, locale: &Locale) -> &'static str;
        }
    }
    pub mod quest {
        use super::{Language, Locale, LocalizedText, rich_text_helpers::*};
        use crate::{card::Suit, *};
        pub enum QuestText {
            BuildTowerRankNew { rank: String, count: usize },
            BuildTowerRank { rank: String, count: usize, current_count: usize },
            BuildTowerSuitNew { suit: Suit, count: usize },
            BuildTowerSuit { suit: Suit, count: usize, current_count: usize },
            BuildTowerHandNew { hand: String, count: usize },
            BuildTowerHand { hand: String, count: usize, current_count: usize },
            ClearBossRoundWithoutItems,
            DealDamageWithItems { damage: usize },
            BuildTowersWithoutReroll { count: usize },
            UseReroll { count: usize },
            SpendGold { gold: usize },
            EarnGold { gold: usize },
            IncreaseAttackSpeed { speed: usize },
            IncreaseAttackRange { range: usize },
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for QuestText {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    QuestText::BuildTowerRankNew { rank: __self_0, count: __self_1 } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "BuildTowerRankNew",
                            "rank",
                            __self_0,
                            "count",
                            &__self_1,
                        )
                    }
                    QuestText::BuildTowerRank {
                        rank: __self_0,
                        count: __self_1,
                        current_count: __self_2,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "BuildTowerRank",
                            "rank",
                            __self_0,
                            "count",
                            __self_1,
                            "current_count",
                            &__self_2,
                        )
                    }
                    QuestText::BuildTowerSuitNew { suit: __self_0, count: __self_1 } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "BuildTowerSuitNew",
                            "suit",
                            __self_0,
                            "count",
                            &__self_1,
                        )
                    }
                    QuestText::BuildTowerSuit {
                        suit: __self_0,
                        count: __self_1,
                        current_count: __self_2,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "BuildTowerSuit",
                            "suit",
                            __self_0,
                            "count",
                            __self_1,
                            "current_count",
                            &__self_2,
                        )
                    }
                    QuestText::BuildTowerHandNew { hand: __self_0, count: __self_1 } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "BuildTowerHandNew",
                            "hand",
                            __self_0,
                            "count",
                            &__self_1,
                        )
                    }
                    QuestText::BuildTowerHand {
                        hand: __self_0,
                        count: __self_1,
                        current_count: __self_2,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "BuildTowerHand",
                            "hand",
                            __self_0,
                            "count",
                            __self_1,
                            "current_count",
                            &__self_2,
                        )
                    }
                    QuestText::ClearBossRoundWithoutItems => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "ClearBossRoundWithoutItems",
                        )
                    }
                    QuestText::DealDamageWithItems { damage: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DealDamageWithItems",
                            "damage",
                            &__self_0,
                        )
                    }
                    QuestText::BuildTowersWithoutReroll { count: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "BuildTowersWithoutReroll",
                            "count",
                            &__self_0,
                        )
                    }
                    QuestText::UseReroll { count: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "UseReroll",
                            "count",
                            &__self_0,
                        )
                    }
                    QuestText::SpendGold { gold: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "SpendGold",
                            "gold",
                            &__self_0,
                        )
                    }
                    QuestText::EarnGold { gold: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "EarnGold",
                            "gold",
                            &__self_0,
                        )
                    }
                    QuestText::IncreaseAttackSpeed { speed: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseAttackSpeed",
                            "speed",
                            &__self_0,
                        )
                    }
                    QuestText::IncreaseAttackRange { range: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "IncreaseAttackRange",
                            "range",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for QuestText {
            #[inline]
            fn clone(&self) -> QuestText {
                match self {
                    QuestText::BuildTowerRankNew { rank: __self_0, count: __self_1 } => {
                        QuestText::BuildTowerRankNew {
                            rank: ::core::clone::Clone::clone(__self_0),
                            count: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    QuestText::BuildTowerRank {
                        rank: __self_0,
                        count: __self_1,
                        current_count: __self_2,
                    } => {
                        QuestText::BuildTowerRank {
                            rank: ::core::clone::Clone::clone(__self_0),
                            count: ::core::clone::Clone::clone(__self_1),
                            current_count: ::core::clone::Clone::clone(__self_2),
                        }
                    }
                    QuestText::BuildTowerSuitNew { suit: __self_0, count: __self_1 } => {
                        QuestText::BuildTowerSuitNew {
                            suit: ::core::clone::Clone::clone(__self_0),
                            count: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    QuestText::BuildTowerSuit {
                        suit: __self_0,
                        count: __self_1,
                        current_count: __self_2,
                    } => {
                        QuestText::BuildTowerSuit {
                            suit: ::core::clone::Clone::clone(__self_0),
                            count: ::core::clone::Clone::clone(__self_1),
                            current_count: ::core::clone::Clone::clone(__self_2),
                        }
                    }
                    QuestText::BuildTowerHandNew { hand: __self_0, count: __self_1 } => {
                        QuestText::BuildTowerHandNew {
                            hand: ::core::clone::Clone::clone(__self_0),
                            count: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    QuestText::BuildTowerHand {
                        hand: __self_0,
                        count: __self_1,
                        current_count: __self_2,
                    } => {
                        QuestText::BuildTowerHand {
                            hand: ::core::clone::Clone::clone(__self_0),
                            count: ::core::clone::Clone::clone(__self_1),
                            current_count: ::core::clone::Clone::clone(__self_2),
                        }
                    }
                    QuestText::ClearBossRoundWithoutItems => {
                        QuestText::ClearBossRoundWithoutItems
                    }
                    QuestText::DealDamageWithItems { damage: __self_0 } => {
                        QuestText::DealDamageWithItems {
                            damage: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    QuestText::BuildTowersWithoutReroll { count: __self_0 } => {
                        QuestText::BuildTowersWithoutReroll {
                            count: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    QuestText::UseReroll { count: __self_0 } => {
                        QuestText::UseReroll {
                            count: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    QuestText::SpendGold { gold: __self_0 } => {
                        QuestText::SpendGold {
                            gold: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    QuestText::EarnGold { gold: __self_0 } => {
                        QuestText::EarnGold {
                            gold: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    QuestText::IncreaseAttackSpeed { speed: __self_0 } => {
                        QuestText::IncreaseAttackSpeed {
                            speed: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    QuestText::IncreaseAttackRange { range: __self_0 } => {
                        QuestText::IncreaseAttackRange {
                            range: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                }
            }
        }
        impl bincode::Encode for QuestText {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::BuildTowerRankNew { rank, count } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                        bincode::Encode::encode(count, encoder)?;
                    }
                    Self::BuildTowerRank { rank, count, current_count } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                        bincode::Encode::encode(count, encoder)?;
                        bincode::Encode::encode(current_count, encoder)?;
                    }
                    Self::BuildTowerSuitNew { suit, count } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                        bincode::Encode::encode(count, encoder)?;
                    }
                    Self::BuildTowerSuit { suit, count, current_count } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(suit, encoder)?;
                        bincode::Encode::encode(count, encoder)?;
                        bincode::Encode::encode(current_count, encoder)?;
                    }
                    Self::BuildTowerHandNew { hand, count } => {
                        bincode::Encode::encode(&4u32, encoder)?;
                        bincode::Encode::encode(hand, encoder)?;
                        bincode::Encode::encode(count, encoder)?;
                    }
                    Self::BuildTowerHand { hand, count, current_count } => {
                        bincode::Encode::encode(&5u32, encoder)?;
                        bincode::Encode::encode(hand, encoder)?;
                        bincode::Encode::encode(count, encoder)?;
                        bincode::Encode::encode(current_count, encoder)?;
                    }
                    Self::ClearBossRoundWithoutItems => {
                        bincode::Encode::encode(&6u32, encoder)?;
                    }
                    Self::DealDamageWithItems { damage } => {
                        bincode::Encode::encode(&7u32, encoder)?;
                        bincode::Encode::encode(damage, encoder)?;
                    }
                    Self::BuildTowersWithoutReroll { count } => {
                        bincode::Encode::encode(&8u32, encoder)?;
                        bincode::Encode::encode(count, encoder)?;
                    }
                    Self::UseReroll { count } => {
                        bincode::Encode::encode(&9u32, encoder)?;
                        bincode::Encode::encode(count, encoder)?;
                    }
                    Self::SpendGold { gold } => {
                        bincode::Encode::encode(&10u32, encoder)?;
                        bincode::Encode::encode(gold, encoder)?;
                    }
                    Self::EarnGold { gold } => {
                        bincode::Encode::encode(&11u32, encoder)?;
                        bincode::Encode::encode(gold, encoder)?;
                    }
                    Self::IncreaseAttackSpeed { speed } => {
                        bincode::Encode::encode(&12u32, encoder)?;
                        bincode::Encode::encode(speed, encoder)?;
                    }
                    Self::IncreaseAttackRange { range } => {
                        bincode::Encode::encode(&13u32, encoder)?;
                        bincode::Encode::encode(range, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for QuestText {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::BuildTowerRankNew {
                            rank: bincode::Decode::decode(decoder)?,
                            count: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => {
                        Ok(Self::BuildTowerRank {
                            rank: bincode::Decode::decode(decoder)?,
                            count: bincode::Decode::decode(decoder)?,
                            current_count: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => {
                        Ok(Self::BuildTowerSuitNew {
                            suit: bincode::Decode::decode(decoder)?,
                            count: bincode::Decode::decode(decoder)?,
                        })
                    }
                    3u32 => {
                        Ok(Self::BuildTowerSuit {
                            suit: bincode::Decode::decode(decoder)?,
                            count: bincode::Decode::decode(decoder)?,
                            current_count: bincode::Decode::decode(decoder)?,
                        })
                    }
                    4u32 => {
                        Ok(Self::BuildTowerHandNew {
                            hand: bincode::Decode::decode(decoder)?,
                            count: bincode::Decode::decode(decoder)?,
                        })
                    }
                    5u32 => {
                        Ok(Self::BuildTowerHand {
                            hand: bincode::Decode::decode(decoder)?,
                            count: bincode::Decode::decode(decoder)?,
                            current_count: bincode::Decode::decode(decoder)?,
                        })
                    }
                    6u32 => Ok(Self::ClearBossRoundWithoutItems),
                    7u32 => {
                        Ok(Self::DealDamageWithItems {
                            damage: bincode::Decode::decode(decoder)?,
                        })
                    }
                    8u32 => {
                        Ok(Self::BuildTowersWithoutReroll {
                            count: bincode::Decode::decode(decoder)?,
                        })
                    }
                    9u32 => {
                        Ok(Self::UseReroll {
                            count: bincode::Decode::decode(decoder)?,
                        })
                    }
                    10u32 => {
                        Ok(Self::SpendGold {
                            gold: bincode::Decode::decode(decoder)?,
                        })
                    }
                    11u32 => {
                        Ok(Self::EarnGold {
                            gold: bincode::Decode::decode(decoder)?,
                        })
                    }
                    12u32 => {
                        Ok(Self::IncreaseAttackSpeed {
                            speed: bincode::Decode::decode(decoder)?,
                        })
                    }
                    13u32 => {
                        Ok(Self::IncreaseAttackRange {
                            range: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 13u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for QuestText {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::BuildTowerRankNew { rank, count } => {
                        buf.write_string("BuildTowerRankNew");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                        buf.write_string("count");
                        count.serialize_without_name(buf);
                    }
                    Self::BuildTowerRank { rank, count, current_count } => {
                        buf.write_string("BuildTowerRank");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                        buf.write_string("count");
                        count.serialize_without_name(buf);
                        buf.write_string("current_count");
                        current_count.serialize_without_name(buf);
                    }
                    Self::BuildTowerSuitNew { suit, count } => {
                        buf.write_string("BuildTowerSuitNew");
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                        buf.write_string("count");
                        count.serialize_without_name(buf);
                    }
                    Self::BuildTowerSuit { suit, count, current_count } => {
                        buf.write_string("BuildTowerSuit");
                        buf.write_string("suit");
                        suit.serialize_without_name(buf);
                        buf.write_string("count");
                        count.serialize_without_name(buf);
                        buf.write_string("current_count");
                        current_count.serialize_without_name(buf);
                    }
                    Self::BuildTowerHandNew { hand, count } => {
                        buf.write_string("BuildTowerHandNew");
                        buf.write_string("hand");
                        hand.serialize_without_name(buf);
                        buf.write_string("count");
                        count.serialize_without_name(buf);
                    }
                    Self::BuildTowerHand { hand, count, current_count } => {
                        buf.write_string("BuildTowerHand");
                        buf.write_string("hand");
                        hand.serialize_without_name(buf);
                        buf.write_string("count");
                        count.serialize_without_name(buf);
                        buf.write_string("current_count");
                        current_count.serialize_without_name(buf);
                    }
                    Self::ClearBossRoundWithoutItems => {
                        buf.write_string("ClearBossRoundWithoutItems");
                    }
                    Self::DealDamageWithItems { damage } => {
                        buf.write_string("DealDamageWithItems");
                        buf.write_string("damage");
                        damage.serialize_without_name(buf);
                    }
                    Self::BuildTowersWithoutReroll { count } => {
                        buf.write_string("BuildTowersWithoutReroll");
                        buf.write_string("count");
                        count.serialize_without_name(buf);
                    }
                    Self::UseReroll { count } => {
                        buf.write_string("UseReroll");
                        buf.write_string("count");
                        count.serialize_without_name(buf);
                    }
                    Self::SpendGold { gold } => {
                        buf.write_string("SpendGold");
                        buf.write_string("gold");
                        gold.serialize_without_name(buf);
                    }
                    Self::EarnGold { gold } => {
                        buf.write_string("EarnGold");
                        buf.write_string("gold");
                        gold.serialize_without_name(buf);
                    }
                    Self::IncreaseAttackSpeed { speed } => {
                        buf.write_string("IncreaseAttackSpeed");
                        buf.write_string("speed");
                        speed.serialize_without_name(buf);
                    }
                    Self::IncreaseAttackRange { range } => {
                        buf.write_string("IncreaseAttackRange");
                        buf.write_string("range");
                        range.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for QuestText {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "BuildTowerRankNew" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("count")?;
                        let count = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::BuildTowerRankNew {
                            rank,
                            count,
                        })
                    }
                    "BuildTowerRank" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("count")?;
                        let count = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("current_count")?;
                        let current_count = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::BuildTowerRank {
                            rank,
                            count,
                            current_count,
                        })
                    }
                    "BuildTowerSuitNew" => {
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("count")?;
                        let count = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::BuildTowerSuitNew {
                            suit,
                            count,
                        })
                    }
                    "BuildTowerSuit" => {
                        let field_name = buf.read_name("suit")?;
                        let suit = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("count")?;
                        let count = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("current_count")?;
                        let current_count = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::BuildTowerSuit {
                            suit,
                            count,
                            current_count,
                        })
                    }
                    "BuildTowerHandNew" => {
                        let field_name = buf.read_name("hand")?;
                        let hand = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("count")?;
                        let count = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::BuildTowerHandNew {
                            hand,
                            count,
                        })
                    }
                    "BuildTowerHand" => {
                        let field_name = buf.read_name("hand")?;
                        let hand = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("count")?;
                        let count = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("current_count")?;
                        let current_count = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::BuildTowerHand {
                            hand,
                            count,
                            current_count,
                        })
                    }
                    "ClearBossRoundWithoutItems" => Ok(Self::ClearBossRoundWithoutItems),
                    "DealDamageWithItems" => {
                        let field_name = buf.read_name("damage")?;
                        let damage = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DealDamageWithItems {
                            damage,
                        })
                    }
                    "BuildTowersWithoutReroll" => {
                        let field_name = buf.read_name("count")?;
                        let count = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::BuildTowersWithoutReroll {
                            count,
                        })
                    }
                    "UseReroll" => {
                        let field_name = buf.read_name("count")?;
                        let count = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::UseReroll { count })
                    }
                    "SpendGold" => {
                        let field_name = buf.read_name("gold")?;
                        let gold = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SpendGold { gold })
                    }
                    "EarnGold" => {
                        let field_name = buf.read_name("gold")?;
                        let gold = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::EarnGold { gold })
                    }
                    "IncreaseAttackSpeed" => {
                        let field_name = buf.read_name("speed")?;
                        let speed = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseAttackSpeed { speed })
                    }
                    "IncreaseAttackRange" => {
                        let field_name = buf.read_name("range")?;
                        let range = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::IncreaseAttackRange { range })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl QuestText {
            pub(super) fn to_korean(&self) -> String {
                match self {
                    QuestText::BuildTowerRankNew { rank, count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}타워를 {1}개 새로 건설하세요.",
                                    rank,
                                    count,
                                ),
                            )
                        })
                    }
                    QuestText::BuildTowerRank { rank, count, current_count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}타워를 {1}개 소유하세요. ({2}/{1})",
                                    rank,
                                    count,
                                    current_count,
                                ),
                            )
                        })
                    }
                    QuestText::BuildTowerSuitNew { suit, count } => {
                        let suit_text = suit_icon(*suit);
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}타워를 {1}개 새로 건설하세요.",
                                    suit_text,
                                    count,
                                ),
                            )
                        })
                    }
                    QuestText::BuildTowerSuit { suit, count, current_count } => {
                        let suit_text = suit_icon(*suit);
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}타워를 {1}개 소유하세요. ({2}/{1})",
                                    suit_text,
                                    count,
                                    current_count,
                                ),
                            )
                        })
                    }
                    QuestText::BuildTowerHandNew { hand, count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}타워를 {1}개 새로 건설하세요.",
                                    hand,
                                    count,
                                ),
                            )
                        })
                    }
                    QuestText::BuildTowerHand { hand, count, current_count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}타워를 {1}개 소유하세요. ({2}/{1})",
                                    hand,
                                    count,
                                    current_count,
                                ),
                            )
                        })
                    }
                    QuestText::ClearBossRoundWithoutItems => {
                        "아이템을 사용하지않고 보스라운드 클리어"
                            .to_string()
                    }
                    QuestText::DealDamageWithItems { damage } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "아이템을 사용해 {0}피해 입히기",
                                    attack_damage_icon(damage),
                                ),
                            )
                        })
                    }
                    QuestText::BuildTowersWithoutReroll { count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "리롤하지않고 타워 {0}개 만들기",
                                    count,
                                ),
                            )
                        })
                    }
                    QuestText::UseReroll { count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("리롤 {0}회 사용하기", count),
                            )
                        })
                    }
                    QuestText::SpendGold { gold } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0} 사용하기", gold_icon(*gold)),
                            )
                        })
                    }
                    QuestText::EarnGold { gold } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0} 획득하기", gold_icon(*gold)),
                            )
                        })
                    }
                    QuestText::IncreaseAttackSpeed { speed } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} 증가시키기",
                                    attack_speed_icon(speed),
                                ),
                            )
                        })
                    }
                    QuestText::IncreaseAttackRange { range } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} 증가시키기",
                                    attack_range_icon(range),
                                ),
                            )
                        })
                    }
                }
            }
            pub(super) fn to_english(&self) -> String {
                match self {
                    QuestText::BuildTowerRankNew { rank, count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Build {0} new {1} towers.", count, rank),
                            )
                        })
                    }
                    QuestText::BuildTowerRank { rank, count, current_count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Own {0} {1} towers. ({2}/{0})",
                                    count,
                                    rank,
                                    current_count,
                                ),
                            )
                        })
                    }
                    QuestText::BuildTowerSuitNew { suit, count } => {
                        let suit_text = suit_icon(*suit);
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Build {0} new {1} towers.", count, suit_text),
                            )
                        })
                    }
                    QuestText::BuildTowerSuit { suit, count, current_count } => {
                        let suit_text = suit_icon(*suit);
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Own {0} {1} towers. ({2}/{0})",
                                    count,
                                    suit_text,
                                    current_count,
                                ),
                            )
                        })
                    }
                    QuestText::BuildTowerHandNew { hand, count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Build {0} new {1} towers.", count, hand),
                            )
                        })
                    }
                    QuestText::BuildTowerHand { hand, count, current_count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Own {0} {1} towers. ({2}/{0})",
                                    count,
                                    hand,
                                    current_count,
                                ),
                            )
                        })
                    }
                    QuestText::ClearBossRoundWithoutItems => {
                        "Clear the boss round without using items".to_string()
                    }
                    QuestText::DealDamageWithItems { damage } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Deal {0} damage using items",
                                    attack_damage_icon(damage),
                                ),
                            )
                        })
                    }
                    QuestText::BuildTowersWithoutReroll { count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Build {0} towers without rerolling", count),
                            )
                        })
                    }
                    QuestText::UseReroll { count } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Use reroll {0} times", count),
                            )
                        })
                    }
                    QuestText::SpendGold { gold } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Spend {0}", gold_icon(*gold)),
                            )
                        })
                    }
                    QuestText::EarnGold { gold } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Gain {0}", gold_icon(*gold)),
                            )
                        })
                    }
                    QuestText::IncreaseAttackSpeed { speed } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Increase {0} by {1}",
                                    attack_speed_icon("attack speed"),
                                    speed,
                                ),
                            )
                        })
                    }
                    QuestText::IncreaseAttackRange { range } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Increase {0} by {1}",
                                    attack_range_icon("attack range"),
                                    range,
                                ),
                            )
                        })
                    }
                }
            }
        }
        impl LocalizedText for QuestText {
            fn localized_text(&self, locale: &Locale) -> String {
                match locale.language {
                    Language::Korean => self.to_korean(),
                    Language::English => self.to_english(),
                }
            }
        }
        pub enum QuestRewardText {
            Money { amount: usize },
            Item,
            Upgrade,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for QuestRewardText {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    QuestRewardText::Money { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Money",
                            "amount",
                            &__self_0,
                        )
                    }
                    QuestRewardText::Item => ::core::fmt::Formatter::write_str(f, "Item"),
                    QuestRewardText::Upgrade => {
                        ::core::fmt::Formatter::write_str(f, "Upgrade")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for QuestRewardText {
            #[inline]
            fn clone(&self) -> QuestRewardText {
                match self {
                    QuestRewardText::Money { amount: __self_0 } => {
                        QuestRewardText::Money {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    QuestRewardText::Item => QuestRewardText::Item,
                    QuestRewardText::Upgrade => QuestRewardText::Upgrade,
                }
            }
        }
        impl bincode::Encode for QuestRewardText {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Money { amount } => {
                        bincode::Encode::encode(&0u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::Item => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::Upgrade => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for QuestRewardText {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => {
                        Ok(Self::Money {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    1u32 => Ok(Self::Item),
                    2u32 => Ok(Self::Upgrade),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 2u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for QuestRewardText {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Money { amount } => {
                        buf.write_string("Money");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::Item => {
                        buf.write_string("Item");
                    }
                    Self::Upgrade => {
                        buf.write_string("Upgrade");
                    }
                }
            }
        }
        impl Deserialize for QuestRewardText {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Money" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Money { amount })
                    }
                    "Item" => Ok(Self::Item),
                    "Upgrade" => Ok(Self::Upgrade),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl QuestRewardText {
            pub(super) fn to_korean(&self) -> String {
                match self {
                    QuestRewardText::Money { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0} 골드", gold_icon(amount)),
                            )
                        })
                    }
                    QuestRewardText::Item => "아이템".to_string(),
                    QuestRewardText::Upgrade => "업그레이드".to_string(),
                }
            }
            pub(super) fn to_english(&self) -> String {
                match self {
                    QuestRewardText::Money { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0} Gold", gold_icon(amount)),
                            )
                        })
                    }
                    QuestRewardText::Item => "Item".to_string(),
                    QuestRewardText::Upgrade => "Upgrade".to_string(),
                }
            }
        }
        impl LocalizedText for QuestRewardText {
            fn localized_text(&self, locale: &Locale) -> String {
                match locale.language {
                    Language::Korean => self.to_korean(),
                    Language::English => self.to_english(),
                }
            }
        }
    }
    pub mod rich_text_helpers {
        use crate::icon::{Icon, IconKind};
        pub fn range<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|blue|{0}|/blue|", value))
            })
        }
        pub fn beam_thickness<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|blue|{0}|/blue|", value))
            })
        }
        pub fn time_duration<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|yellow|{0}|/yellow|", value))
            })
        }
        pub fn gold_icon<T: std::fmt::Display>(value: T) -> String {
            let icon = Icon::new(IconKind::Gold);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!("|gold_color|{0}{1}|/gold_color|", icon.as_tag(), value),
                )
            })
        }
        pub fn gold_icon_small<T: std::fmt::Display>(value: T) -> String {
            let icon = Icon::new(IconKind::Gold).size(crate::icon::IconSize::Small);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!("|gold_color|{0}{1}|/gold_color|", icon.as_tag(), value),
                )
            })
        }
        pub fn attack_damage_stat(stat_name: &str) -> String {
            let icon = Icon::new(IconKind::AttackDamage);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}|attack_damage_color|{1}|/attack_damage_color|",
                        icon.as_tag(),
                        stat_name,
                    ),
                )
            })
        }
        pub fn additive_value<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|green|+{0}|/green|", value))
            })
        }
        pub fn multiplier_value<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|blue|x{0}|/blue|", value))
            })
        }
        pub fn card_rank<T: std::fmt::Display>(rank: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|purple|{0}|/purple|", rank))
            })
        }
        pub fn special_item_text<T: std::fmt::Display>(text: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|blue|{0}|/blue|", text))
            })
        }
        pub fn movement_speed_debuff_text(text: &str) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|red|{0}|/red|", text))
            })
        }
        pub fn movement_speed_debuff_value<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|red|{0}|/red|", value))
            })
        }
        pub fn percentage_increase<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|green|+{0}%|/green|", value))
            })
        }
        pub fn percentage_decrease<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|red|-{0}%|/red|", value))
            })
        }
        pub fn value_increase<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|green|+{0}|/green|", value))
            })
        }
        pub fn shield_value<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|blue|{0}|/blue|", value))
            })
        }
        pub fn reduction_percentage<T: std::fmt::Display>(value: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|green|{0}%|/green|", value))
            })
        }
        pub fn attack_damage_icon<T: std::fmt::Display>(value: T) -> String {
            let icon = Icon::new(IconKind::AttackDamage);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "|attack_damage_color|{0}{1}|/attack_damage_color|",
                        icon.as_tag(),
                        value,
                    ),
                )
            })
        }
        pub fn attack_damage_icon_small<T: std::fmt::Display>(value: T) -> String {
            let icon = Icon::new(IconKind::AttackDamage)
                .size(crate::icon::IconSize::Small);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "|attack_damage_color|{0}{1}|/attack_damage_color|",
                        icon.as_tag(),
                        value,
                    ),
                )
            })
        }
        pub fn attack_speed_stat(stat_name: &str) -> String {
            let icon = Icon::new(IconKind::AttackSpeed);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}|attack_speed_color|{1}|/attack_speed_color|",
                        icon.as_tag(),
                        stat_name,
                    ),
                )
            })
        }
        pub fn attack_speed_icon<T: std::fmt::Display>(value: T) -> String {
            let icon = Icon::new(IconKind::AttackSpeed);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "|attack_speed_color|{0}{1}|/attack_speed_color|",
                        icon.as_tag(),
                        value,
                    ),
                )
            })
        }
        pub fn attack_speed_icon_small<T: std::fmt::Display>(value: T) -> String {
            let icon = Icon::new(IconKind::AttackSpeed)
                .size(crate::icon::IconSize::Small);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "|attack_speed_color|{0}{1}|/attack_speed_color|",
                        icon.as_tag(),
                        value,
                    ),
                )
            })
        }
        pub fn attack_range_stat(stat_name: &str) -> String {
            let icon = Icon::new(IconKind::AttackRange);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}|attack_range_color|{1}|/attack_range_color|",
                        icon.as_tag(),
                        stat_name,
                    ),
                )
            })
        }
        pub fn attack_range_icon<T: std::fmt::Display>(value: T) -> String {
            let icon = Icon::new(IconKind::AttackRange);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "|attack_range_color|{0}{1}|/attack_range_color|",
                        icon.as_tag(),
                        value,
                    ),
                )
            })
        }
        pub fn attack_range_icon_small<T: std::fmt::Display>(value: T) -> String {
            let icon = Icon::new(IconKind::AttackRange)
                .size(crate::icon::IconSize::Small);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "|attack_range_color|{0}{1}|/attack_range_color|",
                        icon.as_tag(),
                        value,
                    ),
                )
            })
        }
        pub fn heal_icon<T: std::fmt::Display>(value: T) -> String {
            let icon = Icon::new(IconKind::Health);
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!("|gold_color|{0}{1}|/gold_color|", icon.as_tag(), value),
                )
            })
        }
        pub fn shop_icon() -> String {
            Icon::new(IconKind::Shop).as_tag()
        }
        pub fn quest_icon() -> String {
            Icon::new(IconKind::Quest).as_tag()
        }
        pub fn refresh_icon() -> String {
            Icon::new(IconKind::Refresh).as_tag()
        }
        pub fn suit_icon(suit: crate::card::Suit) -> String {
            Icon::new(IconKind::Suit { suit }).as_tag()
        }
        pub fn with_suit_color(text: String, suit: crate::card::Suit) -> String {
            use crate::card::Suit;
            let color_tag = match suit {
                Suit::Spades | Suit::Clubs => "black_suit_color",
                Suit::Hearts | Suit::Diamonds => "red_suit_color",
            };
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|{0}|{1}|/{0}|", color_tag, text))
            })
        }
        pub fn contract_risk<T: std::fmt::Display>(text: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|red|{0}|/red|", text))
            })
        }
        pub fn contract_reward<T: std::fmt::Display>(text: T) -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("|blue|{0}|/blue|", text))
            })
        }
    }
    pub mod tower {
        use super::{Language, Locale, LocalizedStaticText};
        use crate::*;
        pub enum TowerKindText {
            Barricade,
            High,
            OnePair,
            TwoPair,
            ThreeOfAKind,
            Straight,
            Flush,
            FullHouse,
            FourOfAKind,
            StraightFlush,
            RoyalFlush,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TowerKindText {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TowerKindText::Barricade => "Barricade",
                        TowerKindText::High => "High",
                        TowerKindText::OnePair => "OnePair",
                        TowerKindText::TwoPair => "TwoPair",
                        TowerKindText::ThreeOfAKind => "ThreeOfAKind",
                        TowerKindText::Straight => "Straight",
                        TowerKindText::Flush => "Flush",
                        TowerKindText::FullHouse => "FullHouse",
                        TowerKindText::FourOfAKind => "FourOfAKind",
                        TowerKindText::StraightFlush => "StraightFlush",
                        TowerKindText::RoyalFlush => "RoyalFlush",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TowerKindText {
            #[inline]
            fn clone(&self) -> TowerKindText {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TowerKindText {}
        impl bincode::Encode for TowerKindText {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Barricade => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::High => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::OnePair => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::TwoPair => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                    Self::ThreeOfAKind => {
                        bincode::Encode::encode(&4u32, encoder)?;
                    }
                    Self::Straight => {
                        bincode::Encode::encode(&5u32, encoder)?;
                    }
                    Self::Flush => {
                        bincode::Encode::encode(&6u32, encoder)?;
                    }
                    Self::FullHouse => {
                        bincode::Encode::encode(&7u32, encoder)?;
                    }
                    Self::FourOfAKind => {
                        bincode::Encode::encode(&8u32, encoder)?;
                    }
                    Self::StraightFlush => {
                        bincode::Encode::encode(&9u32, encoder)?;
                    }
                    Self::RoyalFlush => {
                        bincode::Encode::encode(&10u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for TowerKindText {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Barricade),
                    1u32 => Ok(Self::High),
                    2u32 => Ok(Self::OnePair),
                    3u32 => Ok(Self::TwoPair),
                    4u32 => Ok(Self::ThreeOfAKind),
                    5u32 => Ok(Self::Straight),
                    6u32 => Ok(Self::Flush),
                    7u32 => Ok(Self::FullHouse),
                    8u32 => Ok(Self::FourOfAKind),
                    9u32 => Ok(Self::StraightFlush),
                    10u32 => Ok(Self::RoyalFlush),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 10u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for TowerKindText {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Barricade => {
                        buf.write_string("Barricade");
                    }
                    Self::High => {
                        buf.write_string("High");
                    }
                    Self::OnePair => {
                        buf.write_string("OnePair");
                    }
                    Self::TwoPair => {
                        buf.write_string("TwoPair");
                    }
                    Self::ThreeOfAKind => {
                        buf.write_string("ThreeOfAKind");
                    }
                    Self::Straight => {
                        buf.write_string("Straight");
                    }
                    Self::Flush => {
                        buf.write_string("Flush");
                    }
                    Self::FullHouse => {
                        buf.write_string("FullHouse");
                    }
                    Self::FourOfAKind => {
                        buf.write_string("FourOfAKind");
                    }
                    Self::StraightFlush => {
                        buf.write_string("StraightFlush");
                    }
                    Self::RoyalFlush => {
                        buf.write_string("RoyalFlush");
                    }
                }
            }
        }
        impl Deserialize for TowerKindText {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Barricade" => Ok(Self::Barricade),
                    "High" => Ok(Self::High),
                    "OnePair" => Ok(Self::OnePair),
                    "TwoPair" => Ok(Self::TwoPair),
                    "ThreeOfAKind" => Ok(Self::ThreeOfAKind),
                    "Straight" => Ok(Self::Straight),
                    "Flush" => Ok(Self::Flush),
                    "FullHouse" => Ok(Self::FullHouse),
                    "FourOfAKind" => Ok(Self::FourOfAKind),
                    "StraightFlush" => Ok(Self::StraightFlush),
                    "RoyalFlush" => Ok(Self::RoyalFlush),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl LocalizedStaticText for TowerKindText {
            fn localized_text(&self, locale: &Locale) -> &'static str {
                match locale.language {
                    Language::Korean => self.to_korean(),
                    Language::English => self.to_english(),
                }
            }
        }
        impl TowerKindText {
            pub(super) fn to_korean(self) -> &'static str {
                match self {
                    TowerKindText::Barricade => "바리케이드",
                    TowerKindText::High => "하이카드",
                    TowerKindText::OnePair => "원페어",
                    TowerKindText::TwoPair => "투페어",
                    TowerKindText::ThreeOfAKind => "트리플",
                    TowerKindText::Straight => "스트레이트",
                    TowerKindText::Flush => "플러쉬",
                    TowerKindText::FullHouse => "풀하우스",
                    TowerKindText::FourOfAKind => "포카드",
                    TowerKindText::StraightFlush => "스트레이트 플러쉬",
                    TowerKindText::RoyalFlush => "로열 플러쉬",
                }
            }
            pub(super) fn to_english(self) -> &'static str {
                match self {
                    TowerKindText::Barricade => "Barricade",
                    TowerKindText::High => "High",
                    TowerKindText::OnePair => "One Pair",
                    TowerKindText::TwoPair => "Two Pair",
                    TowerKindText::ThreeOfAKind => "Three of a Kind",
                    TowerKindText::Straight => "Straight",
                    TowerKindText::Flush => "Flush",
                    TowerKindText::FullHouse => "Full House",
                    TowerKindText::FourOfAKind => "Four of a Kind",
                    TowerKindText::StraightFlush => "Straight Flush",
                    TowerKindText::RoyalFlush => "Royal Flush",
                }
            }
        }
    }
    pub mod tower_skill {
        use super::{Language, Locale, LocalizedText, rich_text_helpers::*};
        use crate::*;
        pub enum TowerSkillText {
            NearbyTowerDamageMulTitle,
            NearbyTowerDamageAddTitle,
            NearbyTowerAttackSpeedAddTitle,
            NearbyTowerAttackSpeedMulTitle,
            NearbyTowerAttackRangeAddTitle,
            NearbyMonsterSpeedMulTitle,
            MoneyIncomeAddTitle,
            TopCardBonusTitle,
            NearbyTowerDamageMulDesc { mul: f32, range_radius: usize },
            NearbyTowerDamageAddDesc { add: f32, range_radius: usize },
            NearbyTowerAttackSpeedAddDesc { add: f32, range_radius: usize },
            NearbyTowerAttackSpeedMulDesc { mul: f32, range_radius: usize },
            NearbyTowerAttackRangeAddDesc { add: f32, range_radius: usize },
            NearbyMonsterSpeedMulDesc { mul: f32, range_radius: usize },
            MoneyIncomeAddDesc { add: u32 },
            TopCardBonusDesc { rank: String, bonus_damage: usize },
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TowerSkillText {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TowerSkillText::NearbyTowerDamageMulTitle => {
                        ::core::fmt::Formatter::write_str(f, "NearbyTowerDamageMulTitle")
                    }
                    TowerSkillText::NearbyTowerDamageAddTitle => {
                        ::core::fmt::Formatter::write_str(f, "NearbyTowerDamageAddTitle")
                    }
                    TowerSkillText::NearbyTowerAttackSpeedAddTitle => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "NearbyTowerAttackSpeedAddTitle",
                        )
                    }
                    TowerSkillText::NearbyTowerAttackSpeedMulTitle => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "NearbyTowerAttackSpeedMulTitle",
                        )
                    }
                    TowerSkillText::NearbyTowerAttackRangeAddTitle => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "NearbyTowerAttackRangeAddTitle",
                        )
                    }
                    TowerSkillText::NearbyMonsterSpeedMulTitle => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "NearbyMonsterSpeedMulTitle",
                        )
                    }
                    TowerSkillText::MoneyIncomeAddTitle => {
                        ::core::fmt::Formatter::write_str(f, "MoneyIncomeAddTitle")
                    }
                    TowerSkillText::TopCardBonusTitle => {
                        ::core::fmt::Formatter::write_str(f, "TopCardBonusTitle")
                    }
                    TowerSkillText::NearbyTowerDamageMulDesc {
                        mul: __self_0,
                        range_radius: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "NearbyTowerDamageMulDesc",
                            "mul",
                            __self_0,
                            "range_radius",
                            &__self_1,
                        )
                    }
                    TowerSkillText::NearbyTowerDamageAddDesc {
                        add: __self_0,
                        range_radius: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "NearbyTowerDamageAddDesc",
                            "add",
                            __self_0,
                            "range_radius",
                            &__self_1,
                        )
                    }
                    TowerSkillText::NearbyTowerAttackSpeedAddDesc {
                        add: __self_0,
                        range_radius: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "NearbyTowerAttackSpeedAddDesc",
                            "add",
                            __self_0,
                            "range_radius",
                            &__self_1,
                        )
                    }
                    TowerSkillText::NearbyTowerAttackSpeedMulDesc {
                        mul: __self_0,
                        range_radius: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "NearbyTowerAttackSpeedMulDesc",
                            "mul",
                            __self_0,
                            "range_radius",
                            &__self_1,
                        )
                    }
                    TowerSkillText::NearbyTowerAttackRangeAddDesc {
                        add: __self_0,
                        range_radius: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "NearbyTowerAttackRangeAddDesc",
                            "add",
                            __self_0,
                            "range_radius",
                            &__self_1,
                        )
                    }
                    TowerSkillText::NearbyMonsterSpeedMulDesc {
                        mul: __self_0,
                        range_radius: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "NearbyMonsterSpeedMulDesc",
                            "mul",
                            __self_0,
                            "range_radius",
                            &__self_1,
                        )
                    }
                    TowerSkillText::MoneyIncomeAddDesc { add: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "MoneyIncomeAddDesc",
                            "add",
                            &__self_0,
                        )
                    }
                    TowerSkillText::TopCardBonusDesc {
                        rank: __self_0,
                        bonus_damage: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "TopCardBonusDesc",
                            "rank",
                            __self_0,
                            "bonus_damage",
                            &__self_1,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TowerSkillText {
            #[inline]
            fn clone(&self) -> TowerSkillText {
                match self {
                    TowerSkillText::NearbyTowerDamageMulTitle => {
                        TowerSkillText::NearbyTowerDamageMulTitle
                    }
                    TowerSkillText::NearbyTowerDamageAddTitle => {
                        TowerSkillText::NearbyTowerDamageAddTitle
                    }
                    TowerSkillText::NearbyTowerAttackSpeedAddTitle => {
                        TowerSkillText::NearbyTowerAttackSpeedAddTitle
                    }
                    TowerSkillText::NearbyTowerAttackSpeedMulTitle => {
                        TowerSkillText::NearbyTowerAttackSpeedMulTitle
                    }
                    TowerSkillText::NearbyTowerAttackRangeAddTitle => {
                        TowerSkillText::NearbyTowerAttackRangeAddTitle
                    }
                    TowerSkillText::NearbyMonsterSpeedMulTitle => {
                        TowerSkillText::NearbyMonsterSpeedMulTitle
                    }
                    TowerSkillText::MoneyIncomeAddTitle => {
                        TowerSkillText::MoneyIncomeAddTitle
                    }
                    TowerSkillText::TopCardBonusTitle => {
                        TowerSkillText::TopCardBonusTitle
                    }
                    TowerSkillText::NearbyTowerDamageMulDesc {
                        mul: __self_0,
                        range_radius: __self_1,
                    } => {
                        TowerSkillText::NearbyTowerDamageMulDesc {
                            mul: ::core::clone::Clone::clone(__self_0),
                            range_radius: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    TowerSkillText::NearbyTowerDamageAddDesc {
                        add: __self_0,
                        range_radius: __self_1,
                    } => {
                        TowerSkillText::NearbyTowerDamageAddDesc {
                            add: ::core::clone::Clone::clone(__self_0),
                            range_radius: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    TowerSkillText::NearbyTowerAttackSpeedAddDesc {
                        add: __self_0,
                        range_radius: __self_1,
                    } => {
                        TowerSkillText::NearbyTowerAttackSpeedAddDesc {
                            add: ::core::clone::Clone::clone(__self_0),
                            range_radius: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    TowerSkillText::NearbyTowerAttackSpeedMulDesc {
                        mul: __self_0,
                        range_radius: __self_1,
                    } => {
                        TowerSkillText::NearbyTowerAttackSpeedMulDesc {
                            mul: ::core::clone::Clone::clone(__self_0),
                            range_radius: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    TowerSkillText::NearbyTowerAttackRangeAddDesc {
                        add: __self_0,
                        range_radius: __self_1,
                    } => {
                        TowerSkillText::NearbyTowerAttackRangeAddDesc {
                            add: ::core::clone::Clone::clone(__self_0),
                            range_radius: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    TowerSkillText::NearbyMonsterSpeedMulDesc {
                        mul: __self_0,
                        range_radius: __self_1,
                    } => {
                        TowerSkillText::NearbyMonsterSpeedMulDesc {
                            mul: ::core::clone::Clone::clone(__self_0),
                            range_radius: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                    TowerSkillText::MoneyIncomeAddDesc { add: __self_0 } => {
                        TowerSkillText::MoneyIncomeAddDesc {
                            add: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    TowerSkillText::TopCardBonusDesc {
                        rank: __self_0,
                        bonus_damage: __self_1,
                    } => {
                        TowerSkillText::TopCardBonusDesc {
                            rank: ::core::clone::Clone::clone(__self_0),
                            bonus_damage: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                }
            }
        }
        impl bincode::Encode for TowerSkillText {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::NearbyTowerDamageMulTitle => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::NearbyTowerDamageAddTitle => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::NearbyTowerAttackSpeedAddTitle => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::NearbyTowerAttackSpeedMulTitle => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                    Self::NearbyTowerAttackRangeAddTitle => {
                        bincode::Encode::encode(&4u32, encoder)?;
                    }
                    Self::NearbyMonsterSpeedMulTitle => {
                        bincode::Encode::encode(&5u32, encoder)?;
                    }
                    Self::MoneyIncomeAddTitle => {
                        bincode::Encode::encode(&6u32, encoder)?;
                    }
                    Self::TopCardBonusTitle => {
                        bincode::Encode::encode(&7u32, encoder)?;
                    }
                    Self::NearbyTowerDamageMulDesc { mul, range_radius } => {
                        bincode::Encode::encode(&8u32, encoder)?;
                        bincode::Encode::encode(mul, encoder)?;
                        bincode::Encode::encode(range_radius, encoder)?;
                    }
                    Self::NearbyTowerDamageAddDesc { add, range_radius } => {
                        bincode::Encode::encode(&9u32, encoder)?;
                        bincode::Encode::encode(add, encoder)?;
                        bincode::Encode::encode(range_radius, encoder)?;
                    }
                    Self::NearbyTowerAttackSpeedAddDesc { add, range_radius } => {
                        bincode::Encode::encode(&10u32, encoder)?;
                        bincode::Encode::encode(add, encoder)?;
                        bincode::Encode::encode(range_radius, encoder)?;
                    }
                    Self::NearbyTowerAttackSpeedMulDesc { mul, range_radius } => {
                        bincode::Encode::encode(&11u32, encoder)?;
                        bincode::Encode::encode(mul, encoder)?;
                        bincode::Encode::encode(range_radius, encoder)?;
                    }
                    Self::NearbyTowerAttackRangeAddDesc { add, range_radius } => {
                        bincode::Encode::encode(&12u32, encoder)?;
                        bincode::Encode::encode(add, encoder)?;
                        bincode::Encode::encode(range_radius, encoder)?;
                    }
                    Self::NearbyMonsterSpeedMulDesc { mul, range_radius } => {
                        bincode::Encode::encode(&13u32, encoder)?;
                        bincode::Encode::encode(mul, encoder)?;
                        bincode::Encode::encode(range_radius, encoder)?;
                    }
                    Self::MoneyIncomeAddDesc { add } => {
                        bincode::Encode::encode(&14u32, encoder)?;
                        bincode::Encode::encode(add, encoder)?;
                    }
                    Self::TopCardBonusDesc { rank, bonus_damage } => {
                        bincode::Encode::encode(&15u32, encoder)?;
                        bincode::Encode::encode(rank, encoder)?;
                        bincode::Encode::encode(bonus_damage, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for TowerSkillText {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::NearbyTowerDamageMulTitle),
                    1u32 => Ok(Self::NearbyTowerDamageAddTitle),
                    2u32 => Ok(Self::NearbyTowerAttackSpeedAddTitle),
                    3u32 => Ok(Self::NearbyTowerAttackSpeedMulTitle),
                    4u32 => Ok(Self::NearbyTowerAttackRangeAddTitle),
                    5u32 => Ok(Self::NearbyMonsterSpeedMulTitle),
                    6u32 => Ok(Self::MoneyIncomeAddTitle),
                    7u32 => Ok(Self::TopCardBonusTitle),
                    8u32 => {
                        Ok(Self::NearbyTowerDamageMulDesc {
                            mul: bincode::Decode::decode(decoder)?,
                            range_radius: bincode::Decode::decode(decoder)?,
                        })
                    }
                    9u32 => {
                        Ok(Self::NearbyTowerDamageAddDesc {
                            add: bincode::Decode::decode(decoder)?,
                            range_radius: bincode::Decode::decode(decoder)?,
                        })
                    }
                    10u32 => {
                        Ok(Self::NearbyTowerAttackSpeedAddDesc {
                            add: bincode::Decode::decode(decoder)?,
                            range_radius: bincode::Decode::decode(decoder)?,
                        })
                    }
                    11u32 => {
                        Ok(Self::NearbyTowerAttackSpeedMulDesc {
                            mul: bincode::Decode::decode(decoder)?,
                            range_radius: bincode::Decode::decode(decoder)?,
                        })
                    }
                    12u32 => {
                        Ok(Self::NearbyTowerAttackRangeAddDesc {
                            add: bincode::Decode::decode(decoder)?,
                            range_radius: bincode::Decode::decode(decoder)?,
                        })
                    }
                    13u32 => {
                        Ok(Self::NearbyMonsterSpeedMulDesc {
                            mul: bincode::Decode::decode(decoder)?,
                            range_radius: bincode::Decode::decode(decoder)?,
                        })
                    }
                    14u32 => {
                        Ok(Self::MoneyIncomeAddDesc {
                            add: bincode::Decode::decode(decoder)?,
                        })
                    }
                    15u32 => {
                        Ok(Self::TopCardBonusDesc {
                            rank: bincode::Decode::decode(decoder)?,
                            bonus_damage: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 15u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for TowerSkillText {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::NearbyTowerDamageMulTitle => {
                        buf.write_string("NearbyTowerDamageMulTitle");
                    }
                    Self::NearbyTowerDamageAddTitle => {
                        buf.write_string("NearbyTowerDamageAddTitle");
                    }
                    Self::NearbyTowerAttackSpeedAddTitle => {
                        buf.write_string("NearbyTowerAttackSpeedAddTitle");
                    }
                    Self::NearbyTowerAttackSpeedMulTitle => {
                        buf.write_string("NearbyTowerAttackSpeedMulTitle");
                    }
                    Self::NearbyTowerAttackRangeAddTitle => {
                        buf.write_string("NearbyTowerAttackRangeAddTitle");
                    }
                    Self::NearbyMonsterSpeedMulTitle => {
                        buf.write_string("NearbyMonsterSpeedMulTitle");
                    }
                    Self::MoneyIncomeAddTitle => {
                        buf.write_string("MoneyIncomeAddTitle");
                    }
                    Self::TopCardBonusTitle => {
                        buf.write_string("TopCardBonusTitle");
                    }
                    Self::NearbyTowerDamageMulDesc { mul, range_radius } => {
                        buf.write_string("NearbyTowerDamageMulDesc");
                        buf.write_string("mul");
                        mul.serialize_without_name(buf);
                        buf.write_string("range_radius");
                        range_radius.serialize_without_name(buf);
                    }
                    Self::NearbyTowerDamageAddDesc { add, range_radius } => {
                        buf.write_string("NearbyTowerDamageAddDesc");
                        buf.write_string("add");
                        add.serialize_without_name(buf);
                        buf.write_string("range_radius");
                        range_radius.serialize_without_name(buf);
                    }
                    Self::NearbyTowerAttackSpeedAddDesc { add, range_radius } => {
                        buf.write_string("NearbyTowerAttackSpeedAddDesc");
                        buf.write_string("add");
                        add.serialize_without_name(buf);
                        buf.write_string("range_radius");
                        range_radius.serialize_without_name(buf);
                    }
                    Self::NearbyTowerAttackSpeedMulDesc { mul, range_radius } => {
                        buf.write_string("NearbyTowerAttackSpeedMulDesc");
                        buf.write_string("mul");
                        mul.serialize_without_name(buf);
                        buf.write_string("range_radius");
                        range_radius.serialize_without_name(buf);
                    }
                    Self::NearbyTowerAttackRangeAddDesc { add, range_radius } => {
                        buf.write_string("NearbyTowerAttackRangeAddDesc");
                        buf.write_string("add");
                        add.serialize_without_name(buf);
                        buf.write_string("range_radius");
                        range_radius.serialize_without_name(buf);
                    }
                    Self::NearbyMonsterSpeedMulDesc { mul, range_radius } => {
                        buf.write_string("NearbyMonsterSpeedMulDesc");
                        buf.write_string("mul");
                        mul.serialize_without_name(buf);
                        buf.write_string("range_radius");
                        range_radius.serialize_without_name(buf);
                    }
                    Self::MoneyIncomeAddDesc { add } => {
                        buf.write_string("MoneyIncomeAddDesc");
                        buf.write_string("add");
                        add.serialize_without_name(buf);
                    }
                    Self::TopCardBonusDesc { rank, bonus_damage } => {
                        buf.write_string("TopCardBonusDesc");
                        buf.write_string("rank");
                        rank.serialize_without_name(buf);
                        buf.write_string("bonus_damage");
                        bonus_damage.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for TowerSkillText {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "NearbyTowerDamageMulTitle" => Ok(Self::NearbyTowerDamageMulTitle),
                    "NearbyTowerDamageAddTitle" => Ok(Self::NearbyTowerDamageAddTitle),
                    "NearbyTowerAttackSpeedAddTitle" => {
                        Ok(Self::NearbyTowerAttackSpeedAddTitle)
                    }
                    "NearbyTowerAttackSpeedMulTitle" => {
                        Ok(Self::NearbyTowerAttackSpeedMulTitle)
                    }
                    "NearbyTowerAttackRangeAddTitle" => {
                        Ok(Self::NearbyTowerAttackRangeAddTitle)
                    }
                    "NearbyMonsterSpeedMulTitle" => Ok(Self::NearbyMonsterSpeedMulTitle),
                    "MoneyIncomeAddTitle" => Ok(Self::MoneyIncomeAddTitle),
                    "TopCardBonusTitle" => Ok(Self::TopCardBonusTitle),
                    "NearbyTowerDamageMulDesc" => {
                        let field_name = buf.read_name("mul")?;
                        let mul = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_radius")?;
                        let range_radius = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::NearbyTowerDamageMulDesc {
                            mul,
                            range_radius,
                        })
                    }
                    "NearbyTowerDamageAddDesc" => {
                        let field_name = buf.read_name("add")?;
                        let add = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_radius")?;
                        let range_radius = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::NearbyTowerDamageAddDesc {
                            add,
                            range_radius,
                        })
                    }
                    "NearbyTowerAttackSpeedAddDesc" => {
                        let field_name = buf.read_name("add")?;
                        let add = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_radius")?;
                        let range_radius = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::NearbyTowerAttackSpeedAddDesc {
                            add,
                            range_radius,
                        })
                    }
                    "NearbyTowerAttackSpeedMulDesc" => {
                        let field_name = buf.read_name("mul")?;
                        let mul = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_radius")?;
                        let range_radius = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::NearbyTowerAttackSpeedMulDesc {
                            mul,
                            range_radius,
                        })
                    }
                    "NearbyTowerAttackRangeAddDesc" => {
                        let field_name = buf.read_name("add")?;
                        let add = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_radius")?;
                        let range_radius = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::NearbyTowerAttackRangeAddDesc {
                            add,
                            range_radius,
                        })
                    }
                    "NearbyMonsterSpeedMulDesc" => {
                        let field_name = buf.read_name("mul")?;
                        let mul = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("range_radius")?;
                        let range_radius = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::NearbyMonsterSpeedMulDesc {
                            mul,
                            range_radius,
                        })
                    }
                    "MoneyIncomeAddDesc" => {
                        let field_name = buf.read_name("add")?;
                        let add = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::MoneyIncomeAddDesc { add })
                    }
                    "TopCardBonusDesc" => {
                        let field_name = buf.read_name("rank")?;
                        let rank = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("bonus_damage")?;
                        let bonus_damage = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TopCardBonusDesc {
                            rank,
                            bonus_damage,
                        })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl LocalizedText for TowerSkillText {
            fn localized_text(&self, locale: &Locale) -> String {
                match locale.language {
                    Language::Korean => self.to_korean(),
                    Language::English => self.to_english(),
                }
            }
        }
        impl TowerSkillText {
            pub(super) fn to_korean(&self) -> String {
                match self {
                    TowerSkillText::NearbyTowerDamageMulTitle => {
                        "주변 타워 공격력 증가".to_string()
                    }
                    TowerSkillText::NearbyTowerDamageAddTitle => {
                        "주변 타워 공격력 추가".to_string()
                    }
                    TowerSkillText::NearbyTowerAttackSpeedAddTitle => {
                        "주변 타워 공격 속도 추가".to_string()
                    }
                    TowerSkillText::NearbyTowerAttackSpeedMulTitle => {
                        "주변 타워 공격 속도 증가".to_string()
                    }
                    TowerSkillText::NearbyTowerAttackRangeAddTitle => {
                        "주변 타워 공격 범위 추가".to_string()
                    }
                    TowerSkillText::NearbyMonsterSpeedMulTitle => {
                        "주변 몬스터 속도 감소".to_string()
                    }
                    TowerSkillText::MoneyIncomeAddTitle => {
                        "돈 수입 증가".to_string()
                    }
                    TowerSkillText::TopCardBonusTitle => {
                        "탑 카드 보너스".to_string()
                    }
                    TowerSkillText::NearbyTowerDamageMulDesc { mul, range_radius } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "주변 타워의 {0}를 {1} 증가시킵니다 (반경 {2})",
                                    attack_damage_icon_small("공격력"),
                                    percentage_increase(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", mul * 100.0))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 타일", range_radius),
                                            )
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyTowerDamageAddDesc { add, range_radius } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "주변 타워의 {0}를 {1}만큼 증가시킵니다 (반경 {2})",
                                    attack_damage_icon_small("공격력"),
                                    value_increase(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", add))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 타일", range_radius),
                                            )
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyTowerAttackSpeedAddDesc {
                        add,
                        range_radius,
                    } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "주변 타워의 {0}를 {1} 증가시킵니다 (반경 {2})",
                                    attack_speed_icon_small("공격 속도"),
                                    percentage_increase(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", add * 100.0))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 타일", range_radius),
                                            )
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyTowerAttackSpeedMulDesc {
                        mul,
                        range_radius,
                    } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "주변 타워의 {0}를 {1}배 증가시킵니다 (반경 {2})",
                                    attack_speed_icon_small("공격 속도"),
                                    multiplier_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", mul))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 타일", range_radius),
                                            )
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyTowerAttackRangeAddDesc {
                        add,
                        range_radius,
                    } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "주변 타워의 {0}를 {1} 타일 증가시킵니다 (반경 {2})",
                                    attack_range_icon_small("공격 범위"),
                                    value_increase(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", add))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 타일", range_radius),
                                            )
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyMonsterSpeedMulDesc { mul, range_radius } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "주변 몬스터의 속도를 {0} 감소시킵니다 (반경 {1})",
                                    percentage_decrease(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", mul * 100.0))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 타일", range_radius),
                                            )
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::MoneyIncomeAddDesc { add } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "적 처치시 {0} 골드를 추가로 획득합니다",
                                    gold_icon_small(add),
                                ),
                            )
                        })
                    }
                    TowerSkillText::TopCardBonusDesc { rank, bonus_damage } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "탑 카드 보너스: {0} ({1})",
                                    card_rank(rank),
                                    attack_damage_icon_small(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("+{0}", bonus_damage))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                }
            }
            pub(super) fn to_english(&self) -> String {
                match self {
                    TowerSkillText::NearbyTowerDamageMulTitle => {
                        "Nearby Tower Damage Multiplier".to_string()
                    }
                    TowerSkillText::NearbyTowerDamageAddTitle => {
                        "Nearby Tower Damage Addition".to_string()
                    }
                    TowerSkillText::NearbyTowerAttackSpeedAddTitle => {
                        "Nearby Tower Attack Speed Addition".to_string()
                    }
                    TowerSkillText::NearbyTowerAttackSpeedMulTitle => {
                        "Nearby Tower Attack Speed Multiplier".to_string()
                    }
                    TowerSkillText::NearbyTowerAttackRangeAddTitle => {
                        "Nearby Tower Attack Range Addition".to_string()
                    }
                    TowerSkillText::NearbyMonsterSpeedMulTitle => {
                        "Nearby Monster Speed Multiplier".to_string()
                    }
                    TowerSkillText::MoneyIncomeAddTitle => {
                        "Additional Money Income".to_string()
                    }
                    TowerSkillText::TopCardBonusTitle => "Top Card Bonus".to_string(),
                    TowerSkillText::NearbyTowerDamageMulDesc { mul, range_radius } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Increases nearby towers\' {0} by {1} (within {2} tiles)",
                                    attack_damage_icon_small("damage"),
                                    percentage_increase(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", mul * 100.0))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0}", range_radius))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyTowerDamageAddDesc { add, range_radius } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Increases nearby towers\' {0} by {1} (within {2} tiles)",
                                    attack_damage_icon_small("damage"),
                                    value_increase(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", add))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0}", range_radius))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyTowerAttackSpeedAddDesc {
                        add,
                        range_radius,
                    } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Increases nearby towers\' {0} by {1} (within {2} tiles)",
                                    attack_speed_icon_small("attack speed"),
                                    percentage_increase(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", add * 100.0))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0}", range_radius))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyTowerAttackSpeedMulDesc {
                        mul,
                        range_radius,
                    } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Increases nearby towers\' {0} by {1} (within {2} tiles)",
                                    attack_speed_icon_small("attack speed"),
                                    multiplier_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", mul))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0}", range_radius))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyTowerAttackRangeAddDesc {
                        add,
                        range_radius,
                    } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Increases nearby towers\' {0} by {1} tiles (within {2} tiles)",
                                    attack_range_icon_small("attack range"),
                                    value_increase(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", add))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0}", range_radius))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::NearbyMonsterSpeedMulDesc { mul, range_radius } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Decreases nearby monsters\' speed by {0} (within {1} tiles)",
                                    percentage_decrease(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.0}", mul * 100.0))
                                        }),
                                    ),
                                    range(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0}", range_radius))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    TowerSkillText::MoneyIncomeAddDesc { add } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Gain an additional {0} when defeating enemies",
                                    gold_icon_small(add),
                                ),
                            )
                        })
                    }
                    TowerSkillText::TopCardBonusDesc { rank, bonus_damage } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Top Card Bonus: {0} ({1})",
                                    card_rank(rank),
                                    attack_damage_icon_small(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("+{0}", bonus_damage))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                }
            }
        }
    }
    pub mod ui {
        use super::{Language, Locale, LocalizedStaticText};
        use crate::*;
        pub enum TopBarText {
            Stage,
            Quest,
            Refresh,
            Accepted,
            Use,
            Settings,
            Shop,
            SoldOut,
            UseTower,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TopBarText {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TopBarText::Stage => "Stage",
                        TopBarText::Quest => "Quest",
                        TopBarText::Refresh => "Refresh",
                        TopBarText::Accepted => "Accepted",
                        TopBarText::Use => "Use",
                        TopBarText::Settings => "Settings",
                        TopBarText::Shop => "Shop",
                        TopBarText::SoldOut => "SoldOut",
                        TopBarText::UseTower => "UseTower",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TopBarText {
            #[inline]
            fn clone(&self) -> TopBarText {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TopBarText {}
        impl bincode::Encode for TopBarText {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Stage => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Quest => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::Refresh => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::Accepted => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                    Self::Use => {
                        bincode::Encode::encode(&4u32, encoder)?;
                    }
                    Self::Settings => {
                        bincode::Encode::encode(&5u32, encoder)?;
                    }
                    Self::Shop => {
                        bincode::Encode::encode(&6u32, encoder)?;
                    }
                    Self::SoldOut => {
                        bincode::Encode::encode(&7u32, encoder)?;
                    }
                    Self::UseTower => {
                        bincode::Encode::encode(&8u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for TopBarText {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Stage),
                    1u32 => Ok(Self::Quest),
                    2u32 => Ok(Self::Refresh),
                    3u32 => Ok(Self::Accepted),
                    4u32 => Ok(Self::Use),
                    5u32 => Ok(Self::Settings),
                    6u32 => Ok(Self::Shop),
                    7u32 => Ok(Self::SoldOut),
                    8u32 => Ok(Self::UseTower),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 8u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for TopBarText {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Stage => {
                        buf.write_string("Stage");
                    }
                    Self::Quest => {
                        buf.write_string("Quest");
                    }
                    Self::Refresh => {
                        buf.write_string("Refresh");
                    }
                    Self::Accepted => {
                        buf.write_string("Accepted");
                    }
                    Self::Use => {
                        buf.write_string("Use");
                    }
                    Self::Settings => {
                        buf.write_string("Settings");
                    }
                    Self::Shop => {
                        buf.write_string("Shop");
                    }
                    Self::SoldOut => {
                        buf.write_string("SoldOut");
                    }
                    Self::UseTower => {
                        buf.write_string("UseTower");
                    }
                }
            }
        }
        impl Deserialize for TopBarText {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Stage" => Ok(Self::Stage),
                    "Quest" => Ok(Self::Quest),
                    "Refresh" => Ok(Self::Refresh),
                    "Accepted" => Ok(Self::Accepted),
                    "Use" => Ok(Self::Use),
                    "Settings" => Ok(Self::Settings),
                    "Shop" => Ok(Self::Shop),
                    "SoldOut" => Ok(Self::SoldOut),
                    "UseTower" => Ok(Self::UseTower),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub enum StartConfirmModalText {
            Title,
            Message,
            No,
            Yes,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for StartConfirmModalText {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        StartConfirmModalText::Title => "Title",
                        StartConfirmModalText::Message => "Message",
                        StartConfirmModalText::No => "No",
                        StartConfirmModalText::Yes => "Yes",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StartConfirmModalText {
            #[inline]
            fn clone(&self) -> StartConfirmModalText {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for StartConfirmModalText {}
        impl bincode::Encode for StartConfirmModalText {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Title => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Message => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::No => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::Yes => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for StartConfirmModalText {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Title),
                    1u32 => Ok(Self::Message),
                    2u32 => Ok(Self::No),
                    3u32 => Ok(Self::Yes),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 3u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for StartConfirmModalText {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Title => {
                        buf.write_string("Title");
                    }
                    Self::Message => {
                        buf.write_string("Message");
                    }
                    Self::No => {
                        buf.write_string("No");
                    }
                    Self::Yes => {
                        buf.write_string("Yes");
                    }
                }
            }
        }
        impl Deserialize for StartConfirmModalText {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Title" => Ok(Self::Title),
                    "Message" => Ok(Self::Message),
                    "No" => Ok(Self::No),
                    "Yes" => Ok(Self::Yes),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl LocalizedStaticText for TopBarText {
            fn localized_text(&self, locale: &Locale) -> &'static str {
                match locale.language {
                    Language::Korean => self.to_korean(),
                    Language::English => self.to_english(),
                }
            }
        }
        impl TopBarText {
            pub(super) fn to_korean(self) -> &'static str {
                match self {
                    TopBarText::Stage => "스테이지",
                    TopBarText::Quest => "퀘스트",
                    TopBarText::Refresh => "새로고침",
                    TopBarText::Accepted => "수락됨",
                    TopBarText::Use => "사용",
                    TopBarText::Settings => "설정",
                    TopBarText::Shop => "상점",
                    TopBarText::SoldOut => "품절",
                    TopBarText::UseTower => "타워 사용",
                }
            }
            pub(super) fn to_english(self) -> &'static str {
                match self {
                    TopBarText::Stage => "Stage",
                    TopBarText::Quest => "Quest",
                    TopBarText::Refresh => "Refresh",
                    TopBarText::Accepted => "Accepted",
                    TopBarText::Use => "Use",
                    TopBarText::Settings => "Settings",
                    TopBarText::Shop => "Shop",
                    TopBarText::SoldOut => "Sold Out",
                    TopBarText::UseTower => "Use Tower",
                }
            }
        }
        impl StartConfirmModalText {
            pub(super) fn to_korean(self) -> &'static str {
                match self {
                    StartConfirmModalText::Title => "확인",
                    StartConfirmModalText::Message => {
                        "아직 사용할 수 있는 타워가 남았습니다.\n그래도 정말 시작하시겠습니까?"
                    }
                    StartConfirmModalText::No => "아니오",
                    StartConfirmModalText::Yes => "예",
                }
            }
            pub(super) fn to_english(self) -> &'static str {
                match self {
                    StartConfirmModalText::Title => "Confirm",
                    StartConfirmModalText::Message => {
                        "You still have towers available.\nAre you sure you want to start?"
                    }
                    StartConfirmModalText::No => "No",
                    StartConfirmModalText::Yes => "Yes",
                }
            }
        }
    }
    pub mod upgrade {
        mod upgrade_kind {
            mod english {
                use crate::l10n::{rich_text_helpers::*, upgrade::UpgradeKindText};
                impl UpgradeKindText<'_> {
                    pub fn to_english(&self) -> String {
                        match self {
                            UpgradeKindText::Name(upgrade_kind) => {
                                match upgrade_kind {
                                    crate::game_state::upgrade::UpgradeKind::GoldEarnPlus => {
                                        "Gold Income Increase".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackDamagePlus {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Card Attack Damage Increase", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackDamageMultiply {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Card Attack Damage Multiplier", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackSpeedPlus {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Card Attack Speed Increase", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackSpeedMultiply {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Card Attack Speed Multiplier", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackRangePlus {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Card Attack Range Increase", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackDamagePlus {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} Card Attack Damage Increase",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackDamageMultiply {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} Card Attack Damage Multiplier",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackSpeedPlus {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} Card Attack Speed Increase",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackSpeedMultiply {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} Card Attack Speed Multiplier",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackRangePlus {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} Card Attack Range Increase",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackDamagePlus {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Attack Damage Increase", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackDamageMultiply {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Attack Damage Multiplier", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackSpeedPlus {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Attack Speed Increase", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackSpeedMultiply {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Attack Speed Multiplier", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackRangePlus {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} Attack Range Increase", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopSlotExpansion => {
                                        "Shop Slot Expansion".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestSlotExpansion => {
                                        "Quest Slot Expansion".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestBoardExpansion => {
                                        "Quest Board Expansion".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollCountPlus => {
                                        "Reroll Count Increase".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerDamagePlus {
                                        ..
                                    } => "Low Card Tower Attack Damage Increase".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerDamageMultiply {
                                        ..
                                    } => "Low Card Tower Attack Damage Multiplier".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackSpeedPlus {
                                        ..
                                    } => "Low Card Tower Attack Speed Increase".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackSpeedMultiply {
                                        ..
                                    } => "Low Card Tower Attack Speed Multiplier".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackRangePlus {
                                        ..
                                    } => "Low Card Tower Attack Range Increase".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::ShopItemPriceMinus => {
                                        "Shop Item Price Discount".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopRefreshPlus => {
                                        "Shop Refresh Count Increase".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestBoardRefreshPlus => {
                                        "Quest Board Refresh Count Increase".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackDamagePlus {
                                        ..
                                    } => "No Reroll Tower Attack Damage Increase".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackDamageMultiply {
                                        ..
                                    } => "No Reroll Tower Attack Damage Multiplier".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackSpeedPlus {
                                        ..
                                    } => "No Reroll Tower Attack Speed Increase".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackSpeedMultiply {
                                        ..
                                    } => "No Reroll Tower Attack Speed Multiplier".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackRangePlus {
                                        ..
                                    } => "No Reroll Tower Attack Range Increase".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackDamagePlus {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "Even Card Attack Damage Increase"
                                        } else {
                                            "Odd Card Attack Damage Increase"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackDamageMultiply {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "Even Card Attack Damage Multiplier"
                                        } else {
                                            "Odd Card Attack Damage Multiplier"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackSpeedPlus {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "Even Card Attack Speed Increase"
                                        } else {
                                            "Odd Card Attack Speed Increase"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackSpeedMultiply {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "Even Card Attack Speed Multiplier"
                                        } else {
                                            "Odd Card Attack Speed Multiplier"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackRangePlus {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "Even Card Attack Range Increase"
                                        } else {
                                            "Odd Card Attack Range Increase"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "Face Card Attack Damage Increase"
                                        } else {
                                            "Number Card Attack Damage Increase"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "Face Card Attack Damage Multiplier"
                                        } else {
                                            "Number Card Attack Damage Multiplier"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "Face Card Attack Speed Increase"
                                        } else {
                                            "Number Card Attack Speed Increase"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "Face Card Attack Speed Multiplier"
                                        } else {
                                            "Number Card Attack Speed Multiplier"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "Face Card Attack Range Increase"
                                        } else {
                                            "Number Card Attack Range Increase"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShortenStraightFlushTo4Cards => {
                                        "Shorten Straight Flush to 4 Cards".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SkipRankForStraight => {
                                        "Skip Rank for Straight".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::TreatSuitsAsSame => {
                                        "Treat All Suits as Same".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackDamagePlus {
                                        ..
                                    } => "Reroll Tower Attack Damage Increase".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackDamageMultiply {
                                        ..
                                    } => "Reroll Tower Attack Damage Multiplier".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackSpeedPlus {
                                        ..
                                    } => "Reroll Tower Attack Speed Increase".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackSpeedMultiply {
                                        ..
                                    } => "Reroll Tower Attack Speed Multiplier".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackRangePlus {
                                        ..
                                    } => "Reroll Tower Attack Range Increase".to_string(),
                                }
                            }
                            UpgradeKindText::Description(upgrade_kind) => {
                                match upgrade_kind {
                                    crate::game_state::upgrade::UpgradeKind::GoldEarnPlus => {
                                        "Increases gold earned when defeating monsters.".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackDamagePlus {
                                        rank,
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackDamageMultiply {
                                        rank,
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackSpeedPlus {
                                        rank,
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackSpeedMultiply {
                                        rank,
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackRangePlus {
                                        rank,
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_range_stat("Attack Range"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackDamagePlus {
                                        suit,
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackDamageMultiply {
                                        suit,
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackSpeedPlus {
                                        suit,
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackSpeedMultiply {
                                        suit,
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackRangePlus {
                                        suit,
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_range_stat("Attack Range"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackDamagePlus {
                                        tower_kind,
                                        damage_plus,
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for {2} towers.",
                                                    attack_damage_stat("Attack Damage"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackDamageMultiply {
                                        tower_kind,
                                        damage_multiplier,
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for {2} towers.",
                                                    attack_damage_stat("Attack Damage"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackSpeedPlus {
                                        tower_kind,
                                        speed_plus,
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for {2} towers.",
                                                    attack_speed_stat("Attack Speed"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackSpeedMultiply {
                                        tower_kind,
                                        speed_multiplier,
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for {2} towers.",
                                                    attack_speed_stat("Attack Speed"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackRangePlus {
                                        tower_kind,
                                        range_plus,
                                    } => {
                                        let tower_name = Self::get_english_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for {2} towers.",
                                                    attack_range_stat("Attack Range"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopSlotExpansion => {
                                        "Adds 1 slot available for purchase in the shop."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestSlotExpansion => {
                                        "Adds 1 quest inventory slot.".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestBoardExpansion => {
                                        "Adds 1 quest displayed on the quest board.".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollCountPlus => {
                                        "Increases the number of rerolls available each round by 1."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerDamagePlus {
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with 3 or fewer cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerDamageMultiply {
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with 3 or fewer cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackSpeedPlus {
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with 3 or fewer cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackSpeedMultiply {
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with 3 or fewer cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackRangePlus {
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with 3 or fewer cards.",
                                                    attack_range_stat("Attack Range"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopItemPriceMinus => {
                                        "Shop item prices are discounted.".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopRefreshPlus => {
                                        "Shop refresh count increases by 1.".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestBoardRefreshPlus => {
                                        "Quest board refresh count increases by 1.".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackDamagePlus {
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made without rerolling.",
                                                    attack_damage_stat("Attack Damage"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackDamageMultiply {
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made without rerolling.",
                                                    attack_damage_stat("Attack Damage"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackSpeedPlus {
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made without rerolling.",
                                                    attack_speed_stat("Attack Speed"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackSpeedMultiply {
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made without rerolling.",
                                                    attack_speed_stat("Attack Speed"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackRangePlus {
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made without rerolling.",
                                                    attack_range_stat("Attack Range"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackDamagePlus {
                                        even,
                                        damage_plus,
                                    } => {
                                        let card_type = if *even { "even" } else { "odd" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackDamageMultiply {
                                        even,
                                        damage_multiplier,
                                    } => {
                                        let card_type = if *even { "even" } else { "odd" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackSpeedPlus {
                                        even,
                                        speed_plus,
                                    } => {
                                        let card_type = if *even { "even" } else { "odd" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackSpeedMultiply {
                                        even,
                                        speed_multiplier,
                                    } => {
                                        let card_type = if *even { "even" } else { "odd" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackRangePlus {
                                        even,
                                        range_plus,
                                    } => {
                                        let card_type = if *even { "even" } else { "odd" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_range_stat("Attack Range"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                                        face,
                                        damage_plus,
                                    } => {
                                        let card_type = if *face { "face" } else { "number" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                                        face,
                                        damage_multiplier,
                                    } => {
                                        let card_type = if *face { "face" } else { "number" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_damage_stat("Attack Damage"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                                        face,
                                        speed_plus,
                                    } => {
                                        let card_type = if *face { "face" } else { "number" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                                        face,
                                        speed_multiplier,
                                    } => {
                                        let card_type = if *face { "face" } else { "number" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_speed_stat("Attack Speed"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                                        face,
                                        range_plus,
                                    } => {
                                        let card_type = if *face { "face" } else { "number" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made with {2} cards.",
                                                    attack_range_stat("Attack Range"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShortenStraightFlushTo4Cards => {
                                        "Allows making straight flush with 4 cards.".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SkipRankForStraight => {
                                        "Allows skipping one rank when making a straight."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::TreatSuitsAsSame => {
                                        "Treats all suits as the same.".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackDamagePlus {
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made after rerolling.",
                                                    attack_damage_stat("Attack Damage"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackDamageMultiply {
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made after rerolling.",
                                                    attack_damage_stat("Attack Damage"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackSpeedPlus {
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made after rerolling.",
                                                    attack_speed_stat("Attack Speed"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackSpeedMultiply {
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made after rerolling.",
                                                    attack_speed_stat("Attack Speed"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackRangePlus {
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} increases by {1} for towers made after rerolling.",
                                                    attack_range_stat("Attack Range"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                }
                            }
                        }
                    }
                    fn get_english_tower_name(
                        tower_kind: &crate::game_state::tower::TowerKind,
                    ) -> &'static str {
                        match tower_kind {
                            crate::game_state::tower::TowerKind::Barricade => "Barricade",
                            crate::game_state::tower::TowerKind::High => "High Card",
                            crate::game_state::tower::TowerKind::OnePair => "One Pair",
                            crate::game_state::tower::TowerKind::TwoPair => "Two Pair",
                            crate::game_state::tower::TowerKind::ThreeOfAKind => {
                                "Three of a Kind"
                            }
                            crate::game_state::tower::TowerKind::Straight => "Straight",
                            crate::game_state::tower::TowerKind::Flush => "Flush",
                            crate::game_state::tower::TowerKind::FullHouse => {
                                "Full House"
                            }
                            crate::game_state::tower::TowerKind::FourOfAKind => {
                                "Four of a Kind"
                            }
                            crate::game_state::tower::TowerKind::StraightFlush => {
                                "Straight Flush"
                            }
                            crate::game_state::tower::TowerKind::RoyalFlush => {
                                "Royal Flush"
                            }
                        }
                    }
                }
            }
            mod korean {
                use crate::l10n::{rich_text_helpers::*, upgrade::UpgradeKindText};
                impl UpgradeKindText<'_> {
                    pub fn to_korean(&self) -> String {
                        match self {
                            UpgradeKindText::Name(upgrade_kind) => {
                                match upgrade_kind {
                                    crate::game_state::upgrade::UpgradeKind::GoldEarnPlus => {
                                        "골드 수입 증가".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackDamagePlus {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 카드 공격력 증가", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackDamageMultiply {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 카드 공격력 배수 증가", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackSpeedPlus {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 카드 공격 속도 증가", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackSpeedMultiply {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 카드 공격 속도 배수 증가", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackRangePlus {
                                        rank,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 카드 사거리 증가", rank),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackDamagePlus {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드 공격력 증가",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackDamageMultiply {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드 공격력 배수 증가",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackSpeedPlus {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드 공격 속도 증가",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackSpeedMultiply {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드 공격 속도 배수 증가",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackRangePlus {
                                        suit,
                                        ..
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드 사거리 증가",
                                                    suit_icon(*suit),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackDamagePlus {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 공격력 증가", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackDamageMultiply {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 공격력 배수 증가", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackSpeedPlus {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 공격 속도 증가", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackSpeedMultiply {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 공격 속도 배수 증가", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackRangePlus {
                                        tower_kind,
                                        ..
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0} 사거리 증가", tower_name),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopSlotExpansion => {
                                        "상점 슬롯 확장".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestSlotExpansion => {
                                        "퀘스트 슬롯 확장".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestBoardExpansion => {
                                        "퀘스트 보드 확장".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollCountPlus => {
                                        "리롤 횟수 증가".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerDamagePlus {
                                        ..
                                    } => "로우카드 타워 공격력 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerDamageMultiply {
                                        ..
                                    } => {
                                        "로우카드 타워 공격력 배수 증가".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackSpeedPlus {
                                        ..
                                    } => "로우카드 타워 공격 속도 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackSpeedMultiply {
                                        ..
                                    } => {
                                        "로우카드 타워 공격 속도 배수 증가"
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackRangePlus {
                                        ..
                                    } => "로우카드 타워 사거리 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::ShopItemPriceMinus => {
                                        "상점 아이템 가격 할인".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopRefreshPlus => {
                                        "상점 새로고침 횟수 증가".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestBoardRefreshPlus => {
                                        "퀘스트 보드 새로고침 횟수 증가".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackDamagePlus {
                                        ..
                                    } => "무리롤 타워 공격력 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackDamageMultiply {
                                        ..
                                    } => "무리롤 타워 공격력 배수 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackSpeedPlus {
                                        ..
                                    } => "무리롤 타워 공격 속도 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackSpeedMultiply {
                                        ..
                                    } => {
                                        "무리롤 타워 공격 속도 배수 증가".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackRangePlus {
                                        ..
                                    } => "무리롤 타워 사거리 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackDamagePlus {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "짝수 카드 공격력 증가"
                                        } else {
                                            "홀수 카드 공격력 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackDamageMultiply {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "짝수 카드 공격력 배수 증가"
                                        } else {
                                            "홀수 카드 공격력 배수 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackSpeedPlus {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "짝수 카드 공격 속도 증가"
                                        } else {
                                            "홀수 카드 공격 속도 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackSpeedMultiply {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "짝수 카드 공격 속도 배수 증가"
                                        } else {
                                            "홀수 카드 공격 속도 배수 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackRangePlus {
                                        even,
                                        ..
                                    } => {
                                        if *even {
                                            "짝수 카드 사거리 증가"
                                        } else {
                                            "홀수 카드 사거리 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "페이스 카드 공격력 증가"
                                        } else {
                                            "숫자 카드 공격력 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "페이스 카드 공격력 배수 증가"
                                        } else {
                                            "숫자 카드 공격력 배수 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "페이스 카드 공격 속도 증가"
                                        } else {
                                            "숫자 카드 공격 속도 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "페이스 카드 공격 속도 배수 증가"
                                        } else {
                                            "숫자 카드 공격 속도 배수 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                                        face,
                                        ..
                                    } => {
                                        if *face {
                                            "페이스 카드 사거리 증가"
                                        } else {
                                            "숫자 카드 사거리 증가"
                                        }
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShortenStraightFlushTo4Cards => {
                                        "스트레이트 플러시 4장 단축".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SkipRankForStraight => {
                                        "스트레이트 랭크 건너뛰기".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::TreatSuitsAsSame => {
                                        "모든 무늬 동일 취급".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackDamagePlus {
                                        ..
                                    } => "리롤 타워 공격력 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackDamageMultiply {
                                        ..
                                    } => "리롤 타워 공격력 배수 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackSpeedPlus {
                                        ..
                                    } => "리롤 타워 공격 속도 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackSpeedMultiply {
                                        ..
                                    } => "리롤 타워 공격 속도 배수 증가".to_string(),
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackRangePlus {
                                        ..
                                    } => "리롤 타워 사거리 증가".to_string(),
                                }
                            }
                            UpgradeKindText::Description(upgrade_kind) => {
                                match upgrade_kind {
                                    crate::game_state::upgrade::UpgradeKind::GoldEarnPlus => {
                                        "몬스터를 처치할 때 얻는 골드가 증가합니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackDamagePlus {
                                        rank,
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackDamageMultiply {
                                        rank,
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackSpeedPlus {
                                        rank,
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackSpeedMultiply {
                                        rank,
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RankAttackRangePlus {
                                        rank,
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_range_stat("사거리"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                    rank,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackDamagePlus {
                                        suit,
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드로 만든 타워의 {1}이 {2} 증가합니다.",
                                                    suit_icon(*suit),
                                                    attack_damage_stat("공격력"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackDamageMultiply {
                                        suit,
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드로 만든 타워의 {1}이 {2} 증가합니다.",
                                                    suit_icon(*suit),
                                                    attack_damage_stat("공격력"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackSpeedPlus {
                                        suit,
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드로 만든 타워의 {1}가 {2} 증가합니다.",
                                                    suit_icon(*suit),
                                                    attack_speed_stat("공격 속도"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackSpeedMultiply {
                                        suit,
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드로 만든 타워의 {1}가 {2} 증가합니다.",
                                                    suit_icon(*suit),
                                                    attack_speed_stat("공격 속도"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SuitAttackRangePlus {
                                        suit,
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} 카드로 만든 타워의 {1}가 {2} 증가합니다.",
                                                    suit_icon(*suit),
                                                    attack_range_stat("사거리"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackDamagePlus {
                                        tower_kind,
                                        damage_plus,
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackDamageMultiply {
                                        tower_kind,
                                        damage_multiplier,
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackSpeedPlus {
                                        tower_kind,
                                        speed_plus,
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackSpeedMultiply {
                                        tower_kind,
                                        speed_multiplier,
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::HandAttackRangePlus {
                                        tower_kind,
                                        range_plus,
                                    } => {
                                        let tower_name = Self::get_tower_name(tower_kind);
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 타워의 {0}가 {1} 증가합니다.",
                                                    attack_range_stat("사거리"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                    tower_name,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopSlotExpansion => {
                                        "상점에서 구매할 수 있는 슬롯이 1개 추가됩니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestSlotExpansion => {
                                        "퀘스트 인벤토리 슬롯이 1개 추가됩니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestBoardExpansion => {
                                        "퀘스트 보드에 표시되는 퀘스트가 1개 추가됩니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollCountPlus => {
                                        "매 라운드마다 사용할 수 있는 리롤 횟수가 1회 증가합니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerDamagePlus {
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "3장 이하로 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerDamageMultiply {
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "3장 이하로 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackSpeedPlus {
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "3장 이하로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackSpeedMultiply {
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "3장 이하로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::LowCardTowerAttackRangePlus {
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "3장 이하로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_range_stat("사거리"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopItemPriceMinus => {
                                        "상점 아이템의 가격이 할인됩니다.".to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShopRefreshPlus => {
                                        "상점 새로고침 횟수가 1회 증가합니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::QuestBoardRefreshPlus => {
                                        "퀘스트 보드 새로고침 횟수가 1회 증가합니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackDamagePlus {
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하지 않고 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackDamageMultiply {
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하지 않고 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackSpeedPlus {
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하지 않고 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackSpeedMultiply {
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하지 않고 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::NoRerollTowerAttackRangePlus {
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하지 않고 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_range_stat("사거리"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackDamagePlus {
                                        even,
                                        damage_plus,
                                    } => {
                                        let card_type = if *even { "짝수" } else { "홀수" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackDamageMultiply {
                                        even,
                                        damage_multiplier,
                                    } => {
                                        let card_type = if *even { "짝수" } else { "홀수" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackSpeedPlus {
                                        even,
                                        speed_plus,
                                    } => {
                                        let card_type = if *even { "짝수" } else { "홀수" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackSpeedMultiply {
                                        even,
                                        speed_multiplier,
                                    } => {
                                        let card_type = if *even { "짝수" } else { "홀수" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::EvenOddTowerAttackRangePlus {
                                        even,
                                        range_plus,
                                    } => {
                                        let card_type = if *even { "짝수" } else { "홀수" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_range_stat("사거리"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                                        face,
                                        damage_plus,
                                    } => {
                                        let card_type = if *face { "페이스" } else { "숫자" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                                        face,
                                        damage_multiplier,
                                    } => {
                                        let card_type = if *face { "페이스" } else { "숫자" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                                        face,
                                        speed_plus,
                                    } => {
                                        let card_type = if *face { "페이스" } else { "숫자" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                                        face,
                                        speed_multiplier,
                                    } => {
                                        let card_type = if *face { "페이스" } else { "숫자" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                                        face,
                                        range_plus,
                                    } => {
                                        let card_type = if *face { "페이스" } else { "숫자" };
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "{2} 카드로 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_range_stat("사거리"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                    card_type,
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::ShortenStraightFlushTo4Cards => {
                                        "스트레이트 플러시를 4장으로 만들 수 있게 됩니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::SkipRankForStraight => {
                                        "스트레이트에서 한 랭크를 건너뛸 수 있게 됩니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::TreatSuitsAsSame => {
                                        "모든 무늬를 같은 것으로 취급합니다."
                                            .to_string()
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackDamagePlus {
                                        damage_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하고 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", damage_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackDamageMultiply {
                                        damage_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하고 만든 타워의 {0}이 {1} 증가합니다.",
                                                    attack_damage_stat("공격력"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", damage_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackSpeedPlus {
                                        speed_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하고 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", speed_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackSpeedMultiply {
                                        speed_multiplier,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하고 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_speed_stat("공격 속도"),
                                                    multiplier_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(
                                                                format_args!("{0:.1}", speed_multiplier),
                                                            )
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                    crate::game_state::upgrade::UpgradeKind::RerollTowerAttackRangePlus {
                                        range_plus,
                                    } => {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "리롤하고 만든 타워의 {0}가 {1} 증가합니다.",
                                                    attack_range_stat("사거리"),
                                                    additive_value(
                                                        ::alloc::__export::must_use({
                                                            ::alloc::fmt::format(format_args!("{0:.1}", range_plus))
                                                        }),
                                                    ),
                                                ),
                                            )
                                        })
                                    }
                                }
                            }
                        }
                    }
                    fn get_tower_name(
                        tower_kind: &crate::game_state::tower::TowerKind,
                    ) -> &'static str {
                        match tower_kind {
                            crate::game_state::tower::TowerKind::Barricade => {
                                "바리케이드"
                            }
                            crate::game_state::tower::TowerKind::High => "하이카드",
                            crate::game_state::tower::TowerKind::OnePair => "원페어",
                            crate::game_state::tower::TowerKind::TwoPair => "투페어",
                            crate::game_state::tower::TowerKind::ThreeOfAKind => {
                                "트리플"
                            }
                            crate::game_state::tower::TowerKind::Straight => {
                                "스트레이트"
                            }
                            crate::game_state::tower::TowerKind::Flush => "플러쉬",
                            crate::game_state::tower::TowerKind::FullHouse => {
                                "풀하우스"
                            }
                            crate::game_state::tower::TowerKind::FourOfAKind => {
                                "포카드"
                            }
                            crate::game_state::tower::TowerKind::StraightFlush => {
                                "스트레이트 플러쉬"
                            }
                            crate::game_state::tower::TowerKind::RoyalFlush => {
                                "로열 플러쉬"
                            }
                        }
                    }
                }
            }
        }
        use super::{Language, Locale, LocalizedText};
        pub enum UpgradeKindText<'a> {
            Name(&'a crate::game_state::upgrade::UpgradeKind),
            Description(&'a crate::game_state::upgrade::UpgradeKind),
        }
        impl LocalizedText for UpgradeKindText<'_> {
            fn localized_text(&self, locale: &Locale) -> String {
                match locale.language {
                    Language::Korean => self.to_korean(),
                    Language::English => self.to_english(),
                }
            }
        }
    }
    pub mod upgrade_board {
        use super::{Language, Locale, LocalizedText, rich_text_helpers::*};
        use crate::*;
        pub enum UpgradeBoardText {
            Title,
            GoldEarnPlus { amount: usize },
            ShopSlotExpand { amount: usize },
            QuestSlotExpand { amount: usize },
            QuestBoardSlotExpand { amount: usize },
            RerollChancePlus { amount: usize },
            ShopItemPriceMinus { amount: usize },
            ShopRefreshChancePlus { amount: usize },
            QuestBoardRefreshChancePlus { amount: usize },
            ShortenStraightFlushTo4Cards,
            SkipRankForStraight,
            TreatSuitsAsSame,
            TowerSelectLowCard { amount: usize },
            TowerSelectNoReroll,
            TowerSelectReroll,
            TowerUpgradeRank { name: String },
            TowerUpgradeSuit { name: String },
            TowerUpgradeKind { name: String },
            TowerUpgradeEvenOdd { name: String },
            TowerUpgradeFaceNumber { name: String },
            DamagePlus { amount: f32 },
            DamageMultiplier { amount: f32 },
            SpeedPlus { amount: f32 },
            SpeedMultiplier { amount: f32 },
            RangePlus { amount: f32 },
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UpgradeBoardText {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    UpgradeBoardText::Title => {
                        ::core::fmt::Formatter::write_str(f, "Title")
                    }
                    UpgradeBoardText::GoldEarnPlus { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "GoldEarnPlus",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::ShopSlotExpand { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "ShopSlotExpand",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::QuestSlotExpand { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "QuestSlotExpand",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::QuestBoardSlotExpand { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "QuestBoardSlotExpand",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::RerollChancePlus { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RerollChancePlus",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::ShopItemPriceMinus { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "ShopItemPriceMinus",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::ShopRefreshChancePlus { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "ShopRefreshChancePlus",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::QuestBoardRefreshChancePlus {
                        amount: __self_0,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "QuestBoardRefreshChancePlus",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::ShortenStraightFlushTo4Cards => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "ShortenStraightFlushTo4Cards",
                        )
                    }
                    UpgradeBoardText::SkipRankForStraight => {
                        ::core::fmt::Formatter::write_str(f, "SkipRankForStraight")
                    }
                    UpgradeBoardText::TreatSuitsAsSame => {
                        ::core::fmt::Formatter::write_str(f, "TreatSuitsAsSame")
                    }
                    UpgradeBoardText::TowerSelectLowCard { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "TowerSelectLowCard",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::TowerSelectNoReroll => {
                        ::core::fmt::Formatter::write_str(f, "TowerSelectNoReroll")
                    }
                    UpgradeBoardText::TowerSelectReroll => {
                        ::core::fmt::Formatter::write_str(f, "TowerSelectReroll")
                    }
                    UpgradeBoardText::TowerUpgradeRank { name: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "TowerUpgradeRank",
                            "name",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::TowerUpgradeSuit { name: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "TowerUpgradeSuit",
                            "name",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::TowerUpgradeKind { name: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "TowerUpgradeKind",
                            "name",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::TowerUpgradeEvenOdd { name: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "TowerUpgradeEvenOdd",
                            "name",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::TowerUpgradeFaceNumber { name: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "TowerUpgradeFaceNumber",
                            "name",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::DamagePlus { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DamagePlus",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::DamageMultiplier { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "DamageMultiplier",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::SpeedPlus { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "SpeedPlus",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::SpeedMultiplier { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "SpeedMultiplier",
                            "amount",
                            &__self_0,
                        )
                    }
                    UpgradeBoardText::RangePlus { amount: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "RangePlus",
                            "amount",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UpgradeBoardText {
            #[inline]
            fn clone(&self) -> UpgradeBoardText {
                match self {
                    UpgradeBoardText::Title => UpgradeBoardText::Title,
                    UpgradeBoardText::GoldEarnPlus { amount: __self_0 } => {
                        UpgradeBoardText::GoldEarnPlus {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::ShopSlotExpand { amount: __self_0 } => {
                        UpgradeBoardText::ShopSlotExpand {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::QuestSlotExpand { amount: __self_0 } => {
                        UpgradeBoardText::QuestSlotExpand {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::QuestBoardSlotExpand { amount: __self_0 } => {
                        UpgradeBoardText::QuestBoardSlotExpand {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::RerollChancePlus { amount: __self_0 } => {
                        UpgradeBoardText::RerollChancePlus {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::ShopItemPriceMinus { amount: __self_0 } => {
                        UpgradeBoardText::ShopItemPriceMinus {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::ShopRefreshChancePlus { amount: __self_0 } => {
                        UpgradeBoardText::ShopRefreshChancePlus {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::QuestBoardRefreshChancePlus {
                        amount: __self_0,
                    } => {
                        UpgradeBoardText::QuestBoardRefreshChancePlus {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::ShortenStraightFlushTo4Cards => {
                        UpgradeBoardText::ShortenStraightFlushTo4Cards
                    }
                    UpgradeBoardText::SkipRankForStraight => {
                        UpgradeBoardText::SkipRankForStraight
                    }
                    UpgradeBoardText::TreatSuitsAsSame => {
                        UpgradeBoardText::TreatSuitsAsSame
                    }
                    UpgradeBoardText::TowerSelectLowCard { amount: __self_0 } => {
                        UpgradeBoardText::TowerSelectLowCard {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::TowerSelectNoReroll => {
                        UpgradeBoardText::TowerSelectNoReroll
                    }
                    UpgradeBoardText::TowerSelectReroll => {
                        UpgradeBoardText::TowerSelectReroll
                    }
                    UpgradeBoardText::TowerUpgradeRank { name: __self_0 } => {
                        UpgradeBoardText::TowerUpgradeRank {
                            name: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::TowerUpgradeSuit { name: __self_0 } => {
                        UpgradeBoardText::TowerUpgradeSuit {
                            name: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::TowerUpgradeKind { name: __self_0 } => {
                        UpgradeBoardText::TowerUpgradeKind {
                            name: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::TowerUpgradeEvenOdd { name: __self_0 } => {
                        UpgradeBoardText::TowerUpgradeEvenOdd {
                            name: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::TowerUpgradeFaceNumber { name: __self_0 } => {
                        UpgradeBoardText::TowerUpgradeFaceNumber {
                            name: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::DamagePlus { amount: __self_0 } => {
                        UpgradeBoardText::DamagePlus {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::DamageMultiplier { amount: __self_0 } => {
                        UpgradeBoardText::DamageMultiplier {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::SpeedPlus { amount: __self_0 } => {
                        UpgradeBoardText::SpeedPlus {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::SpeedMultiplier { amount: __self_0 } => {
                        UpgradeBoardText::SpeedMultiplier {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    UpgradeBoardText::RangePlus { amount: __self_0 } => {
                        UpgradeBoardText::RangePlus {
                            amount: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                }
            }
        }
        impl bincode::Encode for UpgradeBoardText {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Title => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::GoldEarnPlus { amount } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::ShopSlotExpand { amount } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::QuestSlotExpand { amount } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::QuestBoardSlotExpand { amount } => {
                        bincode::Encode::encode(&4u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::RerollChancePlus { amount } => {
                        bincode::Encode::encode(&5u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::ShopItemPriceMinus { amount } => {
                        bincode::Encode::encode(&6u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::ShopRefreshChancePlus { amount } => {
                        bincode::Encode::encode(&7u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::QuestBoardRefreshChancePlus { amount } => {
                        bincode::Encode::encode(&8u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::ShortenStraightFlushTo4Cards => {
                        bincode::Encode::encode(&9u32, encoder)?;
                    }
                    Self::SkipRankForStraight => {
                        bincode::Encode::encode(&10u32, encoder)?;
                    }
                    Self::TreatSuitsAsSame => {
                        bincode::Encode::encode(&11u32, encoder)?;
                    }
                    Self::TowerSelectLowCard { amount } => {
                        bincode::Encode::encode(&12u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::TowerSelectNoReroll => {
                        bincode::Encode::encode(&13u32, encoder)?;
                    }
                    Self::TowerSelectReroll => {
                        bincode::Encode::encode(&14u32, encoder)?;
                    }
                    Self::TowerUpgradeRank { name } => {
                        bincode::Encode::encode(&15u32, encoder)?;
                        bincode::Encode::encode(name, encoder)?;
                    }
                    Self::TowerUpgradeSuit { name } => {
                        bincode::Encode::encode(&16u32, encoder)?;
                        bincode::Encode::encode(name, encoder)?;
                    }
                    Self::TowerUpgradeKind { name } => {
                        bincode::Encode::encode(&17u32, encoder)?;
                        bincode::Encode::encode(name, encoder)?;
                    }
                    Self::TowerUpgradeEvenOdd { name } => {
                        bincode::Encode::encode(&18u32, encoder)?;
                        bincode::Encode::encode(name, encoder)?;
                    }
                    Self::TowerUpgradeFaceNumber { name } => {
                        bincode::Encode::encode(&19u32, encoder)?;
                        bincode::Encode::encode(name, encoder)?;
                    }
                    Self::DamagePlus { amount } => {
                        bincode::Encode::encode(&20u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::DamageMultiplier { amount } => {
                        bincode::Encode::encode(&21u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::SpeedPlus { amount } => {
                        bincode::Encode::encode(&22u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::SpeedMultiplier { amount } => {
                        bincode::Encode::encode(&23u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                    Self::RangePlus { amount } => {
                        bincode::Encode::encode(&24u32, encoder)?;
                        bincode::Encode::encode(amount, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for UpgradeBoardText {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Title),
                    1u32 => {
                        Ok(Self::GoldEarnPlus {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => {
                        Ok(Self::ShopSlotExpand {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    3u32 => {
                        Ok(Self::QuestSlotExpand {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    4u32 => {
                        Ok(Self::QuestBoardSlotExpand {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    5u32 => {
                        Ok(Self::RerollChancePlus {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    6u32 => {
                        Ok(Self::ShopItemPriceMinus {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    7u32 => {
                        Ok(Self::ShopRefreshChancePlus {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    8u32 => {
                        Ok(Self::QuestBoardRefreshChancePlus {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    9u32 => Ok(Self::ShortenStraightFlushTo4Cards),
                    10u32 => Ok(Self::SkipRankForStraight),
                    11u32 => Ok(Self::TreatSuitsAsSame),
                    12u32 => {
                        Ok(Self::TowerSelectLowCard {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    13u32 => Ok(Self::TowerSelectNoReroll),
                    14u32 => Ok(Self::TowerSelectReroll),
                    15u32 => {
                        Ok(Self::TowerUpgradeRank {
                            name: bincode::Decode::decode(decoder)?,
                        })
                    }
                    16u32 => {
                        Ok(Self::TowerUpgradeSuit {
                            name: bincode::Decode::decode(decoder)?,
                        })
                    }
                    17u32 => {
                        Ok(Self::TowerUpgradeKind {
                            name: bincode::Decode::decode(decoder)?,
                        })
                    }
                    18u32 => {
                        Ok(Self::TowerUpgradeEvenOdd {
                            name: bincode::Decode::decode(decoder)?,
                        })
                    }
                    19u32 => {
                        Ok(Self::TowerUpgradeFaceNumber {
                            name: bincode::Decode::decode(decoder)?,
                        })
                    }
                    20u32 => {
                        Ok(Self::DamagePlus {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    21u32 => {
                        Ok(Self::DamageMultiplier {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    22u32 => {
                        Ok(Self::SpeedPlus {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    23u32 => {
                        Ok(Self::SpeedMultiplier {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    24u32 => {
                        Ok(Self::RangePlus {
                            amount: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 24u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for UpgradeBoardText {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Title => {
                        buf.write_string("Title");
                    }
                    Self::GoldEarnPlus { amount } => {
                        buf.write_string("GoldEarnPlus");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::ShopSlotExpand { amount } => {
                        buf.write_string("ShopSlotExpand");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::QuestSlotExpand { amount } => {
                        buf.write_string("QuestSlotExpand");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::QuestBoardSlotExpand { amount } => {
                        buf.write_string("QuestBoardSlotExpand");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::RerollChancePlus { amount } => {
                        buf.write_string("RerollChancePlus");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::ShopItemPriceMinus { amount } => {
                        buf.write_string("ShopItemPriceMinus");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::ShopRefreshChancePlus { amount } => {
                        buf.write_string("ShopRefreshChancePlus");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::QuestBoardRefreshChancePlus { amount } => {
                        buf.write_string("QuestBoardRefreshChancePlus");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::ShortenStraightFlushTo4Cards => {
                        buf.write_string("ShortenStraightFlushTo4Cards");
                    }
                    Self::SkipRankForStraight => {
                        buf.write_string("SkipRankForStraight");
                    }
                    Self::TreatSuitsAsSame => {
                        buf.write_string("TreatSuitsAsSame");
                    }
                    Self::TowerSelectLowCard { amount } => {
                        buf.write_string("TowerSelectLowCard");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::TowerSelectNoReroll => {
                        buf.write_string("TowerSelectNoReroll");
                    }
                    Self::TowerSelectReroll => {
                        buf.write_string("TowerSelectReroll");
                    }
                    Self::TowerUpgradeRank { name } => {
                        buf.write_string("TowerUpgradeRank");
                        buf.write_string("name");
                        name.serialize_without_name(buf);
                    }
                    Self::TowerUpgradeSuit { name } => {
                        buf.write_string("TowerUpgradeSuit");
                        buf.write_string("name");
                        name.serialize_without_name(buf);
                    }
                    Self::TowerUpgradeKind { name } => {
                        buf.write_string("TowerUpgradeKind");
                        buf.write_string("name");
                        name.serialize_without_name(buf);
                    }
                    Self::TowerUpgradeEvenOdd { name } => {
                        buf.write_string("TowerUpgradeEvenOdd");
                        buf.write_string("name");
                        name.serialize_without_name(buf);
                    }
                    Self::TowerUpgradeFaceNumber { name } => {
                        buf.write_string("TowerUpgradeFaceNumber");
                        buf.write_string("name");
                        name.serialize_without_name(buf);
                    }
                    Self::DamagePlus { amount } => {
                        buf.write_string("DamagePlus");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::DamageMultiplier { amount } => {
                        buf.write_string("DamageMultiplier");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::SpeedPlus { amount } => {
                        buf.write_string("SpeedPlus");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::SpeedMultiplier { amount } => {
                        buf.write_string("SpeedMultiplier");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                    Self::RangePlus { amount } => {
                        buf.write_string("RangePlus");
                        buf.write_string("amount");
                        amount.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for UpgradeBoardText {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Title" => Ok(Self::Title),
                    "GoldEarnPlus" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::GoldEarnPlus { amount })
                    }
                    "ShopSlotExpand" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::ShopSlotExpand { amount })
                    }
                    "QuestSlotExpand" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::QuestSlotExpand { amount })
                    }
                    "QuestBoardSlotExpand" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::QuestBoardSlotExpand {
                            amount,
                        })
                    }
                    "RerollChancePlus" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RerollChancePlus { amount })
                    }
                    "ShopItemPriceMinus" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::ShopItemPriceMinus { amount })
                    }
                    "ShopRefreshChancePlus" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::ShopRefreshChancePlus {
                            amount,
                        })
                    }
                    "QuestBoardRefreshChancePlus" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::QuestBoardRefreshChancePlus {
                            amount,
                        })
                    }
                    "ShortenStraightFlushTo4Cards" => {
                        Ok(Self::ShortenStraightFlushTo4Cards)
                    }
                    "SkipRankForStraight" => Ok(Self::SkipRankForStraight),
                    "TreatSuitsAsSame" => Ok(Self::TreatSuitsAsSame),
                    "TowerSelectLowCard" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TowerSelectLowCard { amount })
                    }
                    "TowerSelectNoReroll" => Ok(Self::TowerSelectNoReroll),
                    "TowerSelectReroll" => Ok(Self::TowerSelectReroll),
                    "TowerUpgradeRank" => {
                        let field_name = buf.read_name("name")?;
                        let name = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TowerUpgradeRank { name })
                    }
                    "TowerUpgradeSuit" => {
                        let field_name = buf.read_name("name")?;
                        let name = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TowerUpgradeSuit { name })
                    }
                    "TowerUpgradeKind" => {
                        let field_name = buf.read_name("name")?;
                        let name = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TowerUpgradeKind { name })
                    }
                    "TowerUpgradeEvenOdd" => {
                        let field_name = buf.read_name("name")?;
                        let name = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TowerUpgradeEvenOdd { name })
                    }
                    "TowerUpgradeFaceNumber" => {
                        let field_name = buf.read_name("name")?;
                        let name = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::TowerUpgradeFaceNumber {
                            name,
                        })
                    }
                    "DamagePlus" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DamagePlus { amount })
                    }
                    "DamageMultiplier" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::DamageMultiplier { amount })
                    }
                    "SpeedPlus" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SpeedPlus { amount })
                    }
                    "SpeedMultiplier" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::SpeedMultiplier { amount })
                    }
                    "RangePlus" => {
                        let field_name = buf.read_name("amount")?;
                        let amount = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::RangePlus { amount })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl LocalizedText for UpgradeBoardText {
            fn localized_text(&self, locale: &Locale) -> String {
                match locale.language {
                    Language::Korean => self.to_korean(),
                    Language::English => self.to_english(),
                }
            }
        }
        impl UpgradeBoardText {
            pub(super) fn to_korean(&self) -> String {
                match self {
                    UpgradeBoardText::Title => "강화 정보".to_string(),
                    UpgradeBoardText::GoldEarnPlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "몬스터 처치 시 {0}를 추가로 얻습니다",
                                    gold_icon(amount),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::ShopSlotExpand { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}상점 슬롯이 {1}개 증가합니다",
                                    shop_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::QuestSlotExpand { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}퀘스트 슬롯이 {1}개 증가합니다",
                                    quest_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::QuestBoardSlotExpand { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}퀘스트 게시판 슬롯이 {1}개 증가합니다",
                                    quest_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::RerollChancePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}리롤 기회가 {1}개 증가합니다",
                                    refresh_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::ShopItemPriceMinus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}상점 아이템 가격이 {1} 감소합니다",
                                    shop_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::ShopRefreshChancePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}상점 새로고침 기회가 {1}개 증가합니다",
                                    shop_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::QuestBoardRefreshChancePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}퀘스트 게시판 새로고침 기회가 {1}개 증가합니다",
                                    quest_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::ShortenStraightFlushTo4Cards => {
                        "스트레이트와 플러시를 4장으로 줄입니다"
                            .to_string()
                    }
                    UpgradeBoardText::SkipRankForStraight => {
                        "스트레이트를 만들 때 랭크 하나를 건너뛸 수 있습니다"
                            .to_string()
                    }
                    UpgradeBoardText::TreatSuitsAsSame => {
                        "색이 같으면 같은 문양으로 취급합니다"
                            .to_string()
                    }
                    UpgradeBoardText::TowerSelectLowCard { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "카드 {0}개 이하로 타워를 만들 때 타워의",
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::TowerSelectNoReroll => {
                        "리롤을 하지 않고 타워를 만들 때 타워의"
                            .to_string()
                    }
                    UpgradeBoardText::TowerSelectReroll => {
                        "리롤을 할 때 마다 타워의".to_string()
                    }
                    UpgradeBoardText::TowerUpgradeRank { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("랭크가 {0}인 타워의", name),
                            )
                        })
                    }
                    UpgradeBoardText::TowerUpgradeSuit { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("문양이 {0}인 타워의", name),
                            )
                        })
                    }
                    UpgradeBoardText::TowerUpgradeKind { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0} 타워의", name))
                        })
                    }
                    UpgradeBoardText::TowerUpgradeEvenOdd { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0} 타워의", name))
                        })
                    }
                    UpgradeBoardText::TowerUpgradeFaceNumber { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0} 타워의", name))
                        })
                    }
                    UpgradeBoardText::DamagePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}이 {1} 증가합니다",
                                    attack_damage_stat("공격력"),
                                    additive_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::DamageMultiplier { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}이 {1} 증가합니다",
                                    attack_damage_stat("공격력"),
                                    multiplier_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::SpeedPlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}가 {1} 증가합니다",
                                    attack_speed_stat("공격 속도"),
                                    additive_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::SpeedMultiplier { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}가 {1} 증가합니다",
                                    attack_speed_stat("공격 속도"),
                                    multiplier_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::RangePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}가 {1} 증가합니다",
                                    attack_range_stat("사정거리"),
                                    additive_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                }
            }
            pub(super) fn to_english(&self) -> String {
                match self {
                    UpgradeBoardText::Title => "Upgrade Information".to_string(),
                    UpgradeBoardText::GoldEarnPlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Earn an additional {0} when defeating monsters",
                                    gold_icon(amount),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::ShopSlotExpand { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}Increases shop slots by {1}",
                                    shop_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::QuestSlotExpand { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}Increases quest slots by {1}",
                                    quest_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::QuestBoardSlotExpand { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}Increases quest board slots by {1}",
                                    quest_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::RerollChancePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}Increases reroll chances by {1}",
                                    refresh_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::ShopItemPriceMinus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}Decreases shop item prices by {1}",
                                    shop_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::ShopRefreshChancePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}Increases shop refresh chances by {1}",
                                    shop_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::QuestBoardRefreshChancePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}Increases quest board refresh chances by {1}",
                                    quest_icon(),
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::ShortenStraightFlushTo4Cards => {
                        "Shortens straight and flush to 4 cards".to_string()
                    }
                    UpgradeBoardText::SkipRankForStraight => {
                        "Skip one rank when creating a straight".to_string()
                    }
                    UpgradeBoardText::TreatSuitsAsSame => {
                        "Treats same colors as the same pattern".to_string()
                    }
                    UpgradeBoardText::TowerSelectLowCard { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "When creating a tower with {0} or fewer cards, the tower\'s",
                                    amount,
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::TowerSelectNoReroll => {
                        "When creating a tower without rerolling, the tower's"
                            .to_string()
                    }
                    UpgradeBoardText::TowerSelectReroll => {
                        "Each time you reroll, the tower's".to_string()
                    }
                    UpgradeBoardText::TowerUpgradeRank { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("For towers with rank {0},", name),
                            )
                        })
                    }
                    UpgradeBoardText::TowerUpgradeSuit { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("For towers with suit {0},", name),
                            )
                        })
                    }
                    UpgradeBoardText::TowerUpgradeKind { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("For {0} towers,", name))
                        })
                    }
                    UpgradeBoardText::TowerUpgradeEvenOdd { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("For {0} towers,", name))
                        })
                    }
                    UpgradeBoardText::TowerUpgradeFaceNumber { name } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("For {0} towers,", name))
                        })
                    }
                    UpgradeBoardText::DamagePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} increases by {1}",
                                    attack_damage_stat("Attack Damage"),
                                    additive_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::DamageMultiplier { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} increases by {1}",
                                    attack_damage_stat("Attack Damage"),
                                    multiplier_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::SpeedPlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} increases by {1}",
                                    attack_speed_stat("Attack Speed"),
                                    additive_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::SpeedMultiplier { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} increases by {1}",
                                    attack_speed_stat("Attack Speed"),
                                    multiplier_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                    UpgradeBoardText::RangePlus { amount } => {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0} increases by {1}",
                                    attack_range_stat("Attack Range"),
                                    additive_value(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0:.1}", amount))
                                        }),
                                    ),
                                ),
                            )
                        })
                    }
                }
            }
        }
    }
    pub use locale::{Language, Locale, LocalizedStaticText, LocalizedText};
    pub use api::{ENGLISH_TEXT, KOREAN_TEXT, TextManager};
    pub use api::{LegacyKoKRLocale as KoKRLocale, LegacyLocales as Locales};
    /// 기본 텍스트 매니저 (한국어)
    pub fn text() -> TextManager {
        TextManager::korean()
    }
    /// 한국어 텍스트 매니저
    pub fn korean_text() -> TextManager {
        TextManager::korean()
    }
    /// 영어 텍스트 매니저
    pub fn english_text() -> TextManager {
        TextManager::english()
    }
}
mod rarity {
    use crate::*;
    use namui::Color;
    pub enum Rarity {
        Common,
        Rare,
        Epic,
        Legendary,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Rarity {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Rarity::Common => "Common",
                    Rarity::Rare => "Rare",
                    Rarity::Epic => "Epic",
                    Rarity::Legendary => "Legendary",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Rarity {
        #[inline]
        fn clone(&self) -> Rarity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Rarity {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Rarity {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Rarity {
        #[inline]
        fn eq(&self, other: &Rarity) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Rarity {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    impl bincode::Encode for Rarity {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            match self {
                Self::Common => {
                    bincode::Encode::encode(&0u32, encoder)?;
                }
                Self::Rare => {
                    bincode::Encode::encode(&1u32, encoder)?;
                }
                Self::Epic => {
                    bincode::Encode::encode(&2u32, encoder)?;
                }
                Self::Legendary => {
                    bincode::Encode::encode(&3u32, encoder)?;
                }
            }
            Ok(())
        }
    }
    impl bincode::Decode<()> for Rarity {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            let discriminant: u32 = bincode::Decode::decode(decoder)?;
            match discriminant {
                0u32 => Ok(Self::Common),
                1u32 => Ok(Self::Rare),
                2u32 => Ok(Self::Epic),
                3u32 => Ok(Self::Legendary),
                _ => {
                    Err(bincode::error::DecodeError::UnexpectedVariant {
                        type_name: core::any::type_name::<Self>(),
                        allowed: &bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 3u32,
                        },
                        found: discriminant,
                    })
                }
            }
        }
    }
    impl Serialize for Rarity {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            match self {
                Self::Common => {
                    buf.write_string("Common");
                }
                Self::Rare => {
                    buf.write_string("Rare");
                }
                Self::Epic => {
                    buf.write_string("Epic");
                }
                Self::Legendary => {
                    buf.write_string("Legendary");
                }
            }
        }
    }
    impl Deserialize for Rarity {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let variant_name = buf.read_string();
            match variant_name.as_ref() {
                "Common" => Ok(Self::Common),
                "Rare" => Ok(Self::Rare),
                "Epic" => Ok(Self::Epic),
                "Legendary" => Ok(Self::Legendary),
                _ => {
                    Err(DeserializeError::InvalidEnumVariant {
                        expected: std::any::type_name::<Self>().to_string(),
                        actual: variant_name,
                    })
                }
            }
        }
    }
    impl Rarity {
        pub const fn color(&self) -> Color {
            match self {
                Rarity::Common => palette::COMMON,
                Rarity::Rare => palette::RARE,
                Rarity::Epic => palette::EPIC,
                Rarity::Legendary => palette::LEGENDARY,
            }
        }
    }
}
mod route {
    mod move_on_route {
        use super::*;
        use crate::*;
        use std::sync::Arc;
        pub struct MoveOnRoute {
            route: Arc<Route>,
            route_index: usize,
            /// must be in [0.0, 1.0]
            route_progress: f32,
            map_coord: MapCoordF32,
            velocity: Velocity,
        }
        impl bincode::Encode for MoveOnRoute {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.route, encoder)?;
                bincode::Encode::encode(&self.route_index, encoder)?;
                bincode::Encode::encode(&self.route_progress, encoder)?;
                bincode::Encode::encode(&self.map_coord, encoder)?;
                bincode::Encode::encode(&self.velocity, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for MoveOnRoute {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    route: bincode::Decode::decode(decoder)?,
                    route_index: bincode::Decode::decode(decoder)?,
                    route_progress: bincode::Decode::decode(decoder)?,
                    map_coord: bincode::Decode::decode(decoder)?,
                    velocity: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for MoveOnRoute {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("route");
                self.route.serialize_without_name(buf);
                buf.write_string("route_index");
                self.route_index.serialize_without_name(buf);
                buf.write_string("route_progress");
                self.route_progress.serialize_without_name(buf);
                buf.write_string("map_coord");
                self.map_coord.serialize_without_name(buf);
                buf.write_string("velocity");
                self.velocity.serialize_without_name(buf);
            }
        }
        impl Deserialize for MoveOnRoute {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("route")?;
                let route = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("route_index")?;
                let route_index = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("route_progress")?;
                let route_progress = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("map_coord")?;
                let map_coord = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("velocity")?;
                let velocity = Deserialize::deserialize_without_name(buf)?;
                Ok(Self {
                    route,
                    route_index,
                    route_progress,
                    map_coord,
                    velocity,
                })
            }
        }
        pub type Velocity = Per<f32, Duration>;
        impl MoveOnRoute {
            pub fn new(route: Arc<Route>, velocity: Velocity) -> Self {
                Self {
                    map_coord: route.map_coords[0].map(|x| x as f32),
                    route,
                    route_index: 0,
                    route_progress: 0.0,
                    velocity,
                }
            }
            pub fn is_finished(&self) -> bool {
                self.route_index >= self.route.map_coords.len() - 1
            }
            pub fn xy(&self) -> Xy<f32> {
                self.map_coord
            }
            pub fn velocity(&self) -> Velocity {
                self.velocity
            }
            pub(crate) fn move_by(&mut self, dt: Duration) {
                let mut movable_distance = self.velocity * dt;
                while movable_distance > 0.0 {
                    let Some(next_route_xy) = self
                        .route
                        .map_coords
                        .get(self.route_index + 1)
                        .map(|x| x.map(|x| x as f32)) else {
                        return;
                    };
                    let last_route_xy = self
                        .route
                        .map_coords[self.route_index]
                        .map(|x| x as f32);
                    let left_distance_to_next_route_xy = (next_route_xy - self.map_coord)
                        .length();
                    if movable_distance < left_distance_to_next_route_xy {
                        let distance_between_route_xy = (next_route_xy - last_route_xy)
                            .length();
                        self.route_progress
                            += movable_distance / distance_between_route_xy;
                        self.route_progress = self.route_progress.clamp(0.0, 1.0);
                        self.map_coord = last_route_xy
                            + (next_route_xy - last_route_xy) * self.route_progress;
                        return;
                    }
                    movable_distance -= left_distance_to_next_route_xy;
                    self.route_index += 1;
                    self.route_progress = 0.0;
                    self.map_coord = next_route_xy;
                }
            }
        }
    }
    mod render_route {
        use super::*;
        use crate::game_state::{
            can_place_tower::can_place_tower, flow::GameFlow,
            tower::{Tower, TowerTemplate},
            *,
        };
        use namui::*;
        pub fn render_route_guide(ctx: &RenderCtx, game_state: &GameState) {
            let cursor_coord = ctx
                .track_eq(
                    &game_state.cursor_preview.map_coord.map(|f| f.round() as usize),
                );
            let game_state_route = ctx.track_eq(&game_state.route);
            let towers = ctx.track_eq(&game_state.towers);
            let is_tower_placing = ctx
                .track_eq(
                    &if let GameFlow::PlacingTower { hand } = &game_state.flow {
                        !hand.selected_slot_ids().is_empty()
                    } else {
                        false
                    },
                );
            let route = ctx
                .memo(|| {
                    'placing_tower: {
                        if cursor_coord.x == 0 || cursor_coord.y == 0
                            || !*is_tower_placing
                        {
                            break 'placing_tower;
                        }
                        let cursor_tower_coord = cursor_coord.as_ref().map(|v| v - 1);
                        if !can_place_tower(
                            cursor_tower_coord,
                            Wh::single(2),
                            &TRAVEL_POINTS,
                            &towers.coords(),
                            game_state_route.iter_coords(),
                            MAP_SIZE,
                        ) {
                            break 'placing_tower;
                        }
                        let mut towers = towers.clone_inner();
                        towers
                            .place_tower(
                                Tower::new(
                                    &TowerTemplate::barricade(),
                                    cursor_tower_coord,
                                    game_state.now(),
                                ),
                            );
                        return calculate_routes(
                                &towers.coords(),
                                &TRAVEL_POINTS,
                                MAP_SIZE,
                            )
                            .unwrap();
                    };
                    game_state_route.clone_inner()
                });
            let mut path = Path::new();
            for coord in route.iter_coords() {
                let xy = Xy::new(
                        (coord.x.as_f32() + 0.5) * TILE_PX_SIZE.width.as_f32(),
                        (coord.y.as_f32() + 0.5) * TILE_PX_SIZE.height.as_f32(),
                    )
                    .map(px);
                if path.commands().is_empty() {
                    path = path.move_to(xy.x, xy.y);
                } else {
                    path = path.line_to(xy.x, xy.y);
                }
            }
            let path = path
                .stroke(StrokeOptions {
                    width: Some(TILE_PX_SIZE.width * 0.65),
                    miter_limit: None,
                    precision: None,
                    join: Some(StrokeJoin::Round),
                    cap: Some(StrokeCap::Round),
                });
            let texture_paint = Paint::new(Color::WHITE)
                .set_style(PaintStyle::Fill)
                .set_shader(Shader::Image {
                    src: asset::image::route::ROUTE_1,
                    tile_mode: Xy::single(TileMode::Repeat),
                });
            let border_paint = Paint::new(Color::from_u8(205, 170, 125, 128))
                .set_style(PaintStyle::Stroke)
                .set_stroke_width(12.px());
            ctx.add(namui::path(path.clone(), texture_paint));
            ctx.add(namui::path(path, border_paint));
        }
    }
    mod route_find {
        use namui::*;
        use std::collections::VecDeque;
        /// # Diagonal movement
        ///
        /// Diagonal movement is blocked if both sides are blocked.
        ///
        /// ```text
        /// f: from, t: to, b: blocker, 0: empty
        ///
        /// // blocked
        /// f b
        /// b t
        ///
        /// // not blocked
        /// f 0
        /// b t
        ///
        /// f b
        /// 0 t
        ///
        /// f 0
        /// 0 t
        pub fn find_shortest_route(
            wh: Wh<usize>,
            start_xy: Xy<usize>,
            end_xy: Xy<usize>,
            blockers: &[Xy<usize>],
        ) -> Option<Vec<Xy<usize>>> {
            if end_xy == start_xy {
                return Some(<[_]>::into_vec(::alloc::boxed::box_new([start_xy])));
            }
            if blockers.contains(&start_xy) || blockers.contains(&end_xy) {
                return None;
            }
            let mut map = Map::new(wh, blockers);
            let mut queue = VecDeque::new();
            queue.push_back(start_xy);
            map.set_visit(start_xy, start_xy);
            while let Some(from_xy) = queue.pop_front() {
                for xy in neighbor(from_xy) {
                    if map.cannot_visit(xy, from_xy) {
                        continue;
                    }
                    queue.push_back(xy);
                    map.set_visit(xy, from_xy);
                    if xy == end_xy {
                        return Some(map.gather_route(xy));
                    }
                }
            }
            None
        }
        fn neighbor(last_xy: Xy<usize>) -> impl Iterator<Item = Xy<usize>> {
            DX_DY
                .iter()
                .filter_map(move |(dx, dy)| {
                    let x = last_xy.x as isize + dx;
                    let y = last_xy.y as isize + dy;
                    if x >= 0 && y >= 0 {
                        Some(Xy::new(x as usize, y as usize))
                    } else {
                        None
                    }
                })
        }
        enum Block {
            Empty,
            Blocker,
            Visited { from_xy: Xy<usize> },
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Block {
            #[inline]
            fn clone(&self) -> Block {
                let _: ::core::clone::AssertParamIsClone<Xy<usize>>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Block {}
        #[automatically_derived]
        impl ::core::fmt::Debug for Block {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Block::Empty => ::core::fmt::Formatter::write_str(f, "Empty"),
                    Block::Blocker => ::core::fmt::Formatter::write_str(f, "Blocker"),
                    Block::Visited { from_xy: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Visited",
                            "from_xy",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Block {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Block {
            #[inline]
            fn eq(&self, other: &Block) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            Block::Visited { from_xy: __self_0 },
                            Block::Visited { from_xy: __arg1_0 },
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        impl bincode::Encode for Block {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Empty => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Blocker => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::Visited { from_xy } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(from_xy, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for Block {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Empty),
                    1u32 => Ok(Self::Blocker),
                    2u32 => {
                        Ok(Self::Visited {
                            from_xy: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 2u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for Block {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Empty => {
                        buf.write_string("Empty");
                    }
                    Self::Blocker => {
                        buf.write_string("Blocker");
                    }
                    Self::Visited { from_xy } => {
                        buf.write_string("Visited");
                        buf.write_string("from_xy");
                        from_xy.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for Block {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Empty" => Ok(Self::Empty),
                    "Blocker" => Ok(Self::Blocker),
                    "Visited" => {
                        let field_name = buf.read_name("from_xy")?;
                        let from_xy = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Visited { from_xy })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        struct Map {
            wh: Wh<usize>,
            blocks: Vec<Block>,
        }
        impl Map {
            fn new(wh: Wh<usize>, blockers: &[Xy<usize>]) -> Self {
                let blocks = ::alloc::vec::from_elem(Block::Empty, wh.width * wh.height);
                let mut this = Self { wh, blocks };
                for &blocker in blockers {
                    *this.block_mut(blocker) = Block::Blocker;
                }
                this
            }
            fn block(&self, xy: Xy<usize>) -> Block {
                self.blocks[xy.y * self.wh.width + xy.x]
            }
            fn block_mut(&mut self, xy: Xy<usize>) -> &mut Block {
                &mut self.blocks[xy.y * self.wh.width + xy.x]
            }
            fn set_visit(&mut self, xy: Xy<usize>, from_xy: Xy<usize>) {
                *self.block_mut(xy) = Block::Visited { from_xy };
            }
            fn cannot_visit(&self, xy: Xy<usize>, from_xy: Xy<usize>) -> bool {
                if self.is_outside(xy) {
                    return true;
                }
                match self.block(xy) {
                    Block::Blocker | Block::Visited { .. } => true,
                    Block::Empty => {
                        !is_orthogonal(from_xy, xy)
                            && self.blocked_on_diagonal(from_xy, xy)
                    }
                }
            }
            fn is_outside(&self, xy: Xy<usize>) -> bool {
                xy.x >= self.wh.width || xy.y >= self.wh.height
            }
            fn gather_route(&self, end_xy: Xy<usize>) -> Vec<Xy<usize>> {
                let mut route = <[_]>::into_vec(::alloc::boxed::box_new([end_xy]));
                let mut xy = end_xy;
                loop {
                    match self.block(xy) {
                        Block::Visited { from_xy } => {
                            if xy == from_xy {
                                break;
                            }
                            route.push(from_xy);
                            xy = from_xy;
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
                route.reverse();
                route
            }
            fn blocked_on_diagonal(&self, from_xy: Xy<usize>, xy: Xy<usize>) -> bool {
                let a_xy = Xy::new(from_xy.x, xy.y);
                let b_xy = Xy::new(xy.x, from_xy.y);
                self.block(a_xy) == Block::Blocker && self.block(b_xy) == Block::Blocker
            }
        }
        fn is_orthogonal(from_xy: Xy<usize>, xy: Xy<usize>) -> bool {
            from_xy.x == xy.x || from_xy.y == xy.y
        }
        /// Orthogonal first, then diagonal.
        const DX_DY: [(isize, isize); 8] = [
            (0, -1),
            (-1, 0),
            (1, 0),
            (0, 1),
            (1, 1),
            (-1, -1),
            (1, -1),
            (-1, 1),
        ];
    }
    use crate::*;
    pub use move_on_route::*;
    use namui::State;
    pub use render_route::*;
    pub use route_find::*;
    use std::sync::Arc;
    pub struct Route {
        map_coords: Vec<MapCoord>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Route {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Route",
                "map_coords",
                &&self.map_coords,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Route {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Route {
        #[inline]
        fn eq(&self, other: &Route) -> bool {
            self.map_coords == other.map_coords
        }
    }
    impl bincode::Encode for Route {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            bincode::Encode::encode(&self.map_coords, encoder)?;
            Ok(())
        }
    }
    impl bincode::Decode<()> for Route {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            Ok(Self {
                map_coords: bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl Serialize for Route {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            buf.write_string("map_coords");
            self.map_coords.serialize_without_name(buf);
        }
    }
    impl Deserialize for Route {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let field_name = buf.read_name("map_coords")?;
            let map_coords = Deserialize::deserialize_without_name(buf)?;
            Ok(Self { map_coords })
        }
    }
    impl Route {
        pub fn iter_coords(&self) -> &[MapCoord] {
            &self.map_coords
        }
    }
    pub fn calculate_routes(
        blockers: &[MapCoord],
        travel_points: &[MapCoord],
        map_wh: Wh<usize>,
    ) -> Option<Arc<Route>> {
        let mut map_coords = ::alloc::vec::Vec::new();
        for i in 0..travel_points.len() - 1 {
            let start_xy = travel_points[i];
            let end_xy = travel_points[i + 1];
            let route = crate::route::find_shortest_route(
                map_wh,
                start_xy,
                end_xy,
                blockers,
            )?;
            map_coords.extend_from_slice(if i == 0 { &route } else { &route[1..] });
        }
        Some(Arc::new(Route { map_coords }))
    }
}
mod settings {
    use crate::game_state::set_modal;
    use crate::icon::{Icon, IconKind, IconSize};
    use crate::l10n::ui::TopBarText;
    use crate::theme::button::{Button, ButtonVariant};
    use crate::theme::{palette, typography::{self, headline}};
    use namui::*;
    use namui_prebuilt::{scroll_view::AutoScrollViewWithCtx, simple_rect, table};
    const TITLE_HEIGHT: Px = px(36.);
    const PADDING: Px = px(8.);
    pub struct SettingsModal;
    impl Component for SettingsModal {
        fn render(self, ctx: &RenderCtx) {
            let screen_wh = screen::size().into_type::<Px>();
            let game_state = crate::game_state::use_game_state(ctx);
            let modal_wh = Wh::new(400.px(), 300.px());
            let modal_xy = ((screen_wh - modal_wh) * 0.5).to_xy();
            ctx.compose(|ctx| {
                    let ctx = ctx.translate(modal_xy);
                    ctx.compose(|ctx| {
                        table::vertical([
                            table::fixed(
                                TITLE_HEIGHT,
                                table::horizontal([
                                    table::fixed(PADDING, |_, _| {}),
                                    table::ratio(
                                        1,
                                        |wh, ctx| {
                                            ctx.add(
                                                headline(
                                                        game_state.text().ui(TopBarText::Settings).to_string(),
                                                    )
                                                    .size(typography::FontSize::Medium)
                                                    .align(typography::TextAlign::LeftCenter {
                                                        height: wh.height,
                                                    })
                                                    .build(),
                                            );
                                        },
                                    ),
                                    table::fixed(
                                        64.px(),
                                        |wh, ctx| {
                                            ctx.add(
                                                Button::new(
                                                        wh,
                                                        &|| set_modal(None),
                                                        &|wh, _text_color, ctx| {
                                                            ctx.add(
                                                                Icon::new(IconKind::Reject).size(IconSize::Large).wh(wh),
                                                            );
                                                        },
                                                    )
                                                    .variant(ButtonVariant::Text),
                                            );
                                        },
                                    ),
                                ]),
                            ),
                            table::ratio(
                                1,
                                table::padding(
                                    PADDING,
                                    |wh, ctx| {
                                        ctx.add(AutoScrollViewWithCtx {
                                            wh,
                                            scroll_bar_width: PADDING,
                                            content: |_ctx| {},
                                        });
                                    },
                                ),
                            ),
                        ])(modal_wh, ctx);
                    });
                    ctx.add(
                        rect(RectParam {
                            rect: Wh::new(modal_wh.width, TITLE_HEIGHT).to_rect(),
                            style: RectStyle {
                                stroke: None,
                                fill: Some(RectFill {
                                    color: palette::SURFACE_CONTAINER,
                                }),
                                round: Some(RectRound {
                                    radius: palette::ROUND,
                                }),
                            },
                        }),
                    );
                    ctx.add(
                        rect(RectParam {
                            rect: modal_wh.to_rect(),
                            style: RectStyle {
                                stroke: None,
                                fill: Some(RectFill {
                                    color: palette::SURFACE,
                                }),
                                round: Some(RectRound {
                                    radius: palette::ROUND,
                                }),
                            },
                        }),
                    );
                })
                .attach_event(|event| {
                    match event {
                        Event::MouseDown { event }
                        | Event::MouseMove { event }
                        | Event::MouseUp { event } => {
                            if !event.is_local_xy_in() {
                                return;
                            }
                            event.stop_propagation();
                        }
                        Event::Wheel { event } => {
                            if !event.is_local_xy_in() {
                                return;
                            }
                            event.stop_propagation();
                        }
                        _ => {}
                    };
                });
            ctx.add(
                simple_rect(
                        screen_wh,
                        Color::TRANSPARENT,
                        0.px(),
                        Color::from_u8(0, 0, 0, 128),
                    )
                    .attach_event(|event| {
                        let Event::MouseDown { event } = event else {
                            return;
                        };
                        set_modal(None);
                        event.stop_propagation();
                    }),
            );
        }
    }
}
mod shop {
    mod shop_slot {
        use crate::{
            game_state::{contract::Contract, item::Item, upgrade::Upgrade},
            *,
        };
        pub enum ShopSlot {
            #[default]
            Locked,
            Item { item: Item, cost: usize, purchased: bool },
            Upgrade { upgrade: Upgrade, cost: usize, purchased: bool },
            Contract { contract: Contract, cost: usize, purchased: bool },
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ShopSlot {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ShopSlot::Locked => ::core::fmt::Formatter::write_str(f, "Locked"),
                    ShopSlot::Item {
                        item: __self_0,
                        cost: __self_1,
                        purchased: __self_2,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "Item",
                            "item",
                            __self_0,
                            "cost",
                            __self_1,
                            "purchased",
                            &__self_2,
                        )
                    }
                    ShopSlot::Upgrade {
                        upgrade: __self_0,
                        cost: __self_1,
                        purchased: __self_2,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "Upgrade",
                            "upgrade",
                            __self_0,
                            "cost",
                            __self_1,
                            "purchased",
                            &__self_2,
                        )
                    }
                    ShopSlot::Contract {
                        contract: __self_0,
                        cost: __self_1,
                        purchased: __self_2,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "Contract",
                            "contract",
                            __self_0,
                            "cost",
                            __self_1,
                            "purchased",
                            &__self_2,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ShopSlot {
            #[inline]
            fn default() -> ShopSlot {
                Self::Locked
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ShopSlot {
            #[inline]
            fn clone(&self) -> ShopSlot {
                match self {
                    ShopSlot::Locked => ShopSlot::Locked,
                    ShopSlot::Item {
                        item: __self_0,
                        cost: __self_1,
                        purchased: __self_2,
                    } => {
                        ShopSlot::Item {
                            item: ::core::clone::Clone::clone(__self_0),
                            cost: ::core::clone::Clone::clone(__self_1),
                            purchased: ::core::clone::Clone::clone(__self_2),
                        }
                    }
                    ShopSlot::Upgrade {
                        upgrade: __self_0,
                        cost: __self_1,
                        purchased: __self_2,
                    } => {
                        ShopSlot::Upgrade {
                            upgrade: ::core::clone::Clone::clone(__self_0),
                            cost: ::core::clone::Clone::clone(__self_1),
                            purchased: ::core::clone::Clone::clone(__self_2),
                        }
                    }
                    ShopSlot::Contract {
                        contract: __self_0,
                        cost: __self_1,
                        purchased: __self_2,
                    } => {
                        ShopSlot::Contract {
                            contract: ::core::clone::Clone::clone(__self_0),
                            cost: ::core::clone::Clone::clone(__self_1),
                            purchased: ::core::clone::Clone::clone(__self_2),
                        }
                    }
                }
            }
        }
        impl bincode::Encode for ShopSlot {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Locked => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Item { item, cost, purchased } => {
                        bincode::Encode::encode(&1u32, encoder)?;
                        bincode::Encode::encode(item, encoder)?;
                        bincode::Encode::encode(cost, encoder)?;
                        bincode::Encode::encode(purchased, encoder)?;
                    }
                    Self::Upgrade { upgrade, cost, purchased } => {
                        bincode::Encode::encode(&2u32, encoder)?;
                        bincode::Encode::encode(upgrade, encoder)?;
                        bincode::Encode::encode(cost, encoder)?;
                        bincode::Encode::encode(purchased, encoder)?;
                    }
                    Self::Contract { contract, cost, purchased } => {
                        bincode::Encode::encode(&3u32, encoder)?;
                        bincode::Encode::encode(contract, encoder)?;
                        bincode::Encode::encode(cost, encoder)?;
                        bincode::Encode::encode(purchased, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for ShopSlot {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Locked),
                    1u32 => {
                        Ok(Self::Item {
                            item: bincode::Decode::decode(decoder)?,
                            cost: bincode::Decode::decode(decoder)?,
                            purchased: bincode::Decode::decode(decoder)?,
                        })
                    }
                    2u32 => {
                        Ok(Self::Upgrade {
                            upgrade: bincode::Decode::decode(decoder)?,
                            cost: bincode::Decode::decode(decoder)?,
                            purchased: bincode::Decode::decode(decoder)?,
                        })
                    }
                    3u32 => {
                        Ok(Self::Contract {
                            contract: bincode::Decode::decode(decoder)?,
                            cost: bincode::Decode::decode(decoder)?,
                            purchased: bincode::Decode::decode(decoder)?,
                        })
                    }
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 3u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for ShopSlot {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Locked => {
                        buf.write_string("Locked");
                    }
                    Self::Item { item, cost, purchased } => {
                        buf.write_string("Item");
                        buf.write_string("item");
                        item.serialize_without_name(buf);
                        buf.write_string("cost");
                        cost.serialize_without_name(buf);
                        buf.write_string("purchased");
                        purchased.serialize_without_name(buf);
                    }
                    Self::Upgrade { upgrade, cost, purchased } => {
                        buf.write_string("Upgrade");
                        buf.write_string("upgrade");
                        upgrade.serialize_without_name(buf);
                        buf.write_string("cost");
                        cost.serialize_without_name(buf);
                        buf.write_string("purchased");
                        purchased.serialize_without_name(buf);
                    }
                    Self::Contract { contract, cost, purchased } => {
                        buf.write_string("Contract");
                        buf.write_string("contract");
                        contract.serialize_without_name(buf);
                        buf.write_string("cost");
                        cost.serialize_without_name(buf);
                        buf.write_string("purchased");
                        purchased.serialize_without_name(buf);
                    }
                }
            }
        }
        impl Deserialize for ShopSlot {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Locked" => Ok(Self::Locked),
                    "Item" => {
                        let field_name = buf.read_name("item")?;
                        let item = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("cost")?;
                        let cost = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("purchased")?;
                        let purchased = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Item {
                            item,
                            cost,
                            purchased,
                        })
                    }
                    "Upgrade" => {
                        let field_name = buf.read_name("upgrade")?;
                        let upgrade = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("cost")?;
                        let cost = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("purchased")?;
                        let purchased = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Upgrade {
                            upgrade,
                            cost,
                            purchased,
                        })
                    }
                    "Contract" => {
                        let field_name = buf.read_name("contract")?;
                        let contract = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("cost")?;
                        let cost = Deserialize::deserialize_without_name(buf)?;
                        let field_name = buf.read_name("purchased")?;
                        let purchased = Deserialize::deserialize_without_name(buf)?;
                        Ok(Self::Contract {
                            contract,
                            cost,
                            purchased,
                        })
                    }
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
    }
    use crate::{
        game_state::{
            GameState, contract::generation::generate_contract, flow::GameFlow,
            item::generation::generate_item, upgrade::generate_upgrade,
        },
        rarity::Rarity, *,
    };
    use namui::OneZero;
    use rand::{Rng, thread_rng};
    pub use shop_slot::*;
    pub struct Shop {
        pub slots: [ShopSlot; 4],
        pub left_refresh_chance: usize,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Shop {
        #[inline]
        fn clone(&self) -> Shop {
            Shop {
                slots: ::core::clone::Clone::clone(&self.slots),
                left_refresh_chance: ::core::clone::Clone::clone(
                    &self.left_refresh_chance,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Shop {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Shop",
                "slots",
                &self.slots,
                "left_refresh_chance",
                &&self.left_refresh_chance,
            )
        }
    }
    impl bincode::Encode for Shop {
        fn encode<__E: bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), bincode::error::EncodeError> {
            bincode::Encode::encode(&self.slots, encoder)?;
            bincode::Encode::encode(&self.left_refresh_chance, encoder)?;
            Ok(())
        }
    }
    impl bincode::Decode<()> for Shop {
        fn decode<__D: bincode::de::Decoder<Context = ()>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, bincode::error::DecodeError> {
            Ok(Self {
                slots: bincode::Decode::decode(decoder)?,
                left_refresh_chance: bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl Serialize for Shop {
        fn serialize(&self, buf: &mut Vec<u8>) {
            buf.write_string(std::any::type_name::<Self>());
            self.serialize_without_name(buf);
        }
        fn serialize_without_name(&self, buf: &mut Vec<u8>) {
            buf.write_string("slots");
            self.slots.serialize_without_name(buf);
            buf.write_string("left_refresh_chance");
            self.left_refresh_chance.serialize_without_name(buf);
        }
    }
    impl Deserialize for Shop {
        fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            buf.read_name(std::any::type_name::<Self>())?;
            Self::deserialize_without_name(buf)
        }
        fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
            let field_name = buf.read_name("slots")?;
            let slots = Deserialize::deserialize_without_name(buf)?;
            let field_name = buf.read_name("left_refresh_chance")?;
            let left_refresh_chance = Deserialize::deserialize_without_name(buf)?;
            Ok(Self { slots, left_refresh_chance })
        }
    }
    impl Shop {
        pub fn new(game_state: &GameState) -> Self {
            let items = (0..game_state.max_shop_slot())
                .map(|_| generate_shop_slot(game_state))
                .collect::<Vec<_>>();
            let mut slots = [const { ShopSlot::Locked }; 4];
            for (slot, item) in slots.iter_mut().zip(items.into_iter()) {
                *slot = item;
            }
            Self {
                slots,
                left_refresh_chance: game_state.max_shop_refresh_chance(),
            }
        }
    }
    pub fn refresh_shop(game_state: &mut GameState) {
        let items = (0..game_state.max_shop_slot())
            .map(|_| generate_shop_slot(game_state))
            .collect::<Vec<_>>();
        let GameFlow::SelectingTower(flow) = &mut game_state.flow else {
            ::core::panicking::panic("internal error: entered unreachable code")
        };
        for (slot, item) in flow.shop.slots.iter_mut().zip(items.into_iter()) {
            let purchased = match slot {
                ShopSlot::Item { purchased, .. }
                | ShopSlot::Upgrade { purchased, .. }
                | ShopSlot::Contract { purchased, .. } => *purchased,
                ShopSlot::Locked => false,
            };
            if purchased {
                continue;
            }
            *slot = item;
        }
    }
    fn generate_shop_slot(game_state: &GameState) -> ShopSlot {
        let slot_type = thread_rng().gen_range(0..10);
        let rarity = game_state.generate_rarity(Default::default());
        match slot_type {
            0..=2 => {
                let item = generate_item(rarity);
                let cost = item_cost(
                    rarity,
                    item.value,
                    game_state.upgrade_state.shop_item_price_minus,
                );
                ShopSlot::Item {
                    item,
                    cost,
                    purchased: false,
                }
            }
            3..=7 => {
                let upgrade = generate_upgrade(game_state, rarity);
                let cost = item_cost(
                    rarity,
                    upgrade.value,
                    game_state.upgrade_state.shop_item_price_minus,
                );
                ShopSlot::Upgrade {
                    upgrade,
                    cost,
                    purchased: false,
                }
            }
            8..=9 => {
                let contract = generate_contract(rarity);
                let cost = item_cost(
                    rarity,
                    0.5.into(),
                    game_state.upgrade_state.shop_item_price_minus,
                );
                ShopSlot::Contract {
                    contract,
                    cost,
                    purchased: false,
                }
            }
            _ => ::core::panicking::panic("internal error: entered unreachable code"),
        }
    }
    fn item_cost(rarity: Rarity, value: OneZero, discount: usize) -> usize {
        let base_cost = match rarity {
            crate::rarity::Rarity::Common => 25.0,
            crate::rarity::Rarity::Rare => 50.0,
            crate::rarity::Rarity::Epic => 75.0,
            crate::rarity::Rarity::Legendary => 100.0,
        };
        let additional_cost = value.as_f32() * base_cost * 0.5;
        let cost = base_cost + additional_cost - discount as f32;
        cost.max(0.0) as usize
    }
}
mod theme {
    pub mod button {
        use super::palette;
        use namui::*;
        #[allow(dead_code)]
        pub enum ButtonVariant {
            Text,
            Contained,
            Outlined,
            Fab,
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::fmt::Debug for ButtonVariant {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ButtonVariant::Text => "Text",
                        ButtonVariant::Contained => "Contained",
                        ButtonVariant::Outlined => "Outlined",
                        ButtonVariant::Fab => "Fab",
                    },
                )
            }
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::clone::Clone for ButtonVariant {
            #[inline]
            fn clone(&self) -> ButtonVariant {
                *self
            }
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::marker::Copy for ButtonVariant {}
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::marker::StructuralPartialEq for ButtonVariant {}
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::cmp::PartialEq for ButtonVariant {
            #[inline]
            fn eq(&self, other: &ButtonVariant) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::cmp::Eq for ButtonVariant {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl bincode::Encode for ButtonVariant {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Text => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Contained => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::Outlined => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::Fab => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for ButtonVariant {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Text),
                    1u32 => Ok(Self::Contained),
                    2u32 => Ok(Self::Outlined),
                    3u32 => Ok(Self::Fab),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 3u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for ButtonVariant {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Text => {
                        buf.write_string("Text");
                    }
                    Self::Contained => {
                        buf.write_string("Contained");
                    }
                    Self::Outlined => {
                        buf.write_string("Outlined");
                    }
                    Self::Fab => {
                        buf.write_string("Fab");
                    }
                }
            }
        }
        impl Deserialize for ButtonVariant {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Text" => Ok(Self::Text),
                    "Contained" => Ok(Self::Contained),
                    "Outlined" => Ok(Self::Outlined),
                    "Fab" => Ok(Self::Fab),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        #[allow(dead_code)]
        pub enum ButtonColor {
            Primary,
            Secondary,
            Error,
            Warn,
            Info,
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::fmt::Debug for ButtonColor {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ButtonColor::Primary => "Primary",
                        ButtonColor::Secondary => "Secondary",
                        ButtonColor::Error => "Error",
                        ButtonColor::Warn => "Warn",
                        ButtonColor::Info => "Info",
                    },
                )
            }
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::clone::Clone for ButtonColor {
            #[inline]
            fn clone(&self) -> ButtonColor {
                *self
            }
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::marker::Copy for ButtonColor {}
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::marker::StructuralPartialEq for ButtonColor {}
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::cmp::PartialEq for ButtonColor {
            #[inline]
            fn eq(&self, other: &ButtonColor) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl ::core::cmp::Eq for ButtonColor {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl bincode::Encode for ButtonColor {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Primary => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Secondary => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::Error => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::Warn => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                    Self::Info => {
                        bincode::Encode::encode(&4u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for ButtonColor {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Primary),
                    1u32 => Ok(Self::Secondary),
                    2u32 => Ok(Self::Error),
                    3u32 => Ok(Self::Warn),
                    4u32 => Ok(Self::Info),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 4u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for ButtonColor {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Primary => {
                        buf.write_string("Primary");
                    }
                    Self::Secondary => {
                        buf.write_string("Secondary");
                    }
                    Self::Error => {
                        buf.write_string("Error");
                    }
                    Self::Warn => {
                        buf.write_string("Warn");
                    }
                    Self::Info => {
                        buf.write_string("Info");
                    }
                }
            }
        }
        impl Deserialize for ButtonColor {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Primary" => Ok(Self::Primary),
                    "Secondary" => Ok(Self::Secondary),
                    "Error" => Ok(Self::Error),
                    "Warn" => Ok(Self::Warn),
                    "Info" => Ok(Self::Info),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        enum ButtonState {
            Normal,
            Hovered,
            Pressed,
            Disabled,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ButtonState {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ButtonState::Normal => "Normal",
                        ButtonState::Hovered => "Hovered",
                        ButtonState::Pressed => "Pressed",
                        ButtonState::Disabled => "Disabled",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ButtonState {
            #[inline]
            fn clone(&self) -> ButtonState {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ButtonState {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ButtonState {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ButtonState {
            #[inline]
            fn eq(&self, other: &ButtonState) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ButtonState {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl bincode::Encode for ButtonState {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::Normal => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::Hovered => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::Pressed => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::Disabled => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for ButtonState {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::Normal),
                    1u32 => Ok(Self::Hovered),
                    2u32 => Ok(Self::Pressed),
                    3u32 => Ok(Self::Disabled),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 3u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for ButtonState {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::Normal => {
                        buf.write_string("Normal");
                    }
                    Self::Hovered => {
                        buf.write_string("Hovered");
                    }
                    Self::Pressed => {
                        buf.write_string("Pressed");
                    }
                    Self::Disabled => {
                        buf.write_string("Disabled");
                    }
                }
            }
        }
        impl Deserialize for ButtonState {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "Normal" => Ok(Self::Normal),
                    "Hovered" => Ok(Self::Hovered),
                    "Pressed" => Ok(Self::Pressed),
                    "Disabled" => Ok(Self::Disabled),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        pub struct Button<'a> {
            pub wh: Wh<Px>,
            pub on_click: &'a dyn Fn(),
            pub content: &'a dyn Fn(Wh<Px>, Color, &RenderCtx),
            pub variant: ButtonVariant,
            pub color: ButtonColor,
            pub disabled: bool,
        }
        #[allow(dead_code)]
        impl<'a> Button<'a> {
            pub fn new(
                wh: Wh<Px>,
                on_click: &'a dyn Fn(),
                content: &'a dyn Fn(Wh<Px>, Color, &RenderCtx),
            ) -> Self {
                Self {
                    wh,
                    on_click,
                    content,
                    variant: ButtonVariant::Contained,
                    color: ButtonColor::Primary,
                    disabled: false,
                }
            }
            pub fn variant(mut self, variant: ButtonVariant) -> Self {
                self.variant = variant;
                self
            }
            pub fn color(mut self, color: ButtonColor) -> Self {
                self.color = color;
                self
            }
            pub fn disabled(mut self, disabled: bool) -> Self {
                self.disabled = disabled;
                self
            }
        }
        impl Component for Button<'_> {
            fn render(self, ctx: &RenderCtx) {
                let Button { wh, on_click, content, variant, color, disabled } = self;
                let (button_state, set_button_state) = ctx
                    .state(|| {
                        if disabled {
                            ButtonState::Disabled
                        } else {
                            ButtonState::Normal
                        }
                    });
                let current_state = if disabled {
                    ButtonState::Disabled
                } else {
                    *button_state
                };
                let (fill_color, stroke_color, stroke_width) = get_button_style(
                    variant,
                    color,
                    current_state,
                );
                let base_colors = get_base_colors(color);
                let text_color = if disabled {
                    palette::ON_SURFACE.with_alpha(97)
                } else {
                    match variant {
                        ButtonVariant::Text | ButtonVariant::Outlined => base_colors.0,
                        ButtonVariant::Contained | ButtonVariant::Fab => base_colors.1,
                    }
                };
                content(wh, text_color, ctx);
                let cursor = if disabled {
                    MouseCursor::Standard(StandardCursor::NotAllowed)
                } else {
                    MouseCursor::Standard(StandardCursor::Pointer)
                };
                ctx.mouse_cursor(cursor)
                    .add(
                        rect(RectParam {
                            rect: Rect::Xywh {
                                x: px(0.0),
                                y: px(0.0),
                                width: wh.width,
                                height: wh.height,
                            },
                            style: RectStyle {
                                stroke: Some(RectStroke {
                                    color: stroke_color,
                                    width: stroke_width,
                                    border_position: BorderPosition::Inside,
                                }),
                                fill: Some(RectFill { color: fill_color }),
                                round: Some(RectRound {
                                    radius: palette::ROUND,
                                }),
                            },
                        }),
                    )
                    .attach_event({
                        move |event| {
                            if disabled {
                                return;
                            }
                            match event {
                                Event::MouseDown { event } => {
                                    if event.is_local_xy_in() {
                                        event.stop_propagation();
                                        set_button_state.set(ButtonState::Pressed);
                                    }
                                }
                                Event::MouseUp { event } => {
                                    if event.is_local_xy_in()
                                        && *button_state == ButtonState::Pressed
                                    {
                                        on_click();
                                    }
                                    set_button_state
                                        .set(
                                            if event.is_local_xy_in() {
                                                ButtonState::Hovered
                                            } else {
                                                ButtonState::Normal
                                            },
                                        );
                                }
                                Event::MouseMove { event } => {
                                    let is_hovering = event.is_local_xy_in();
                                    let new_state = match (*button_state, is_hovering) {
                                        (ButtonState::Pressed, _) => ButtonState::Pressed,
                                        (_, true) => ButtonState::Hovered,
                                        (_, false) => ButtonState::Normal,
                                    };
                                    if new_state != *button_state {
                                        set_button_state.set(new_state);
                                    }
                                }
                                _ => {}
                            }
                        }
                    });
            }
        }
        fn get_button_style(
            variant: ButtonVariant,
            color: ButtonColor,
            state: ButtonState,
        ) -> (Color, Color, Px) {
            let base_colors = get_base_colors(color);
            match (variant, state) {
                (ButtonVariant::Text, ButtonState::Normal) => {
                    (Color::TRANSPARENT, Color::TRANSPARENT, 0.px())
                }
                (ButtonVariant::Text, ButtonState::Hovered) => {
                    (lighten_color(base_colors.0, 0.1), Color::TRANSPARENT, 0.px())
                }
                (ButtonVariant::Text, ButtonState::Pressed) => {
                    (lighten_color(base_colors.0, 0.2), Color::TRANSPARENT, 0.px())
                }
                (ButtonVariant::Text, ButtonState::Disabled) => {
                    (Color::TRANSPARENT, Color::TRANSPARENT, 0.px())
                }
                (ButtonVariant::Contained, ButtonState::Normal) => {
                    (base_colors.0, base_colors.0, 0.px())
                }
                (ButtonVariant::Contained, ButtonState::Hovered) => {
                    (
                        lighten_color(base_colors.0, 0.1),
                        lighten_color(base_colors.0, 0.1),
                        0.px(),
                    )
                }
                (ButtonVariant::Contained, ButtonState::Pressed) => {
                    (
                        lighten_color(base_colors.0, 0.2),
                        lighten_color(base_colors.0, 0.2),
                        0.px(),
                    )
                }
                (ButtonVariant::Contained, ButtonState::Disabled) => {
                    (palette::DISABLED_CONTAINER, palette::DISABLED_CONTAINER, 0.px())
                }
                (ButtonVariant::Outlined, ButtonState::Normal) => {
                    (Color::TRANSPARENT, base_colors.0, 1.px())
                }
                (ButtonVariant::Outlined, ButtonState::Hovered) => {
                    (
                        lighten_color(base_colors.0, 0.1),
                        lighten_color(base_colors.0, 0.1),
                        1.px(),
                    )
                }
                (ButtonVariant::Outlined, ButtonState::Pressed) => {
                    (
                        lighten_color(base_colors.0, 0.2),
                        lighten_color(base_colors.0, 0.2),
                        1.px(),
                    )
                }
                (ButtonVariant::Outlined, ButtonState::Disabled) => {
                    (Color::TRANSPARENT, palette::OUTLINE, 1.px())
                }
                (ButtonVariant::Fab, ButtonState::Normal) => {
                    (base_colors.0, darken_color(base_colors.0, 0.3), 5.px())
                }
                (ButtonVariant::Fab, ButtonState::Hovered) => {
                    (
                        lighten_color(base_colors.0, 0.1),
                        darken_color(base_colors.0, 0.3),
                        5.px(),
                    )
                }
                (ButtonVariant::Fab, ButtonState::Pressed) => {
                    (
                        lighten_color(base_colors.0, 0.2),
                        darken_color(base_colors.0, 0.3),
                        5.px(),
                    )
                }
                (ButtonVariant::Fab, ButtonState::Disabled) => {
                    (
                        palette::DISABLED_CONTAINER,
                        darken_color(palette::DISABLED_CONTAINER, 0.2),
                        5.px(),
                    )
                }
            }
        }
        fn get_base_colors(color: ButtonColor) -> (Color, Color) {
            match color {
                ButtonColor::Primary => (palette::PRIMARY, palette::ON_PRIMARY),
                ButtonColor::Secondary => (palette::SECONDARY, palette::ON_SECONDARY),
                ButtonColor::Error => (palette::RED, palette::WHITE),
                ButtonColor::Warn => (palette::YELLOW, palette::BLACK),
                ButtonColor::Info => (palette::BLUE, palette::WHITE),
            }
        }
        fn lighten_color(color: Color, factor: f32) -> Color {
            let r = ((color.r as f32 / 255.0) + factor).min(1.0);
            let g = ((color.g as f32 / 255.0) + factor).min(1.0);
            let b = ((color.b as f32 / 255.0) + factor).min(1.0);
            Color::from_f01(r, g, b, color.a as f32 / 255.0)
        }
        fn darken_color(color: Color, factor: f32) -> Color {
            let r = ((color.r as f32 / 255.0) - factor).max(0.0);
            let g = ((color.g as f32 / 255.0) - factor).max(0.0);
            let b = ((color.b as f32 / 255.0) - factor).max(0.0);
            Color::from_f01(r, g, b, color.a as f32 / 255.0)
        }
    }
    pub mod palette {
        #![allow(dead_code)]
        use namui::*;
        pub const PRIMARY: Color = Color::from_u8(208, 188, 254, 255);
        pub const ON_PRIMARY: Color = Color::from_u8(56, 30, 114, 255);
        pub const SECONDARY: Color = Color::from_u8(204, 194, 220, 255);
        pub const ON_SECONDARY: Color = Color::from_u8(51, 45, 65, 255);
        pub const SURFACE: Color = Color::from_u8(20, 18, 24, 255);
        pub const SURFACE_CONTAINER_LOWEST: Color = Color::from_u8(15, 13, 19, 255);
        pub const SURFACE_CONTAINER_LOW: Color = Color::from_u8(29, 27, 32, 255);
        pub const SURFACE_CONTAINER: Color = Color::from_u8(33, 31, 38, 255);
        pub const SURFACE_CONTAINER_HIGH: Color = Color::from_u8(43, 41, 48, 255);
        pub const SURFACE_CONTAINER_HIGHEST: Color = Color::from_u8(54, 52, 59, 255);
        pub const ON_SURFACE: Color = Color::from_u8(230, 224, 233, 255);
        pub const ON_SURFACE_VARIANT: Color = Color::from_u8(202, 196, 208, 255);
        pub const OUTLINE: Color = Color::from_u8(147, 143, 153, 255);
        pub const COMMON: Color = Color::from_u8(234, 242, 215, 255);
        pub const RARE: Color = Color::from_u8(3, 138, 255, 255);
        pub const EPIC: Color = Color::from_u8(191, 85, 236, 255);
        pub const LEGENDARY: Color = Color::from_u8(216, 250, 8, 255);
        pub const RED: Color = Color::from_u8(244, 67, 54, 255);
        pub const BLUE: Color = Color::from_u8(33, 150, 243, 255);
        pub const YELLOW: Color = Color::from_u8(255, 193, 7, 255);
        pub const WHITE: Color = Color::from_u8(255, 255, 255, 255);
        pub const BLACK: Color = Color::from_u8(0, 0, 0, 255);
        pub const DISABLED_CONTAINER: Color = Color::from_u8(60, 60, 60, 255);
        pub const ON_DISABLED_CONTAINER: Color = Color::from_u8(120, 120, 120, 255);
        pub const ROUND: Px = px(8.);
    }
    pub mod typography {
        use super::palette;
        use crate::icon;
        use namui::*;
        use namui_prebuilt::rich_text::*;
        use std::{cell::RefCell, collections::HashMap, sync::OnceLock};
        pub const HEADLINE_FONT_NAME: &str = "NotoSansKR-Bold";
        pub const PARAGRAPH_FONT_NAME: &str = "NotoSansKR-Regular";
        pub const HEADLINE_FONT_SIZE_LARGE: IntPx = int_px(24);
        pub const HEADLINE_FONT_SIZE_MEDIUM: IntPx = int_px(20);
        pub const HEADLINE_FONT_SIZE_SMALL: IntPx = int_px(16);
        pub const PARAGRAPH_FONT_SIZE_LARGE: IntPx = int_px(16);
        pub const PARAGRAPH_FONT_SIZE_MEDIUM: IntPx = int_px(14);
        pub const PARAGRAPH_FONT_SIZE_SMALL: IntPx = int_px(12);
        pub const DEFAULT_TEXT_STYLE: TextStyle = TextStyle {
            border: None,
            drop_shadow: None,
            color: palette::ON_SURFACE,
            background: None,
            line_height_percent: percent(130.0),
            underline: None,
        };
        pub static TAG_MAP: OnceLock<HashMap<String, Tag>> = OnceLock::new();
        const REGEX_HANDLERS: ::std::thread::LocalKey<
            RefCell<Option<Vec<RegexHandler>>>,
        > = {
            const __INIT: RefCell<Option<Vec<RegexHandler>>> = { RefCell::new(None) };
            unsafe {
                ::std::thread::LocalKey::new(const {
                    if ::std::mem::needs_drop::<RefCell<Option<Vec<RegexHandler>>>>() {
                        |_| {
                            #[thread_local]
                            static VAL: ::std::thread::local_impl::EagerStorage<
                                RefCell<Option<Vec<RegexHandler>>>,
                            > = ::std::thread::local_impl::EagerStorage::new(__INIT);
                            VAL.get()
                        }
                    } else {
                        |_| {
                            #[thread_local]
                            static VAL: RefCell<Option<Vec<RegexHandler>>> = __INIT;
                            &VAL
                        }
                    }
                })
            }
        };
        fn with_regex_handlers<F, R>(f: F) -> R
        where
            F: FnOnce(&Vec<RegexHandler>) -> R,
        {
            REGEX_HANDLERS
                .with(|handlers| {
                    let mut handlers = handlers.borrow_mut();
                    if handlers.is_none() {
                        *handlers = Some(init_regex_handlers());
                    }
                    f(handlers.as_ref().unwrap())
                })
        }
        pub fn init_tag_map() -> HashMap<String, Tag> {
            let mut map = HashMap::new();
            map.insert(
                "red".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: palette::RED,
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "blue".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: palette::BLUE,
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "purple".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: Color::from_u8(128, 0, 128, 255),
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "green".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: Color::from_u8(0, 255, 0, 255),
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "yellow".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: Color::from_u8(255, 255, 0, 255),
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "epic".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: palette::EPIC,
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "rare".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: palette::RARE,
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "attack_damage_color".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: Color::from_u8(255, 100, 100, 255),
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "attack_speed_color".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: Color::from_u8(100, 100, 255, 255),
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "attack_range_color".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: Color::from_u8(100, 255, 100, 255),
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "gold_color".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: Color::from_u8(255, 215, 0, 255),
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "black_suit_color".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: Color::BLACK,
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "red_suit_color".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: palette::RED,
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "white_suit_color".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: TextStyle {
                        color: palette::WHITE,
                        ..DEFAULT_TEXT_STYLE
                    },
                },
            );
            map.insert(
                "B".to_string(),
                Tag::StyledText {
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size: PARAGRAPH_FONT_SIZE_MEDIUM,
                    },
                    style: DEFAULT_TEXT_STYLE,
                },
            );
            map
        }
        pub fn init_regex_handlers() -> Vec<RegexHandler> {
            icon::Icon::create_icon_regex_handlers()
        }
        pub enum FontSize {
            Large,
            Medium,
            Small,
            Custom { size: Px },
        }
        pub enum TextAlign {
            LeftTop,
            LeftCenter { height: Px },
            Center { wh: Wh<Px> },
            RightTop { width: Px },
        }
        pub struct HeadlineBuilder {
            text_content: String,
            font_size: FontSize,
            text_align: TextAlign,
            max_width: Option<Px>,
            text_color: Option<Color>,
            text_border: Option<TextStyleBorder>,
            vertical_align: namui_prebuilt::rich_text::VerticalAlign,
        }
        impl HeadlineBuilder {
            pub fn new(text: impl Into<String>) -> Self {
                Self {
                    text_content: text.into(),
                    font_size: FontSize::Medium,
                    text_align: TextAlign::LeftTop,
                    max_width: None,
                    text_color: None,
                    text_border: None,
                    vertical_align: namui_prebuilt::rich_text::VerticalAlign::Center,
                }
            }
            pub fn size(mut self, size: FontSize) -> Self {
                self.font_size = size;
                self
            }
            pub fn align(mut self, align: TextAlign) -> Self {
                self.text_align = align;
                self
            }
            pub fn max_width(mut self, width: Px) -> Self {
                self.max_width = Some(width);
                self
            }
            pub fn color(mut self, color: Color) -> Self {
                self.text_color = Some(color);
                self
            }
            pub fn stroke(mut self, width: Px, color: Color) -> Self {
                self.text_border = Some(TextStyleBorder { width, color });
                self
            }
            #[allow(dead_code)]
            pub fn vertical_align(
                mut self,
                align: namui_prebuilt::rich_text::VerticalAlign,
            ) -> Self {
                self.vertical_align = align;
                self
            }
            pub fn build(self) -> HeadlineComponent {
                HeadlineComponent {
                    text: self.text_content,
                    font_size: self.font_size,
                    text_align: self.text_align,
                    max_width: self.max_width,
                    text_color: self.text_color,
                    text_border: self.text_border,
                }
            }
            pub fn build_rich(self) -> RichHeadlineComponent {
                RichHeadlineComponent {
                    text: self.text_content,
                    font_size: self.font_size,
                    text_align: self.text_align,
                    max_width: self.max_width,
                    text_color: self.text_color,
                    vertical_align: self.vertical_align,
                }
            }
        }
        pub struct ParagraphBuilder {
            text_content: String,
            font_size: FontSize,
            text_align: TextAlign,
            max_width: Option<Px>,
            text_color: Option<Color>,
            vertical_align: namui_prebuilt::rich_text::VerticalAlign,
        }
        impl ParagraphBuilder {
            pub fn new(text: impl Into<String>) -> Self {
                Self {
                    text_content: text.into(),
                    font_size: FontSize::Medium,
                    text_align: TextAlign::LeftTop,
                    max_width: None,
                    text_color: None,
                    vertical_align: namui_prebuilt::rich_text::VerticalAlign::Center,
                }
            }
            pub fn size(mut self, size: FontSize) -> Self {
                self.font_size = size;
                self
            }
            pub fn align(mut self, align: TextAlign) -> Self {
                self.text_align = align;
                self
            }
            pub fn max_width(mut self, width: Px) -> Self {
                self.max_width = Some(width);
                self
            }
            pub fn color(mut self, color: Color) -> Self {
                self.text_color = Some(color);
                self
            }
            #[allow(dead_code)]
            pub fn vertical_align(
                mut self,
                align: namui_prebuilt::rich_text::VerticalAlign,
            ) -> Self {
                self.vertical_align = align;
                self
            }
            pub fn build(self) -> ParagraphComponent {
                ParagraphComponent {
                    text: self.text_content,
                    font_size: self.font_size,
                    text_align: self.text_align,
                    max_width: self.max_width,
                }
            }
            pub fn build_rich(self) -> RichParagraphComponent {
                RichParagraphComponent {
                    text: self.text_content,
                    font_size: self.font_size,
                    text_align: self.text_align,
                    max_width: self.max_width,
                    vertical_align: self.vertical_align,
                }
            }
        }
        pub struct RichHeadlineComponent {
            text: String,
            font_size: FontSize,
            text_align: TextAlign,
            max_width: Option<Px>,
            text_color: Option<Color>,
            vertical_align: namui_prebuilt::rich_text::VerticalAlign,
        }
        impl Component for RichHeadlineComponent {
            fn render(self, ctx: &RenderCtx) {
                let Self {
                    text,
                    font_size,
                    text_align,
                    max_width,
                    text_color,
                    vertical_align,
                } = self;
                let (x, y) = match text_align {
                    TextAlign::LeftTop => (0.px(), 0.px()),
                    TextAlign::LeftCenter { height } => (0.px(), height * 0.5),
                    TextAlign::Center { wh } => (wh.width * 0.5, wh.height * 0.5),
                    TextAlign::RightTop { width } => (width, 0.px()),
                };
                let size = match font_size {
                    FontSize::Large => HEADLINE_FONT_SIZE_LARGE,
                    FontSize::Medium => HEADLINE_FONT_SIZE_MEDIUM,
                    FontSize::Small => HEADLINE_FONT_SIZE_SMALL,
                    FontSize::Custom { size } => size.into(),
                };
                ctx.translate(Xy { x, y });
                let text_style = if let Some(custom_color) = text_color {
                    TextStyle {
                        color: custom_color,
                        ..DEFAULT_TEXT_STYLE
                    }
                } else {
                    DEFAULT_TEXT_STYLE
                };
                let rich_text_align = match text_align {
                    TextAlign::LeftTop => namui::TextAlign::Left,
                    TextAlign::LeftCenter { .. } => namui::TextAlign::Left,
                    TextAlign::Center { .. } => namui::TextAlign::Center,
                    TextAlign::RightTop { .. } => namui::TextAlign::Right,
                };
                let effective_max_width = match (&text_align, max_width) {
                    (TextAlign::Center { wh }, None) => Some(wh.width),
                    (TextAlign::RightTop { width }, None) => Some(*width),
                    _ => max_width,
                };
                with_regex_handlers(|regex_handlers| {
                    ctx.add(namui_prebuilt::rich_text::RichText {
                        text,
                        max_width: effective_max_width,
                        default_font: Font {
                            name: HEADLINE_FONT_NAME.to_string(),
                            size,
                        },
                        default_text_style: text_style,
                        default_text_align: rich_text_align,
                        default_vertical_align: vertical_align,
                        tag_map: TAG_MAP.get_or_init(init_tag_map),
                        regex_handlers,
                        on_parse_error: None,
                    });
                });
            }
        }
        pub struct RichParagraphComponent {
            text: String,
            font_size: FontSize,
            text_align: TextAlign,
            max_width: Option<Px>,
            vertical_align: namui_prebuilt::rich_text::VerticalAlign,
        }
        impl Component for RichParagraphComponent {
            fn render(self, ctx: &RenderCtx) {
                let Self { text, font_size, text_align, max_width, vertical_align } = self;
                let (x, y) = match text_align {
                    TextAlign::LeftTop => (0.px(), 0.px()),
                    TextAlign::LeftCenter { height } => (0.px(), height * 0.5),
                    TextAlign::Center { wh } => (wh.width * 0.5, wh.height * 0.5),
                    TextAlign::RightTop { width } => (width, 0.px()),
                };
                let size = match font_size {
                    FontSize::Large => PARAGRAPH_FONT_SIZE_LARGE,
                    FontSize::Medium => PARAGRAPH_FONT_SIZE_MEDIUM,
                    FontSize::Small => PARAGRAPH_FONT_SIZE_SMALL,
                    FontSize::Custom { size } => size.into(),
                };
                let rich_text_align = match text_align {
                    TextAlign::LeftTop => namui::TextAlign::Left,
                    TextAlign::LeftCenter { .. } => namui::TextAlign::Left,
                    TextAlign::Center { .. } => namui::TextAlign::Center,
                    TextAlign::RightTop { .. } => namui::TextAlign::Right,
                };
                let effective_max_width = match (&text_align, max_width) {
                    (TextAlign::Center { wh }, None) => Some(wh.width),
                    (TextAlign::RightTop { width }, None) => Some(*width),
                    _ => max_width,
                };
                ctx.translate(Xy { x, y });
                with_regex_handlers(|regex_handlers| {
                    ctx.add(namui_prebuilt::rich_text::RichText {
                        text,
                        max_width: effective_max_width,
                        default_font: Font {
                            name: PARAGRAPH_FONT_NAME.to_string(),
                            size,
                        },
                        default_text_style: DEFAULT_TEXT_STYLE,
                        default_text_align: rich_text_align,
                        default_vertical_align: vertical_align,
                        tag_map: TAG_MAP.get_or_init(init_tag_map),
                        regex_handlers,
                        on_parse_error: None,
                    });
                });
            }
        }
        pub struct HeadlineComponent {
            text: String,
            font_size: FontSize,
            text_align: TextAlign,
            max_width: Option<Px>,
            text_color: Option<Color>,
            text_border: Option<TextStyleBorder>,
        }
        impl HeadlineComponent {
            pub fn into_rendering_tree(self) -> RenderingTree {
                let Self {
                    text,
                    font_size,
                    text_align,
                    max_width,
                    text_color,
                    text_border,
                } = self;
                let (x, y) = match text_align {
                    TextAlign::LeftTop => (0.px(), 0.px()),
                    TextAlign::LeftCenter { height } => (0.px(), height * 0.5),
                    TextAlign::Center { wh } => (wh.width * 0.5, wh.height * 0.5),
                    TextAlign::RightTop { width } => (width, 0.px()),
                };
                let align = match text_align {
                    TextAlign::LeftTop => namui::TextAlign::Left,
                    TextAlign::LeftCenter { .. } => namui::TextAlign::Left,
                    TextAlign::Center { .. } => namui::TextAlign::Center,
                    TextAlign::RightTop { .. } => namui::TextAlign::Right,
                };
                let size = match font_size {
                    FontSize::Large => HEADLINE_FONT_SIZE_LARGE,
                    FontSize::Medium => HEADLINE_FONT_SIZE_MEDIUM,
                    FontSize::Small => HEADLINE_FONT_SIZE_SMALL,
                    FontSize::Custom { size } => size.into(),
                };
                let baseline = match text_align {
                    TextAlign::LeftTop => TextBaseline::Top,
                    TextAlign::LeftCenter { .. } => TextBaseline::Middle,
                    TextAlign::Center { .. } => TextBaseline::Middle,
                    TextAlign::RightTop { .. } => TextBaseline::Top,
                };
                let text_style = TextStyle {
                    color: text_color.unwrap_or(DEFAULT_TEXT_STYLE.color),
                    border: text_border,
                    ..DEFAULT_TEXT_STYLE
                };
                let effective_max_width = match (&text_align, max_width) {
                    (TextAlign::Center { wh }, None) => Some(wh.width),
                    (TextAlign::RightTop { width }, None) => Some(*width),
                    _ => max_width,
                };
                namui::text(TextParam {
                    text,
                    x,
                    y,
                    align,
                    baseline,
                    font: Font {
                        name: HEADLINE_FONT_NAME.to_string(),
                        size,
                    },
                    style: text_style,
                    max_width: effective_max_width,
                })
            }
        }
        impl Component for HeadlineComponent {
            fn render(self, ctx: &RenderCtx) {
                ctx.add(self.into_rendering_tree());
            }
        }
        pub struct ParagraphComponent {
            text: String,
            font_size: FontSize,
            text_align: TextAlign,
            max_width: Option<Px>,
        }
        impl ParagraphComponent {
            pub fn into_rendering_tree(self) -> RenderingTree {
                let Self { text, font_size, text_align, max_width } = self;
                let (x, y) = match text_align {
                    TextAlign::LeftTop => (0.px(), 0.px()),
                    TextAlign::LeftCenter { height } => (0.px(), height * 0.5),
                    TextAlign::Center { wh } => (wh.width * 0.5, wh.height * 0.5),
                    TextAlign::RightTop { width } => (width, 0.px()),
                };
                let align = match text_align {
                    TextAlign::LeftTop => namui::TextAlign::Left,
                    TextAlign::LeftCenter { .. } => namui::TextAlign::Left,
                    TextAlign::Center { .. } => namui::TextAlign::Center,
                    TextAlign::RightTop { .. } => namui::TextAlign::Right,
                };
                let size = match font_size {
                    FontSize::Large => PARAGRAPH_FONT_SIZE_LARGE,
                    FontSize::Medium => PARAGRAPH_FONT_SIZE_MEDIUM,
                    FontSize::Small => PARAGRAPH_FONT_SIZE_SMALL,
                    FontSize::Custom { size } => size.into(),
                };
                let baseline = match text_align {
                    TextAlign::LeftTop => TextBaseline::Top,
                    TextAlign::LeftCenter { .. } => TextBaseline::Middle,
                    TextAlign::Center { .. } => TextBaseline::Middle,
                    TextAlign::RightTop { .. } => TextBaseline::Top,
                };
                let effective_max_width = match (&text_align, max_width) {
                    (TextAlign::Center { wh }, None) => Some(wh.width),
                    (TextAlign::RightTop { width }, None) => Some(*width),
                    _ => max_width,
                };
                namui::text(TextParam {
                    text,
                    x,
                    y,
                    align,
                    baseline,
                    font: Font {
                        name: PARAGRAPH_FONT_NAME.to_string(),
                        size,
                    },
                    style: DEFAULT_TEXT_STYLE,
                    max_width: effective_max_width,
                })
            }
        }
        impl Component for ParagraphComponent {
            fn render(self, ctx: &RenderCtx) {
                ctx.add(self.into_rendering_tree());
            }
        }
        pub fn headline(text: impl Into<String>) -> HeadlineBuilder {
            HeadlineBuilder::new(text)
        }
        pub fn paragraph(text: impl Into<String>) -> ParagraphBuilder {
            ParagraphBuilder::new(text)
        }
    }
}
mod thumbnail {
    pub mod base_rendering {
        use crate::{
            game_state::tower::{AnimationKind, TowerKind, render::TowerImage},
            icon::{Icon, IconKind, IconSize},
        };
        use namui::*;
        /// 타워 이미지를 렌더링하는 기본 함수
        pub fn render_tower_image(
            width_height: Wh<Px>,
            tower_kind: TowerKind,
        ) -> RenderingTree {
            let image = (tower_kind, AnimationKind::Idle1).image();
            namui::image(ImageParam {
                rect: width_height.to_rect(),
                image,
                style: ImageStyle {
                    fit: ImageFit::Contain,
                    paint: None,
                },
            })
        }
        /// 바리케이드 타워를 렌더링하는 함수 (가장 자주 사용되는 기본 타워)
        pub fn render_default_tower(width_height: Wh<Px>) -> RenderingTree {
            render_tower_image(width_height, TowerKind::Barricade)
        }
        /// 아이콘을 렌더링하는 기본 함수
        pub fn render_icon_base(
            width_height: Wh<Px>,
            icon_kind: IconKind,
        ) -> RenderingTree {
            Icon::new(icon_kind)
                .wh(width_height)
                .size(IconSize::Custom {
                    size: width_height.width,
                })
                .to_rendering_tree()
        }
    }
    pub mod composition {
        use super::{base_rendering, overlay_rendering};
        use namui::*;
        /// 썸네일 구성을 위한 빌더 패턴 구조체
        pub struct ThumbnailComposer {
            width_height: Wh<Px>,
            base_layer: Option<RenderingTree>,
            overlay_layers: Vec<RenderingTree>,
        }
        impl ThumbnailComposer {
            /// 새로운 썸네일 구성자를 생성합니다.
            pub fn new(width_height: Wh<Px>) -> Self {
                Self {
                    width_height,
                    base_layer: None,
                    overlay_layers: Vec::new(),
                }
            }
            /// 기본 타워 이미지를 설정합니다.
            pub fn with_default_tower(mut self) -> Self {
                self.base_layer = Some(
                    base_rendering::render_default_tower(self.width_height),
                );
                self
            }
            /// 특정 타워 이미지를 설정합니다.
            pub fn with_tower_image(
                mut self,
                tower_kind: crate::game_state::tower::TowerKind,
            ) -> Self {
                self.base_layer = Some(
                    base_rendering::render_tower_image(self.width_height, tower_kind),
                );
                self
            }
            /// 아이콘을 기본 레이어로 설정합니다.
            pub fn with_icon_base(mut self, icon_kind: crate::icon::IconKind) -> Self {
                self.base_layer = Some(
                    base_rendering::render_icon_base(self.width_height, icon_kind),
                );
                self
            }
            /// 플러스 오버레이를 추가합니다.
            pub fn add_plus_overlay(mut self) -> Self {
                self.overlay_layers
                    .push(overlay_rendering::render_plus_overlay(self.width_height));
                self
            }
            /// 랭크 오버레이를 추가합니다.
            pub fn add_rank_overlay(mut self, rank: crate::card::Rank) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_rank_overlay(self.width_height, rank),
                    );
                self
            }
            /// 슈트 오버레이를 추가합니다.
            pub fn add_suit_overlay(mut self, suit: crate::card::Suit) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_suit_overlay(self.width_height, suit),
                    );
                self
            }
            /// 확장 표시기를 추가합니다.
            pub fn add_expansion_indicator(mut self, text: &str) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_expansion_indicator(
                            self.width_height,
                            text,
                        ),
                    );
                self
            }
            /// 낮은 카드 표시기를 추가합니다.
            pub fn add_low_card_indicator(mut self) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_low_card_indicator(self.width_height),
                    );
                self
            }
            /// 리롤 없음 표시기를 추가합니다.
            pub fn add_no_reroll_indicator(mut self) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_no_reroll_indicator(self.width_height),
                    );
                self
            }
            /// 리롤 허용 표시기를 추가합니다.
            pub fn add_reroll_indicator(mut self) -> Self {
                self.overlay_layers
                    .push(overlay_rendering::render_reroll_indicator(self.width_height));
                self
            }
            /// 짝수/홀수 표시기를 추가합니다.
            pub fn add_even_odd_indicator(mut self, is_even: bool) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_even_odd_indicator(
                            self.width_height,
                            is_even,
                        ),
                    );
                self
            }
            /// 페이스/숫자 표시기를 추가합니다.
            pub fn add_face_number_indicator(mut self, is_face: bool) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_face_number_indicator(
                            self.width_height,
                            is_face,
                        ),
                    );
                self
            }
            /// 단축키 표시기를 추가합니다.
            pub fn add_shortcut_indicator(mut self, text: &str) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_shortcut_indicator(
                            self.width_height,
                            text,
                        ),
                    );
                self
            }
            /// 건너뛰기 표시기를 추가합니다.
            pub fn add_skip_indicator(mut self) -> Self {
                self.overlay_layers
                    .push(overlay_rendering::render_skip_indicator(self.width_height));
                self
            }
            /// 같은 슈트 표시기를 추가합니다.
            pub fn add_same_suits_indicator(mut self) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_same_suits_indicator(self.width_height),
                    );
                self
            }
            /// 아이콘 오버레이를 추가합니다.
            pub fn add_icon_overlay(
                mut self,
                icon_kind: crate::icon::IconKind,
                position: overlay_rendering::OverlayPosition,
                size_ratio: f32,
            ) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_icon_overlay(
                            self.width_height,
                            icon_kind,
                            position,
                            size_ratio,
                        ),
                    );
                self
            }
            /// 텍스트 오버레이를 추가합니다.
            #[allow(dead_code)]
            pub fn add_text_overlay(
                mut self,
                text: &str,
                position: overlay_rendering::OverlayPosition,
                size_ratio: f32,
                text_size_ratio: f32,
            ) -> Self {
                self.overlay_layers
                    .push(
                        overlay_rendering::render_text_overlay(
                            self.width_height,
                            text,
                            position,
                            size_ratio,
                            text_size_ratio,
                        ),
                    );
                self
            }
            /// 최종 렌더링 트리를 생성합니다.
            pub fn build(self) -> RenderingTree {
                let mut layers = Vec::new();
                layers.extend(self.overlay_layers);
                if let Some(base) = self.base_layer {
                    layers.push(base);
                }
                namui::render(layers)
            }
        }
    }
    pub mod constants {
        pub const OVERLAY_SIZE_RATIO: f32 = 0.4;
        pub const LARGE_OVERLAY_SIZE_RATIO: f32 = 0.5;
        pub const RANK_OVERLAY_SIZE_RATIO: f32 = 0.6;
        pub const TEXT_SIZE_RATIO: f32 = 0.6;
        pub const SMALL_TEXT_SIZE_RATIO: f32 = 0.4;
        pub const LARGE_TEXT_SIZE_RATIO: f32 = 0.8;
    }
    pub mod overlay_rendering {
        use super::constants::{
            LARGE_OVERLAY_SIZE_RATIO, LARGE_TEXT_SIZE_RATIO, OVERLAY_SIZE_RATIO,
            RANK_OVERLAY_SIZE_RATIO, SMALL_TEXT_SIZE_RATIO, TEXT_SIZE_RATIO,
        };
        use crate::{
            card::{Rank, Suit},
            icon::{Icon, IconAttribute, IconAttributePosition, IconKind, IconSize},
            theme::typography::{FontSize, TextAlign, headline},
        };
        use namui::*;
        /// 오버레이 위치를 계산하는 열거형
        pub enum OverlayPosition {
            TopLeft,
            TopRight,
            BottomLeft,
            BottomRight,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OverlayPosition {
            #[inline]
            fn clone(&self) -> OverlayPosition {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for OverlayPosition {}
        impl bincode::Encode for OverlayPosition {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                match self {
                    Self::TopLeft => {
                        bincode::Encode::encode(&0u32, encoder)?;
                    }
                    Self::TopRight => {
                        bincode::Encode::encode(&1u32, encoder)?;
                    }
                    Self::BottomLeft => {
                        bincode::Encode::encode(&2u32, encoder)?;
                    }
                    Self::BottomRight => {
                        bincode::Encode::encode(&3u32, encoder)?;
                    }
                }
                Ok(())
            }
        }
        impl bincode::Decode<()> for OverlayPosition {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                let discriminant: u32 = bincode::Decode::decode(decoder)?;
                match discriminant {
                    0u32 => Ok(Self::TopLeft),
                    1u32 => Ok(Self::TopRight),
                    2u32 => Ok(Self::BottomLeft),
                    3u32 => Ok(Self::BottomRight),
                    _ => {
                        Err(bincode::error::DecodeError::UnexpectedVariant {
                            type_name: core::any::type_name::<Self>(),
                            allowed: &bincode::error::AllowedEnumVariants::Range {
                                min: 0,
                                max: 3u32,
                            },
                            found: discriminant,
                        })
                    }
                }
            }
        }
        impl Serialize for OverlayPosition {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                match self {
                    Self::TopLeft => {
                        buf.write_string("TopLeft");
                    }
                    Self::TopRight => {
                        buf.write_string("TopRight");
                    }
                    Self::BottomLeft => {
                        buf.write_string("BottomLeft");
                    }
                    Self::BottomRight => {
                        buf.write_string("BottomRight");
                    }
                }
            }
        }
        impl Deserialize for OverlayPosition {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let variant_name = buf.read_string();
                match variant_name.as_ref() {
                    "TopLeft" => Ok(Self::TopLeft),
                    "TopRight" => Ok(Self::TopRight),
                    "BottomLeft" => Ok(Self::BottomLeft),
                    "BottomRight" => Ok(Self::BottomRight),
                    _ => {
                        Err(DeserializeError::InvalidEnumVariant {
                            expected: std::any::type_name::<Self>().to_string(),
                            actual: variant_name,
                        })
                    }
                }
            }
        }
        impl OverlayPosition {
            pub fn calculate_position(
                self,
                container_size: Wh<Px>,
                overlay_size: Wh<Px>,
            ) -> Xy<Px> {
                match self {
                    OverlayPosition::TopLeft => Xy::new(0.px(), 0.px()),
                    OverlayPosition::TopRight => {
                        Xy::new(container_size.width - overlay_size.width, 0.px())
                    }
                    OverlayPosition::BottomLeft => {
                        Xy::new(0.px(), container_size.height - overlay_size.height)
                    }
                    OverlayPosition::BottomRight => {
                        Xy::new(
                            container_size.width - overlay_size.width,
                            container_size.height - overlay_size.height,
                        )
                    }
                }
            }
        }
        /// 텍스트 오버레이를 렌더링하는 함수
        pub fn render_text_overlay(
            container_size: Wh<Px>,
            text: &str,
            position: OverlayPosition,
            size_ratio: f32,
            text_size_ratio: f32,
        ) -> RenderingTree {
            let overlay_size = container_size * size_ratio;
            let overlay_position = position
                .calculate_position(container_size, overlay_size);
            namui::translate(
                overlay_position.x,
                overlay_position.y,
                headline(text)
                    .align(TextAlign::Center {
                        wh: overlay_size,
                    })
                    .size(FontSize::Custom {
                        size: overlay_size.height * text_size_ratio,
                    })
                    .color(Color::WHITE)
                    .stroke(overlay_size.height * text_size_ratio * 0.05, Color::BLACK)
                    .build()
                    .into_rendering_tree(),
            )
        }
        /// 플러스 아이콘 오버레이를 렌더링하는 함수
        pub fn render_plus_overlay(container_size: Wh<Px>) -> RenderingTree {
            render_icon_overlay(
                container_size,
                IconKind::Add,
                OverlayPosition::BottomRight,
                OVERLAY_SIZE_RATIO,
            )
        }
        /// 아이콘 오버레이를 렌더링하는 함수
        pub fn render_icon_overlay(
            container_size: Wh<Px>,
            icon_kind: IconKind,
            position: OverlayPosition,
            size_ratio: f32,
        ) -> RenderingTree {
            let overlay_size = container_size * size_ratio;
            let overlay_position = position
                .calculate_position(container_size, overlay_size);
            namui::translate(
                overlay_position.x,
                overlay_position.y,
                Icon::new(icon_kind)
                    .wh(overlay_size)
                    .size(IconSize::Custom {
                        size: overlay_size.width,
                    })
                    .to_rendering_tree(),
            )
        }
        /// 랭크 오버레이를 렌더링하는 함수
        pub fn render_rank_overlay(container_size: Wh<Px>, rank: Rank) -> RenderingTree {
            render_text_overlay(
                container_size,
                &rank.to_string(),
                OverlayPosition::TopLeft,
                RANK_OVERLAY_SIZE_RATIO,
                TEXT_SIZE_RATIO,
            )
        }
        /// 슈트 오버레이를 렌더링하는 함수
        pub fn render_suit_overlay(container_size: Wh<Px>, suit: Suit) -> RenderingTree {
            render_icon_overlay(
                container_size,
                IconKind::Suit { suit },
                OverlayPosition::TopLeft,
                RANK_OVERLAY_SIZE_RATIO,
            )
        }
        /// 확장 표시기를 렌더링하는 함수
        pub fn render_expansion_indicator(
            container_size: Wh<Px>,
            text: &str,
        ) -> RenderingTree {
            render_text_overlay(
                container_size,
                text,
                OverlayPosition::BottomLeft,
                LARGE_OVERLAY_SIZE_RATIO,
                SMALL_TEXT_SIZE_RATIO,
            )
        }
        /// 낮은 카드 표시기를 렌더링하는 함수
        pub fn render_low_card_indicator(container_size: Wh<Px>) -> RenderingTree {
            render_text_overlay(
                container_size,
                "≤3",
                OverlayPosition::BottomLeft,
                OVERLAY_SIZE_RATIO,
                TEXT_SIZE_RATIO,
            )
        }
        /// 리롤 없음 표시기를 렌더링하는 함수
        pub fn render_no_reroll_indicator(container_size: Wh<Px>) -> RenderingTree {
            let indicator_size = container_size * OVERLAY_SIZE_RATIO;
            let indicator_position = OverlayPosition::BottomLeft
                .calculate_position(container_size, indicator_size);
            namui::translate(
                indicator_position.x,
                indicator_position.y,
                Icon::new(IconKind::Refresh)
                    .wh(indicator_size)
                    .size(IconSize::Custom {
                        size: indicator_size.width,
                    })
                    .attributes(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                IconAttribute::new(IconKind::Reject)
                                    .position(IconAttributePosition::Center),
                            ]),
                        ),
                    )
                    .to_rendering_tree(),
            )
        }
        /// 리롤 허용 표시기를 렌더링하는 함수
        pub fn render_reroll_indicator(container_size: Wh<Px>) -> RenderingTree {
            let indicator_size = container_size * OVERLAY_SIZE_RATIO;
            let indicator_position = OverlayPosition::BottomLeft
                .calculate_position(container_size, indicator_size);
            namui::translate(
                indicator_position.x,
                indicator_position.y,
                Icon::new(IconKind::Refresh)
                    .wh(indicator_size)
                    .size(IconSize::Custom {
                        size: indicator_size.width,
                    })
                    .attributes(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                IconAttribute::new(IconKind::Accept)
                                    .position(IconAttributePosition::Center),
                            ]),
                        ),
                    )
                    .to_rendering_tree(),
            )
        }
        /// 짝수/홀수 표시기를 렌더링하는 함수
        pub fn render_even_odd_indicator(
            container_size: Wh<Px>,
            is_even: bool,
        ) -> RenderingTree {
            let text = if is_even { "Even" } else { "Odd" };
            render_text_overlay(
                container_size,
                text,
                OverlayPosition::BottomLeft,
                OVERLAY_SIZE_RATIO,
                SMALL_TEXT_SIZE_RATIO,
            )
        }
        /// 페이스/숫자 표시기를 렌더링하는 함수
        pub fn render_face_number_indicator(
            container_size: Wh<Px>,
            is_face: bool,
        ) -> RenderingTree {
            let text = if is_face { "Face" } else { "Num" };
            render_text_overlay(
                container_size,
                text,
                OverlayPosition::BottomLeft,
                OVERLAY_SIZE_RATIO,
                SMALL_TEXT_SIZE_RATIO,
            )
        }
        /// 단축키 표시기를 렌더링하는 함수
        pub fn render_shortcut_indicator(
            container_size: Wh<Px>,
            text: &str,
        ) -> RenderingTree {
            render_text_overlay(
                container_size,
                text,
                OverlayPosition::TopLeft,
                LARGE_OVERLAY_SIZE_RATIO,
                TEXT_SIZE_RATIO,
            )
        }
        /// 건너뛰기 표시기를 렌더링하는 함수
        pub fn render_skip_indicator(container_size: Wh<Px>) -> RenderingTree {
            render_text_overlay(
                container_size,
                "Skip",
                OverlayPosition::TopLeft,
                OVERLAY_SIZE_RATIO,
                SMALL_TEXT_SIZE_RATIO,
            )
        }
        /// 같은 슈트 표시기를 렌더링하는 함수
        pub fn render_same_suits_indicator(container_size: Wh<Px>) -> RenderingTree {
            render_text_overlay(
                container_size,
                "=",
                OverlayPosition::TopLeft,
                OVERLAY_SIZE_RATIO,
                LARGE_TEXT_SIZE_RATIO,
            )
        }
    }
    pub use composition::ThumbnailComposer;
}
mod top_bar {
    mod hp_and_gold {
        use crate::icon::{Icon, IconKind, IconSize};
        use crate::theme::typography::FontSize;
        use crate::{palette, theme::typography::headline};
        use namui::*;
        use namui_prebuilt::{simple_rect, table};
        const PADDING: Px = px(8.);
        pub struct HPAndGoldIndicator {
            pub wh: Wh<Px>,
            pub hp: f32,
            pub gold: usize,
        }
        impl Component for HPAndGoldIndicator {
            fn render(self, ctx: &RenderCtx) {
                let Self { wh, hp, gold } = self;
                ctx.compose(|ctx| {
                    table::vertical([
                        table::ratio(
                            1,
                            table::horizontal([
                                table::fixed(
                                    px(32.),
                                    |wh, ctx| {
                                        ctx.add(
                                            Icon::new(IconKind::Health).size(IconSize::Medium).wh(wh),
                                        );
                                    },
                                ),
                                table::fixed(
                                    48.px(),
                                    |wh, ctx| {
                                        ctx.add(
                                            headline(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0:.0}", hp * 100.0))
                                                    }),
                                                )
                                                .size(FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    table::padding(
                                        PADDING,
                                        |wh, ctx| {
                                            ctx.add(
                                                simple_rect(
                                                    Wh::new(wh.width * (hp).clamp(0.0, 1.0), wh.height),
                                                    Color::TRANSPARENT,
                                                    0.px(),
                                                    palette::PRIMARY,
                                                ),
                                            );
                                            ctx.add(
                                                simple_rect(
                                                    wh,
                                                    Color::TRANSPARENT,
                                                    0.px(),
                                                    palette::SURFACE,
                                                ),
                                            );
                                        },
                                    ),
                                ),
                            ]),
                        ),
                        table::ratio(
                            1,
                            table::horizontal([
                                table::fixed(
                                    32.px(),
                                    |wh, ctx| {
                                        ctx.add(
                                            Icon::new(IconKind::Gold).size(IconSize::Medium).wh(wh),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            headline(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0}", gold))
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::RightTop {
                                                    width: wh.width,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::fixed(PADDING, |_, _| {}),
                            ]),
                        ),
                    ])(wh, ctx);
                });
                ctx.add(
                    simple_rect(
                        wh,
                        Color::TRANSPARENT,
                        0.px(),
                        palette::SURFACE_CONTAINER,
                    ),
                );
            }
        }
    }
    mod level {
        use crate::icon::IconAttribute;
        use crate::theme::button::Button;
        use crate::{
            game_state::{mutate_game_state, use_game_state},
            icon::{Icon, IconKind, IconSize},
            palette, theme::typography::headline,
        };
        use namui::*;
        use namui_prebuilt::{simple_rect, table};
        const PADDING: Px = px(8.);
        pub struct LevelIndicator {
            pub wh: Wh<Px>,
            pub level: usize,
            pub level_up_cost: usize,
            pub gold: usize,
        }
        impl Component for LevelIndicator {
            fn render(self, ctx: &RenderCtx) {
                let Self { wh, level, level_up_cost, gold } = self;
                let _game_state = use_game_state(ctx);
                let (mouse_hovering, set_mouse_hovering) = ctx.state(|| false);
                let can_upgrade = level < 10 && gold >= level_up_cost;
                let level_up = || {
                    mutate_game_state(move |game_state| {
                        game_state.level = game_state
                            .level
                            .checked_add(1)
                            .expect("Level overflow");
                        game_state.spend_gold(level_up_cost);
                    });
                };
                ctx.compose(|ctx| {
                        table::horizontal([
                            table::fixed(
                                48.px(),
                                |wh, ctx| {
                                    ctx.add(
                                        Icon::new(IconKind::Level).size(IconSize::Large).wh(wh),
                                    );
                                },
                            ),
                            table::fixed(
                                32.px(),
                                |wh, ctx| {
                                    ctx.add(
                                        headline(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("{0}", level))
                                                }),
                                            )
                                            .size(crate::theme::typography::FontSize::Medium)
                                            .align(crate::theme::typography::TextAlign::Center {
                                                wh,
                                            })
                                            .build(),
                                    );
                                },
                            ),
                            table::ratio(1, |_, _| {}),
                            table::fixed(
                                128.px(),
                                table::padding(
                                    PADDING,
                                    |wh, ctx| {
                                        ctx.add(
                                            Button::new(
                                                    wh,
                                                    &|| {
                                                        if !can_upgrade {
                                                            return;
                                                        }
                                                        level_up();
                                                    },
                                                    &|wh, _text_color, ctx| {
                                                        let text_color = match can_upgrade {
                                                            true => palette::ON_PRIMARY,
                                                            false => palette::ON_SURFACE,
                                                        };
                                                        ctx.add(
                                                            headline(
                                                                    ::alloc::__export::must_use({
                                                                        ::alloc::fmt::format(
                                                                            format_args!(
                                                                                "{0} {1}{2}",
                                                                                Icon::new(IconKind::Level)
                                                                                    .attributes(
                                                                                        <[_]>::into_vec(
                                                                                            ::alloc::boxed::box_new([
                                                                                                IconAttribute {
                                                                                                    icon_kind: IconKind::Up,
                                                                                                    position: crate::icon::IconAttributePosition::BottomRight,
                                                                                                },
                                                                                            ]),
                                                                                        ),
                                                                                    )
                                                                                    .wh(Wh::single(wh.height))
                                                                                    .as_tag(),
                                                                                Icon::new(IconKind::Gold)
                                                                                    .wh(Wh::single(wh.height))
                                                                                    .as_tag(),
                                                                                level_up_cost,
                                                                            ),
                                                                        )
                                                                    }),
                                                                )
                                                                .align(crate::theme::typography::TextAlign::Center {
                                                                    wh,
                                                                })
                                                                .color(text_color)
                                                                .build_rich(),
                                                        );
                                                    },
                                                )
                                                .variant(crate::theme::button::ButtonVariant::Contained)
                                                .color(crate::theme::button::ButtonColor::Primary)
                                                .disabled(!can_upgrade),
                                        );
                                    },
                                ),
                            ),
                        ])(wh, ctx);
                    })
                    .attach_event(|event| {
                        let Event::MouseMove { event } = event else {
                            return;
                        };
                        let mouse_move_is_local_xy_in = event.is_local_xy_in();
                        if *mouse_hovering != mouse_move_is_local_xy_in {
                            set_mouse_hovering.set(mouse_move_is_local_xy_in);
                        }
                    });
                ctx.compose(|ctx| {
                    if !*mouse_hovering {
                        return;
                    }
                    ctx.translate((0.px(), wh.height))
                        .on_top()
                        .add(crate::top_bar::level_up_details::LevelUpDetails {
                            width: wh.width,
                            current_level: level,
                        });
                });
                ctx.add(
                    simple_rect(
                        wh,
                        Color::TRANSPARENT,
                        0.px(),
                        palette::SURFACE_CONTAINER,
                    ),
                );
            }
        }
    }
    mod level_up_details {
        use crate::{
            game_state::level_rarity_weight, icon::{Icon, IconKind, IconSize},
            palette, rarity::Rarity, theme::typography::paragraph,
        };
        use namui::*;
        use namui_prebuilt::{simple_rect, table};
        use std::num::NonZero;
        const LINE_HEIGHT: Px = px(32.);
        const CONTAINER_HEIGHT: Px = px(128.);
        const RARITY_LABEL_WIDTH: Px = px(64.);
        const PADDING: Px = px(8.);
        pub struct LevelUpDetails {
            pub width: Px,
            pub current_level: usize,
        }
        impl Component for LevelUpDetails {
            fn render(self, ctx: &RenderCtx) {
                let Self { width, current_level } = self;
                let current_level = ctx.track_eq(&current_level);
                let weights = ctx
                    .memo(|| {
                        let current_level = NonZero::new(*current_level)
                            .expect("Level must be non-zero");
                        let next_level = current_level
                            .checked_add(1)
                            .unwrap()
                            .min(NonZero::new(10).unwrap());
                        let mut current_weights = level_rarity_weight(current_level);
                        let current_total_weight: usize = current_weights.iter().sum();
                        current_weights
                            .iter_mut()
                            .for_each(|weight| {
                                *weight = (*weight as f32 / current_total_weight as f32
                                    * 100.0)
                                    .round() as usize;
                            });
                        let mut next_weights = level_rarity_weight(next_level);
                        let next_total_weight: usize = next_weights.iter().sum();
                        next_weights
                            .iter_mut()
                            .for_each(|weight| {
                                *weight = (*weight as f32 / next_total_weight as f32
                                    * 100.0)
                                    .round() as usize;
                            });
                        [
                            [current_weights[0], next_weights[0]],
                            [current_weights[1], next_weights[1]],
                            [current_weights[2], next_weights[2]],
                            [current_weights[3], next_weights[3]],
                        ]
                    });
                let wh = Wh::new(width, CONTAINER_HEIGHT);
                ctx.compose(|ctx| {
                    table::vertical([
                        table::fixed(
                            LINE_HEIGHT,
                            table::horizontal([
                                table::fixed(PADDING, |_, _| {}),
                                table::fixed(
                                    RARITY_LABEL_WIDTH,
                                    |wh, ctx| {
                                        ctx.add(
                                            Icon::new(IconKind::Rarity {
                                                    rarity: Rarity::Common,
                                                })
                                                .size(IconSize::Medium)
                                                .wh(wh),
                                        );
                                    },
                                ),
                                table::ratio(1, |_, _| {}),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0}%", weights[0][0]))
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(">>>".to_string())
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0}%", weights[0][1]))
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                            ]),
                        ),
                        table::fixed(
                            LINE_HEIGHT,
                            table::horizontal([
                                table::fixed(PADDING, |_, _| {}),
                                table::fixed(
                                    RARITY_LABEL_WIDTH,
                                    |wh, ctx| {
                                        ctx.add(
                                            Icon::new(IconKind::Rarity {
                                                    rarity: Rarity::Rare,
                                                })
                                                .size(IconSize::Medium)
                                                .wh(wh),
                                        );
                                    },
                                ),
                                table::ratio(1, |_, _| {}),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0}%", weights[1][0]))
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(">>>".to_string())
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0}%", weights[1][1]))
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                            ]),
                        ),
                        table::fixed(
                            LINE_HEIGHT,
                            table::horizontal([
                                table::fixed(PADDING, |_, _| {}),
                                table::fixed(
                                    RARITY_LABEL_WIDTH,
                                    |wh, ctx| {
                                        ctx.add(
                                            Icon::new(IconKind::Rarity {
                                                    rarity: Rarity::Epic,
                                                })
                                                .size(IconSize::Medium)
                                                .wh(wh),
                                        );
                                    },
                                ),
                                table::ratio(1, |_, _| {}),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0}%", weights[2][0]))
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(">>>".to_string())
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0}%", weights[2][1]))
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                            ]),
                        ),
                        table::fixed(
                            LINE_HEIGHT,
                            table::horizontal([
                                table::fixed(PADDING, |_, _| {}),
                                table::fixed(
                                    RARITY_LABEL_WIDTH,
                                    |wh, ctx| {
                                        ctx.add(
                                            Icon::new(IconKind::Rarity {
                                                    rarity: Rarity::Legendary,
                                                })
                                                .size(IconSize::Medium)
                                                .wh(wh),
                                        );
                                    },
                                ),
                                table::ratio(1, |_, _| {}),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0}%", weights[3][0]))
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(">>>".to_string())
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                                table::ratio(
                                    1,
                                    |wh, ctx| {
                                        ctx.add(
                                            paragraph(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("{0}%", weights[3][1]))
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                            ]),
                        ),
                    ])(wh, ctx);
                });
                ctx.add(
                    simple_rect(wh, palette::OUTLINE, 1.px(), palette::SURFACE_CONTAINER),
                );
            }
        }
    }
    mod stage {
        use crate::{
            game_state::{is_boss_stage, use_game_state},
            icon::{Icon, IconKind, IconSize},
            l10n::ui::TopBarText, palette, theme::typography::headline,
        };
        use namui::*;
        use namui_prebuilt::{simple_rect, table};
        use std::iter::once;
        const PADDING: Px = px(8.);
        pub struct StageIndicator {
            pub wh: Wh<Px>,
            pub stage: usize,
        }
        impl Component for StageIndicator {
            fn render(self, ctx: &RenderCtx) {
                let Self { wh, stage } = self;
                let game_state = use_game_state(ctx);
                ctx.compose(|ctx| {
                    table::horizontal(
                        once(
                                table::fixed(
                                    px(128.),
                                    |wh, ctx| {
                                        ctx.add(
                                            headline(
                                                    ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(
                                                            format_args!(
                                                                "{0} {1}",
                                                                game_state.text().ui(TopBarText::Stage),
                                                                stage,
                                                            ),
                                                        )
                                                    }),
                                                )
                                                .size(crate::theme::typography::FontSize::Medium)
                                                .align(crate::theme::typography::TextAlign::Center {
                                                    wh,
                                                })
                                                .build(),
                                        );
                                    },
                                ),
                            )
                            .chain(
                                (0..5)
                                    .map(|offset| {
                                        table::fixed(
                                            wh.height,
                                            table::padding(
                                                PADDING,
                                                move |wh, ctx| {
                                                    let kind = match is_boss_stage(stage + offset as usize) {
                                                        true => IconKind::EnemyBoss,
                                                        false => IconKind::EnemyNormal,
                                                    };
                                                    ctx.add(Icon::new(kind).size(IconSize::Large).wh(wh));
                                                },
                                            ),
                                        )
                                    }),
                            ),
                    )(wh, ctx);
                });
                ctx.add(
                    simple_rect(
                        wh,
                        Color::TRANSPARENT,
                        0.px(),
                        palette::SURFACE_CONTAINER,
                    ),
                );
            }
        }
    }
    use crate::game_state::use_game_state;
    use namui::*;
    use namui_prebuilt::table;
    const TOP_BAR_HEIGHT: Px = px(48.);
    const ITEM_WIDTH: Px = px(256.);
    const PADDING: Px = px(8.);
    pub struct TopBar {
        pub screen_wh: Wh<Px>,
    }
    impl Component for TopBar {
        fn render(self, ctx: &RenderCtx) {
            let Self { screen_wh } = self;
            let game_state = use_game_state(ctx);
            ctx.compose(|ctx| {
                table::horizontal([
                    table::ratio(1, |_, _| {}),
                    table::fixed(
                        ITEM_WIDTH,
                        |wh, ctx| {
                            ctx.add(crate::top_bar::hp_and_gold::HPAndGoldIndicator {
                                wh,
                                hp: (game_state.hp / 100.0).clamp(0.0, 1.0),
                                gold: game_state.gold,
                            });
                        },
                    ),
                    table::fixed(PADDING, |_, _| {}),
                    table::fixed(
                        ITEM_WIDTH,
                        |wh, ctx| {
                            ctx.add(crate::top_bar::stage::StageIndicator {
                                wh,
                                stage: game_state.stage,
                            });
                        },
                    ),
                    table::fixed(PADDING, |_, _| {}),
                    table::fixed(
                        ITEM_WIDTH,
                        |wh, ctx| {
                            ctx.add(crate::top_bar::level::LevelIndicator {
                                wh,
                                level: game_state.level.get(),
                                level_up_cost: game_state.level_up_cost(),
                                gold: game_state.gold,
                            });
                        },
                    ),
                    table::ratio(1, |_, _| {}),
                ])(Wh::new(screen_wh.width, TOP_BAR_HEIGHT), ctx);
            });
        }
    }
}
mod upgrade_board {
    mod components {
        use super::data_conversion::{UpgradeInfo, get_upgrade_infos};
        use crate::{
            game_state::use_game_state, l10n::upgrade_board::UpgradeBoardText, palette,
            theme::typography::{FontSize, TextAlign, headline, paragraph},
        };
        use namui::*;
        use namui_prebuilt::{list_view, simple_rect, table::{self, horizontal}};
        const SCROLL_BAR_WIDTH: Px = px(4.0);
        const TITLE_HEIGHT: Px = px(36.0);
        const PADDING: Px = px(4.0);
        const UPGRADE_BOARD_WH: Wh<Px> = Wh {
            width: px(640.0),
            height: px(480.0),
        };
        const ITEM_HEIGHT: Px = px(48.0);
        pub struct UpgradeBoardModal;
        impl Component for UpgradeBoardModal {
            fn render(self, ctx: &namui::RenderCtx) {
                let screen_wh = screen::size().into_type::<Px>();
                ctx.compose(|ctx| {
                    let offset = ((screen_wh - UPGRADE_BOARD_WH) * 0.5).to_xy();
                    ctx.translate(offset).add(UpgradeBoard {});
                    ctx.add(
                        simple_rect(
                                screen_wh,
                                Color::TRANSPARENT,
                                0.px(),
                                Color::from_u8(0, 0, 0, 128),
                            )
                            .attach_event(|event| match event {
                                Event::MouseDown { event }
                                | Event::MouseMove { event }
                                | Event::MouseUp { event } => {
                                    event.stop_propagation();
                                }
                                Event::Wheel { event } => {
                                    event.stop_propagation();
                                }
                                _ => {}
                            }),
                    );
                });
            }
        }
        pub struct UpgradeBoard {}
        impl Component for UpgradeBoard {
            fn render(self, ctx: &namui::RenderCtx) {
                let game_state = use_game_state(ctx);
                let upgrade_infos = get_upgrade_infos(
                    &game_state.upgrade_state,
                    &game_state.text(),
                );
                ctx.compose(|ctx| {
                    table::padding(
                        PADDING,
                        table::vertical([
                            table::fixed(
                                TITLE_HEIGHT,
                                |wh, ctx| {
                                    ctx.add(
                                        headline(
                                                game_state
                                                    .text()
                                                    .upgrade_board(UpgradeBoardText::Title)
                                                    .to_string(),
                                            )
                                            .size(FontSize::Large)
                                            .align(TextAlign::Center { wh })
                                            .max_width(wh.width)
                                            .build(),
                                    );
                                },
                            ),
                            table::ratio(
                                1,
                                |wh, ctx| {
                                    let item_wh = Wh {
                                        width: wh.width - SCROLL_BAR_WIDTH,
                                        height: ITEM_HEIGHT,
                                    };
                                    ctx.add(list_view::AutoListView {
                                        height: wh.height,
                                        scroll_bar_width: SCROLL_BAR_WIDTH,
                                        item_wh,
                                        items: upgrade_infos
                                            .into_iter()
                                            .enumerate()
                                            .map(|(index, upgrade_info)| {
                                                (
                                                    index,
                                                    UpgradeItem {
                                                        wh: item_wh,
                                                        upgrade_info,
                                                    },
                                                )
                                            }),
                                    });
                                },
                            ),
                        ]),
                    )(UPGRADE_BOARD_WH, ctx);
                });
                ctx.add(
                    rect(RectParam {
                        rect: UPGRADE_BOARD_WH.to_rect(),
                        style: RectStyle {
                            stroke: Some(RectStroke {
                                color: palette::OUTLINE,
                                width: 1.px(),
                                border_position: BorderPosition::Inside,
                            }),
                            fill: Some(RectFill {
                                color: palette::SURFACE_CONTAINER,
                            }),
                            round: Some(RectRound {
                                radius: palette::ROUND,
                            }),
                        },
                    }),
                );
            }
        }
        struct UpgradeItem {
            wh: Wh<Px>,
            upgrade_info: UpgradeInfo,
        }
        impl Component for UpgradeItem {
            fn render(self, ctx: &RenderCtx) {
                let Self { wh, upgrade_info } = self;
                ctx.compose(|ctx| {
                    table::padding(
                        PADDING,
                        |wh, ctx| {
                            ctx.compose(|ctx| {
                                horizontal([
                                    table::fixed(
                                        wh.height,
                                        table::padding(
                                            PADDING,
                                            |wh, ctx| {
                                                ctx.add(upgrade_info.upgrade_kind.thumbnail(wh));
                                            },
                                        ),
                                    ),
                                    table::fixed(PADDING, |_, _| {}),
                                    table::ratio(
                                        1,
                                        table::padding(
                                            PADDING,
                                            |wh, ctx| {
                                                ctx.add(
                                                    paragraph(&upgrade_info.description)
                                                        .size(FontSize::Medium)
                                                        .align(TextAlign::LeftTop)
                                                        .max_width(wh.width)
                                                        .build_rich(),
                                                );
                                            },
                                        ),
                                    ),
                                ])(wh, ctx);
                            });
                            ctx.add(
                                simple_rect(
                                    wh,
                                    palette::OUTLINE,
                                    1.px(),
                                    palette::SURFACE_CONTAINER_HIGH,
                                ),
                            );
                        },
                    )(wh, ctx);
                });
            }
        }
    }
    mod data_conversion {
        use crate::{
            game_state::upgrade::{
                LOW_CARD_COUNT, TowerSelectUpgradeTarget, TowerUpgradeState,
                TowerUpgradeTarget, UpgradeKind, UpgradeState,
            },
            l10n::upgrade_board::UpgradeBoardText, *,
        };
        pub struct UpgradeInfo {
            pub upgrade_kind: UpgradeKind,
            pub description: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UpgradeInfo {
            #[inline]
            fn clone(&self) -> UpgradeInfo {
                UpgradeInfo {
                    upgrade_kind: ::core::clone::Clone::clone(&self.upgrade_kind),
                    description: ::core::clone::Clone::clone(&self.description),
                }
            }
        }
        impl bincode::Encode for UpgradeInfo {
            fn encode<__E: bincode::enc::Encoder>(
                &self,
                encoder: &mut __E,
            ) -> core::result::Result<(), bincode::error::EncodeError> {
                bincode::Encode::encode(&self.upgrade_kind, encoder)?;
                bincode::Encode::encode(&self.description, encoder)?;
                Ok(())
            }
        }
        impl bincode::Decode<()> for UpgradeInfo {
            fn decode<__D: bincode::de::Decoder<Context = ()>>(
                decoder: &mut __D,
            ) -> core::result::Result<Self, bincode::error::DecodeError> {
                Ok(Self {
                    upgrade_kind: bincode::Decode::decode(decoder)?,
                    description: bincode::Decode::decode(decoder)?,
                })
            }
        }
        impl Serialize for UpgradeInfo {
            fn serialize(&self, buf: &mut Vec<u8>) {
                buf.write_string(std::any::type_name::<Self>());
                self.serialize_without_name(buf);
            }
            fn serialize_without_name(&self, buf: &mut Vec<u8>) {
                buf.write_string("upgrade_kind");
                self.upgrade_kind.serialize_without_name(buf);
                buf.write_string("description");
                self.description.serialize_without_name(buf);
            }
        }
        impl Deserialize for UpgradeInfo {
            fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
                buf.read_name(std::any::type_name::<Self>())?;
                Self::deserialize_without_name(buf)
            }
            fn deserialize_without_name(
                buf: &mut &[u8],
            ) -> Result<Self, DeserializeError> {
                let field_name = buf.read_name("upgrade_kind")?;
                let upgrade_kind = Deserialize::deserialize_without_name(buf)?;
                let field_name = buf.read_name("description")?;
                let description = Deserialize::deserialize_without_name(buf)?;
                Ok(Self { upgrade_kind, description })
            }
        }
        pub fn get_upgrade_infos(
            state: &UpgradeState,
            text: &crate::l10n::TextManager,
        ) -> Vec<UpgradeInfo> {
            let mut infos = ::alloc::vec::Vec::new();
            add_basic_upgrades(state, text, &mut infos);
            add_tower_select_upgrades(state, text, &mut infos);
            add_tower_upgrades(state, text, &mut infos);
            infos
        }
        fn add_basic_upgrades(
            state: &UpgradeState,
            text: &crate::l10n::TextManager,
            infos: &mut Vec<UpgradeInfo>,
        ) {
            if state.gold_earn_plus != 0 {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::GoldEarnPlus,
                        description: text
                            .upgrade_board(UpgradeBoardText::GoldEarnPlus {
                                amount: state.gold_earn_plus,
                            }),
                    });
            }
            if state.shop_slot_expand != 0 {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::ShopSlotExpansion,
                        description: text
                            .upgrade_board(UpgradeBoardText::ShopSlotExpand {
                                amount: state.shop_slot_expand,
                            }),
                    });
            }
            if state.quest_slot_expand != 0 {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::QuestSlotExpansion,
                        description: text
                            .upgrade_board(UpgradeBoardText::QuestSlotExpand {
                                amount: state.quest_slot_expand,
                            }),
                    });
            }
            if state.quest_board_slot_expand != 0 {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::QuestBoardExpansion,
                        description: text
                            .upgrade_board(UpgradeBoardText::QuestBoardSlotExpand {
                                amount: state.quest_board_slot_expand,
                            }),
                    });
            }
            if state.reroll_chance_plus != 0 {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::RerollCountPlus,
                        description: text
                            .upgrade_board(UpgradeBoardText::RerollChancePlus {
                                amount: state.reroll_chance_plus,
                            }),
                    });
            }
            if state.shop_item_price_minus != 0 {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::ShopItemPriceMinus,
                        description: text
                            .upgrade_board(UpgradeBoardText::ShopItemPriceMinus {
                                amount: state.shop_item_price_minus,
                            }),
                    });
            }
            if state.shop_refresh_chance_plus != 0 {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::ShopRefreshPlus,
                        description: text
                            .upgrade_board(UpgradeBoardText::ShopRefreshChancePlus {
                                amount: state.shop_refresh_chance_plus,
                            }),
                    });
            }
            if state.quest_board_refresh_chance_plus != 0 {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::QuestBoardRefreshPlus,
                        description: text
                            .upgrade_board(UpgradeBoardText::QuestBoardRefreshChancePlus {
                                amount: state.quest_board_refresh_chance_plus,
                            }),
                    });
            }
            if state.shorten_straight_flush_to_4_cards {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::ShortenStraightFlushTo4Cards,
                        description: text
                            .upgrade_board(
                                UpgradeBoardText::ShortenStraightFlushTo4Cards,
                            ),
                    });
            }
            if state.skip_rank_for_straight {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::SkipRankForStraight,
                        description: text
                            .upgrade_board(UpgradeBoardText::SkipRankForStraight),
                    });
            }
            if state.treat_suits_as_same {
                infos
                    .push(UpgradeInfo {
                        upgrade_kind: UpgradeKind::TreatSuitsAsSame,
                        description: text
                            .upgrade_board(UpgradeBoardText::TreatSuitsAsSame),
                    });
            }
        }
        fn add_tower_select_upgrades(
            state: &UpgradeState,
            text: &crate::l10n::TextManager,
            infos: &mut Vec<UpgradeInfo>,
        ) {
            for (target, tower_upgrade_state) in &state.tower_select_upgrade_states {
                let target_prefix = match target {
                    TowerSelectUpgradeTarget::LowCard => {
                        text.upgrade_board(UpgradeBoardText::TowerSelectLowCard {
                            amount: LOW_CARD_COUNT,
                        })
                    }
                    TowerSelectUpgradeTarget::NoReroll => {
                        text.upgrade_board(UpgradeBoardText::TowerSelectNoReroll)
                    }
                    TowerSelectUpgradeTarget::Reroll => {
                        text.upgrade_board(UpgradeBoardText::TowerSelectReroll)
                    }
                };
                if tower_upgrade_state.damage_plus != 0.0 {
                    let upgrade_kind = match target {
                        TowerSelectUpgradeTarget::LowCard => {
                            UpgradeKind::LowCardTowerDamagePlus {
                                damage_plus: tower_upgrade_state.damage_plus,
                            }
                        }
                        TowerSelectUpgradeTarget::NoReroll => {
                            UpgradeKind::NoRerollTowerAttackDamagePlus {
                                damage_plus: tower_upgrade_state.damage_plus,
                            }
                        }
                        TowerSelectUpgradeTarget::Reroll => {
                            UpgradeKind::RerollTowerAttackDamagePlus {
                                damage_plus: tower_upgrade_state.damage_plus,
                            }
                        }
                    };
                    let suffix = text
                        .upgrade_board(UpgradeBoardText::DamagePlus {
                            amount: tower_upgrade_state.damage_plus,
                        });
                    infos
                        .push(UpgradeInfo {
                            upgrade_kind,
                            description: ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0} {1}", target_prefix, suffix),
                                )
                            }),
                        });
                }
                if tower_upgrade_state.damage_multiplier != 1.0 {
                    let upgrade_kind = match target {
                        TowerSelectUpgradeTarget::LowCard => {
                            UpgradeKind::LowCardTowerDamageMultiply {
                                damage_multiplier: tower_upgrade_state.damage_multiplier,
                            }
                        }
                        TowerSelectUpgradeTarget::NoReroll => {
                            UpgradeKind::NoRerollTowerAttackDamageMultiply {
                                damage_multiplier: tower_upgrade_state.damage_multiplier,
                            }
                        }
                        TowerSelectUpgradeTarget::Reroll => {
                            UpgradeKind::RerollTowerAttackDamageMultiply {
                                damage_multiplier: tower_upgrade_state.damage_multiplier,
                            }
                        }
                    };
                    let suffix = text
                        .upgrade_board(UpgradeBoardText::DamageMultiplier {
                            amount: tower_upgrade_state.damage_multiplier,
                        });
                    infos
                        .push(UpgradeInfo {
                            upgrade_kind,
                            description: ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0} {1}", target_prefix, suffix),
                                )
                            }),
                        });
                }
                if tower_upgrade_state.speed_plus != 0.0 {
                    let upgrade_kind = match target {
                        TowerSelectUpgradeTarget::LowCard => {
                            UpgradeKind::LowCardTowerAttackSpeedPlus {
                                speed_plus: tower_upgrade_state.speed_plus,
                            }
                        }
                        TowerSelectUpgradeTarget::NoReroll => {
                            UpgradeKind::NoRerollTowerAttackSpeedPlus {
                                speed_plus: tower_upgrade_state.speed_plus,
                            }
                        }
                        TowerSelectUpgradeTarget::Reroll => {
                            UpgradeKind::RerollTowerAttackSpeedPlus {
                                speed_plus: tower_upgrade_state.speed_plus,
                            }
                        }
                    };
                    let suffix = text
                        .upgrade_board(UpgradeBoardText::SpeedPlus {
                            amount: tower_upgrade_state.speed_plus,
                        });
                    infos
                        .push(UpgradeInfo {
                            upgrade_kind,
                            description: ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0} {1}", target_prefix, suffix),
                                )
                            }),
                        });
                }
                if tower_upgrade_state.speed_multiplier != 1.0 {
                    let upgrade_kind = match target {
                        TowerSelectUpgradeTarget::LowCard => {
                            UpgradeKind::LowCardTowerAttackSpeedMultiply {
                                speed_multiplier: tower_upgrade_state.speed_multiplier,
                            }
                        }
                        TowerSelectUpgradeTarget::NoReroll => {
                            UpgradeKind::NoRerollTowerAttackSpeedMultiply {
                                speed_multiplier: tower_upgrade_state.speed_multiplier,
                            }
                        }
                        TowerSelectUpgradeTarget::Reroll => {
                            UpgradeKind::RerollTowerAttackSpeedMultiply {
                                speed_multiplier: tower_upgrade_state.speed_multiplier,
                            }
                        }
                    };
                    let suffix = text
                        .upgrade_board(UpgradeBoardText::SpeedMultiplier {
                            amount: tower_upgrade_state.speed_multiplier,
                        });
                    infos
                        .push(UpgradeInfo {
                            upgrade_kind,
                            description: ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0} {1}", target_prefix, suffix),
                                )
                            }),
                        });
                }
                if tower_upgrade_state.range_plus != 0.0 {
                    let upgrade_kind = match target {
                        TowerSelectUpgradeTarget::LowCard => {
                            UpgradeKind::LowCardTowerAttackRangePlus {
                                range_plus: tower_upgrade_state.range_plus,
                            }
                        }
                        TowerSelectUpgradeTarget::NoReroll => {
                            UpgradeKind::NoRerollTowerAttackRangePlus {
                                range_plus: tower_upgrade_state.range_plus,
                            }
                        }
                        TowerSelectUpgradeTarget::Reroll => {
                            UpgradeKind::RerollTowerAttackRangePlus {
                                range_plus: tower_upgrade_state.range_plus,
                            }
                        }
                    };
                    let suffix = text
                        .upgrade_board(UpgradeBoardText::RangePlus {
                            amount: tower_upgrade_state.range_plus,
                        });
                    infos
                        .push(UpgradeInfo {
                            upgrade_kind,
                            description: ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0} {1}", target_prefix, suffix),
                                )
                            }),
                        });
                }
            }
        }
        fn add_tower_upgrades(
            state: &UpgradeState,
            text: &crate::l10n::TextManager,
            infos: &mut Vec<UpgradeInfo>,
        ) {
            for (target, tower_upgrade_state) in &state.tower_upgrade_states {
                let target_prefix = match target {
                    TowerUpgradeTarget::Rank { rank } => {
                        text.upgrade_board(UpgradeBoardText::TowerUpgradeRank {
                            name: rank.to_string(),
                        })
                    }
                    TowerUpgradeTarget::Suit { suit } => {
                        text.upgrade_board(UpgradeBoardText::TowerUpgradeSuit {
                            name: suit.to_string(),
                        })
                    }
                    TowerUpgradeTarget::TowerKind { tower_kind } => {
                        text.upgrade_board(UpgradeBoardText::TowerUpgradeKind {
                            name: text.tower(tower_kind.to_text()).to_string(),
                        })
                    }
                    TowerUpgradeTarget::EvenOdd { even } => {
                        let name = if *even { "짝수" } else { "홀수" };
                        text.upgrade_board(UpgradeBoardText::TowerUpgradeEvenOdd {
                            name: name.to_string(),
                        })
                    }
                    TowerUpgradeTarget::FaceNumber { face } => {
                        let name = if *face { "그림" } else { "숫자" };
                        text.upgrade_board(UpgradeBoardText::TowerUpgradeFaceNumber {
                            name: name.to_string(),
                        })
                    }
                };
                add_tower_damage_upgrades(
                    target,
                    tower_upgrade_state,
                    &target_prefix,
                    text,
                    infos,
                );
                add_tower_speed_upgrades(
                    target,
                    tower_upgrade_state,
                    &target_prefix,
                    text,
                    infos,
                );
                add_tower_range_upgrades(
                    target,
                    tower_upgrade_state,
                    &target_prefix,
                    text,
                    infos,
                );
            }
        }
        fn add_tower_damage_upgrades(
            target: &TowerUpgradeTarget,
            tower_upgrade_state: &TowerUpgradeState,
            target_prefix: &str,
            text: &crate::l10n::TextManager,
            infos: &mut Vec<UpgradeInfo>,
        ) {
            if tower_upgrade_state.damage_plus != 0.0 {
                let upgrade_kind = match target {
                    TowerUpgradeTarget::Rank { rank } => {
                        UpgradeKind::RankAttackDamagePlus {
                            rank: *rank,
                            damage_plus: tower_upgrade_state.damage_plus,
                        }
                    }
                    TowerUpgradeTarget::Suit { suit } => {
                        UpgradeKind::SuitAttackDamagePlus {
                            suit: *suit,
                            damage_plus: tower_upgrade_state.damage_plus,
                        }
                    }
                    TowerUpgradeTarget::TowerKind { tower_kind } => {
                        UpgradeKind::HandAttackDamagePlus {
                            tower_kind: *tower_kind,
                            damage_plus: tower_upgrade_state.damage_plus,
                        }
                    }
                    TowerUpgradeTarget::EvenOdd { even } => {
                        UpgradeKind::EvenOddTowerAttackDamagePlus {
                            even: *even,
                            damage_plus: tower_upgrade_state.damage_plus,
                        }
                    }
                    TowerUpgradeTarget::FaceNumber { face } => {
                        UpgradeKind::FaceNumberCardTowerAttackDamagePlus {
                            face: *face,
                            damage_plus: tower_upgrade_state.damage_plus,
                        }
                    }
                };
                let suffix = text
                    .upgrade_board(UpgradeBoardText::DamagePlus {
                        amount: tower_upgrade_state.damage_plus,
                    });
                infos
                    .push(UpgradeInfo {
                        upgrade_kind,
                        description: ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0} {1}", target_prefix, suffix),
                            )
                        }),
                    });
            }
            if tower_upgrade_state.damage_multiplier != 1.0 {
                let upgrade_kind = match target {
                    TowerUpgradeTarget::Rank { rank } => {
                        UpgradeKind::RankAttackDamageMultiply {
                            rank: *rank,
                            damage_multiplier: tower_upgrade_state.damage_multiplier,
                        }
                    }
                    TowerUpgradeTarget::Suit { suit } => {
                        UpgradeKind::SuitAttackDamageMultiply {
                            suit: *suit,
                            damage_multiplier: tower_upgrade_state.damage_multiplier,
                        }
                    }
                    TowerUpgradeTarget::TowerKind { tower_kind } => {
                        UpgradeKind::HandAttackDamageMultiply {
                            tower_kind: *tower_kind,
                            damage_multiplier: tower_upgrade_state.damage_multiplier,
                        }
                    }
                    TowerUpgradeTarget::EvenOdd { even } => {
                        UpgradeKind::EvenOddTowerAttackDamageMultiply {
                            even: *even,
                            damage_multiplier: tower_upgrade_state.damage_multiplier,
                        }
                    }
                    TowerUpgradeTarget::FaceNumber { face } => {
                        UpgradeKind::FaceNumberCardTowerAttackDamageMultiply {
                            face: *face,
                            damage_multiplier: tower_upgrade_state.damage_multiplier,
                        }
                    }
                };
                let suffix = text
                    .upgrade_board(UpgradeBoardText::DamageMultiplier {
                        amount: tower_upgrade_state.damage_multiplier,
                    });
                infos
                    .push(UpgradeInfo {
                        upgrade_kind,
                        description: ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0} {1}", target_prefix, suffix),
                            )
                        }),
                    });
            }
        }
        fn add_tower_speed_upgrades(
            target: &TowerUpgradeTarget,
            tower_upgrade_state: &TowerUpgradeState,
            target_prefix: &str,
            text: &crate::l10n::TextManager,
            infos: &mut Vec<UpgradeInfo>,
        ) {
            if tower_upgrade_state.speed_plus != 0.0 {
                let upgrade_kind = match target {
                    TowerUpgradeTarget::Rank { rank } => {
                        UpgradeKind::RankAttackSpeedPlus {
                            rank: *rank,
                            speed_plus: tower_upgrade_state.speed_plus,
                        }
                    }
                    TowerUpgradeTarget::Suit { suit } => {
                        UpgradeKind::SuitAttackSpeedPlus {
                            suit: *suit,
                            speed_plus: tower_upgrade_state.speed_plus,
                        }
                    }
                    TowerUpgradeTarget::TowerKind { tower_kind } => {
                        UpgradeKind::HandAttackSpeedPlus {
                            tower_kind: *tower_kind,
                            speed_plus: tower_upgrade_state.speed_plus,
                        }
                    }
                    TowerUpgradeTarget::EvenOdd { even } => {
                        UpgradeKind::EvenOddTowerAttackSpeedPlus {
                            even: *even,
                            speed_plus: tower_upgrade_state.speed_plus,
                        }
                    }
                    TowerUpgradeTarget::FaceNumber { face } => {
                        UpgradeKind::FaceNumberCardTowerAttackSpeedPlus {
                            face: *face,
                            speed_plus: tower_upgrade_state.speed_plus,
                        }
                    }
                };
                let suffix = text
                    .upgrade_board(UpgradeBoardText::SpeedPlus {
                        amount: tower_upgrade_state.speed_plus,
                    });
                infos
                    .push(UpgradeInfo {
                        upgrade_kind,
                        description: ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0} {1}", target_prefix, suffix),
                            )
                        }),
                    });
            }
            if tower_upgrade_state.speed_multiplier != 1.0 {
                let upgrade_kind = match target {
                    TowerUpgradeTarget::Rank { rank } => {
                        UpgradeKind::RankAttackSpeedMultiply {
                            rank: *rank,
                            speed_multiplier: tower_upgrade_state.speed_multiplier,
                        }
                    }
                    TowerUpgradeTarget::Suit { suit } => {
                        UpgradeKind::SuitAttackSpeedMultiply {
                            suit: *suit,
                            speed_multiplier: tower_upgrade_state.speed_multiplier,
                        }
                    }
                    TowerUpgradeTarget::TowerKind { tower_kind } => {
                        UpgradeKind::HandAttackSpeedMultiply {
                            tower_kind: *tower_kind,
                            speed_multiplier: tower_upgrade_state.speed_multiplier,
                        }
                    }
                    TowerUpgradeTarget::EvenOdd { even } => {
                        UpgradeKind::EvenOddTowerAttackSpeedMultiply {
                            even: *even,
                            speed_multiplier: tower_upgrade_state.speed_multiplier,
                        }
                    }
                    TowerUpgradeTarget::FaceNumber { face } => {
                        UpgradeKind::FaceNumberCardTowerAttackSpeedMultiply {
                            face: *face,
                            speed_multiplier: tower_upgrade_state.speed_multiplier,
                        }
                    }
                };
                let suffix = text
                    .upgrade_board(UpgradeBoardText::SpeedMultiplier {
                        amount: tower_upgrade_state.speed_multiplier,
                    });
                infos
                    .push(UpgradeInfo {
                        upgrade_kind,
                        description: ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0} {1}", target_prefix, suffix),
                            )
                        }),
                    });
            }
        }
        fn add_tower_range_upgrades(
            target: &TowerUpgradeTarget,
            tower_upgrade_state: &TowerUpgradeState,
            target_prefix: &str,
            text: &crate::l10n::TextManager,
            infos: &mut Vec<UpgradeInfo>,
        ) {
            if tower_upgrade_state.range_plus != 0.0 {
                let upgrade_kind = match target {
                    TowerUpgradeTarget::Rank { rank } => {
                        UpgradeKind::RankAttackRangePlus {
                            rank: *rank,
                            range_plus: tower_upgrade_state.range_plus,
                        }
                    }
                    TowerUpgradeTarget::Suit { suit } => {
                        UpgradeKind::SuitAttackRangePlus {
                            suit: *suit,
                            range_plus: tower_upgrade_state.range_plus,
                        }
                    }
                    TowerUpgradeTarget::TowerKind { tower_kind } => {
                        UpgradeKind::HandAttackRangePlus {
                            tower_kind: *tower_kind,
                            range_plus: tower_upgrade_state.range_plus,
                        }
                    }
                    TowerUpgradeTarget::EvenOdd { even } => {
                        UpgradeKind::EvenOddTowerAttackRangePlus {
                            even: *even,
                            range_plus: tower_upgrade_state.range_plus,
                        }
                    }
                    TowerUpgradeTarget::FaceNumber { face } => {
                        UpgradeKind::FaceNumberCardTowerAttackRangePlus {
                            face: *face,
                            range_plus: tower_upgrade_state.range_plus,
                        }
                    }
                };
                let suffix = text
                    .upgrade_board(UpgradeBoardText::RangePlus {
                        amount: tower_upgrade_state.range_plus,
                    });
                infos
                    .push(UpgradeInfo {
                        upgrade_kind,
                        description: ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0} {1}", target_prefix, suffix),
                            )
                        }),
                    });
            }
        }
    }
    pub use components::UpgradeBoardModal;
}
mod upgrade_select {
    use crate::icon::{Icon, IconKind, IconSize};
    use crate::theme::button::Button;
    use crate::{
        game_state::{mutate_game_state, upgrade::Upgrade, use_game_state},
        l10n::upgrade::UpgradeKindText, palette,
        theme::typography::{FontSize, TextAlign, headline, paragraph},
    };
    use namui::*;
    use namui_prebuilt::table::{self, ratio_no_clip};
    const PADDING: Px = px(4.0);
    const UPGRADE_SELECT_WH: Wh<Px> = Wh {
        width: px(640.0),
        height: px(480.0),
    };
    const UPGRADE_SELECT_BUTTON_WH: Wh<Px> = Wh {
        width: px(64.0),
        height: px(36.0),
    };
    pub struct UpgradeSelectModal<'a> {
        pub screen_wh: Wh<Px>,
        pub upgrades: &'a [Upgrade],
    }
    impl Component for UpgradeSelectModal<'_> {
        fn render(self, ctx: &RenderCtx) {
            let Self { screen_wh, upgrades } = self;
            let (opened, set_opened) = ctx.state(|| true);
            let toggle_open = || {
                set_opened.mutate(|opened| *opened = !*opened);
            };
            let on_upgrade_select = |upgrade: Upgrade| {
                mutate_game_state(move |state| {
                    state.upgrade(upgrade);
                    state.goto_next_stage();
                });
            };
            let offset = ((screen_wh - UPGRADE_SELECT_WH) * 0.5).to_xy();
            ctx.compose(|ctx| {
                ctx.translate(offset)
                    .add(UpgradeSelectOpenButton {
                        opened: *opened,
                        toggle_open: &toggle_open,
                    });
            });
            ctx.compose(|ctx| {
                if !*opened {
                    return;
                }
                ctx.translate(offset)
                    .add(UpgradeSelect {
                        upgrades,
                        on_upgrade_select: &on_upgrade_select,
                    });
            });
        }
    }
    struct UpgradeSelectOpenButton<'a> {
        opened: bool,
        toggle_open: &'a dyn Fn(),
    }
    impl Component for UpgradeSelectOpenButton<'_> {
        fn render(self, ctx: &RenderCtx) {
            let Self { opened, toggle_open } = self;
            ctx.compose(|ctx| {
                ctx.translate((0.px(), UPGRADE_SELECT_BUTTON_WH.height))
                    .add(
                        Button::new(
                            UPGRADE_SELECT_BUTTON_WH,
                            &|| {
                                toggle_open();
                            },
                            &|wh, text_color, ctx| {
                                ctx.add(
                                    namui::text(TextParam {
                                        text: ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "강화 선택 {0}",
                                                    if opened { "🔼" } else { "🔽" },
                                                ),
                                            )
                                        }),
                                        x: wh.width / 2.0,
                                        y: wh.height / 2.0,
                                        align: namui::TextAlign::Center,
                                        baseline: TextBaseline::Middle,
                                        font: Font {
                                            size: 14.int_px(),
                                            name: "NotoSansKR-Regular".to_string(),
                                        },
                                        style: TextStyle {
                                            color: text_color,
                                            background: None,
                                            border: None,
                                            drop_shadow: None,
                                            line_height_percent: 100.percent(),
                                            underline: None,
                                        },
                                        max_width: None,
                                    }),
                                );
                            },
                        ),
                    );
            });
        }
    }
    struct UpgradeSelect<'a> {
        upgrades: &'a [Upgrade],
        on_upgrade_select: &'a dyn Fn(Upgrade),
    }
    impl Component for UpgradeSelect<'_> {
        fn render(self, ctx: &RenderCtx) {
            let Self { upgrades, on_upgrade_select } = self;
            ctx.compose(|ctx| {
                table::padding_no_clip(
                    PADDING,
                    table::horizontal(
                        upgrades
                            .iter()
                            .map(|&upgrade| {
                                ratio_no_clip(
                                    1,
                                    move |wh, ctx| {
                                        ctx.add(UpgradeSelectItem {
                                            wh,
                                            upgrade,
                                            on_upgrade_select,
                                        });
                                    },
                                )
                            }),
                    ),
                )(UPGRADE_SELECT_WH, ctx);
            });
        }
    }
    struct UpgradeSelectItem<'a> {
        wh: Wh<Px>,
        upgrade: Upgrade,
        on_upgrade_select: &'a dyn Fn(Upgrade),
    }
    impl Component for UpgradeSelectItem<'_> {
        fn render(self, ctx: &RenderCtx) {
            let Self { wh, upgrade, on_upgrade_select } = self;
            let game_state = use_game_state(ctx);
            ctx.compose(|ctx| {
                table::padding_no_clip(
                    PADDING,
                    |wh, ctx| {
                        ctx.compose(|ctx| {
                            table::vertical([
                                table::fixed_no_clip(
                                    wh.width,
                                    table::padding_no_clip(
                                        PADDING,
                                        |wh, ctx| {
                                            ctx.translate((
                                                    (wh.width - IconSize::Large.px()) * 0.5,
                                                    -PADDING,
                                                ))
                                                .add(
                                                    Icon::new(IconKind::Rarity {
                                                            rarity: upgrade.rarity,
                                                        })
                                                        .size(IconSize::Large)
                                                        .wh(Wh::new(IconSize::Large.px(), PADDING)),
                                                );
                                            ctx.compose(|ctx| {
                                                table::padding(
                                                    PADDING,
                                                    |wh, ctx| {
                                                        ctx.add(upgrade.kind.thumbnail(wh));
                                                    },
                                                )(wh, ctx);
                                            });
                                            ctx.add(
                                                rect(RectParam {
                                                    rect: wh.to_rect(),
                                                    style: RectStyle {
                                                        stroke: None,
                                                        fill: Some(RectFill {
                                                            color: palette::SURFACE_CONTAINER_LOWEST,
                                                        }),
                                                        round: Some(RectRound {
                                                            radius: palette::ROUND,
                                                        }),
                                                    },
                                                }),
                                            );
                                        },
                                    ),
                                ),
                                table::ratio(
                                    1,
                                    table::padding(
                                        PADDING,
                                        |wh, ctx| {
                                            ctx.compose(|ctx| {
                                                table::padding(
                                                    PADDING,
                                                    |wh, ctx| {
                                                        table::vertical([
                                                            table::fit(
                                                                table::FitAlign::LeftTop,
                                                                |ctx| {
                                                                    ctx.add(
                                                                        headline(
                                                                                game_state
                                                                                    .text()
                                                                                    .upgrade_kind(UpgradeKindText::Name(&upgrade.kind)),
                                                                            )
                                                                            .size(FontSize::Small)
                                                                            .align(TextAlign::LeftTop)
                                                                            .max_width(wh.width)
                                                                            .build(),
                                                                    );
                                                                },
                                                            ),
                                                            table::fixed(PADDING, |_, _| {}),
                                                            table::ratio(
                                                                1,
                                                                |_wh, ctx| {
                                                                    ctx.add(
                                                                        paragraph(
                                                                                game_state
                                                                                    .text()
                                                                                    .upgrade_kind(UpgradeKindText::Description(&upgrade.kind)),
                                                                            )
                                                                            .size(FontSize::Medium)
                                                                            .align(TextAlign::LeftTop)
                                                                            .max_width(wh.width)
                                                                            .build(),
                                                                    );
                                                                },
                                                            ),
                                                        ])(wh, ctx);
                                                    },
                                                )(wh, ctx);
                                            });
                                            ctx.add(
                                                rect(RectParam {
                                                    rect: wh.to_rect(),
                                                    style: RectStyle {
                                                        stroke: Some(RectStroke {
                                                            color: palette::OUTLINE,
                                                            width: 1.px(),
                                                            border_position: BorderPosition::Inside,
                                                        }),
                                                        fill: Some(RectFill {
                                                            color: palette::SURFACE,
                                                        }),
                                                        round: Some(RectRound {
                                                            radius: palette::ROUND,
                                                        }),
                                                    },
                                                }),
                                            );
                                        },
                                    ),
                                ),
                            ])(wh, ctx);
                        });
                        ctx.add(
                            rect(RectParam {
                                    rect: wh.to_rect(),
                                    style: RectStyle {
                                        stroke: Some(RectStroke {
                                            color: palette::OUTLINE,
                                            width: 1.px(),
                                            border_position: BorderPosition::Inside,
                                        }),
                                        fill: Some(RectFill {
                                            color: palette::SURFACE_CONTAINER,
                                        }),
                                        round: Some(RectRound {
                                            radius: palette::ROUND,
                                        }),
                                    },
                                })
                                .attach_event(|event| {
                                    let Event::MouseDown { event } = event else {
                                        return;
                                    };
                                    if !event.is_local_xy_in() {
                                        return;
                                    }
                                    on_upgrade_select(upgrade);
                                }),
                        );
                    },
                )(wh, ctx);
            });
        }
    }
}
use crate::{
    camera_controller::CameraController, game_state::{Modal, set_modal},
    icon::{Icon, IconKind, IconSize},
    theme::button::{Button, ButtonVariant},
};
use contracts::Contracts;
use game_speed_indicator::GameSpeedIndicator;
use game_state::{TILE_PX_SIZE, flow::GameFlow, mutate_game_state};
use inventory::Inventory;
use namui::*;
use namui_prebuilt::simple_rect;
use theme::palette;
use top_bar::TopBar;
use upgrade_select::UpgradeSelectModal;
pub mod asset {
    use super::Image;
    pub mod image {
        use super::Image;
        pub mod background {
            use super::Image;
            pub static TILE0: Image = Image::new(0usize);
            pub static TILE1: Image = Image::new(1usize);
            pub static TILE2: Image = Image::new(2usize);
            pub static TILE3: Image = Image::new(3usize);
        }
        pub mod face {
            use super::Image;
            pub mod clubs {
                use super::Image;
                pub static JACK: Image = Image::new(4usize);
                pub static KING: Image = Image::new(5usize);
                pub static QUEEN: Image = Image::new(6usize);
            }
            pub mod diamonds {
                use super::Image;
                pub static JACK: Image = Image::new(7usize);
                pub static KING: Image = Image::new(8usize);
                pub static QUEEN: Image = Image::new(9usize);
            }
            pub mod hearts {
                use super::Image;
                pub static JACK: Image = Image::new(10usize);
                pub static KING: Image = Image::new(11usize);
                pub static QUEEN: Image = Image::new(12usize);
            }
            pub mod spades {
                use super::Image;
                pub static JACK: Image = Image::new(13usize);
                pub static KING: Image = Image::new(14usize);
                pub static QUEEN: Image = Image::new(15usize);
            }
        }
        pub mod icon {
            use super::Image;
            pub static ACCEPT: Image = Image::new(16usize);
            pub static ADD: Image = Image::new(17usize);
            pub static ATTACK_DAMAGE: Image = Image::new(18usize);
            pub static ATTACK_RANGE: Image = Image::new(19usize);
            pub static ATTACK_SPEED: Image = Image::new(20usize);
            pub static CARD: Image = Image::new(21usize);
            pub static CONFIG: Image = Image::new(22usize);
            pub static DOWN: Image = Image::new(23usize);
            pub static ENEMY_BOSS: Image = Image::new(24usize);
            pub static ENEMY_NAMED: Image = Image::new(25usize);
            pub static ENEMY_NORMAL: Image = Image::new(26usize);
            pub static GOLD: Image = Image::new(27usize);
            pub static HEALTH: Image = Image::new(28usize);
            pub static INVINCIBLE: Image = Image::new(29usize);
            pub static ITEM: Image = Image::new(30usize);
            pub static LEVEL: Image = Image::new(31usize);
            pub static LOCK: Image = Image::new(32usize);
            pub static MOVE_SPEED: Image = Image::new(33usize);
            pub static MULTIPLY: Image = Image::new(34usize);
            pub static NEW: Image = Image::new(35usize);
            pub static QUEST: Image = Image::new(36usize);
            pub static RARITY_COMMON: Image = Image::new(37usize);
            pub static RARITY_EPIC: Image = Image::new(38usize);
            pub static RARITY_LEGENDARY: Image = Image::new(39usize);
            pub static RARITY_RARE: Image = Image::new(40usize);
            pub static REFRESH: Image = Image::new(41usize);
            pub static REJECT: Image = Image::new(42usize);
            pub static SHIELD: Image = Image::new(43usize);
            pub static SHOP: Image = Image::new(44usize);
            pub static SPEAKER: Image = Image::new(45usize);
            pub static SUIT_CLUBS: Image = Image::new(46usize);
            pub static SUIT_DIAMONDS: Image = Image::new(47usize);
            pub static SUIT_HEARTS: Image = Image::new(48usize);
            pub static SUIT_SPADES: Image = Image::new(49usize);
            pub static UP: Image = Image::new(50usize);
        }
        pub mod monster {
            use super::Image;
            pub static BOSS01: Image = Image::new(51usize);
            pub static BOSS02: Image = Image::new(52usize);
            pub static BOSS03: Image = Image::new(53usize);
            pub static BOSS04: Image = Image::new(54usize);
            pub static BOSS05: Image = Image::new(55usize);
            pub static BOSS06: Image = Image::new(56usize);
            pub static BOSS07: Image = Image::new(57usize);
            pub static BOSS08: Image = Image::new(58usize);
            pub static BOSS09: Image = Image::new(59usize);
            pub static BOSS10: Image = Image::new(60usize);
            pub static BOSS11: Image = Image::new(61usize);
            pub static MOB01: Image = Image::new(62usize);
            pub static MOB02: Image = Image::new(63usize);
            pub static MOB03: Image = Image::new(64usize);
            pub static MOB04: Image = Image::new(65usize);
            pub static MOB05: Image = Image::new(66usize);
            pub static MOB06: Image = Image::new(67usize);
            pub static MOB07: Image = Image::new(68usize);
            pub static MOB08: Image = Image::new(69usize);
            pub static MOB09: Image = Image::new(70usize);
            pub static MOB10: Image = Image::new(71usize);
            pub static MOB11: Image = Image::new(72usize);
            pub static MOB12: Image = Image::new(73usize);
            pub static MOB13: Image = Image::new(74usize);
            pub static MOB14: Image = Image::new(75usize);
            pub static MOB15: Image = Image::new(76usize);
            pub static NAMED01: Image = Image::new(77usize);
            pub static NAMED02: Image = Image::new(78usize);
            pub static NAMED03: Image = Image::new(79usize);
            pub static NAMED04: Image = Image::new(80usize);
            pub static NAMED05: Image = Image::new(81usize);
            pub static NAMED06: Image = Image::new(82usize);
            pub static NAMED07: Image = Image::new(83usize);
            pub static NAMED08: Image = Image::new(84usize);
            pub static NAMED09: Image = Image::new(85usize);
            pub static NAMED10: Image = Image::new(86usize);
            pub static NAMED11: Image = Image::new(87usize);
            pub static NAMED12: Image = Image::new(88usize);
            pub static NAMED13: Image = Image::new(89usize);
            pub static NAMED14: Image = Image::new(90usize);
            pub static NAMED15: Image = Image::new(91usize);
            pub static NAMED16: Image = Image::new(92usize);
        }
        pub mod route {
            use super::Image;
            pub static ROUTE_1: Image = Image::new(93usize);
        }
        pub mod tower {
            use super::Image;
            pub mod barricade {
                use super::Image;
                pub static IDLE1: Image = Image::new(94usize);
            }
            pub mod flush {
                use super::Image;
                pub static ATTACK: Image = Image::new(95usize);
                pub static IDLE1: Image = Image::new(96usize);
                pub static IDLE2: Image = Image::new(97usize);
            }
            pub mod four_of_a_kind {
                use super::Image;
                pub static ATTACK: Image = Image::new(98usize);
                pub static IDLE1: Image = Image::new(99usize);
                pub static IDLE2: Image = Image::new(100usize);
            }
            pub mod full_house {
                use super::Image;
                pub static ATTACK: Image = Image::new(101usize);
                pub static IDLE1: Image = Image::new(102usize);
                pub static IDLE2: Image = Image::new(103usize);
            }
            pub mod high {
                use super::Image;
                pub static ATTACK: Image = Image::new(104usize);
                pub static IDLE1: Image = Image::new(105usize);
                pub static IDLE2: Image = Image::new(106usize);
            }
            pub mod one_pair {
                use super::Image;
                pub static ATTACK: Image = Image::new(107usize);
                pub static IDLE1: Image = Image::new(108usize);
                pub static IDLE2: Image = Image::new(109usize);
            }
            pub mod royal_flush {
                use super::Image;
                pub static ATTACK: Image = Image::new(110usize);
                pub static IDLE1: Image = Image::new(111usize);
                pub static IDLE2: Image = Image::new(112usize);
            }
            pub mod straight {
                use super::Image;
                pub static ATTACK: Image = Image::new(113usize);
                pub static IDLE1: Image = Image::new(114usize);
                pub static IDLE2: Image = Image::new(115usize);
            }
            pub mod straight_flush {
                use super::Image;
                pub static ATTACK: Image = Image::new(116usize);
                pub static IDLE1: Image = Image::new(117usize);
                pub static IDLE2: Image = Image::new(118usize);
            }
            pub mod three_of_a_kind {
                use super::Image;
                pub static ATTACK: Image = Image::new(119usize);
                pub static IDLE1: Image = Image::new(120usize);
                pub static IDLE2: Image = Image::new(121usize);
            }
            pub mod two_pair {
                use super::Image;
                pub static ATTACK: Image = Image::new(122usize);
                pub static IDLE1: Image = Image::new(123usize);
                pub static IDLE2: Image = Image::new(124usize);
            }
        }
    }
}
type BlockUnit = usize;
type BlockUnitF32 = f32;
type MapCoord = Xy<BlockUnit>;
type MapCoordF32 = Xy<BlockUnitF32>;
pub fn main() {
    namui::start(|ctx: &RenderCtx| {
        ctx.add(Game {});
    });
}
struct Game {}
impl Component for Game {
    fn render(self, ctx: &RenderCtx) {
        let screen_wh = screen::size().into_type::<Px>();
        let game_state = game_state::init_game_state(ctx);
        let (middle_mouse_button_dragging, set_middle_mouse_button_dragging) = ctx
            .state(|| None);
        ctx.compose(|ctx| {
            let Some(modal) = game_state.opened_modal.as_ref() else {
                return;
            };
            ctx.add(modal);
        });
        ctx.translate((8.px(), screen_wh.height - 48.px()))
            .add(
                Button::new(
                        Wh::new(36.px(), 36.px()),
                        &|| {
                            set_modal(Some(Modal::Settings));
                        },
                        &|wh, _text_color, ctx| {
                            ctx.add(
                                Icon::new(IconKind::Config).size(IconSize::Large).wh(wh),
                            );
                        },
                    )
                    .variant(ButtonVariant::Text),
            );
        ctx.translate((screen_wh.width - 116.px(), screen_wh.height - 88.px()))
            .add(GameSpeedIndicator);
        ctx.compose(|ctx| {
            let GameFlow::SelectingUpgrade { upgrades } = &game_state.flow else {
                return;
            };
            ctx.add(UpgradeSelectModal {
                screen_wh,
                upgrades,
            });
        });
        ctx.add(flow_ui::FlowUi);
        ctx.add(Contracts { screen_wh });
        ctx.add(Inventory { screen_wh });
        ctx.add(TopBar { screen_wh });
        ctx.add(game_state::RenderGameState {
            game_state: game_state.as_ref(),
        });
        ctx.add(CameraController);
        ctx.add(
            simple_rect(
                screen_wh,
                Color::TRANSPARENT,
                0.px(),
                palette::SURFACE_CONTAINER_LOWEST,
            ),
        );
        ctx.attach_event(move |event| {
            match event {
                Event::KeyDown { event } => {
                    match event.code {
                        Code::Tab => {
                            mutate_game_state(|game_state| {
                                if #[allow(non_exhaustive_omitted_patterns)]
                                match game_state.opened_modal {
                                    Some(Modal::UpgradeBoard) => true,
                                    _ => false,
                                } {
                                    game_state.opened_modal = None;
                                } else {
                                    game_state.opened_modal = Some(Modal::UpgradeBoard);
                                }
                            });
                        }
                        Code::KeyQ => {
                            mutate_game_state(|game_state| {
                                game_state.fast_forward_multiplier = game_state
                                    .fast_forward_multiplier
                                    .prev();
                            });
                        }
                        Code::KeyE => {
                            mutate_game_state(|game_state| {
                                game_state.fast_forward_multiplier = game_state
                                    .fast_forward_multiplier
                                    .next();
                            });
                        }
                        _ => {}
                    }
                }
                Event::Wheel { event } => {
                    let delta = -event.delta_xy.y / 2048.0;
                    let origin = event.local_xy();
                    mutate_game_state(move |game_state| {
                        game_state.camera.zoom(delta, origin);
                    });
                }
                Event::MouseDown { event } => {
                    let Some(button) = event.button else {
                        return;
                    };
                    if button == MouseButton::Middle {
                        set_middle_mouse_button_dragging
                            .set(
                                Some(MiddleMouseButtonDragging {
                                    last_global_xy: event.global_xy,
                                }),
                            );
                    }
                }
                Event::MouseMove { event } => {
                    if event.pressing_buttons.contains(&MouseButton::Middle)
                        && let Some(middle_mouse_button_dragging) = middle_mouse_button_dragging
                            .as_ref()
                    {
                        let global_xy = event.global_xy;
                        let delta = global_xy
                            - middle_mouse_button_dragging.last_global_xy;
                        mutate_game_state(move |game_state| {
                            game_state.camera.move_by(delta * -1.0);
                        });
                        set_middle_mouse_button_dragging
                            .set(
                                Some(MiddleMouseButtonDragging {
                                    last_global_xy: global_xy,
                                }),
                            );
                    }
                    if game_state.cursor_preview.should_update_position()
                        || #[allow(non_exhaustive_omitted_patterns)]
                        match game_state.flow {
                            crate::game_state::flow::GameFlow::PlacingTower {
                                hand: _,
                            } => true,
                            _ => false,
                        }
                    {
                        let local_xy_tile = (event.global_xy
                            / game_state.camera.zoom_level) / TILE_PX_SIZE.to_xy();
                        let map_coord = game_state.camera.left_top + local_xy_tile;
                        mutate_game_state(move |game_state| {
                            game_state.cursor_preview.update_position(map_coord);
                        });
                    }
                }
                Event::MouseUp { event } => {
                    let Some(button) = event.button else {
                        return;
                    };
                    if button == MouseButton::Middle {
                        set_middle_mouse_button_dragging.set(None);
                    }
                }
                Event::VisibilityChange => {
                    if middle_mouse_button_dragging.is_some() {
                        set_middle_mouse_button_dragging.set(None);
                    }
                }
                _ => {}
            };
        });
    }
}
struct MiddleMouseButtonDragging {
    last_global_xy: Xy<Px>,
}
impl bincode::Encode for MiddleMouseButtonDragging {
    fn encode<__E: bincode::enc::Encoder>(
        &self,
        encoder: &mut __E,
    ) -> core::result::Result<(), bincode::error::EncodeError> {
        bincode::Encode::encode(&self.last_global_xy, encoder)?;
        Ok(())
    }
}
impl bincode::Decode<()> for MiddleMouseButtonDragging {
    fn decode<__D: bincode::de::Decoder<Context = ()>>(
        decoder: &mut __D,
    ) -> core::result::Result<Self, bincode::error::DecodeError> {
        Ok(Self {
            last_global_xy: bincode::Decode::decode(decoder)?,
        })
    }
}
impl Serialize for MiddleMouseButtonDragging {
    fn serialize(&self, buf: &mut Vec<u8>) {
        buf.write_string(std::any::type_name::<Self>());
        self.serialize_without_name(buf);
    }
    fn serialize_without_name(&self, buf: &mut Vec<u8>) {
        buf.write_string("last_global_xy");
        self.last_global_xy.serialize_without_name(buf);
    }
}
impl Deserialize for MiddleMouseButtonDragging {
    fn deserialize(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
        buf.read_name(std::any::type_name::<Self>())?;
        Self::deserialize_without_name(buf)
    }
    fn deserialize_without_name(buf: &mut &[u8]) -> Result<Self, DeserializeError> {
        let field_name = buf.read_name("last_global_xy")?;
        let last_global_xy = Deserialize::deserialize_without_name(buf)?;
        Ok(Self { last_global_xy })
    }
}
pub use card::{Card, Rank, Suit};
pub use game_state::contract::generation::generate_contract_with_rng;
pub use game_state::tower::TowerKind;
pub use game_state::upgrade::UpgradeState;
pub use rarity::Rarity;
