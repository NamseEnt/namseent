/* automatically generated by rust-bindgen 0.66.1 */

pub enum GrContext_Base {}
pub enum GrImageContext {}
pub enum GrImageContextPriv {}
pub enum GrContextThreadSafeProxy {}
pub enum GrContextThreadSafeProxyPriv {}
pub enum GrRecordingContextPriv {}
pub enum GrContextPriv {}
pub enum SkVerticesPriv {}
pub enum SkUnicode {}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
pub type std___apply_cv_type<_Up> = _Up;
pub type std__If = u8;
pub type std_conditional_type<_If> = _If;
pub type std__Or = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
pub type std_make_signed_t = std_make_signed;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Tp> = _Tp;
pub type std___type_identity_t = std___type_identity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::core::marker::PhantomData<::core::cell::UnsafeCell<_T2>>,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair__CheckArgs {
    pub _address: u8,
}
pub type std_pair__CheckArgsDep = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair__CheckTupleLikeConstructor {
    pub _address: u8,
}
pub type std_pair__CheckTLC = u8;
pub type std_streampos = std_fpos<__mbstate_t>;
pub type std_streamoff = ::core::ffi::c_longlong;
pub type std_string = [u64; 3usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__BaseT = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__IsThisTuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableUTypesCtor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableCtorFromUTypesTuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__CtorPredicateFromPair {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableCtorFromPair {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__NothrowConstructibleFromPair {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__BothImplicitlyConvertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::core::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::core::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::core::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_random_access_iterator_tag() {
    assert_eq!(
        ::core::mem::size_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_random_access_iterator_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_random_access_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std_iterator_traits___primary_template = std_iterator_traits;
pub type std___pointer_traits_difference_type_type = ::core::ffi::c_long;
pub type std___pointer_traits_rebind_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = u8;
pub type std_pointer_traits_difference_type = u8;
pub type std_pointer_traits_rebind = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___nat {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___rebind_pointer {
    pub _address: u8,
}
pub type std___rebind_pointer_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
pub type std_iterator_iterator_category<_Category> = _Category;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iter> {
    pub __t: _Iter,
    pub current: _Iter,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iter>>,
}
pub type std_reverse_iterator_iterator_type<_Iter> = _Iter;
pub type std_reverse_iterator_iterator_category = std__If;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_value_type = std_iterator_traits;
pub type std_reverse_iterator_difference_type = std_iterator_traits;
pub type std_reverse_iterator_reference = std_iterator_traits;
pub type std___bit_reference___storage_type = [u8; 0usize];
pub type std___bit_reference___storage_pointer = [u8; 0usize];
#[repr(C)]
pub struct std___bit_const_reference {
    pub __seg_: std___bit_const_reference___storage_pointer,
    pub __mask_: std___bit_const_reference___storage_type,
}
pub type std___bit_const_reference___storage_type = [u8; 0usize];
pub type std___bit_const_reference___storage_pointer = [u8; 0usize];
pub type std___bit_iterator_difference_type = [u8; 0usize];
pub type std___bit_iterator_value_type = bool;
pub type std___bit_iterator_pointer = u8;
pub type std___bit_iterator_reference = u8;
pub type std___bit_iterator_iterator_category = std_random_access_iterator_tag;
pub type std___bit_iterator___storage_type = [u8; 0usize];
pub type std___bit_iterator___storage_pointer = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___wrap_iter<_Iter> {
    pub __i: std___wrap_iter_iterator_type<_Iter>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iter>>,
}
pub type std___wrap_iter_iterator_type<_Iter> = _Iter;
pub type std___wrap_iter_value_type = std_iterator_traits;
pub type std___wrap_iter_difference_type = std_iterator_traits;
pub type std___wrap_iter_pointer = std_iterator_traits;
pub type std___wrap_iter_reference = std_iterator_traits;
pub type std___wrap_iter_iterator_category = std_iterator_traits;
pub type std___pointer_type = [u8; 0usize];
pub type std___allocator_traits_rebind_type = [u8; 0usize];
pub type std___allocator_traits_rebind_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = [u8; 0usize];
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = [u8; 0usize];
pub type std_allocator_traits_const_void_pointer = [u8; 0usize];
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = u8;
pub type std_allocator_traits_propagate_on_container_move_assignment = u8;
pub type std_allocator_traits_propagate_on_container_swap = u8;
pub type std_allocator_traits_is_always_equal = u8;
pub type std_allocator_traits_rebind_alloc = std___allocator_traits_rebind_t;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___rebind_alloc_helper {
    pub _address: u8,
}
pub type std___rebind_alloc_helper_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = ::core::ffi::c_ulong;
pub type std_allocator_difference_type = ::core::ffi::c_long;
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std___compressed_pair_elem__ParamT<_Tp> = _Tp;
pub type std___compressed_pair_elem_reference<_Tp> = *mut _Tp;
pub type std___compressed_pair_elem_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compressed_pair {
    pub _address: u8,
}
pub type std___compressed_pair__Base1 = u8;
pub type std___compressed_pair__Base2 = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
pub type std___binary_function = std_binary_function;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
pub type std_equal_to___result_type = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
pub type std_less___result_type = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unique_ptr_deleter_sfinae {
    pub _address: u8,
}
pub type std___unique_ptr_deleter_sfinae___lval_ref_type<_Deleter> = *const _Deleter;
pub type std___unique_ptr_deleter_sfinae___good_rval_ref_type<_Deleter> = *mut _Deleter;
pub type std___unique_ptr_deleter_sfinae___enable_rval_overload = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr___nat {
    pub __for_bool_: ::core::ffi::c_int,
}
pub type std_unique_ptr__DeleterSFINAE = std___unique_ptr_deleter_sfinae;
pub type std_unique_ptr__LValRefType = u8;
pub type std_unique_ptr__GoodRValRefType = u8;
pub type std_unique_ptr__BadRValRefType = u8;
pub type std_unique_ptr__EnableIfDeleterDefaultConstructible = u8;
pub type std_unique_ptr__EnableIfDeleterConstructible = u8;
pub type std_unique_ptr__EnableIfMoveConvertible = u8;
pub type std_unique_ptr__EnableIfDeleterConvertible = u8;
pub type std_unique_ptr__EnableIfDeleterAssignable = u8;
extern "C" {
    #[link_name = "\u{1}__na"]
    pub static std_ratio___na: ::core::ffi::c_long;
}
extern "C" {
    #[link_name = "\u{1}__da"]
    pub static std_ratio___da: ::core::ffi::c_long;
}
extern "C" {
    #[link_name = "\u{1}__s"]
    pub static std_ratio___s: ::core::ffi::c_long;
}
extern "C" {
    #[link_name = "\u{1}__gcd"]
    pub static std_ratio___gcd: ::core::ffi::c_long;
}
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_ratio_num: ::core::ffi::c_long;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_ratio_den: ::core::ffi::c_long;
}
pub type std_milli = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration<_Rep> {
    pub __rep_: std_chrono_duration_rep<_Rep>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Rep>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration___no_overflow {
    pub _address: u8,
}
pub type std_chrono_duration___no_overflow_type = u8;
pub type std_chrono_duration_rep<_Rep> = _Rep;
pub type std_chrono_duration_period = [u8; 0usize];
pub type std_chrono_milliseconds = std_chrono_duration<::core::ffi::c_longlong>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std_atomic___base = u8;
pub type std_atomic_value_type<_Tp> = _Tp;
pub type std_atomic_difference_type<_Tp> = std_atomic_value_type<_Tp>;
pub type std_variant_alternative_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_variant {
    pub _address: u8,
}
pub type std_variant___first_type = std_variant_alternative_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional {
    pub _address: u8,
}
pub type std_optional___base = u8;
pub type std_optional_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional__CheckOptionalArgsConstructor {
    pub _address: u8,
}
pub type std_optional__CheckOptionalArgsCtor = std__If;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional__CheckOptionalLikeConstructor {
    pub _address: u8,
}
pub type std_optional__CheckOptionalLikeConstructor___check_constructible_from_opt = std__Or;
pub type std_optional__CheckOptionalLikeConstructor___check_assignable_from_opt = std__Or;
pub type std_optional__CheckOptionalLikeCtor = std__If;
pub type std_optional__CheckOptionalLikeAssign = std__If;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_StateT> {
    pub __st_: _StateT,
    pub __off_: std_streamoff,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_StateT>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std_char_traits_char_type<_CharT> = _CharT;
pub type std_char_traits_int_type = ::core::ffi::c_int;
pub type std_char_traits_off_type = std_streamoff;
pub type std_char_traits_pos_type = std_streampos;
pub type std_char_traits_state_type = __mbstate_t;
pub type std_string_view = std_basic_string_view<::core::ffi::c_char>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_node_base {
    pub __next_: std___hash_node_base___next_pointer,
}
pub type std___hash_node_base___node_type = std_pointer_traits;
pub type std___hash_node_base___first_node = std___hash_node_base;
pub type std___hash_node_base___node_base_pointer = std___rebind_pointer;
pub type std___hash_node_base___node_pointer<_NodePtr> = _NodePtr;
pub type std___hash_node_base___next_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_node<_Tp> {
    pub _base: std___hash_node_base,
    pub __hash_: ::core::ffi::c_ulong,
    pub __value_: std___hash_node___node_value_type<_Tp>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Tp>>,
}
pub type std___hash_node___node_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_node_types {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_hash_node_types {
    pub _address: u8,
}
pub type std___make_hash_node_types__NodeTp<_NodeValueTp> = std___hash_node<_NodeValueTp>;
pub type std___make_hash_node_types__NodePtr = std___rebind_pointer;
pub type std___make_hash_node_types_type = std___hash_node_types;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_iterator {
    pub __node_: std___hash_iterator___next_pointer,
}
pub type std___hash_iterator__NodeTypes = std___hash_node_types;
pub type std___hash_iterator___node_pointer<_NodePtr> = _NodePtr;
pub type std___hash_iterator___next_pointer = std___hash_iterator__NodeTypes;
pub type std___hash_iterator_iterator_category = std_forward_iterator_tag;
pub type std___hash_iterator_value_type = std___hash_iterator__NodeTypes;
pub type std___hash_iterator_difference_type = std___hash_iterator__NodeTypes;
pub type std___hash_iterator_reference = *mut std___hash_iterator_value_type;
pub type std___hash_iterator_pointer = std___hash_iterator__NodeTypes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_const_iterator {
    pub __node_: std___hash_const_iterator___next_pointer,
}
pub type std___hash_const_iterator__NodeTypes = std___hash_node_types;
pub type std___hash_const_iterator___node_pointer<_NodePtr> = _NodePtr;
pub type std___hash_const_iterator___next_pointer = std___hash_const_iterator__NodeTypes;
pub type std___hash_const_iterator___non_const_iterator = std___hash_iterator;
pub type std___hash_const_iterator_iterator_category = std_forward_iterator_tag;
pub type std___hash_const_iterator_value_type = std___hash_const_iterator__NodeTypes;
pub type std___hash_const_iterator_difference_type = std___hash_const_iterator__NodeTypes;
pub type std___hash_const_iterator_reference = *const std___hash_const_iterator_value_type;
pub type std___hash_const_iterator_pointer = std___hash_const_iterator__NodeTypes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_local_iterator {
    pub __node_: std___hash_local_iterator___next_pointer,
    pub __bucket_: ::core::ffi::c_ulong,
    pub __bucket_count_: ::core::ffi::c_ulong,
}
pub type std___hash_local_iterator__NodeTypes = std___hash_node_types;
pub type std___hash_local_iterator___node_pointer<_NodePtr> = _NodePtr;
pub type std___hash_local_iterator___next_pointer = std___hash_local_iterator__NodeTypes;
pub type std___hash_local_iterator_iterator_category = std_forward_iterator_tag;
pub type std___hash_local_iterator_value_type = std___hash_local_iterator__NodeTypes;
pub type std___hash_local_iterator_difference_type = std___hash_local_iterator__NodeTypes;
pub type std___hash_local_iterator_reference = *mut std___hash_local_iterator_value_type;
pub type std___hash_local_iterator_pointer = std___hash_local_iterator__NodeTypes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_const_local_iterator {
    pub __node_: std___hash_const_local_iterator___next_pointer,
    pub __bucket_: ::core::ffi::c_ulong,
    pub __bucket_count_: ::core::ffi::c_ulong,
}
pub type std___hash_const_local_iterator__NodeTypes = std___hash_node_types;
pub type std___hash_const_local_iterator___node_pointer<_ConstNodePtr> = _ConstNodePtr;
pub type std___hash_const_local_iterator___next_pointer =
    std___hash_const_local_iterator__NodeTypes;
pub type std___hash_const_local_iterator___pointer_traits = std_pointer_traits;
pub type std___hash_const_local_iterator___node = std___hash_const_local_iterator___pointer_traits;
pub type std___hash_const_local_iterator___non_const_node = std_remove_const;
pub type std___hash_const_local_iterator___non_const_node_pointer = std___rebind_pointer;
pub type std___hash_const_local_iterator___non_const_iterator = std___hash_local_iterator;
pub type std___hash_const_local_iterator_iterator_category = std_forward_iterator_tag;
pub type std___hash_const_local_iterator_value_type = std___hash_const_local_iterator__NodeTypes;
pub type std___hash_const_local_iterator_difference_type =
    std___hash_const_local_iterator__NodeTypes;
pub type std___hash_const_local_iterator_reference =
    *const std___hash_const_local_iterator_value_type;
pub type std___hash_const_local_iterator_pointer = std___hash_const_local_iterator__NodeTypes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___bucket_list_deallocator {
    pub __data_: std___compressed_pair,
}
pub type std___bucket_list_deallocator_allocator_type<_Alloc> = _Alloc;
pub type std___bucket_list_deallocator___alloc_traits = std_allocator_traits;
pub type std___bucket_list_deallocator_size_type = std___bucket_list_deallocator___alloc_traits;
pub type std___bucket_list_deallocator_pointer = std___bucket_list_deallocator___alloc_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_node_destructor<_Alloc> {
    pub __na_: *mut std___hash_node_destructor_allocator_type<_Alloc>,
    pub __value_constructed: bool,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Alloc>>,
}
pub type std___hash_node_destructor_allocator_type<_Alloc> = _Alloc;
pub type std___hash_node_destructor___alloc_traits = std_allocator_traits;
pub type std___hash_node_destructor_pointer = std___hash_node_destructor___alloc_traits;
pub type std___hash_node_destructor__NodeTypes = std___hash_node_types;
#[repr(C)]
#[derive(Debug)]
pub struct std___hash_table {
    pub __bucket_list_: std___hash_table___bucket_list,
    pub __p1_: std___compressed_pair,
    pub __p2_: std___compressed_pair,
    pub __p3_: std___compressed_pair,
}
pub type std___hash_table_value_type<_Tp> = _Tp;
pub type std___hash_table_hasher<_Hash> = _Hash;
pub type std___hash_table_key_equal<_Equal> = _Equal;
pub type std___hash_table_allocator_type<_Alloc> = _Alloc;
pub type std___hash_table___alloc_traits = std_allocator_traits;
pub type std___hash_table__NodeTypes = std___make_hash_node_types;
pub type std___hash_table___node_value_type = std___hash_table__NodeTypes;
pub type std___hash_table___container_value_type = std___hash_table__NodeTypes;
pub type std___hash_table_key_type = std___hash_table__NodeTypes;
pub type std___hash_table_reference<_Tp> = *mut std___hash_table_value_type<_Tp>;
pub type std___hash_table_const_reference<_Tp> = *const std___hash_table_value_type<_Tp>;
pub type std___hash_table_pointer = std___hash_table___alloc_traits;
pub type std___hash_table_const_pointer = std___hash_table___alloc_traits;
pub type std___hash_table_size_type = std___hash_table___alloc_traits;
pub type std___hash_table_difference_type = std___hash_table__NodeTypes;
pub type std___hash_table___node = std___hash_table__NodeTypes;
pub type std___hash_table___node_allocator = std___rebind_alloc_helper;
pub type std___hash_table___node_traits = std_allocator_traits;
pub type std___hash_table___void_pointer = std___hash_table__NodeTypes;
pub type std___hash_table___node_pointer = std___hash_table__NodeTypes;
pub type std___hash_table___node_const_pointer = std___hash_table__NodeTypes;
pub type std___hash_table___first_node = std___hash_table__NodeTypes;
pub type std___hash_table___node_base_pointer = std___hash_table__NodeTypes;
pub type std___hash_table___next_pointer = std___hash_table__NodeTypes;
pub type std___hash_table___node_base_allocator = std___rebind_alloc_helper;
pub type std___hash_table___node_base_traits = std_allocator_traits;
pub type std___hash_table___pointer_allocator = std___rebind_alloc_helper;
pub type std___hash_table___bucket_list_deleter = std___bucket_list_deallocator;
pub type std___hash_table___bucket_list = u8;
pub type std___hash_table___pointer_alloc_traits = std_allocator_traits;
pub type std___hash_table___node_pointer_pointer = std___hash_table___bucket_list_deleter;
pub type std___hash_table_iterator = std___hash_iterator;
pub type std___hash_table_const_iterator = std___hash_const_iterator;
pub type std___hash_table_local_iterator = std___hash_local_iterator;
pub type std___hash_table_const_local_iterator = std___hash_const_local_iterator;
pub type std___hash_table__Dp = std___hash_node_destructor<std___hash_table___node_allocator>;
pub type std___hash_table___node_holder = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std___basic_node_handle {
    pub __ptr_: std___basic_node_handle___node_pointer_type,
    pub __alloc_: u8,
}
pub type std___basic_node_handle___alloc_traits = std_allocator_traits;
pub type std___basic_node_handle___node_pointer_type = std___rebind_pointer;
pub type std___basic_node_handle_allocator_type<_Alloc> = _Alloc;
pub type std___set_node_handle = std___basic_node_handle;
pub type std___map_node_handle = std___basic_node_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___insert_return_type<_Iterator, _NodeType> {
    pub position: _Iterator,
    pub inserted: bool,
    pub node: _NodeType,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
    pub _phantom_1: ::core::marker::PhantomData<::core::cell::UnsafeCell<_NodeType>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub __data: *const std_basic_string_view_value_type<_CharT>,
    pub __size: std_basic_string_view_size_type,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_pointer<_CharT> = *const _CharT;
pub type std_basic_string_view_reference<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_reference<_CharT> = *const _CharT;
pub type std_basic_string_view_const_iterator<_CharT> = std_basic_string_view_const_pointer<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = ::core::ffi::c_ulong;
pub type std_basic_string_view_difference_type = ::core::ffi::c_long;
pub type std_u16string = [u64; 3usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string___self = u8;
pub type std_basic_string___self_view<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_allocator_type<_Allocator> = _Allocator;
pub type std_basic_string___alloc_traits = std_allocator_traits;
pub type std_basic_string_size_type = std_basic_string___alloc_traits;
pub type std_basic_string_difference_type = std_basic_string___alloc_traits;
pub type std_basic_string_reference = *mut std_basic_string_value_type;
pub type std_basic_string_const_reference = *const std_basic_string_value_type;
pub type std_basic_string_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_const_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_iterator = std___wrap_iter<std_basic_string_pointer>;
pub type std_basic_string_const_iterator = std___wrap_iter<std_basic_string_const_pointer>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___long {
    pub _address: u8,
}
pub const std_basic_string___min_cap: std_basic_string__bindgen_ty_1 =
    std_basic_string__bindgen_ty_1::__min_cap;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum std_basic_string__bindgen_ty_1 {
    __min_cap = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___short {
    pub __data_: *mut std_basic_string_value_type,
    pub __padding_: *mut ::core::ffi::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl std_basic_string___short {
    #[inline]
    pub fn __size_(&self) -> ::core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set___size_(&mut self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __is_long_(&self) -> ::core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set___is_long_(&mut self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __size_: ::core::ffi::c_uchar,
        __is_long_: ::core::ffi::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __size_: u8 = unsafe { ::core::mem::transmute(__size_) };
            __size_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __is_long_: u8 = unsafe { ::core::mem::transmute(__is_long_) };
            __is_long_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___ulx {
    pub __lx: __BindgenUnionField<u8>,
    pub __lxx: __BindgenUnionField<std_basic_string___short>,
    pub bindgen_union_field: [u8; 0usize],
}
pub const std_basic_string___n_words: std_basic_string__bindgen_ty_2 =
    std_basic_string__bindgen_ty_2::__n_words;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum std_basic_string__bindgen_ty_2 {
    __n_words = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___raw {
    pub __words: *mut std_basic_string_size_type,
}
#[repr(C)]
pub struct std_basic_string___rep {
    pub __bindgen_anon_1: std_basic_string___rep__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___rep__bindgen_ty_1 {
    pub __l: __BindgenUnionField<u8>,
    pub __s: __BindgenUnionField<std_basic_string___short>,
    pub __r: __BindgenUnionField<std_basic_string___raw>,
    pub bindgen_union_field: [u8; 0usize],
}
pub const std_basic_string___alignment: std_basic_string__bindgen_ty_3 =
    std_basic_string__bindgen_ty_3::__alignment;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum std_basic_string__bindgen_ty_3 {
    __alignment = 0,
}
pub type std___bitset_difference_type = ::core::ffi::c_long;
pub type std___bitset_size_type = ::core::ffi::c_ulong;
pub type std___bitset___storage_type = std___bitset_size_type;
pub type std___bitset___self = u8;
pub type std___bitset___storage_pointer = *mut std___bitset___storage_type;
pub type std___bitset___const_storage_pointer = *const std___bitset___storage_type;
pub const std___bitset___bits_per_word: ::core::ffi::c_uint = 64;
pub type std___bitset_reference = u8;
pub type std___bitset_const_reference = std___bit_const_reference;
pub type std___bitset_iterator = u8;
pub type std___bitset_const_iterator = u8;
extern "C" {
    #[link_name = "\u{1}flip"]
    pub fn std___bitset_flip(this: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}all"]
    pub fn std___bitset_all(this: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}any"]
    pub fn std___bitset_any(this: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__n_words"]
    pub static std_bitset___n_words: ::core::ffi::c_uint;
}
pub type std_bitset_base = u8;
pub type std_bitset_reference = std_bitset_base;
pub type std_bitset_const_reference = std_bitset_base;
extern "C" {
    #[link_name = "\u{1}set"]
    pub fn std_bitset_set(this: *mut u8, __pos: ::core::ffi::c_ulong, __val: bool) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}reset"]
    pub fn std_bitset_reset(this: *mut u8, __pos: ::core::ffi::c_ulong) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}test"]
    pub fn std_bitset_test(this: *const u8, __pos: ::core::ffi::c_ulong) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tree_node_types {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_tree_node_types {
    pub _address: u8,
}
pub type std___make_tree_node_types__NodePtr = std___rebind_pointer;
pub type std___make_tree_node_types_type = std___tree_node_types;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tree_node_destructor<_Allocator> {
    pub __na_: *mut std___tree_node_destructor_allocator_type<_Allocator>,
    pub __value_constructed: bool,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Allocator>>,
}
pub type std___tree_node_destructor_allocator_type<_Allocator> = _Allocator;
pub type std___tree_node_destructor___alloc_traits = std_allocator_traits;
pub type std___tree_node_destructor_pointer = std___tree_node_destructor___alloc_traits;
pub type std___tree_node_destructor__NodeTypes = std___tree_node_types;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tree_iterator {
    pub __ptr_: std___tree_iterator___iter_pointer,
}
pub type std___tree_iterator__NodeTypes = std___tree_node_types;
pub type std___tree_iterator___node_pointer<_NodePtr> = _NodePtr;
pub type std___tree_iterator___node_base_pointer = std___tree_iterator__NodeTypes;
pub type std___tree_iterator___end_node_pointer = std___tree_iterator__NodeTypes;
pub type std___tree_iterator___iter_pointer = std___tree_iterator__NodeTypes;
pub type std___tree_iterator___pointer_traits = std_pointer_traits;
pub type std___tree_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std___tree_iterator_value_type<_Tp> = _Tp;
pub type std___tree_iterator_difference_type<_DiffType> = _DiffType;
pub type std___tree_iterator_reference<_Tp> = *mut std___tree_iterator_value_type<_Tp>;
pub type std___tree_iterator_pointer = std___tree_iterator__NodeTypes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tree_const_iterator {
    pub __ptr_: std___tree_const_iterator___iter_pointer,
}
pub type std___tree_const_iterator__NodeTypes = std___tree_node_types;
pub type std___tree_const_iterator___node_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___node_base_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___end_node_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___iter_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___pointer_traits = std_pointer_traits;
pub type std___tree_const_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std___tree_const_iterator_value_type<_Tp> = _Tp;
pub type std___tree_const_iterator_difference_type<_DiffType> = _DiffType;
pub type std___tree_const_iterator_reference<_Tp> =
    *const std___tree_const_iterator_value_type<_Tp>;
pub type std___tree_const_iterator_pointer = std___tree_const_iterator__NodeTypes;
pub type std___tree_const_iterator___non_const_iterator = std___tree_iterator;
#[repr(C)]
#[derive(Debug)]
pub struct std___tree {
    pub __begin_node_: std___tree___iter_pointer,
    pub __pair1_: std___compressed_pair,
    pub __pair3_: std___compressed_pair,
}
pub type std___tree_value_type<_Tp> = _Tp;
pub type std___tree_value_compare<_Compare> = _Compare;
pub type std___tree_allocator_type<_Allocator> = _Allocator;
pub type std___tree___alloc_traits = std_allocator_traits;
pub type std___tree__NodeTypes = std___make_tree_node_types;
pub type std___tree_key_type = std___tree__NodeTypes;
pub type std___tree___node_value_type = std___tree__NodeTypes;
pub type std___tree___container_value_type = std___tree__NodeTypes;
pub type std___tree_pointer = std___tree___alloc_traits;
pub type std___tree_const_pointer = std___tree___alloc_traits;
pub type std___tree_size_type = std___tree___alloc_traits;
pub type std___tree_difference_type = std___tree___alloc_traits;
pub type std___tree___void_pointer = std___tree__NodeTypes;
pub type std___tree___node = std___tree__NodeTypes;
pub type std___tree___node_pointer = std___tree__NodeTypes;
pub type std___tree___node_base = std___tree__NodeTypes;
pub type std___tree___node_base_pointer = std___tree__NodeTypes;
pub type std___tree___end_node_t = std___tree__NodeTypes;
pub type std___tree___end_node_ptr = std___tree__NodeTypes;
pub type std___tree___parent_pointer = std___tree__NodeTypes;
pub type std___tree___iter_pointer = std___tree__NodeTypes;
pub type std___tree___node_allocator = std___rebind_alloc_helper;
pub type std___tree___node_traits = std_allocator_traits;
pub type std___tree___node_base_allocator = std___rebind_alloc_helper;
pub type std___tree___node_base_traits = std_allocator_traits;
pub type std___tree__Dp = std___tree_node_destructor<std___tree___node_allocator>;
pub type std___tree___node_holder = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std___tree__DetachedTreeCache {
    pub __t_: *mut std___tree,
    pub __cache_root_: std___tree___node_pointer,
    pub __cache_elem_: std___tree___node_pointer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___map_node_destructor<_Allocator> {
    pub __na_: *mut std___map_node_destructor_allocator_type<_Allocator>,
    pub __first_constructed: bool,
    pub __second_constructed: bool,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Allocator>>,
}
pub type std___map_node_destructor_allocator_type<_Allocator> = _Allocator;
pub type std___map_node_destructor___alloc_traits = std_allocator_traits;
pub type std___map_node_destructor_pointer = std___map_node_destructor___alloc_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std___value_type<_Key, _Tp> {
    pub __cc: std___value_type_value_type<_Key, _Tp>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Key>>,
    pub _phantom_1: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Tp>>,
}
pub type std___value_type_key_type<_Key> = _Key;
pub type std___value_type_mapped_type<_Tp> = _Tp;
pub type std___value_type_value_type<_Key, _Tp> =
    std_pair<std___value_type_key_type<_Key>, std___value_type_mapped_type<_Tp>>;
pub type std___value_type___nc_ref_pair_type<_Key, _Tp> =
    std_pair<std___value_type_key_type<_Key>, std___value_type_mapped_type<_Tp>>;
pub type std___value_type___nc_rref_pair_type<_Key, _Tp> =
    std_pair<std___value_type_key_type<_Key>, std___value_type_mapped_type<_Tp>>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___map_iterator<_TreeIterator> {
    pub __i_: _TreeIterator,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_TreeIterator>>,
}
pub type std___map_iterator__NodeTypes = [u8; 0usize];
pub type std___map_iterator___pointer_traits = [u8; 0usize];
pub type std___map_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std___map_iterator_value_type = [u8; 0usize];
pub type std___map_iterator_difference_type = [u8; 0usize];
pub type std___map_iterator_reference = *mut std___map_iterator_value_type;
pub type std___map_iterator_pointer = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___map_const_iterator<_TreeIterator> {
    pub __i_: _TreeIterator,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_TreeIterator>>,
}
pub type std___map_const_iterator__NodeTypes = [u8; 0usize];
pub type std___map_const_iterator___pointer_traits = [u8; 0usize];
pub type std___map_const_iterator_iterator_category = std_bidirectional_iterator_tag;
pub type std___map_const_iterator_value_type = [u8; 0usize];
pub type std___map_const_iterator_difference_type = [u8; 0usize];
pub type std___map_const_iterator_reference = *const std___map_const_iterator_value_type;
pub type std___map_const_iterator_pointer = [u8; 0usize];
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum std_byte {
    __bindgen_cannot_repr_c_on_empty_enum = 0,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::core::ffi::c_char; 128usize],
    pub _mbstateL: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type FILE = [u64; 19usize];
pub type SkFourByteTag = u32;
pub type SkUnichar = i32;
pub type SkGlyphID = u16;
#[repr(C)]
pub struct SkRefCntBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkRefCntBase {
    pub vtable_: *const SkRefCntBase__bindgen_vtable,
    pub fRefCnt: u32,
}
#[test]
fn bindgen_test_layout_SkRefCntBase() {
    const UNINIT: ::core::mem::MaybeUninit<SkRefCntBase> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRefCntBase>(),
        16usize,
        concat!("Size of: ", stringify!(SkRefCntBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRefCntBase>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRefCntBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRefCnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRefCntBase),
            "::",
            stringify!(fRefCnt)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRefCnt {
    pub _base: SkRefCntBase,
}
#[test]
fn bindgen_test_layout_SkRefCnt() {
    assert_eq!(
        ::core::mem::size_of::<SkRefCnt>(),
        16usize,
        concat!("Size of: ", stringify!(SkRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRefCnt>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRefCnt))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkNVRefCnt {
    pub fRefCnt: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct sk_sp<T> {
    pub fPtr: *mut T,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
pub type sk_sp_element_type<T> = T;
pub type sk_sp_sk_is_trivially_relocatable = std_true_type;
pub type U8CPU = ::core::ffi::c_uint;
pub type SkScalar = f32;
#[repr(C)]
#[derive(Debug)]
pub struct SkString {
    pub fRec: sk_sp<SkString_Rec>,
}
pub type SkString_sk_is_trivially_relocatable = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkString_Rec {
    pub fLength: u32,
    pub fRefCnt: u32,
    pub fBeginningOfData: [::core::ffi::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_SkString_Rec() {
    const UNINIT: ::core::mem::MaybeUninit<SkString_Rec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkString_Rec>(),
        12usize,
        concat!("Size of: ", stringify!(SkString_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkString_Rec>(),
        4usize,
        concat!("Alignment of ", stringify!(SkString_Rec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkString_Rec),
            "::",
            stringify!(fLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRefCnt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkString_Rec),
            "::",
            stringify!(fRefCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBeginningOfData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkString_Rec),
            "::",
            stringify!(fBeginningOfData)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString3Rec4MakeEPKcm"]
    pub fn SkString_Rec_Make(text: *const ::core::ffi::c_char, len: usize) -> sk_sp<SkString_Rec>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString3Rec3refEv"]
    pub fn SkString_Rec_ref(this: *const SkString_Rec);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString3Rec5unrefEv"]
    pub fn SkString_Rec_unref(this: *const SkString_Rec);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString3Rec6uniqueEv"]
    pub fn SkString_Rec_unique(this: *const SkString_Rec) -> bool;
}
impl SkString_Rec {
    #[inline]
    pub unsafe fn Make(text: *const ::core::ffi::c_char, len: usize) -> sk_sp<SkString_Rec> {
        SkString_Rec_Make(text, len)
    }
    #[inline]
    pub unsafe fn ref_(&self) {
        SkString_Rec_ref(self)
    }
    #[inline]
    pub unsafe fn unref(&self) {
        SkString_Rec_unref(self)
    }
    #[inline]
    pub unsafe fn unique(&self) -> bool {
        SkString_Rec_unique(self)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9gEmptyRecE"]
    pub static SkString_gEmptyRec: SkString_Rec;
}
#[test]
fn bindgen_test_layout_SkString() {
    const UNINIT: ::core::mem::MaybeUninit<SkString> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkString>(),
        8usize,
        concat!("Size of: ", stringify!(SkString))
    );
    assert_eq!(
        ::core::mem::align_of::<SkString>(),
        8usize,
        concat!("Alignment of ", stringify!(SkString))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkString),
            "::",
            stringify!(fRec)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString6equalsERKS_"]
    pub fn SkString_equals(this: *const SkString, arg1: *const SkString) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString6equalsEPKc"]
    pub fn SkString_equals1(this: *const SkString, text: *const ::core::ffi::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString6equalsEPKcm"]
    pub fn SkString_equals2(
        this: *const SkString,
        text: *const ::core::ffi::c_char,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString4dataEv"]
    pub fn SkString_data(this: *mut SkString) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString5resetEv"]
    pub fn SkString_reset(this: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6resizeEm"]
    pub fn SkString_resize(this: *mut SkString, len: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString3setEPKc"]
    pub fn SkString_set(this: *mut SkString, text: *const ::core::ffi::c_char);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString3setEPKcm"]
    pub fn SkString_set1(this: *mut SkString, text: *const ::core::ffi::c_char, len: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6insertEmPKc"]
    pub fn SkString_insert(this: *mut SkString, offset: usize, text: *const ::core::ffi::c_char);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6insertEmPKcm"]
    pub fn SkString_insert1(
        this: *mut SkString,
        offset: usize,
        text: *const ::core::ffi::c_char,
        len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString13insertUnicharEmi"]
    pub fn SkString_insertUnichar(this: *mut SkString, offset: usize, arg1: SkUnichar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertS32Emi"]
    pub fn SkString_insertS32(this: *mut SkString, offset: usize, value: i32);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertS64Emxi"]
    pub fn SkString_insertS64(
        this: *mut SkString,
        offset: usize,
        value: i64,
        minDigits: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertU32Emj"]
    pub fn SkString_insertU32(this: *mut SkString, offset: usize, value: u32);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertU64Emyi"]
    pub fn SkString_insertU64(
        this: *mut SkString,
        offset: usize,
        value: u64,
        minDigits: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertHexEmji"]
    pub fn SkString_insertHex(
        this: *mut SkString,
        offset: usize,
        value: u32,
        minDigits: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString12insertScalarEmf"]
    pub fn SkString_insertScalar(this: *mut SkString, offset: usize, arg1: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6printfEPKcz"]
    pub fn SkString_printf(this: *mut SkString, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString11printVAListEPKcPc"]
    pub fn SkString_printVAList(
        this: *mut SkString,
        format: *const ::core::ffi::c_char,
        arg1: va_list,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString7appendfEPKcz"]
    pub fn SkString_appendf(this: *mut SkString, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString12appendVAListEPKcPc"]
    pub fn SkString_appendVAList(
        this: *mut SkString,
        format: *const ::core::ffi::c_char,
        arg1: va_list,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString8prependfEPKcz"]
    pub fn SkString_prependf(this: *mut SkString, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString13prependVAListEPKcPc"]
    pub fn SkString_prependVAList(
        this: *mut SkString,
        format: *const ::core::ffi::c_char,
        arg1: va_list,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6removeEmm"]
    pub fn SkString_remove(this: *mut SkString, offset: usize, length: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString4swapERS_"]
    pub fn SkString_swap(this: *mut SkString, other: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1Ev"]
    pub fn SkString_SkString(this: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1Em"]
    pub fn SkString_SkString1(this: *mut SkString, len: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1EPKc"]
    pub fn SkString_SkString2(this: *mut SkString, text: *const ::core::ffi::c_char);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1EPKcm"]
    pub fn SkString_SkString3(this: *mut SkString, text: *const ::core::ffi::c_char, len: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1ERKS_"]
    pub fn SkString_SkString4(this: *mut SkString, arg1: *const SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1EOS_"]
    pub fn SkString_SkString5(this: *mut SkString, arg1: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1ERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"]
    pub fn SkString_SkString6(this: *mut SkString, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1ENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE"]
    pub fn SkString_SkString7(this: *mut SkString, arg1: std_string_view);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringD1Ev"]
    pub fn SkString_SkString_destructor(this: *mut SkString);
}
impl SkString {
    #[inline]
    pub unsafe fn equals(&self, arg1: *const SkString) -> bool {
        SkString_equals(self, arg1)
    }
    #[inline]
    pub unsafe fn equals1(&self, text: *const ::core::ffi::c_char) -> bool {
        SkString_equals1(self, text)
    }
    #[inline]
    pub unsafe fn equals2(&self, text: *const ::core::ffi::c_char, len: usize) -> bool {
        SkString_equals2(self, text, len)
    }
    #[inline]
    pub unsafe fn data(&mut self) -> *mut ::core::ffi::c_char {
        SkString_data(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkString_reset(self)
    }
    #[inline]
    pub unsafe fn resize(&mut self, len: usize) {
        SkString_resize(self, len)
    }
    #[inline]
    pub unsafe fn set(&mut self, text: *const ::core::ffi::c_char) {
        SkString_set(self, text)
    }
    #[inline]
    pub unsafe fn set1(&mut self, text: *const ::core::ffi::c_char, len: usize) {
        SkString_set1(self, text, len)
    }
    #[inline]
    pub unsafe fn insert(&mut self, offset: usize, text: *const ::core::ffi::c_char) {
        SkString_insert(self, offset, text)
    }
    #[inline]
    pub unsafe fn insert1(&mut self, offset: usize, text: *const ::core::ffi::c_char, len: usize) {
        SkString_insert1(self, offset, text, len)
    }
    #[inline]
    pub unsafe fn insertUnichar(&mut self, offset: usize, arg1: SkUnichar) {
        SkString_insertUnichar(self, offset, arg1)
    }
    #[inline]
    pub unsafe fn insertS32(&mut self, offset: usize, value: i32) {
        SkString_insertS32(self, offset, value)
    }
    #[inline]
    pub unsafe fn insertS64(&mut self, offset: usize, value: i64, minDigits: ::core::ffi::c_int) {
        SkString_insertS64(self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertU32(&mut self, offset: usize, value: u32) {
        SkString_insertU32(self, offset, value)
    }
    #[inline]
    pub unsafe fn insertU64(&mut self, offset: usize, value: u64, minDigits: ::core::ffi::c_int) {
        SkString_insertU64(self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertHex(&mut self, offset: usize, value: u32, minDigits: ::core::ffi::c_int) {
        SkString_insertHex(self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertScalar(&mut self, offset: usize, arg1: SkScalar) {
        SkString_insertScalar(self, offset, arg1)
    }
    #[inline]
    pub unsafe fn printVAList(&mut self, format: *const ::core::ffi::c_char, arg1: va_list) {
        SkString_printVAList(self, format, arg1)
    }
    #[inline]
    pub unsafe fn appendVAList(&mut self, format: *const ::core::ffi::c_char, arg1: va_list) {
        SkString_appendVAList(self, format, arg1)
    }
    #[inline]
    pub unsafe fn prependVAList(&mut self, format: *const ::core::ffi::c_char, arg1: va_list) {
        SkString_prependVAList(self, format, arg1)
    }
    #[inline]
    pub unsafe fn remove(&mut self, offset: usize, length: usize) {
        SkString_remove(self, offset, length)
    }
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkString) {
        SkString_swap(self, other)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(len: usize) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString1(__bindgen_tmp.as_mut_ptr(), len);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(text: *const ::core::ffi::c_char) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString2(__bindgen_tmp.as_mut_ptr(), text);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(text: *const ::core::ffi::c_char, len: usize) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString3(__bindgen_tmp.as_mut_ptr(), text, len);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(arg1: *const SkString) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString4(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(arg1: *mut SkString) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString5(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString6(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new7(arg1: std_string_view) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString7(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkString_SkString_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TraitObject {
    pub data: *mut ::core::ffi::c_void,
    pub vtable: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_TraitObject() {
    const UNINIT: ::core::mem::MaybeUninit<TraitObject> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TraitObject>(),
        16usize,
        concat!("Size of: ", stringify!(TraitObject))
    );
    assert_eq!(
        ::core::mem::align_of::<TraitObject>(),
        8usize,
        concat!("Alignment of ", stringify!(TraitObject))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TraitObject),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TraitObject),
            "::",
            stringify!(vtable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VecSink<T> {
    pub fn_trait: TraitObject,
    pub set_fn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut T, arg2: usize, arg3: TraitObject)>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sink<T> {
    pub fn_trait: TraitObject,
    pub set_fn: ::core::option::Option<unsafe extern "C" fn(arg1: *const T, arg2: TraitObject)>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(C)]
pub struct SkStrings {
    pub strings: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_SkStrings() {
    const UNINIT: ::core::mem::MaybeUninit<SkStrings> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkStrings>(),
        24usize,
        concat!("Size of: ", stringify!(SkStrings))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStrings>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStrings))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkStrings),
            "::",
            stringify!(strings)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkIPoint {
    pub fX: i32,
    pub fY: i32,
}
#[test]
fn bindgen_test_layout_SkIPoint() {
    const UNINIT: ::core::mem::MaybeUninit<SkIPoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkIPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SkIPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SkIPoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIPoint),
            "::",
            stringify!(fX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIPoint),
            "::",
            stringify!(fY)
        )
    );
}
pub type SkVector = SkPoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPoint {
    pub fX: f32,
    pub fY: f32,
}
#[test]
fn bindgen_test_layout_SkPoint() {
    const UNINIT: ::core::mem::MaybeUninit<SkPoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SkPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint),
            "::",
            stringify!(fX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint),
            "::",
            stringify!(fY)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint9normalizeEv"]
    pub fn SkPoint_normalize(this: *mut SkPoint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint12setNormalizeEff"]
    pub fn SkPoint_setNormalize(this: *mut SkPoint, x: f32, y: f32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint9setLengthEf"]
    pub fn SkPoint_setLength(this: *mut SkPoint, length: f32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint9setLengthEfff"]
    pub fn SkPoint_setLength1(this: *mut SkPoint, x: f32, y: f32, length: f32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPoint5scaleEfPS_"]
    pub fn SkPoint_scale(this: *const SkPoint, scale: f32, dst: *mut SkPoint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint6LengthEff"]
    pub fn SkPoint_Length(x: f32, y: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint9NormalizeEPS_"]
    pub fn SkPoint_Normalize(vec: *mut SkVector) -> f32;
}
impl SkPoint {
    #[inline]
    pub unsafe fn normalize(&mut self) -> bool {
        SkPoint_normalize(self)
    }
    #[inline]
    pub unsafe fn setNormalize(&mut self, x: f32, y: f32) -> bool {
        SkPoint_setNormalize(self, x, y)
    }
    #[inline]
    pub unsafe fn setLength(&mut self, length: f32) -> bool {
        SkPoint_setLength(self, length)
    }
    #[inline]
    pub unsafe fn setLength1(&mut self, x: f32, y: f32, length: f32) -> bool {
        SkPoint_setLength1(self, x, y, length)
    }
    #[inline]
    pub unsafe fn scale(&self, scale: f32, dst: *mut SkPoint) {
        SkPoint_scale(self, scale, dst)
    }
    #[inline]
    pub unsafe fn Length(x: f32, y: f32) -> f32 {
        SkPoint_Length(x, y)
    }
    #[inline]
    pub unsafe fn Normalize(vec: *mut SkVector) -> f32 {
        SkPoint_Normalize(vec)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkISize {
    pub fWidth: i32,
    pub fHeight: i32,
}
#[test]
fn bindgen_test_layout_SkISize() {
    const UNINIT: ::core::mem::MaybeUninit<SkISize> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkISize>(),
        8usize,
        concat!("Size of: ", stringify!(SkISize))
    );
    assert_eq!(
        ::core::mem::align_of::<SkISize>(),
        4usize,
        concat!("Alignment of ", stringify!(SkISize))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkISize),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkISize),
            "::",
            stringify!(fHeight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSize {
    pub fWidth: SkScalar,
    pub fHeight: SkScalar,
}
#[test]
fn bindgen_test_layout_SkSize() {
    const UNINIT: ::core::mem::MaybeUninit<SkSize> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkSize>(),
        8usize,
        concat!("Size of: ", stringify!(SkSize))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSize>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSize))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSize),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSize),
            "::",
            stringify!(fHeight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkIRect {
    pub fLeft: i32,
    pub fTop: i32,
    pub fRight: i32,
    pub fBottom: i32,
}
#[test]
fn bindgen_test_layout_SkIRect() {
    const UNINIT: ::core::mem::MaybeUninit<SkIRect> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkIRect>(),
        16usize,
        concat!("Size of: ", stringify!(SkIRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkIRect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLeft) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIRect),
            "::",
            stringify!(fLeft)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTop) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIRect),
            "::",
            stringify!(fTop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIRect),
            "::",
            stringify!(fRight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIRect),
            "::",
            stringify!(fBottom)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkIRect9intersectERKS_S1_"]
    pub fn SkIRect_intersect(this: *mut SkIRect, a: *const SkIRect, b: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkIRect4joinERKS_"]
    pub fn SkIRect_join(this: *mut SkIRect, r: *const SkIRect);
}
impl SkIRect {
    #[inline]
    pub unsafe fn intersect(&mut self, a: *const SkIRect, b: *const SkIRect) -> bool {
        SkIRect_intersect(self, a, b)
    }
    #[inline]
    pub unsafe fn join(&mut self, r: *const SkIRect) {
        SkIRect_join(self, r)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRect {
    pub fLeft: f32,
    pub fTop: f32,
    pub fRight: f32,
    pub fBottom: f32,
}
#[test]
fn bindgen_test_layout_SkRect() {
    const UNINIT: ::core::mem::MaybeUninit<SkRect> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRect>(),
        16usize,
        concat!("Size of: ", stringify!(SkRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLeft) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRect),
            "::",
            stringify!(fLeft)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTop) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRect),
            "::",
            stringify!(fTop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRect),
            "::",
            stringify!(fRight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRect),
            "::",
            stringify!(fBottom)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkRect6toQuadEP7SkPoint"]
    pub fn SkRect_toQuad(this: *const SkRect, quad: *mut SkPoint);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect14setBoundsCheckEPK7SkPointi"]
    pub fn SkRect_setBoundsCheck(
        this: *mut SkRect,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect16setBoundsNoCheckEPK7SkPointi"]
    pub fn SkRect_setBoundsNoCheck(
        this: *mut SkRect,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect9intersectERKS_"]
    pub fn SkRect_intersect(this: *mut SkRect, r: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect9intersectERKS_S1_"]
    pub fn SkRect_intersect1(this: *mut SkRect, a: *const SkRect, b: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect4joinERKS_"]
    pub fn SkRect_join(this: *mut SkRect, r: *const SkRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkRect4dumpEb"]
    pub fn SkRect_dump(this: *const SkRect, asHex: bool);
}
impl SkRect {
    #[inline]
    pub unsafe fn toQuad(&self, quad: *mut SkPoint) {
        SkRect_toQuad(self, quad)
    }
    #[inline]
    pub unsafe fn setBoundsCheck(
        &mut self,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
    ) -> bool {
        SkRect_setBoundsCheck(self, pts, count)
    }
    #[inline]
    pub unsafe fn setBoundsNoCheck(&mut self, pts: *const SkPoint, count: ::core::ffi::c_int) {
        SkRect_setBoundsNoCheck(self, pts, count)
    }
    #[inline]
    pub unsafe fn intersect(&mut self, r: *const SkRect) -> bool {
        SkRect_intersect(self, r)
    }
    #[inline]
    pub unsafe fn intersect1(&mut self, a: *const SkRect, b: *const SkRect) -> bool {
        SkRect_intersect1(self, a, b)
    }
    #[inline]
    pub unsafe fn join(&mut self, r: *const SkRect) {
        SkRect_join(self, r)
    }
    #[inline]
    pub unsafe fn dump(&self, asHex: bool) {
        SkRect_dump(self, asHex)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkApplyPerspectiveClip {
    No = 0,
    Yes = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMatrix {
    pub fMat: [SkScalar; 9usize],
    pub fTypeMask: i32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMatrix_ScaleToFit {
    Fill = 0,
    Start = 1,
    Center = 2,
    End = 3,
}
pub const SkMatrix_TypeMask_kIdentity_Mask: SkMatrix_TypeMask = 0;
pub const SkMatrix_TypeMask_kTranslate_Mask: SkMatrix_TypeMask = 1;
pub const SkMatrix_TypeMask_kScale_Mask: SkMatrix_TypeMask = 2;
pub const SkMatrix_TypeMask_kAffine_Mask: SkMatrix_TypeMask = 4;
pub const SkMatrix_TypeMask_kPerspective_Mask: SkMatrix_TypeMask = 8;
pub type SkMatrix_TypeMask = ::core::ffi::c_uint;
pub type SkMatrix_MapXYProc = ::core::option::Option<
    unsafe extern "C" fn(mat: *const SkMatrix, x: SkScalar, y: SkScalar, result: *mut SkPoint),
>;
pub type SkMatrix_MapPtsProc = ::core::option::Option<
    unsafe extern "C" fn(
        mat: *const SkMatrix,
        dst: *mut SkPoint,
        src: *const SkPoint,
        count: ::core::ffi::c_int,
    ),
>;
pub const SkMatrix_kMScaleX: ::core::ffi::c_int = 0;
pub const SkMatrix_kMSkewX: ::core::ffi::c_int = 1;
pub const SkMatrix_kMTransX: ::core::ffi::c_int = 2;
pub const SkMatrix_kMSkewY: ::core::ffi::c_int = 3;
pub const SkMatrix_kMScaleY: ::core::ffi::c_int = 4;
pub const SkMatrix_kMTransY: ::core::ffi::c_int = 5;
pub const SkMatrix_kMPersp0: ::core::ffi::c_int = 6;
pub const SkMatrix_kMPersp1: ::core::ffi::c_int = 7;
pub const SkMatrix_kMPersp2: ::core::ffi::c_int = 8;
pub const SkMatrix_kAScaleX: ::core::ffi::c_int = 0;
pub const SkMatrix_kASkewY: ::core::ffi::c_int = 1;
pub const SkMatrix_kASkewX: ::core::ffi::c_int = 2;
pub const SkMatrix_kAScaleY: ::core::ffi::c_int = 3;
pub const SkMatrix_kATransX: ::core::ffi::c_int = 4;
pub const SkMatrix_kATransY: ::core::ffi::c_int = 5;
pub const SkMatrix_kRectStaysRect_Mask: ::core::ffi::c_int = 16;
pub const SkMatrix_kOnlyPerspectiveValid_Mask: ::core::ffi::c_int = 64;
pub const SkMatrix_kUnknown_Mask: ::core::ffi::c_int = 128;
pub const SkMatrix_kORableMasks: ::core::ffi::c_int = 15;
pub const SkMatrix_kAllMasks: ::core::ffi::c_int = 31;
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix11gMapXYProcsE"]
    pub static SkMatrix_gMapXYProcs: [SkMatrix_MapXYProc; 0usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix12gMapPtsProcsE"]
    pub static SkMatrix_gMapPtsProcs: [SkMatrix_MapPtsProc; 0usize];
}
#[test]
fn bindgen_test_layout_SkMatrix() {
    const UNINIT: ::core::mem::MaybeUninit<SkMatrix> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkMatrix>(),
        40usize,
        concat!("Size of: ", stringify!(SkMatrix))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMatrix>(),
        4usize,
        concat!("Alignment of ", stringify!(SkMatrix))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMatrix),
            "::",
            stringify!(fMat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTypeMask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMatrix),
            "::",
            stringify!(fTypeMask)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix12isSimilarityEf"]
    pub fn SkMatrix_isSimilarity(this: *const SkMatrix, tol: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix20preservesRightAnglesEf"]
    pub fn SkMatrix_preservesRightAngles(this: *const SkMatrix, tol: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix4set9EPKf"]
    pub fn SkMatrix_set9(this: *mut SkMatrix, buffer: *const SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix5resetEv"]
    pub fn SkMatrix_reset(this: *mut SkMatrix) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix12setTranslateEff"]
    pub fn SkMatrix_setTranslate(this: *mut SkMatrix, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8setScaleEffff"]
    pub fn SkMatrix_setScale(
        this: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8setScaleEff"]
    pub fn SkMatrix_setScale1(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setRotateEfff"]
    pub fn SkMatrix_setRotate(
        this: *mut SkMatrix,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setRotateEf"]
    pub fn SkMatrix_setRotate1(this: *mut SkMatrix, degrees: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setSinCosEffff"]
    pub fn SkMatrix_setSinCos(
        this: *mut SkMatrix,
        sinValue: SkScalar,
        cosValue: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setSinCosEff"]
    pub fn SkMatrix_setSinCos1(
        this: *mut SkMatrix,
        sinValue: SkScalar,
        cosValue: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix10setRSXformERK9SkRSXform"]
    pub fn SkMatrix_setRSXform(this: *mut SkMatrix, rsxForm: *const SkRSXform) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix7setSkewEffff"]
    pub fn SkMatrix_setSkew(
        this: *mut SkMatrix,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix7setSkewEff"]
    pub fn SkMatrix_setSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setConcatERKS_S1_"]
    pub fn SkMatrix_setConcat(
        this: *mut SkMatrix,
        a: *const SkMatrix,
        b: *const SkMatrix,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix12preTranslateEff"]
    pub fn SkMatrix_preTranslate(this: *mut SkMatrix, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8preScaleEffff"]
    pub fn SkMatrix_preScale(
        this: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8preScaleEff"]
    pub fn SkMatrix_preScale1(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9preRotateEfff"]
    pub fn SkMatrix_preRotate(
        this: *mut SkMatrix,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9preRotateEf"]
    pub fn SkMatrix_preRotate1(this: *mut SkMatrix, degrees: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix7preSkewEffff"]
    pub fn SkMatrix_preSkew(
        this: *mut SkMatrix,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix7preSkewEff"]
    pub fn SkMatrix_preSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9preConcatERKS_"]
    pub fn SkMatrix_preConcat(this: *mut SkMatrix, other: *const SkMatrix) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix13postTranslateEff"]
    pub fn SkMatrix_postTranslate(this: *mut SkMatrix, dx: SkScalar, dy: SkScalar)
        -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9postScaleEffff"]
    pub fn SkMatrix_postScale(
        this: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9postScaleEff"]
    pub fn SkMatrix_postScale1(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix10postRotateEfff"]
    pub fn SkMatrix_postRotate(
        this: *mut SkMatrix,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix10postRotateEf"]
    pub fn SkMatrix_postRotate1(this: *mut SkMatrix, degrees: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8postSkewEffff"]
    pub fn SkMatrix_postSkew(
        this: *mut SkMatrix,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8postSkewEff"]
    pub fn SkMatrix_postSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix10postConcatERKS_"]
    pub fn SkMatrix_postConcat(this: *mut SkMatrix, other: *const SkMatrix) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix13setRectToRectERK6SkRectS2_NS_10ScaleToFitE"]
    pub fn SkMatrix_setRectToRect(
        this: *mut SkMatrix,
        src: *const SkRect,
        dst: *const SkRect,
        stf: SkMatrix_ScaleToFit,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix13setPolyToPolyEPK7SkPointS2_i"]
    pub fn SkMatrix_setPolyToPoly(
        this: *mut SkMatrix,
        src: *const SkPoint,
        dst: *const SkPoint,
        count: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix17SetAffineIdentityEPf"]
    pub fn SkMatrix_SetAffineIdentity(affine: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix8asAffineEPf"]
    pub fn SkMatrix_asAffine(this: *const SkMatrix, affine: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setAffineEPKf"]
    pub fn SkMatrix_setAffine(this: *mut SkMatrix, affine: *const SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix9mapPointsEP7SkPointPKS0_i"]
    pub fn SkMatrix_mapPoints(
        this: *const SkMatrix,
        dst: *mut SkPoint,
        src: *const SkPoint,
        count: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix20mapHomogeneousPointsEP8SkPoint3PKS0_i"]
    pub fn SkMatrix_mapHomogeneousPoints(
        this: *const SkMatrix,
        dst: *mut SkPoint3,
        src: *const SkPoint3,
        count: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix20mapHomogeneousPointsEP8SkPoint3PK7SkPointi"]
    pub fn SkMatrix_mapHomogeneousPoints1(
        this: *const SkMatrix,
        dst: *mut SkPoint3,
        src: *const SkPoint,
        count: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix5mapXYEffP7SkPoint"]
    pub fn SkMatrix_mapXY(this: *const SkMatrix, x: SkScalar, y: SkScalar, result: *mut SkPoint);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix10mapVectorsEP7SkPointPKS0_i"]
    pub fn SkMatrix_mapVectors(
        this: *const SkMatrix,
        dst: *mut SkVector,
        src: *const SkVector,
        count: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix7mapRectEP6SkRectRKS0_22SkApplyPerspectiveClip"]
    pub fn SkMatrix_mapRect(
        this: *const SkMatrix,
        dst: *mut SkRect,
        src: *const SkRect,
        pc: SkApplyPerspectiveClip,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix21mapRectScaleTranslateEP6SkRectRKS0_"]
    pub fn SkMatrix_mapRectScaleTranslate(
        this: *const SkMatrix,
        dst: *mut SkRect,
        src: *const SkRect,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix9mapRadiusEf"]
    pub fn SkMatrix_mapRadius(this: *const SkMatrix, radius: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix4dumpEv"]
    pub fn SkMatrix_dump(this: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix11getMinScaleEv"]
    pub fn SkMatrix_getMinScale(this: *const SkMatrix) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix11getMaxScaleEv"]
    pub fn SkMatrix_getMaxScale(this: *const SkMatrix) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix15getMinMaxScalesEPf"]
    pub fn SkMatrix_getMinMaxScales(this: *const SkMatrix, scaleFactors: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix14decomposeScaleEP6SkSizePS_"]
    pub fn SkMatrix_decomposeScale(
        this: *const SkMatrix,
        scale: *mut SkSize,
        remaining: *mut SkMatrix,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix1IEv"]
    pub fn SkMatrix_I() -> *const SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix13InvalidMatrixEv"]
    pub fn SkMatrix_InvalidMatrix() -> *const SkMatrix;
}
impl SkMatrix {
    #[inline]
    pub unsafe fn isSimilarity(&self, tol: SkScalar) -> bool {
        SkMatrix_isSimilarity(self, tol)
    }
    #[inline]
    pub unsafe fn preservesRightAngles(&self, tol: SkScalar) -> bool {
        SkMatrix_preservesRightAngles(self, tol)
    }
    #[inline]
    pub unsafe fn set9(&mut self, buffer: *const SkScalar) -> *mut SkMatrix {
        SkMatrix_set9(self, buffer)
    }
    #[inline]
    pub unsafe fn reset(&mut self) -> *mut SkMatrix {
        SkMatrix_reset(self)
    }
    #[inline]
    pub unsafe fn setTranslate(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix {
        SkMatrix_setTranslate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn setScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setScale(self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn setScale1(&mut self, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix {
        SkMatrix_setScale1(self, sx, sy)
    }
    #[inline]
    pub unsafe fn setRotate(
        &mut self,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setRotate(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn setRotate1(&mut self, degrees: SkScalar) -> *mut SkMatrix {
        SkMatrix_setRotate1(self, degrees)
    }
    #[inline]
    pub unsafe fn setSinCos(
        &mut self,
        sinValue: SkScalar,
        cosValue: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setSinCos(self, sinValue, cosValue, px, py)
    }
    #[inline]
    pub unsafe fn setSinCos1(&mut self, sinValue: SkScalar, cosValue: SkScalar) -> *mut SkMatrix {
        SkMatrix_setSinCos1(self, sinValue, cosValue)
    }
    #[inline]
    pub unsafe fn setRSXform(&mut self, rsxForm: *const SkRSXform) -> *mut SkMatrix {
        SkMatrix_setRSXform(self, rsxForm)
    }
    #[inline]
    pub unsafe fn setSkew(
        &mut self,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setSkew(self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn setSkew1(&mut self, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix {
        SkMatrix_setSkew1(self, kx, ky)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkMatrix, b: *const SkMatrix) -> *mut SkMatrix {
        SkMatrix_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn preTranslate(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix {
        SkMatrix_preTranslate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn preScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_preScale(self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn preScale1(&mut self, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix {
        SkMatrix_preScale1(self, sx, sy)
    }
    #[inline]
    pub unsafe fn preRotate(
        &mut self,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_preRotate(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn preRotate1(&mut self, degrees: SkScalar) -> *mut SkMatrix {
        SkMatrix_preRotate1(self, degrees)
    }
    #[inline]
    pub unsafe fn preSkew(
        &mut self,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_preSkew(self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn preSkew1(&mut self, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix {
        SkMatrix_preSkew1(self, kx, ky)
    }
    #[inline]
    pub unsafe fn preConcat(&mut self, other: *const SkMatrix) -> *mut SkMatrix {
        SkMatrix_preConcat(self, other)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix {
        SkMatrix_postTranslate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn postScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_postScale(self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn postScale1(&mut self, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix {
        SkMatrix_postScale1(self, sx, sy)
    }
    #[inline]
    pub unsafe fn postRotate(
        &mut self,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_postRotate(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn postRotate1(&mut self, degrees: SkScalar) -> *mut SkMatrix {
        SkMatrix_postRotate1(self, degrees)
    }
    #[inline]
    pub unsafe fn postSkew(
        &mut self,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_postSkew(self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn postSkew1(&mut self, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix {
        SkMatrix_postSkew1(self, kx, ky)
    }
    #[inline]
    pub unsafe fn postConcat(&mut self, other: *const SkMatrix) -> *mut SkMatrix {
        SkMatrix_postConcat(self, other)
    }
    #[inline]
    pub unsafe fn setRectToRect(
        &mut self,
        src: *const SkRect,
        dst: *const SkRect,
        stf: SkMatrix_ScaleToFit,
    ) -> bool {
        SkMatrix_setRectToRect(self, src, dst, stf)
    }
    #[inline]
    pub unsafe fn setPolyToPoly(
        &mut self,
        src: *const SkPoint,
        dst: *const SkPoint,
        count: ::core::ffi::c_int,
    ) -> bool {
        SkMatrix_setPolyToPoly(self, src, dst, count)
    }
    #[inline]
    pub unsafe fn SetAffineIdentity(affine: *mut SkScalar) {
        SkMatrix_SetAffineIdentity(affine)
    }
    #[inline]
    pub unsafe fn asAffine(&self, affine: *mut SkScalar) -> bool {
        SkMatrix_asAffine(self, affine)
    }
    #[inline]
    pub unsafe fn setAffine(&mut self, affine: *const SkScalar) -> *mut SkMatrix {
        SkMatrix_setAffine(self, affine)
    }
    #[inline]
    pub unsafe fn mapPoints(
        &self,
        dst: *mut SkPoint,
        src: *const SkPoint,
        count: ::core::ffi::c_int,
    ) {
        SkMatrix_mapPoints(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapHomogeneousPoints(
        &self,
        dst: *mut SkPoint3,
        src: *const SkPoint3,
        count: ::core::ffi::c_int,
    ) {
        SkMatrix_mapHomogeneousPoints(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapHomogeneousPoints1(
        &self,
        dst: *mut SkPoint3,
        src: *const SkPoint,
        count: ::core::ffi::c_int,
    ) {
        SkMatrix_mapHomogeneousPoints1(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapXY(&self, x: SkScalar, y: SkScalar, result: *mut SkPoint) {
        SkMatrix_mapXY(self, x, y, result)
    }
    #[inline]
    pub unsafe fn mapVectors(
        &self,
        dst: *mut SkVector,
        src: *const SkVector,
        count: ::core::ffi::c_int,
    ) {
        SkMatrix_mapVectors(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapRect(
        &self,
        dst: *mut SkRect,
        src: *const SkRect,
        pc: SkApplyPerspectiveClip,
    ) -> bool {
        SkMatrix_mapRect(self, dst, src, pc)
    }
    #[inline]
    pub unsafe fn mapRectScaleTranslate(&self, dst: *mut SkRect, src: *const SkRect) {
        SkMatrix_mapRectScaleTranslate(self, dst, src)
    }
    #[inline]
    pub unsafe fn mapRadius(&self, radius: SkScalar) -> SkScalar {
        SkMatrix_mapRadius(self, radius)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkMatrix_dump(self)
    }
    #[inline]
    pub unsafe fn getMinScale(&self) -> SkScalar {
        SkMatrix_getMinScale(self)
    }
    #[inline]
    pub unsafe fn getMaxScale(&self) -> SkScalar {
        SkMatrix_getMaxScale(self)
    }
    #[inline]
    pub unsafe fn getMinMaxScales(&self, scaleFactors: *mut SkScalar) -> bool {
        SkMatrix_getMinMaxScales(self, scaleFactors)
    }
    #[inline]
    pub unsafe fn decomposeScale(&self, scale: *mut SkSize, remaining: *mut SkMatrix) -> bool {
        SkMatrix_decomposeScale(self, scale, remaining)
    }
    #[inline]
    pub unsafe fn I() -> *const SkMatrix {
        SkMatrix_I()
    }
    #[inline]
    pub unsafe fn InvalidMatrix() -> *const SkMatrix {
        SkMatrix_InvalidMatrix()
    }
}
impl SkEncodedOrigin {
    pub const Default: SkEncodedOrigin = SkEncodedOrigin::TopLeft;
}
impl SkEncodedOrigin {
    pub const Last: SkEncodedOrigin = SkEncodedOrigin::LeftBottom;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedOrigin {
    TopLeft = 1,
    TopRight = 2,
    BottomRight = 3,
    BottomLeft = 4,
    LeftTop = 5,
    RightTop = 6,
    RightBottom = 7,
    LeftBottom = 8,
}
impl SkAlphaType {
    pub const LastEnum: SkAlphaType = SkAlphaType::Unpremul;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkAlphaType {
    Unknown = 0,
    Opaque = 1,
    Premul = 2,
    Unpremul = 3,
}
impl SkColorType {
    pub const kLastEnum_SkColorType: SkColorType = SkColorType::kR8_unorm_SkColorType;
}
impl SkColorType {
    pub const kN32_SkColorType: SkColorType = SkColorType::kRGBA_8888_SkColorType;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkColorType {
    kUnknown_SkColorType = 0,
    kAlpha_8_SkColorType = 1,
    kRGB_565_SkColorType = 2,
    kARGB_4444_SkColorType = 3,
    kRGBA_8888_SkColorType = 4,
    kRGB_888x_SkColorType = 5,
    kBGRA_8888_SkColorType = 6,
    kRGBA_1010102_SkColorType = 7,
    kBGRA_1010102_SkColorType = 8,
    kRGB_101010x_SkColorType = 9,
    kBGR_101010x_SkColorType = 10,
    kBGR_101010x_XR_SkColorType = 11,
    kGray_8_SkColorType = 12,
    kRGBA_F16Norm_SkColorType = 13,
    kRGBA_F16_SkColorType = 14,
    kRGBA_F32_SkColorType = 15,
    kR8G8_unorm_SkColorType = 16,
    kA16_float_SkColorType = 17,
    kR16G16_float_SkColorType = 18,
    kA16_unorm_SkColorType = 19,
    kR16G16_unorm_SkColorType = 20,
    kR16G16B16A16_unorm_SkColorType = 21,
    kSRGBA_8888_SkColorType = 22,
    kR8_unorm_SkColorType = 23,
}
extern "C" {
    #[link_name = "\u{1}__Z24SkColorTypeBytesPerPixel11SkColorType"]
    pub fn SkColorTypeBytesPerPixel(ct: SkColorType) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__Z25SkColorTypeIsAlwaysOpaque11SkColorType"]
    pub fn SkColorTypeIsAlwaysOpaque(ct: SkColorType) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z28SkColorTypeValidateAlphaType11SkColorType11SkAlphaTypePS0_"]
    pub fn SkColorTypeValidateAlphaType(
        colorType: SkColorType,
        alphaType: SkAlphaType,
        canonical: *mut SkAlphaType,
    ) -> bool;
}
impl SkYUVColorSpace {
    pub const LastEnum: SkYUVColorSpace = SkYUVColorSpace::Identity;
}
impl SkYUVColorSpace {
    pub const JPEG: SkYUVColorSpace = SkYUVColorSpace::JPEG_Full;
}
impl SkYUVColorSpace {
    pub const Rec601: SkYUVColorSpace = SkYUVColorSpace::Rec601_Limited;
}
impl SkYUVColorSpace {
    pub const Rec709: SkYUVColorSpace = SkYUVColorSpace::Rec709_Limited;
}
impl SkYUVColorSpace {
    pub const BT2020: SkYUVColorSpace = SkYUVColorSpace::BT2020_8bit_Limited;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVColorSpace {
    JPEG_Full = 0,
    Rec601_Limited = 1,
    Rec709_Full = 2,
    Rec709_Limited = 3,
    BT2020_8bit_Full = 4,
    BT2020_8bit_Limited = 5,
    BT2020_10bit_Full = 6,
    BT2020_10bit_Limited = 7,
    BT2020_12bit_Full = 8,
    BT2020_12bit_Limited = 9,
    Identity = 10,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkColorInfo {
    pub fColorSpace: sk_sp<SkColorSpace>,
    pub fColorType: SkColorType,
    pub fAlphaType: SkAlphaType,
}
#[test]
fn bindgen_test_layout_SkColorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SkColorInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkColorInfo>(),
        16usize,
        concat!("Size of: ", stringify!(SkColorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkColorInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorSpace) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorInfo),
            "::",
            stringify!(fColorSpace)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorInfo),
            "::",
            stringify!(fColorType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAlphaType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorInfo),
            "::",
            stringify!(fAlphaType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo10colorSpaceEv"]
    pub fn SkColorInfo_colorSpace(this: *const SkColorInfo) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13refColorSpaceEv"]
    pub fn SkColorInfo_refColorSpace(this: *const SkColorInfo) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo16gammaCloseToSRGBEv"]
    pub fn SkColorInfo_gammaCloseToSRGB(this: *const SkColorInfo) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13makeAlphaTypeE11SkAlphaType"]
    pub fn SkColorInfo_makeAlphaType(
        this: *const SkColorInfo,
        newAlphaType: SkAlphaType,
    ) -> SkColorInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13makeColorTypeE11SkColorType"]
    pub fn SkColorInfo_makeColorType(
        this: *const SkColorInfo,
        newColorType: SkColorType,
    ) -> SkColorInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo14makeColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkColorInfo_makeColorSpace(
        this: *const SkColorInfo,
        cs: sk_sp<SkColorSpace>,
    ) -> SkColorInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13bytesPerPixelEv"]
    pub fn SkColorInfo_bytesPerPixel(this: *const SkColorInfo) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13shiftPerPixelEv"]
    pub fn SkColorInfo_shiftPerPixel(this: *const SkColorInfo) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoC1Ev"]
    pub fn SkColorInfo_SkColorInfo(this: *mut SkColorInfo);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoC1E11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE"]
    pub fn SkColorInfo_SkColorInfo1(
        this: *mut SkColorInfo,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoC1ERKS_"]
    pub fn SkColorInfo_SkColorInfo2(this: *mut SkColorInfo, arg1: *const SkColorInfo);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoC1EOS_"]
    pub fn SkColorInfo_SkColorInfo3(this: *mut SkColorInfo, arg1: *mut SkColorInfo);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoD1Ev"]
    pub fn SkColorInfo_SkColorInfo_destructor(this: *mut SkColorInfo);
}
impl SkColorInfo {
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkColorInfo_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkColorInfo_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn gammaCloseToSRGB(&self) -> bool {
        SkColorInfo_gammaCloseToSRGB(self)
    }
    #[inline]
    pub unsafe fn makeAlphaType(&self, newAlphaType: SkAlphaType) -> SkColorInfo {
        SkColorInfo_makeAlphaType(self, newAlphaType)
    }
    #[inline]
    pub unsafe fn makeColorType(&self, newColorType: SkColorType) -> SkColorInfo {
        SkColorInfo_makeColorType(self, newColorType)
    }
    #[inline]
    pub unsafe fn makeColorSpace(&self, cs: sk_sp<SkColorSpace>) -> SkColorInfo {
        SkColorInfo_makeColorSpace(self, cs)
    }
    #[inline]
    pub unsafe fn bytesPerPixel(&self) -> ::core::ffi::c_int {
        SkColorInfo_bytesPerPixel(self)
    }
    #[inline]
    pub unsafe fn shiftPerPixel(&self) -> ::core::ffi::c_int {
        SkColorInfo_shiftPerPixel(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkColorInfo_SkColorInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(ct: SkColorType, at: SkAlphaType, cs: sk_sp<SkColorSpace>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkColorInfo_SkColorInfo1(__bindgen_tmp.as_mut_ptr(), ct, at, cs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkColorInfo) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkColorInfo_SkColorInfo2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *mut SkColorInfo) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkColorInfo_SkColorInfo3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkColorInfo_SkColorInfo_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkImageInfo {
    pub fColorInfo: SkColorInfo,
    pub fDimensions: SkISize,
}
#[test]
fn bindgen_test_layout_SkImageInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SkImageInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkImageInfo>(),
        24usize,
        concat!("Size of: ", stringify!(SkImageInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImageInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageInfo),
            "::",
            stringify!(fColorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDimensions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageInfo),
            "::",
            stringify!(fDimensions)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo4MakeEii11SkColorType11SkAlphaType"]
    pub fn SkImageInfo_Make(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        ct: SkColorType,
        at: SkAlphaType,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo4MakeEii11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_Make1(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo4MakeE7SkISize11SkColorType11SkAlphaType"]
    pub fn SkImageInfo_Make2(dimensions: SkISize, ct: SkColorType, at: SkAlphaType) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo4MakeE7SkISize11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_Make3(
        dimensions: SkISize,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo7MakeN32Eii11SkAlphaType"]
    pub fn SkImageInfo_MakeN32(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo7MakeN32Eii11SkAlphaType5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_MakeN321(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo7MakeS32Eii11SkAlphaType"]
    pub fn SkImageInfo_MakeS32(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulEii"]
    pub fn SkImageInfo_MakeN32Premul(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulEii5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_MakeN32Premul1(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulE7SkISize"]
    pub fn SkImageInfo_MakeN32Premul2(dimensions: SkISize) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulE7SkISize5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_MakeN32Premul3(dimensions: SkISize, cs: sk_sp<SkColorSpace>) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo6MakeA8Eii"]
    pub fn SkImageInfo_MakeA8(width: ::core::ffi::c_int, height: ::core::ffi::c_int)
        -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo6MakeA8E7SkISize"]
    pub fn SkImageInfo_MakeA81(dimensions: SkISize) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo11MakeUnknownEii"]
    pub fn SkImageInfo_MakeUnknown(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo10colorSpaceEv"]
    pub fn SkImageInfo_colorSpace(this: *const SkImageInfo) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo13refColorSpaceEv"]
    pub fn SkImageInfo_refColorSpace(this: *const SkImageInfo) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo14makeColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_makeColorSpace(
        this: *const SkImageInfo,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo13computeOffsetEiim"]
    pub fn SkImageInfo_computeOffset(
        this: *const SkImageInfo,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        rowBytes: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo15computeByteSizeEm"]
    pub fn SkImageInfo_computeByteSize(this: *const SkImageInfo, rowBytes: usize) -> usize;
}
impl SkImageInfo {
    #[inline]
    pub unsafe fn Make(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        ct: SkColorType,
        at: SkAlphaType,
    ) -> SkImageInfo {
        SkImageInfo_Make(width, height, ct, at)
    }
    #[inline]
    pub unsafe fn Make1(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo {
        SkImageInfo_Make1(width, height, ct, at, cs)
    }
    #[inline]
    pub unsafe fn Make2(dimensions: SkISize, ct: SkColorType, at: SkAlphaType) -> SkImageInfo {
        SkImageInfo_Make2(dimensions, ct, at)
    }
    #[inline]
    pub unsafe fn Make3(
        dimensions: SkISize,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo {
        SkImageInfo_Make3(dimensions, ct, at, cs)
    }
    #[inline]
    pub unsafe fn MakeN32(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo {
        SkImageInfo_MakeN32(width, height, at)
    }
    #[inline]
    pub unsafe fn MakeN321(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo {
        SkImageInfo_MakeN321(width, height, at, cs)
    }
    #[inline]
    pub unsafe fn MakeS32(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo {
        SkImageInfo_MakeS32(width, height, at)
    }
    #[inline]
    pub unsafe fn MakeN32Premul(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> SkImageInfo {
        SkImageInfo_MakeN32Premul(width, height)
    }
    #[inline]
    pub unsafe fn MakeN32Premul1(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo {
        SkImageInfo_MakeN32Premul1(width, height, cs)
    }
    #[inline]
    pub unsafe fn MakeN32Premul2(dimensions: SkISize) -> SkImageInfo {
        SkImageInfo_MakeN32Premul2(dimensions)
    }
    #[inline]
    pub unsafe fn MakeN32Premul3(dimensions: SkISize, cs: sk_sp<SkColorSpace>) -> SkImageInfo {
        SkImageInfo_MakeN32Premul3(dimensions, cs)
    }
    #[inline]
    pub unsafe fn MakeA8(width: ::core::ffi::c_int, height: ::core::ffi::c_int) -> SkImageInfo {
        SkImageInfo_MakeA8(width, height)
    }
    #[inline]
    pub unsafe fn MakeA81(dimensions: SkISize) -> SkImageInfo {
        SkImageInfo_MakeA81(dimensions)
    }
    #[inline]
    pub unsafe fn MakeUnknown(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> SkImageInfo {
        SkImageInfo_MakeUnknown(width, height)
    }
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkImageInfo_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkImageInfo_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn makeColorSpace(&self, cs: sk_sp<SkColorSpace>) -> SkImageInfo {
        SkImageInfo_makeColorSpace(self, cs)
    }
    #[inline]
    pub unsafe fn computeOffset(
        &self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        rowBytes: usize,
    ) -> usize {
        SkImageInfo_computeOffset(self, x, y, rowBytes)
    }
    #[inline]
    pub unsafe fn computeByteSize(&self, rowBytes: usize) -> usize {
        SkImageInfo_computeByteSize(self, rowBytes)
    }
}
pub type SkColor = u32;
pub const SK_ColorTRANSPARENT: SkColor = 0;
pub const SK_ColorBLACK: SkColor = 4278190080;
pub const SK_ColorDKGRAY: SkColor = 4282664004;
pub const SK_ColorGRAY: SkColor = 4287137928;
pub const SK_ColorLTGRAY: SkColor = 4291611852;
pub const SK_ColorWHITE: SkColor = 4294967295;
pub const SK_ColorRED: SkColor = 4294901760;
pub const SK_ColorGREEN: SkColor = 4278255360;
pub const SK_ColorBLUE: SkColor = 4278190335;
pub const SK_ColorYELLOW: SkColor = 4294967040;
pub const SK_ColorCYAN: SkColor = 4278255615;
pub const SK_ColorMAGENTA: SkColor = 4294902015;
extern "C" {
    #[link_name = "\u{1}__Z10SkRGBToHSVjjjPf"]
    pub fn SkRGBToHSV(red: U8CPU, green: U8CPU, blue: U8CPU, hsv: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__Z12SkHSVToColorjPKf"]
    pub fn SkHSVToColor(alpha: U8CPU, hsv: *const SkScalar) -> SkColor;
}
pub type SkPMColor = u32;
extern "C" {
    #[link_name = "\u{1}__Z17SkPreMultiplyARGBjjjj"]
    pub fn SkPreMultiplyARGB(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) -> SkPMColor;
}
extern "C" {
    #[link_name = "\u{1}__Z18SkPreMultiplyColorj"]
    pub fn SkPreMultiplyColor(c: SkColor) -> SkPMColor;
}
impl SkColorChannel {
    pub const LastEnum: SkColorChannel = SkColorChannel::A;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkColorChannel {
    R = 0,
    G = 1,
    B = 2,
    A = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkColorChannelFlag {
    kRed_SkColorChannelFlag = 1,
    kGreen_SkColorChannelFlag = 2,
    kBlue_SkColorChannelFlag = 4,
    kAlpha_SkColorChannelFlag = 8,
    kGray_SkColorChannelFlag = 16,
    kGrayAlpha_SkColorChannelFlags = 24,
    kRG_SkColorChannelFlags = 3,
    kRGB_SkColorChannelFlags = 7,
    kRGBA_SkColorChannelFlags = 15,
}
extern "C" {
    #[link_name = "\u{1}FromColor"]
    pub fn SkRGBA4f_FromColor(color: SkColor) -> u8;
}
extern "C" {
    #[link_name = "\u{1}toSkColor"]
    pub fn SkRGBA4f_toSkColor(this: *const u8) -> SkColor;
}
extern "C" {
    #[link_name = "\u{1}FromPMColor"]
    pub fn SkRGBA4f_FromPMColor(arg1: SkPMColor) -> u8;
}
extern "C" {
    #[link_name = "\u{1}toBytes_RGBA"]
    pub fn SkRGBA4f_toBytes_RGBA(this: *const u8) -> u32;
}
extern "C" {
    #[link_name = "\u{1}FromBytes_RGBA"]
    pub fn SkRGBA4f_FromBytes_RGBA(color: u32) -> u8;
}
pub type SkColor4f = [u32; 4usize];
impl SkFilterMode {
    pub const Last: SkFilterMode = SkFilterMode::Linear;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFilterMode {
    Nearest = 0,
    Linear = 1,
}
impl SkMipmapMode {
    pub const Last: SkMipmapMode = SkMipmapMode::Linear;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMipmapMode {
    None = 0,
    Nearest = 1,
    Linear = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCubicResampler {
    pub B: f32,
    pub C: f32,
}
#[test]
fn bindgen_test_layout_SkCubicResampler() {
    const UNINIT: ::core::mem::MaybeUninit<SkCubicResampler> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCubicResampler>(),
        8usize,
        concat!("Size of: ", stringify!(SkCubicResampler))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCubicResampler>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCubicResampler))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCubicResampler),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).C) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCubicResampler),
            "::",
            stringify!(C)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSamplingOptions {
    pub maxAniso: ::core::ffi::c_int,
    pub useCubic: bool,
    pub cubic: SkCubicResampler,
    pub filter: SkFilterMode,
    pub mipmap: SkMipmapMode,
}
#[test]
fn bindgen_test_layout_SkSamplingOptions() {
    const UNINIT: ::core::mem::MaybeUninit<SkSamplingOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkSamplingOptions>(),
        24usize,
        concat!("Size of: ", stringify!(SkSamplingOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSamplingOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSamplingOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxAniso) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSamplingOptions),
            "::",
            stringify!(maxAniso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).useCubic) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSamplingOptions),
            "::",
            stringify!(useCubic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cubic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSamplingOptions),
            "::",
            stringify!(cubic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSamplingOptions),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSamplingOptions),
            "::",
            stringify!(mipmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMask {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPixmap {
    pub fPixels: *const ::core::ffi::c_void,
    pub fRowBytes: usize,
    pub fInfo: SkImageInfo,
}
#[test]
fn bindgen_test_layout_SkPixmap() {
    const UNINIT: ::core::mem::MaybeUninit<SkPixmap> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPixmap>(),
        40usize,
        concat!("Size of: ", stringify!(SkPixmap))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPixmap>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPixmap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPixels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPixmap),
            "::",
            stringify!(fPixels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRowBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPixmap),
            "::",
            stringify!(fRowBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPixmap),
            "::",
            stringify!(fInfo)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPixmap5resetEv"]
    pub fn SkPixmap_reset(this: *mut SkPixmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPixmap5resetERK11SkImageInfoPKvm"]
    pub fn SkPixmap_reset1(
        this: *mut SkPixmap,
        info: *const SkImageInfo,
        addr: *const ::core::ffi::c_void,
        rowBytes: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPixmap13setColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkPixmap_setColorSpace(this: *mut SkPixmap, colorSpace: sk_sp<SkColorSpace>);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPixmap5resetERK6SkMask"]
    pub fn SkPixmap_reset2(this: *mut SkPixmap, mask: *const SkMask) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap13extractSubsetEPS_RK7SkIRect"]
    pub fn SkPixmap_extractSubset(
        this: *const SkPixmap,
        subset: *mut SkPixmap,
        area: *const SkIRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap10colorSpaceEv"]
    pub fn SkPixmap_colorSpace(this: *const SkPixmap) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap13refColorSpaceEv"]
    pub fn SkPixmap_refColorSpace(this: *const SkPixmap) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap15computeIsOpaqueEv"]
    pub fn SkPixmap_computeIsOpaque(this: *const SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap8getColorEii"]
    pub fn SkPixmap_getColor(
        this: *const SkPixmap,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> SkColor;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap10getColor4fEii"]
    pub fn SkPixmap_getColor4f(
        this: *const SkPixmap,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> SkColor4f;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap9getAlphafEii"]
    pub fn SkPixmap_getAlphaf(
        this: *const SkPixmap,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkPixmap_readPixels(
        this: *const SkPixmap,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap11scalePixelsERKS_RK17SkSamplingOptions"]
    pub fn SkPixmap_scalePixels(
        this: *const SkPixmap,
        dst: *const SkPixmap,
        arg1: *const SkSamplingOptions,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap5eraseEjRK7SkIRect"]
    pub fn SkPixmap_erase(this: *const SkPixmap, color: SkColor, subset: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap5eraseERK8SkRGBA4fIL11SkAlphaType3EEPK7SkIRect"]
    pub fn SkPixmap_erase1(
        this: *const SkPixmap,
        color: *const SkColor4f,
        subset: *const SkIRect,
    ) -> bool;
}
impl SkPixmap {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPixmap_reset(self)
    }
    #[inline]
    pub unsafe fn reset1(
        &mut self,
        info: *const SkImageInfo,
        addr: *const ::core::ffi::c_void,
        rowBytes: usize,
    ) {
        SkPixmap_reset1(self, info, addr, rowBytes)
    }
    #[inline]
    pub unsafe fn setColorSpace(&mut self, colorSpace: sk_sp<SkColorSpace>) {
        SkPixmap_setColorSpace(self, colorSpace)
    }
    #[inline]
    pub unsafe fn reset2(&mut self, mask: *const SkMask) -> bool {
        SkPixmap_reset2(self, mask)
    }
    #[inline]
    pub unsafe fn extractSubset(&self, subset: *mut SkPixmap, area: *const SkIRect) -> bool {
        SkPixmap_extractSubset(self, subset, area)
    }
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkPixmap_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkPixmap_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn computeIsOpaque(&self) -> bool {
        SkPixmap_computeIsOpaque(self)
    }
    #[inline]
    pub unsafe fn getColor(&self, x: ::core::ffi::c_int, y: ::core::ffi::c_int) -> SkColor {
        SkPixmap_getColor(self, x, y)
    }
    #[inline]
    pub unsafe fn getColor4f(&self, x: ::core::ffi::c_int, y: ::core::ffi::c_int) -> SkColor4f {
        SkPixmap_getColor4f(self, x, y)
    }
    #[inline]
    pub unsafe fn getAlphaf(&self, x: ::core::ffi::c_int, y: ::core::ffi::c_int) -> f32 {
        SkPixmap_getAlphaf(self, x, y)
    }
    #[inline]
    pub unsafe fn readPixels(
        &self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool {
        SkPixmap_readPixels(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn scalePixels(&self, dst: *const SkPixmap, arg1: *const SkSamplingOptions) -> bool {
        SkPixmap_scalePixels(self, dst, arg1)
    }
    #[inline]
    pub unsafe fn erase(&self, color: SkColor, subset: *const SkIRect) -> bool {
        SkPixmap_erase(self, color, subset)
    }
    #[inline]
    pub unsafe fn erase1(&self, color: *const SkColor4f, subset: *const SkIRect) -> bool {
        SkPixmap_erase1(self, color, subset)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkData {
    pub _base: SkNVRefCnt,
    pub fReleaseProc: SkData_ReleaseProc,
    pub fReleaseProcContext: *mut ::core::ffi::c_void,
    pub fPtr: *const ::core::ffi::c_void,
    pub fSize: usize,
}
pub type SkData_ReleaseProc = ::core::option::Option<
    unsafe extern "C" fn(ptr: *const ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
>;
pub type SkData_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkData() {
    const UNINIT: ::core::mem::MaybeUninit<SkData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkData>(),
        40usize,
        concat!("Size of: ", stringify!(SkData))
    );
    assert_eq!(
        ::core::mem::align_of::<SkData>(),
        8usize,
        concat!("Alignment of ", stringify!(SkData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fReleaseProc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkData),
            "::",
            stringify!(fReleaseProc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fReleaseProcContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkData),
            "::",
            stringify!(fReleaseProcContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPtr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkData),
            "::",
            stringify!(fPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkData),
            "::",
            stringify!(fSize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkData9copyRangeEmmPv"]
    pub fn SkData_copyRange(
        this: *const SkData,
        offset: usize,
        length: usize,
        buffer: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkData6equalsEPKS_"]
    pub fn SkData_equals(this: *const SkData, other: *const SkData) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData12MakeWithCopyEPKvm"]
    pub fn SkData_MakeWithCopy(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData17MakeUninitializedEm"]
    pub fn SkData_MakeUninitialized(length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData19MakeZeroInitializedEm"]
    pub fn SkData_MakeZeroInitialized(length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData15MakeWithCStringEPKc"]
    pub fn SkData_MakeWithCString(cstr: *const ::core::ffi::c_char) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData12MakeWithProcEPKvmPFvS1_PvES2_"]
    pub fn SkData_MakeWithProc(
        ptr: *const ::core::ffi::c_void,
        length: usize,
        proc_: SkData_ReleaseProc,
        ctx: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData14MakeFromMallocEPKvm"]
    pub fn SkData_MakeFromMalloc(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData16MakeFromFileNameEPKc"]
    pub fn SkData_MakeFromFileName(path: *const ::core::ffi::c_char) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData12MakeFromFILEEP7__sFILE"]
    pub fn SkData_MakeFromFILE(f: *mut FILE) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData10MakeFromFDEi"]
    pub fn SkData_MakeFromFD(fd: ::core::ffi::c_int) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData14MakeFromStreamEP8SkStreamm"]
    pub fn SkData_MakeFromStream(arg1: *mut SkStream, size: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData10MakeSubsetEPKS_mm"]
    pub fn SkData_MakeSubset(src: *const SkData, offset: usize, length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData9MakeEmptyEv"]
    pub fn SkData_MakeEmpty() -> sk_sp<SkData>;
}
impl SkData {
    #[inline]
    pub unsafe fn copyRange(
        &self,
        offset: usize,
        length: usize,
        buffer: *mut ::core::ffi::c_void,
    ) -> usize {
        SkData_copyRange(self, offset, length, buffer)
    }
    #[inline]
    pub unsafe fn equals(&self, other: *const SkData) -> bool {
        SkData_equals(self, other)
    }
    #[inline]
    pub unsafe fn MakeWithCopy(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData> {
        SkData_MakeWithCopy(data, length)
    }
    #[inline]
    pub unsafe fn MakeUninitialized(length: usize) -> sk_sp<SkData> {
        SkData_MakeUninitialized(length)
    }
    #[inline]
    pub unsafe fn MakeZeroInitialized(length: usize) -> sk_sp<SkData> {
        SkData_MakeZeroInitialized(length)
    }
    #[inline]
    pub unsafe fn MakeWithCString(cstr: *const ::core::ffi::c_char) -> sk_sp<SkData> {
        SkData_MakeWithCString(cstr)
    }
    #[inline]
    pub unsafe fn MakeWithProc(
        ptr: *const ::core::ffi::c_void,
        length: usize,
        proc_: SkData_ReleaseProc,
        ctx: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkData> {
        SkData_MakeWithProc(ptr, length, proc_, ctx)
    }
    #[inline]
    pub unsafe fn MakeFromMalloc(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData> {
        SkData_MakeFromMalloc(data, length)
    }
    #[inline]
    pub unsafe fn MakeFromFileName(path: *const ::core::ffi::c_char) -> sk_sp<SkData> {
        SkData_MakeFromFileName(path)
    }
    #[inline]
    pub unsafe fn MakeFromFILE(f: *mut FILE) -> sk_sp<SkData> {
        SkData_MakeFromFILE(f)
    }
    #[inline]
    pub unsafe fn MakeFromFD(fd: ::core::ffi::c_int) -> sk_sp<SkData> {
        SkData_MakeFromFD(fd)
    }
    #[inline]
    pub unsafe fn MakeFromStream(arg1: *mut SkStream, size: usize) -> sk_sp<SkData> {
        SkData_MakeFromStream(arg1, size)
    }
    #[inline]
    pub unsafe fn MakeSubset(src: *const SkData, offset: usize, length: usize) -> sk_sp<SkData> {
        SkData_MakeSubset(src, offset, length)
    }
    #[inline]
    pub unsafe fn MakeEmpty() -> sk_sp<SkData> {
        SkData_MakeEmpty()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVAInfo {
    pub fDimensions: SkISize,
    pub fPlaneConfig: SkYUVAInfo_PlaneConfig,
    pub fSubsampling: SkYUVAInfo_Subsampling,
    pub fYUVColorSpace: SkYUVColorSpace,
    pub fOrigin: SkEncodedOrigin,
    pub fSitingX: SkYUVAInfo_Siting,
    pub fSitingY: SkYUVAInfo_Siting,
}
impl SkYUVAInfo_YUVAChannels {
    pub const kLast: SkYUVAInfo_YUVAChannels = SkYUVAInfo_YUVAChannels::kA;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_YUVAChannels {
    kY = 0,
    kU = 1,
    kV = 2,
    kA = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVAInfo_YUVALocation {
    _unused: [u8; 0],
}
pub type SkYUVAInfo_YUVALocations = u8;
impl SkYUVAInfo_PlaneConfig {
    pub const Last: SkYUVAInfo_PlaneConfig = SkYUVAInfo_PlaneConfig::UYVA;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_PlaneConfig {
    Unknown = 0,
    Y_U_V = 1,
    Y_V_U = 2,
    Y_UV = 3,
    Y_VU = 4,
    YUV = 5,
    UYV = 6,
    Y_U_V_A = 7,
    Y_V_U_A = 8,
    Y_UV_A = 9,
    Y_VU_A = 10,
    YUVA = 11,
    UYVA = 12,
}
impl SkYUVAInfo_Subsampling {
    pub const kLast: SkYUVAInfo_Subsampling = SkYUVAInfo_Subsampling::k410;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_Subsampling {
    kUnknown = 0,
    k444 = 1,
    k422 = 2,
    k420 = 3,
    k440 = 4,
    k411 = 5,
    k410 = 6,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_Siting {
    Centered = 0,
}
pub const SkYUVAInfo_kYUVAChannelCount: ::core::ffi::c_int = 4;
pub const SkYUVAInfo_kMaxPlanes: ::core::ffi::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SkYUVAInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkYUVAInfo>(),
        32usize,
        concat!("Size of: ", stringify!(SkYUVAInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SkYUVAInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDimensions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fDimensions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPlaneConfig) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fPlaneConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSubsampling) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fSubsampling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fYUVColorSpace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fYUVColorSpace)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOrigin) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fOrigin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSitingX) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fSitingX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSitingY) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAInfo),
            "::",
            stringify!(fSitingY)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo18SubsamplingFactorsENS_11SubsamplingE"]
    pub fn SkYUVAInfo_SubsamplingFactors(arg1: SkYUVAInfo_Subsampling) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo23PlaneSubsamplingFactorsENS_11PlaneConfigENS_11SubsamplingEi"]
    pub fn SkYUVAInfo_PlaneSubsamplingFactors(
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        planeIdx: ::core::ffi::c_int,
    ) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo15PlaneDimensionsE7SkISizeNS_11PlaneConfigENS_11SubsamplingE15SkEncodedOriginPS0_"]
    pub fn SkYUVAInfo_PlaneDimensions(
        imageDimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkEncodedOrigin,
        planeDimensions: *mut SkISize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo16GetYUVALocationsENS_11PlaneConfigEPKj"]
    pub fn SkYUVAInfo_GetYUVALocations(
        arg1: SkYUVAInfo_PlaneConfig,
        planeChannelFlags: *const u32,
    ) -> SkYUVAInfo_YUVALocations;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo8HasAlphaENS_11PlaneConfigE"]
    pub fn SkYUVAInfo_HasAlpha(arg1: SkYUVAInfo_PlaneConfig) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkYUVAInfo17computeTotalBytesEPKmPm"]
    pub fn SkYUVAInfo_computeTotalBytes(
        this: *const SkYUVAInfo,
        rowBytes: *const usize,
        planeSizes: *mut usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkYUVAInfo15toYUVALocationsEPKj"]
    pub fn SkYUVAInfo_toYUVALocations(
        this: *const SkYUVAInfo,
        channelFlags: *const u32,
    ) -> SkYUVAInfo_YUVALocations;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkYUVAInfo15makeSubsamplingENS_11SubsamplingE"]
    pub fn SkYUVAInfo_makeSubsampling(
        this: *const SkYUVAInfo,
        arg1: SkYUVAInfo_Subsampling,
    ) -> SkYUVAInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkYUVAInfo14makeDimensionsE7SkISize"]
    pub fn SkYUVAInfo_makeDimensions(this: *const SkYUVAInfo, arg1: SkISize) -> SkYUVAInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfoC1E7SkISizeNS_11PlaneConfigENS_11SubsamplingE15SkYUVColorSpace15SkEncodedOriginNS_6SitingES5_"]
    pub fn SkYUVAInfo_SkYUVAInfo(
        this: *mut SkYUVAInfo,
        dimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkYUVColorSpace,
        origin: SkEncodedOrigin,
        sitingX: SkYUVAInfo_Siting,
        sitingY: SkYUVAInfo_Siting,
    );
}
impl SkYUVAInfo {
    #[inline]
    pub unsafe fn SubsamplingFactors(arg1: SkYUVAInfo_Subsampling) -> [u32; 2usize] {
        SkYUVAInfo_SubsamplingFactors(arg1)
    }
    #[inline]
    pub unsafe fn PlaneSubsamplingFactors(
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        planeIdx: ::core::ffi::c_int,
    ) -> [u32; 2usize] {
        SkYUVAInfo_PlaneSubsamplingFactors(arg1, arg2, planeIdx)
    }
    #[inline]
    pub unsafe fn PlaneDimensions(
        imageDimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkEncodedOrigin,
        planeDimensions: *mut SkISize,
    ) -> ::core::ffi::c_int {
        SkYUVAInfo_PlaneDimensions(imageDimensions, arg1, arg2, arg3, planeDimensions)
    }
    #[inline]
    pub unsafe fn GetYUVALocations(
        arg1: SkYUVAInfo_PlaneConfig,
        planeChannelFlags: *const u32,
    ) -> SkYUVAInfo_YUVALocations {
        SkYUVAInfo_GetYUVALocations(arg1, planeChannelFlags)
    }
    #[inline]
    pub unsafe fn HasAlpha(arg1: SkYUVAInfo_PlaneConfig) -> bool {
        SkYUVAInfo_HasAlpha(arg1)
    }
    #[inline]
    pub unsafe fn computeTotalBytes(
        &self,
        rowBytes: *const usize,
        planeSizes: *mut usize,
    ) -> usize {
        SkYUVAInfo_computeTotalBytes(self, rowBytes, planeSizes)
    }
    #[inline]
    pub unsafe fn toYUVALocations(&self, channelFlags: *const u32) -> SkYUVAInfo_YUVALocations {
        SkYUVAInfo_toYUVALocations(self, channelFlags)
    }
    #[inline]
    pub unsafe fn makeSubsampling(&self, arg1: SkYUVAInfo_Subsampling) -> SkYUVAInfo {
        SkYUVAInfo_makeSubsampling(self, arg1)
    }
    #[inline]
    pub unsafe fn makeDimensions(&self, arg1: SkISize) -> SkYUVAInfo {
        SkYUVAInfo_makeDimensions(self, arg1)
    }
    #[inline]
    pub unsafe fn new(
        dimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkYUVColorSpace,
        origin: SkEncodedOrigin,
        sitingX: SkYUVAInfo_Siting,
        sitingY: SkYUVAInfo_Siting,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAInfo_SkYUVAInfo(
            __bindgen_tmp.as_mut_ptr(),
            dimensions,
            arg1,
            arg2,
            arg3,
            origin,
            sitingX,
            sitingY,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct SkYUVAPixmapInfo {
    pub fYUVAInfo: SkYUVAInfo,
    pub fPlaneInfos: [u64; 12usize],
    pub fRowBytes: [u64; 4usize],
    pub fDataType: SkYUVAPixmapInfo_DataType,
}
pub use self::SkYUVAInfo_PlaneConfig as SkYUVAPixmapInfo_PlaneConfig;
pub use self::SkYUVAInfo_Subsampling as SkYUVAPixmapInfo_Subsampling;
impl SkYUVAPixmapInfo_DataType {
    pub const Last: SkYUVAPixmapInfo_DataType = SkYUVAPixmapInfo_DataType::Unorm10_Unorm2;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAPixmapInfo_DataType {
    Unorm8 = 0,
    Unorm16 = 1,
    Float16 = 2,
    Unorm10_Unorm2 = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVAPixmapInfo_SupportedDataTypes {
    pub fDataTypeSupport: u64,
}
#[test]
fn bindgen_test_layout_SkYUVAPixmapInfo_SupportedDataTypes() {
    const UNINIT: ::core::mem::MaybeUninit<SkYUVAPixmapInfo_SupportedDataTypes> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkYUVAPixmapInfo_SupportedDataTypes>(),
        8usize,
        concat!("Size of: ", stringify!(SkYUVAPixmapInfo_SupportedDataTypes))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAPixmapInfo_SupportedDataTypes>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkYUVAPixmapInfo_SupportedDataTypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDataTypeSupport) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo_SupportedDataTypes),
            "::",
            stringify!(fDataTypeSupport)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkYUVAPixmapInfo18SupportedDataTypes14enableDataTypeENS_8DataTypeEi"]
    pub fn SkYUVAPixmapInfo_SupportedDataTypes_enableDataType(
        this: *mut SkYUVAPixmapInfo_SupportedDataTypes,
        arg1: SkYUVAPixmapInfo_DataType,
        numChannels: ::core::ffi::c_int,
    );
}
impl SkYUVAPixmapInfo_SupportedDataTypes {
    #[inline]
    pub unsafe fn enableDataType(
        &mut self,
        arg1: SkYUVAPixmapInfo_DataType,
        numChannels: ::core::ffi::c_int,
    ) {
        SkYUVAPixmapInfo_SupportedDataTypes_enableDataType(self, arg1, numChannels)
    }
}
pub const SkYUVAPixmapInfo_kMaxPlanes: ::core::ffi::c_int = 4;
pub const SkYUVAPixmapInfo_kDataTypeCnt: ::core::ffi::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAPixmapInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SkYUVAPixmapInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkYUVAPixmapInfo>(),
        168usize,
        concat!("Size of: ", stringify!(SkYUVAPixmapInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAPixmapInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkYUVAPixmapInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fYUVAInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo),
            "::",
            stringify!(fYUVAInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPlaneInfos) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo),
            "::",
            stringify!(fPlaneInfos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRowBytes) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo),
            "::",
            stringify!(fRowBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDataType) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmapInfo),
            "::",
            stringify!(fDataType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkYUVAPixmapInfo22NumChannelsAndDataTypeE11SkColorType"]
    pub fn SkYUVAPixmapInfo_NumChannelsAndDataType(arg1: SkColorType) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkYUVAPixmapInfo17computeTotalBytesEPm"]
    pub fn SkYUVAPixmapInfo_computeTotalBytes(
        this: *const SkYUVAPixmapInfo,
        planeSizes: *mut usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkYUVAPixmapInfo31initPixmapsFromSingleAllocationEPvP8SkPixmap"]
    pub fn SkYUVAPixmapInfo_initPixmapsFromSingleAllocation(
        this: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
        pixmaps: *mut SkPixmap,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkYUVAPixmapInfo11isSupportedERKNS_18SupportedDataTypesE"]
    pub fn SkYUVAPixmapInfo_isSupported(
        this: *const SkYUVAPixmapInfo,
        arg1: *const SkYUVAPixmapInfo_SupportedDataTypes,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkYUVAPixmapInfoC1ERK10SkYUVAInfoPK11SkColorTypePKm"]
    pub fn SkYUVAPixmapInfo_SkYUVAPixmapInfo(
        this: *mut SkYUVAPixmapInfo,
        arg1: *const SkYUVAInfo,
        arg2: *const SkColorType,
        rowBytes: *const usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkYUVAPixmapInfoC1ERK10SkYUVAInfoNS_8DataTypeEPKm"]
    pub fn SkYUVAPixmapInfo_SkYUVAPixmapInfo1(
        this: *mut SkYUVAPixmapInfo,
        arg1: *const SkYUVAInfo,
        arg2: SkYUVAPixmapInfo_DataType,
        rowBytes: *const usize,
    );
}
impl SkYUVAPixmapInfo {
    #[inline]
    pub unsafe fn NumChannelsAndDataType(arg1: SkColorType) -> [u32; 2usize] {
        SkYUVAPixmapInfo_NumChannelsAndDataType(arg1)
    }
    #[inline]
    pub unsafe fn computeTotalBytes(&self, planeSizes: *mut usize) -> usize {
        SkYUVAPixmapInfo_computeTotalBytes(self, planeSizes)
    }
    #[inline]
    pub unsafe fn initPixmapsFromSingleAllocation(
        &self,
        memory: *mut ::core::ffi::c_void,
        pixmaps: *mut SkPixmap,
    ) -> bool {
        SkYUVAPixmapInfo_initPixmapsFromSingleAllocation(self, memory, pixmaps)
    }
    #[inline]
    pub unsafe fn isSupported(&self, arg1: *const SkYUVAPixmapInfo_SupportedDataTypes) -> bool {
        SkYUVAPixmapInfo_isSupported(self, arg1)
    }
    #[inline]
    pub unsafe fn new(
        arg1: *const SkYUVAInfo,
        arg2: *const SkColorType,
        rowBytes: *const usize,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAPixmapInfo_SkYUVAPixmapInfo(__bindgen_tmp.as_mut_ptr(), arg1, arg2, rowBytes);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        arg1: *const SkYUVAInfo,
        arg2: SkYUVAPixmapInfo_DataType,
        rowBytes: *const usize,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAPixmapInfo_SkYUVAPixmapInfo1(__bindgen_tmp.as_mut_ptr(), arg1, arg2, rowBytes);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct SkYUVAPixmaps {
    pub fPlanes: [u64; 20usize],
    pub fData: sk_sp<SkData>,
    pub fYUVAInfo: SkYUVAInfo,
    pub fDataType: SkYUVAPixmaps_DataType,
}
pub use self::SkYUVAPixmapInfo_DataType as SkYUVAPixmaps_DataType;
pub const SkYUVAPixmaps_kMaxPlanes: ::core::ffi::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAPixmaps() {
    const UNINIT: ::core::mem::MaybeUninit<SkYUVAPixmaps> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkYUVAPixmaps>(),
        208usize,
        concat!("Size of: ", stringify!(SkYUVAPixmaps))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAPixmaps>(),
        8usize,
        concat!("Alignment of ", stringify!(SkYUVAPixmaps))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPlanes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmaps),
            "::",
            stringify!(fPlanes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fData) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmaps),
            "::",
            stringify!(fData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fYUVAInfo) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmaps),
            "::",
            stringify!(fYUVAInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDataType) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(SkYUVAPixmaps),
            "::",
            stringify!(fDataType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps24RecommendedRGBAColorTypeEN16SkYUVAPixmapInfo8DataTypeE"]
    pub fn SkYUVAPixmaps_RecommendedRGBAColorType(arg1: SkYUVAPixmaps_DataType) -> SkColorType;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps8AllocateERK16SkYUVAPixmapInfo"]
    pub fn SkYUVAPixmaps_Allocate(yuvaPixmapInfo: *const SkYUVAPixmapInfo) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps8FromDataERK16SkYUVAPixmapInfo5sk_spI6SkDataE"]
    pub fn SkYUVAPixmaps_FromData(
        arg1: *const SkYUVAPixmapInfo,
        arg2: sk_sp<SkData>,
    ) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps8MakeCopyERKS_"]
    pub fn SkYUVAPixmaps_MakeCopy(src: *const SkYUVAPixmaps) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps18FromExternalMemoryERK16SkYUVAPixmapInfoPv"]
    pub fn SkYUVAPixmaps_FromExternalMemory(
        arg1: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
    ) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps19FromExternalPixmapsERK10SkYUVAInfoPK8SkPixmap"]
    pub fn SkYUVAPixmaps_FromExternalPixmaps(
        arg1: *const SkYUVAInfo,
        arg2: *const SkPixmap,
    ) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkYUVAPixmaps11pixmapsInfoEv"]
    pub fn SkYUVAPixmaps_pixmapsInfo(this: *const SkYUVAPixmaps) -> SkYUVAPixmapInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkYUVAPixmaps15toYUVALocationsEv"]
    pub fn SkYUVAPixmaps_toYUVALocations(this: *const SkYUVAPixmaps) -> SkYUVAInfo_YUVALocations;
}
impl SkYUVAPixmaps {
    #[inline]
    pub unsafe fn RecommendedRGBAColorType(arg1: SkYUVAPixmaps_DataType) -> SkColorType {
        SkYUVAPixmaps_RecommendedRGBAColorType(arg1)
    }
    #[inline]
    pub unsafe fn Allocate(yuvaPixmapInfo: *const SkYUVAPixmapInfo) -> SkYUVAPixmaps {
        SkYUVAPixmaps_Allocate(yuvaPixmapInfo)
    }
    #[inline]
    pub unsafe fn FromData(arg1: *const SkYUVAPixmapInfo, arg2: sk_sp<SkData>) -> SkYUVAPixmaps {
        SkYUVAPixmaps_FromData(arg1, arg2)
    }
    #[inline]
    pub unsafe fn MakeCopy(src: *const SkYUVAPixmaps) -> SkYUVAPixmaps {
        SkYUVAPixmaps_MakeCopy(src)
    }
    #[inline]
    pub unsafe fn FromExternalMemory(
        arg1: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
    ) -> SkYUVAPixmaps {
        SkYUVAPixmaps_FromExternalMemory(arg1, memory)
    }
    #[inline]
    pub unsafe fn FromExternalPixmaps(
        arg1: *const SkYUVAInfo,
        arg2: *const SkPixmap,
    ) -> SkYUVAPixmaps {
        SkYUVAPixmaps_FromExternalPixmaps(arg1, arg2)
    }
    #[inline]
    pub unsafe fn pixmapsInfo(&self) -> SkYUVAPixmapInfo {
        SkYUVAPixmaps_pixmapsInfo(self)
    }
    #[inline]
    pub unsafe fn toYUVALocations(&self) -> SkYUVAInfo_YUVALocations {
        SkYUVAPixmaps_toYUVALocations(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkOnce {
    pub fState: u8,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkOnce_State {
    NotStarted = 0,
    Claimed = 1,
    Done = 2,
}
#[test]
fn bindgen_test_layout_SkOnce() {
    const UNINIT: ::core::mem::MaybeUninit<SkOnce> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkOnce>(),
        1usize,
        concat!("Size of: ", stringify!(SkOnce))
    );
    assert_eq!(
        ::core::mem::align_of::<SkOnce>(),
        1usize,
        concat!("Alignment of ", stringify!(SkOnce))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkOnce),
            "::",
            stringify!(fState)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Matrix3x3 {
    pub vals: [[f32; 3usize]; 3usize],
}
#[test]
fn bindgen_test_layout_skcms_Matrix3x3() {
    const UNINIT: ::core::mem::MaybeUninit<skcms_Matrix3x3> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skcms_Matrix3x3>(),
        36usize,
        concat!("Size of: ", stringify!(skcms_Matrix3x3))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Matrix3x3>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_Matrix3x3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vals) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Matrix3x3),
            "::",
            stringify!(vals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Matrix3x4 {
    pub vals: [[f32; 4usize]; 3usize],
}
#[test]
fn bindgen_test_layout_skcms_Matrix3x4() {
    const UNINIT: ::core::mem::MaybeUninit<skcms_Matrix3x4> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skcms_Matrix3x4>(),
        48usize,
        concat!("Size of: ", stringify!(skcms_Matrix3x4))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Matrix3x4>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_Matrix3x4))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vals) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Matrix3x4),
            "::",
            stringify!(vals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_TransferFunction {
    pub g: f32,
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub e: f32,
    pub f: f32,
}
#[test]
fn bindgen_test_layout_skcms_TransferFunction() {
    const UNINIT: ::core::mem::MaybeUninit<skcms_TransferFunction> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skcms_TransferFunction>(),
        28usize,
        concat!("Size of: ", stringify!(skcms_TransferFunction))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_TransferFunction>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_TransferFunction))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_TransferFunction),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skcms_Curve {
    pub __bindgen_anon_1: skcms_Curve__bindgen_ty_1,
    pub __bindgen_anon_2: skcms_Curve__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Curve__bindgen_ty_1 {
    pub alias_of_table_entries: u32,
    pub parametric: skcms_TransferFunction,
}
#[test]
fn bindgen_test_layout_skcms_Curve__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<skcms_Curve__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skcms_Curve__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(skcms_Curve__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Curve__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_Curve__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alias_of_table_entries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_1),
            "::",
            stringify!(alias_of_table_entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parametric) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_1),
            "::",
            stringify!(parametric)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Curve__bindgen_ty_2 {
    pub table_entries: u32,
    pub table_8: *const u8,
    pub table_16: *const u8,
}
#[test]
fn bindgen_test_layout_skcms_Curve__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<skcms_Curve__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skcms_Curve__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(skcms_Curve__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Curve__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_Curve__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).table_entries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_2),
            "::",
            stringify!(table_entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).table_8) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_2),
            "::",
            stringify!(table_8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).table_16) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_Curve__bindgen_ty_2),
            "::",
            stringify!(table_16)
        )
    );
}
#[test]
fn bindgen_test_layout_skcms_Curve() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Curve>(),
        32usize,
        concat!("Size of: ", stringify!(skcms_Curve))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Curve>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_Curve))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skcms_A2B {
    pub input_channels: u32,
    pub input_curves: [skcms_Curve; 4usize],
    pub grid_points: [u8; 4usize],
    pub grid_8: *const u8,
    pub grid_16: *const u8,
    pub matrix_channels: u32,
    pub matrix_curves: [skcms_Curve; 3usize],
    pub matrix: skcms_Matrix3x4,
    pub output_channels: u32,
    pub output_curves: [skcms_Curve; 3usize],
}
#[test]
fn bindgen_test_layout_skcms_A2B() {
    const UNINIT: ::core::mem::MaybeUninit<skcms_A2B> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skcms_A2B>(),
        416usize,
        concat!("Size of: ", stringify!(skcms_A2B))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_A2B>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_A2B))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input_channels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(input_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input_curves) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(input_curves)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grid_points) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(grid_points)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grid_8) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(grid_8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grid_16) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(grid_16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrix_channels) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(matrix_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrix_curves) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(matrix_curves)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_channels) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(output_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_curves) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_A2B),
            "::",
            stringify!(output_curves)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skcms_B2A {
    pub input_channels: u32,
    pub input_curves: [skcms_Curve; 3usize],
    pub matrix_channels: u32,
    pub matrix: skcms_Matrix3x4,
    pub matrix_curves: [skcms_Curve; 3usize],
    pub output_channels: u32,
    pub grid_points: [u8; 4usize],
    pub grid_8: *const u8,
    pub grid_16: *const u8,
    pub output_curves: [skcms_Curve; 4usize],
}
#[test]
fn bindgen_test_layout_skcms_B2A() {
    const UNINIT: ::core::mem::MaybeUninit<skcms_B2A> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skcms_B2A>(),
        408usize,
        concat!("Size of: ", stringify!(skcms_B2A))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_B2A>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_B2A))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input_channels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(input_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input_curves) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(input_curves)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrix_channels) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(matrix_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrix_curves) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(matrix_curves)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_channels) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(output_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grid_points) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(grid_points)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grid_8) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(grid_8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grid_16) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(grid_16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_curves) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_B2A),
            "::",
            stringify!(output_curves)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_CICP {
    pub color_primaries: u8,
    pub transfer_characteristics: u8,
    pub matrix_coefficients: u8,
    pub video_full_range_flag: u8,
}
#[test]
fn bindgen_test_layout_skcms_CICP() {
    const UNINIT: ::core::mem::MaybeUninit<skcms_CICP> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skcms_CICP>(),
        4usize,
        concat!("Size of: ", stringify!(skcms_CICP))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_CICP>(),
        1usize,
        concat!("Alignment of ", stringify!(skcms_CICP))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_CICP),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transfer_characteristics) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_CICP),
            "::",
            stringify!(transfer_characteristics)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrix_coefficients) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_CICP),
            "::",
            stringify!(matrix_coefficients)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).video_full_range_flag) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_CICP),
            "::",
            stringify!(video_full_range_flag)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skcms_ICCProfile {
    pub buffer: *const u8,
    pub size: u32,
    pub data_color_space: u32,
    pub pcs: u32,
    pub tag_count: u32,
    pub has_trc: bool,
    pub trc: [skcms_Curve; 3usize],
    pub has_toXYZD50: bool,
    pub toXYZD50: skcms_Matrix3x3,
    pub has_A2B: bool,
    pub A2B: skcms_A2B,
    pub has_B2A: bool,
    pub B2A: skcms_B2A,
    pub has_CICP: bool,
    pub CICP: skcms_CICP,
}
#[test]
fn bindgen_test_layout_skcms_ICCProfile() {
    const UNINIT: ::core::mem::MaybeUninit<skcms_ICCProfile> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skcms_ICCProfile>(),
        1016usize,
        concat!("Size of: ", stringify!(skcms_ICCProfile))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_ICCProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_ICCProfile))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_color_space) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(data_color_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pcs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(pcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag_count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(tag_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_trc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(has_trc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(trc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_toXYZD50) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(has_toXYZD50)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).toXYZD50) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(toXYZD50)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_A2B) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(has_A2B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A2B) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(A2B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_B2A) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(has_B2A)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).B2A) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(B2A)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_CICP) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(has_CICP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CICP) as usize - ptr as usize },
        1009usize,
        concat!(
            "Offset of field: ",
            stringify!(skcms_ICCProfile),
            "::",
            stringify!(CICP)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skcms_PixelFormat {
    skcms_PixelFormat_A_8 = 0,
    skcms_PixelFormat_A_8_ = 1,
    skcms_PixelFormat_G_8 = 2,
    skcms_PixelFormat_G_8_ = 3,
    skcms_PixelFormat_RGBA_8888_Palette8 = 4,
    skcms_PixelFormat_BGRA_8888_Palette8 = 5,
    skcms_PixelFormat_RGB_565 = 6,
    skcms_PixelFormat_BGR_565 = 7,
    skcms_PixelFormat_ABGR_4444 = 8,
    skcms_PixelFormat_ARGB_4444 = 9,
    skcms_PixelFormat_RGB_888 = 10,
    skcms_PixelFormat_BGR_888 = 11,
    skcms_PixelFormat_RGBA_8888 = 12,
    skcms_PixelFormat_BGRA_8888 = 13,
    skcms_PixelFormat_RGBA_8888_sRGB = 14,
    skcms_PixelFormat_BGRA_8888_sRGB = 15,
    skcms_PixelFormat_RGBA_1010102 = 16,
    skcms_PixelFormat_BGRA_1010102 = 17,
    skcms_PixelFormat_RGB_161616LE = 18,
    skcms_PixelFormat_BGR_161616LE = 19,
    skcms_PixelFormat_RGBA_16161616LE = 20,
    skcms_PixelFormat_BGRA_16161616LE = 21,
    skcms_PixelFormat_RGB_161616BE = 22,
    skcms_PixelFormat_BGR_161616BE = 23,
    skcms_PixelFormat_RGBA_16161616BE = 24,
    skcms_PixelFormat_BGRA_16161616BE = 25,
    skcms_PixelFormat_RGB_hhh_Norm = 26,
    skcms_PixelFormat_BGR_hhh_Norm = 27,
    skcms_PixelFormat_RGBA_hhhh_Norm = 28,
    skcms_PixelFormat_BGRA_hhhh_Norm = 29,
    skcms_PixelFormat_RGB_hhh = 30,
    skcms_PixelFormat_BGR_hhh = 31,
    skcms_PixelFormat_RGBA_hhhh = 32,
    skcms_PixelFormat_BGRA_hhhh = 33,
    skcms_PixelFormat_RGB_fff = 34,
    skcms_PixelFormat_BGR_fff = 35,
    skcms_PixelFormat_RGBA_ffff = 36,
    skcms_PixelFormat_BGRA_ffff = 37,
    skcms_PixelFormat_RGB_101010x_XR = 38,
    skcms_PixelFormat_BGR_101010x_XR = 39,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skcms_AlphaFormat {
    skcms_AlphaFormat_Opaque = 0,
    skcms_AlphaFormat_Unpremul = 1,
    skcms_AlphaFormat_PremulAsEncoded = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkColorSpacePrimaries {
    pub fRX: f32,
    pub fRY: f32,
    pub fGX: f32,
    pub fGY: f32,
    pub fBX: f32,
    pub fBY: f32,
    pub fWX: f32,
    pub fWY: f32,
}
#[test]
fn bindgen_test_layout_SkColorSpacePrimaries() {
    const UNINIT: ::core::mem::MaybeUninit<SkColorSpacePrimaries> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkColorSpacePrimaries>(),
        32usize,
        concat!("Size of: ", stringify!(SkColorSpacePrimaries))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorSpacePrimaries>(),
        4usize,
        concat!("Alignment of ", stringify!(SkColorSpacePrimaries))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fRX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fRY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fGX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fGY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fBX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fBY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWX) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fWX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWY) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpacePrimaries),
            "::",
            stringify!(fWY)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK21SkColorSpacePrimaries8toXYZD50EP15skcms_Matrix3x3"]
    pub fn SkColorSpacePrimaries_toXYZD50(
        this: *const SkColorSpacePrimaries,
        toXYZD50: *mut skcms_Matrix3x3,
    ) -> bool;
}
impl SkColorSpacePrimaries {
    #[inline]
    pub unsafe fn toXYZD50(&self, toXYZD50: *mut skcms_Matrix3x3) -> bool {
        SkColorSpacePrimaries_toXYZD50(self, toXYZD50)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkColorSpace {
    pub _base: SkNVRefCnt,
    pub fTransferFnHash: u32,
    pub fToXYZD50Hash: u32,
    pub fTransferFn: skcms_TransferFunction,
    pub fToXYZD50: skcms_Matrix3x3,
    pub fInvTransferFn: skcms_TransferFunction,
    pub fFromXYZD50: skcms_Matrix3x3,
    pub fLazyDstFieldsOnce: SkOnce,
}
#[test]
fn bindgen_test_layout_SkColorSpace() {
    const UNINIT: ::core::mem::MaybeUninit<SkColorSpace> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkColorSpace>(),
        144usize,
        concat!("Size of: ", stringify!(SkColorSpace))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorSpace>(),
        4usize,
        concat!("Alignment of ", stringify!(SkColorSpace))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTransferFnHash) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fTransferFnHash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fToXYZD50Hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fToXYZD50Hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTransferFn) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fTransferFn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fToXYZD50) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fToXYZD50)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInvTransferFn) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fInvTransferFn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFromXYZD50) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fFromXYZD50)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLazyDstFieldsOnce) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorSpace),
            "::",
            stringify!(fLazyDstFieldsOnce)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace8MakeSRGBEv"]
    pub fn SkColorSpace_MakeSRGB() -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace14MakeSRGBLinearEv"]
    pub fn SkColorSpace_MakeSRGBLinear() -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace7MakeRGBERK22skcms_TransferFunctionRK15skcms_Matrix3x3"]
    pub fn SkColorSpace_MakeRGB(
        transferFn: *const skcms_TransferFunction,
        toXYZ: *const skcms_Matrix3x3,
    ) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace4MakeERK16skcms_ICCProfile"]
    pub fn SkColorSpace_Make(arg1: *const skcms_ICCProfile) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace9toProfileEP16skcms_ICCProfile"]
    pub fn SkColorSpace_toProfile(this: *const SkColorSpace, arg1: *mut skcms_ICCProfile);
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace16gammaCloseToSRGBEv"]
    pub fn SkColorSpace_gammaCloseToSRGB(this: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13gammaIsLinearEv"]
    pub fn SkColorSpace_gammaIsLinear(this: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace21isNumericalTransferFnEP22skcms_TransferFunction"]
    pub fn SkColorSpace_isNumericalTransferFn(
        this: *const SkColorSpace,
        fn_: *mut skcms_TransferFunction,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace8toXYZD50EP15skcms_Matrix3x3"]
    pub fn SkColorSpace_toXYZD50(this: *const SkColorSpace, toXYZD50: *mut skcms_Matrix3x3)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace15makeLinearGammaEv"]
    pub fn SkColorSpace_makeLinearGamma(this: *const SkColorSpace) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13makeSRGBGammaEv"]
    pub fn SkColorSpace_makeSRGBGamma(this: *const SkColorSpace) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13makeColorSpinEv"]
    pub fn SkColorSpace_makeColorSpin(this: *const SkColorSpace) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace6isSRGBEv"]
    pub fn SkColorSpace_isSRGB(this: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace9serializeEv"]
    pub fn SkColorSpace_serialize(this: *const SkColorSpace) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13writeToMemoryEPv"]
    pub fn SkColorSpace_writeToMemory(
        this: *const SkColorSpace,
        memory: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace11DeserializeEPKvm"]
    pub fn SkColorSpace_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace6EqualsEPKS_S1_"]
    pub fn SkColorSpace_Equals(arg1: *const SkColorSpace, arg2: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace10transferFnEPf"]
    pub fn SkColorSpace_transferFn(this: *const SkColorSpace, gabcdef: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace10transferFnEP22skcms_TransferFunction"]
    pub fn SkColorSpace_transferFn1(this: *const SkColorSpace, fn_: *mut skcms_TransferFunction);
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13invTransferFnEP22skcms_TransferFunction"]
    pub fn SkColorSpace_invTransferFn(this: *const SkColorSpace, fn_: *mut skcms_TransferFunction);
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace16gamutTransformToEPKS_P15skcms_Matrix3x3"]
    pub fn SkColorSpace_gamutTransformTo(
        this: *const SkColorSpace,
        dst: *const SkColorSpace,
        src_to_dst: *mut skcms_Matrix3x3,
    );
}
impl SkColorSpace {
    #[inline]
    pub unsafe fn MakeSRGB() -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeSRGB()
    }
    #[inline]
    pub unsafe fn MakeSRGBLinear() -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeSRGBLinear()
    }
    #[inline]
    pub unsafe fn MakeRGB(
        transferFn: *const skcms_TransferFunction,
        toXYZ: *const skcms_Matrix3x3,
    ) -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeRGB(transferFn, toXYZ)
    }
    #[inline]
    pub unsafe fn Make(arg1: *const skcms_ICCProfile) -> sk_sp<SkColorSpace> {
        SkColorSpace_Make(arg1)
    }
    #[inline]
    pub unsafe fn toProfile(&self, arg1: *mut skcms_ICCProfile) {
        SkColorSpace_toProfile(self, arg1)
    }
    #[inline]
    pub unsafe fn gammaCloseToSRGB(&self) -> bool {
        SkColorSpace_gammaCloseToSRGB(self)
    }
    #[inline]
    pub unsafe fn gammaIsLinear(&self) -> bool {
        SkColorSpace_gammaIsLinear(self)
    }
    #[inline]
    pub unsafe fn isNumericalTransferFn(&self, fn_: *mut skcms_TransferFunction) -> bool {
        SkColorSpace_isNumericalTransferFn(self, fn_)
    }
    #[inline]
    pub unsafe fn toXYZD50(&self, toXYZD50: *mut skcms_Matrix3x3) -> bool {
        SkColorSpace_toXYZD50(self, toXYZD50)
    }
    #[inline]
    pub unsafe fn makeLinearGamma(&self) -> sk_sp<SkColorSpace> {
        SkColorSpace_makeLinearGamma(self)
    }
    #[inline]
    pub unsafe fn makeSRGBGamma(&self) -> sk_sp<SkColorSpace> {
        SkColorSpace_makeSRGBGamma(self)
    }
    #[inline]
    pub unsafe fn makeColorSpin(&self) -> sk_sp<SkColorSpace> {
        SkColorSpace_makeColorSpin(self)
    }
    #[inline]
    pub unsafe fn isSRGB(&self) -> bool {
        SkColorSpace_isSRGB(self)
    }
    #[inline]
    pub unsafe fn serialize(&self) -> sk_sp<SkData> {
        SkColorSpace_serialize(self)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, memory: *mut ::core::ffi::c_void) -> usize {
        SkColorSpace_writeToMemory(self, memory)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> sk_sp<SkColorSpace> {
        SkColorSpace_Deserialize(data, length)
    }
    #[inline]
    pub unsafe fn Equals(arg1: *const SkColorSpace, arg2: *const SkColorSpace) -> bool {
        SkColorSpace_Equals(arg1, arg2)
    }
    #[inline]
    pub unsafe fn transferFn(&self, gabcdef: *mut f32) {
        SkColorSpace_transferFn(self, gabcdef)
    }
    #[inline]
    pub unsafe fn transferFn1(&self, fn_: *mut skcms_TransferFunction) {
        SkColorSpace_transferFn1(self, fn_)
    }
    #[inline]
    pub unsafe fn invTransferFn(&self, fn_: *mut skcms_TransferFunction) {
        SkColorSpace_invTransferFn(self, fn_)
    }
    #[inline]
    pub unsafe fn gamutTransformTo(
        &self,
        dst: *const SkColorSpace,
        src_to_dst: *mut skcms_Matrix3x3,
    ) {
        SkColorSpace_gamutTransformTo(self, dst, src_to_dst)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkEncodedInfo {
    pub fWidth: ::core::ffi::c_int,
    pub fHeight: ::core::ffi::c_int,
    pub fColor: SkEncodedInfo_Color,
    pub fAlpha: SkEncodedInfo_Alpha,
    pub fBitsPerComponent: u8,
    pub fColorDepth: u8,
    pub fProfile: u64,
}
#[repr(C)]
pub struct SkEncodedInfo_ICCProfile {
    pub fProfile: skcms_ICCProfile,
    pub fData: sk_sp<SkData>,
}
#[test]
fn bindgen_test_layout_SkEncodedInfo_ICCProfile() {
    const UNINIT: ::core::mem::MaybeUninit<SkEncodedInfo_ICCProfile> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkEncodedInfo_ICCProfile>(),
        1024usize,
        concat!("Size of: ", stringify!(SkEncodedInfo_ICCProfile))
    );
    assert_eq!(
        ::core::mem::align_of::<SkEncodedInfo_ICCProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(SkEncodedInfo_ICCProfile))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo_ICCProfile),
            "::",
            stringify!(fProfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fData) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo_ICCProfile),
            "::",
            stringify!(fData)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkEncodedInfo10ICCProfile4MakeE5sk_spI6SkDataE"]
    pub fn SkEncodedInfo_ICCProfile_Make(arg1: sk_sp<SkData>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkEncodedInfo10ICCProfile4MakeERK16skcms_ICCProfile"]
    pub fn SkEncodedInfo_ICCProfile_Make1(arg1: *const skcms_ICCProfile) -> u64;
}
impl SkEncodedInfo_ICCProfile {
    #[inline]
    pub unsafe fn Make(arg1: sk_sp<SkData>) -> u64 {
        SkEncodedInfo_ICCProfile_Make(arg1)
    }
    #[inline]
    pub unsafe fn Make1(arg1: *const skcms_ICCProfile) -> u64 {
        SkEncodedInfo_ICCProfile_Make1(arg1)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedInfo_Alpha {
    kOpaque_Alpha = 0,
    kUnpremul_Alpha = 1,
    kBinary_Alpha = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedInfo_Color {
    kGray_Color = 0,
    kGrayAlpha_Color = 1,
    kXAlpha_Color = 2,
    k565_Color = 3,
    kPalette_Color = 4,
    kRGB_Color = 5,
    kRGBA_Color = 6,
    kBGR_Color = 7,
    kBGRX_Color = 8,
    kBGRA_Color = 9,
    kYUV_Color = 10,
    kYUVA_Color = 11,
    kInvertedCMYK_Color = 12,
    kYCCK_Color = 13,
}
#[test]
fn bindgen_test_layout_SkEncodedInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SkEncodedInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkEncodedInfo>(),
        32usize,
        concat!("Size of: ", stringify!(SkEncodedInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkEncodedInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkEncodedInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fColor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAlpha) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fAlpha)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBitsPerComponent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fBitsPerComponent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorDepth) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fColorDepth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProfile) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkEncodedInfo),
            "::",
            stringify!(fProfile)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkNoncopyable {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkNoncopyable() {
    assert_eq!(
        ::core::mem::size_of::<SkNoncopyable>(),
        1usize,
        concat!("Size of: ", stringify!(SkNoncopyable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNoncopyable>(),
        1usize,
        concat!("Alignment of ", stringify!(SkNoncopyable))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPngChunkReader {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodecAnimation_DisposalMethod {
    Keep = 1,
    RestoreBGColor = 2,
    RestorePrevious = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodecAnimation_Blend {
    SrcOver = 0,
    Src = 1,
}
#[repr(C)]
pub struct SkCodec__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
pub struct SkCodec {
    pub vtable_: *const SkCodec__bindgen_vtable,
    pub fEncodedInfo: SkEncodedInfo,
    pub fSrcXformFormat: SkCodec_XformFormat,
    pub fStream: u64,
    pub fNeedsRewind: bool,
    pub fOrigin: SkEncodedOrigin,
    pub fDstInfo: SkImageInfo,
    pub fOptions: SkCodec_Options,
    pub fXformTime: SkCodec_XformTime,
    pub fDstXformFormat: SkCodec_XformFormat,
    pub fDstProfile: skcms_ICCProfile,
    pub fDstXformAlphaFormat: skcms_AlphaFormat,
    pub fCurrScanline: ::core::ffi::c_int,
    pub fStartedIncrementalDecode: bool,
    pub fUsingCallbackForHandleFrameIndex: bool,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_Result {
    Success = 0,
    IncompleteInput = 1,
    ErrorInInput = 2,
    InvalidConversion = 3,
    InvalidScale = 4,
    InvalidParameters = 5,
    InvalidInput = 6,
    CouldNotRewind = 7,
    InternalError = 8,
    Unimplemented = 9,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_SelectionPolicy {
    PreferStillImage = 0,
    PreferAnimation = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_ZeroInitialized {
    Yes = 0,
    No = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCodec_Options {
    pub fZeroInitialized: SkCodec_ZeroInitialized,
    pub fSubset: *const SkIRect,
    pub fFrameIndex: ::core::ffi::c_int,
    pub fPriorFrame: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_SkCodec_Options() {
    const UNINIT: ::core::mem::MaybeUninit<SkCodec_Options> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCodec_Options>(),
        24usize,
        concat!("Size of: ", stringify!(SkCodec_Options))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCodec_Options>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCodec_Options))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fZeroInitialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_Options),
            "::",
            stringify!(fZeroInitialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSubset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_Options),
            "::",
            stringify!(fSubset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFrameIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_Options),
            "::",
            stringify!(fFrameIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPriorFrame) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_Options),
            "::",
            stringify!(fPriorFrame)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_SkScanlineOrder {
    TopDown = 0,
    BottomUp = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCodec_FrameInfo {
    pub fRequiredFrame: ::core::ffi::c_int,
    pub fDuration: ::core::ffi::c_int,
    pub fFullyReceived: bool,
    pub fAlphaType: SkAlphaType,
    pub fHasAlphaWithinBounds: bool,
    pub fDisposalMethod: SkCodecAnimation_DisposalMethod,
    pub fBlend: SkCodecAnimation_Blend,
    pub fFrameRect: SkIRect,
}
#[test]
fn bindgen_test_layout_SkCodec_FrameInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SkCodec_FrameInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCodec_FrameInfo>(),
        44usize,
        concat!("Size of: ", stringify!(SkCodec_FrameInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCodec_FrameInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCodec_FrameInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRequiredFrame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fRequiredFrame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDuration) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fDuration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFullyReceived) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fFullyReceived)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAlphaType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fAlphaType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHasAlphaWithinBounds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fHasAlphaWithinBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDisposalMethod) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fDisposalMethod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBlend) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fBlend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFrameRect) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec_FrameInfo),
            "::",
            stringify!(fFrameRect)
        )
    );
}
pub use self::skcms_PixelFormat as SkCodec_XformFormat;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_XformTime {
    kNo_XformTime = 0,
    kPalette_XformTime = 1,
    kDecodeRow_XformTime = 2,
}
pub type SkCodec_GetPixelsCallback = [u64; 4usize];
pub const SkCodec_kNoFrame: ::core::ffi::c_int = -1;
pub const SkCodec_kRepetitionCountInfinite: ::core::ffi::c_int = -1;
#[test]
fn bindgen_test_layout_SkCodec() {
    const UNINIT: ::core::mem::MaybeUninit<SkCodec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCodec>(),
        1152usize,
        concat!("Size of: ", stringify!(SkCodec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCodec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCodec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEncodedInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fEncodedInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSrcXformFormat) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fSrcXformFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStream) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fStream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fNeedsRewind) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fNeedsRewind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOrigin) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fOrigin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDstInfo) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fDstInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOptions) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fOptions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fXformTime) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fXformTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDstXformFormat) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fDstXformFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDstProfile) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fDstProfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDstXformAlphaFormat) as usize - ptr as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fDstXformAlphaFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCurrScanline) as usize - ptr as usize },
        1140usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fCurrScanline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStartedIncrementalDecode) as usize - ptr as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fStartedIncrementalDecode)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fUsingCallbackForHandleFrameIndex) as usize - ptr as usize
        },
        1145usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCodec),
            "::",
            stringify!(fUsingCallbackForHandleFrameIndex)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec14ResultToStringENS_6ResultE"]
    pub fn SkCodec_ResultToString(arg1: SkCodec_Result) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec14MakeFromStreamENSt3__110unique_ptrI8SkStreamNS0_14default_deleteIS2_EEEEPNS_6ResultEP16SkPngChunkReaderNS_15SelectionPolicyE"]
    pub fn SkCodec_MakeFromStream(
        arg1: u64,
        arg2: *mut SkCodec_Result,
        arg3: *mut SkPngChunkReader,
        selectionPolicy: SkCodec_SelectionPolicy,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec12MakeFromDataE5sk_spI6SkDataEP16SkPngChunkReader"]
    pub fn SkCodec_MakeFromData(arg1: sk_sp<SkData>, arg2: *mut SkPngChunkReader) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec9getPixelsERK11SkImageInfoPvmPKNS_7OptionsE"]
    pub fn SkCodec_getPixels(
        this: *mut SkCodec,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec8getImageERK11SkImageInfoPKNS_7OptionsE"]
    pub fn SkCodec_getImage(
        this: *mut SkCodec,
        info: *const SkImageInfo,
        opts: *const SkCodec_Options,
    ) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec8getImageEv"]
    pub fn SkCodec_getImage1(this: *mut SkCodec) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkCodec13queryYUVAInfoERKN16SkYUVAPixmapInfo18SupportedDataTypesEPS0_"]
    pub fn SkCodec_queryYUVAInfo(
        this: *const SkCodec,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec13getYUVAPlanesERK13SkYUVAPixmaps"]
    pub fn SkCodec_getYUVAPlanes(
        this: *mut SkCodec,
        yuvaPixmaps: *const SkYUVAPixmaps,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec22startIncrementalDecodeERK11SkImageInfoPvmPKNS_7OptionsE"]
    pub fn SkCodec_startIncrementalDecode(
        this: *mut SkCodec,
        dstInfo: *const SkImageInfo,
        dst: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec19startScanlineDecodeERK11SkImageInfoPKNS_7OptionsE"]
    pub fn SkCodec_startScanlineDecode(
        this: *mut SkCodec,
        dstInfo: *const SkImageInfo,
        options: *const SkCodec_Options,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec12getScanlinesEPvim"]
    pub fn SkCodec_getScanlines(
        this: *mut SkCodec,
        dst: *mut ::core::ffi::c_void,
        countLines: ::core::ffi::c_int,
        rowBytes: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec13skipScanlinesEi"]
    pub fn SkCodec_skipScanlines(this: *mut SkCodec, countLines: ::core::ffi::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkCodec14outputScanlineEi"]
    pub fn SkCodec_outputScanline(
        this: *const SkCodec,
        inputScanline: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec12getFrameInfoEv"]
    pub fn SkCodec_getFrameInfo(this: *mut SkCodec) -> u8;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec17setSrcXformFormatE17skcms_PixelFormat"]
    pub fn SkCodec_setSrcXformFormat(this: *mut SkCodec, pixelFormat: SkCodec_XformFormat);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec14rewindIfNeededEv"]
    pub fn SkCodec_rewindIfNeeded(this: *mut SkCodec) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkCodec15applyColorXformEPvPKvi"]
    pub fn SkCodec_applyColorXform(
        this: *const SkCodec,
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        count: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodecC2EO13SkEncodedInfo17skcms_PixelFormatNSt3__110unique_ptrI8SkStreamNS3_14default_deleteIS5_EEEE15SkEncodedOrigin"]
    pub fn SkCodec_SkCodec(
        this: *mut SkCodec,
        arg1: *mut SkEncodedInfo,
        srcFormat: SkCodec_XformFormat,
        arg2: u64,
        arg3: SkEncodedOrigin,
    );
}
impl SkCodec {
    #[inline]
    pub unsafe fn ResultToString(arg1: SkCodec_Result) -> *const ::core::ffi::c_char {
        SkCodec_ResultToString(arg1)
    }
    #[inline]
    pub unsafe fn MakeFromStream(
        arg1: u64,
        arg2: *mut SkCodec_Result,
        arg3: *mut SkPngChunkReader,
        selectionPolicy: SkCodec_SelectionPolicy,
    ) -> u64 {
        SkCodec_MakeFromStream(arg1, arg2, arg3, selectionPolicy)
    }
    #[inline]
    pub unsafe fn MakeFromData(arg1: sk_sp<SkData>, arg2: *mut SkPngChunkReader) -> u64 {
        SkCodec_MakeFromData(arg1, arg2)
    }
    #[inline]
    pub unsafe fn getPixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result {
        SkCodec_getPixels(self, info, pixels, rowBytes, arg1)
    }
    #[inline]
    pub unsafe fn getImage(
        &mut self,
        info: *const SkImageInfo,
        opts: *const SkCodec_Options,
    ) -> [u64; 2usize] {
        SkCodec_getImage(self, info, opts)
    }
    #[inline]
    pub unsafe fn getImage1(&mut self) -> [u64; 2usize] {
        SkCodec_getImage1(self)
    }
    #[inline]
    pub unsafe fn queryYUVAInfo(
        &self,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool {
        SkCodec_queryYUVAInfo(self, supportedDataTypes, yuvaPixmapInfo)
    }
    #[inline]
    pub unsafe fn getYUVAPlanes(&mut self, yuvaPixmaps: *const SkYUVAPixmaps) -> SkCodec_Result {
        SkCodec_getYUVAPlanes(self, yuvaPixmaps)
    }
    #[inline]
    pub unsafe fn startIncrementalDecode(
        &mut self,
        dstInfo: *const SkImageInfo,
        dst: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result {
        SkCodec_startIncrementalDecode(self, dstInfo, dst, rowBytes, arg1)
    }
    #[inline]
    pub unsafe fn startScanlineDecode(
        &mut self,
        dstInfo: *const SkImageInfo,
        options: *const SkCodec_Options,
    ) -> SkCodec_Result {
        SkCodec_startScanlineDecode(self, dstInfo, options)
    }
    #[inline]
    pub unsafe fn getScanlines(
        &mut self,
        dst: *mut ::core::ffi::c_void,
        countLines: ::core::ffi::c_int,
        rowBytes: usize,
    ) -> ::core::ffi::c_int {
        SkCodec_getScanlines(self, dst, countLines, rowBytes)
    }
    #[inline]
    pub unsafe fn skipScanlines(&mut self, countLines: ::core::ffi::c_int) -> bool {
        SkCodec_skipScanlines(self, countLines)
    }
    #[inline]
    pub unsafe fn outputScanline(&self, inputScanline: ::core::ffi::c_int) -> ::core::ffi::c_int {
        SkCodec_outputScanline(self, inputScanline)
    }
    #[inline]
    pub unsafe fn getFrameInfo(&mut self) -> u8 {
        SkCodec_getFrameInfo(self)
    }
    #[inline]
    pub unsafe fn setSrcXformFormat(&mut self, pixelFormat: SkCodec_XformFormat) {
        SkCodec_setSrcXformFormat(self, pixelFormat)
    }
    #[inline]
    pub unsafe fn rewindIfNeeded(&mut self) -> bool {
        SkCodec_rewindIfNeeded(self)
    }
    #[inline]
    pub unsafe fn applyColorXform(
        &self,
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        count: ::core::ffi::c_int,
    ) {
        SkCodec_applyColorXform(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn new(
        arg1: *mut SkEncodedInfo,
        srcFormat: SkCodec_XformFormat,
        arg2: u64,
        arg3: SkEncodedOrigin,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCodec_SkCodec(__bindgen_tmp.as_mut_ptr(), arg1, srcFormat, arg2, arg3);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodecD1Ev"]
    pub fn SkCodec_SkCodec_destructor(this: *mut SkCodec);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkCodec16onOutputScanlineEi"]
    pub fn SkCodec_onOutputScanline(
        this: *mut ::core::ffi::c_void,
        inputScanline: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec19conversionSupportedERK11SkImageInfobb"]
    pub fn SkCodec_conversionSupported(
        this: *mut ::core::ffi::c_void,
        dst: *const SkImageInfo,
        srcIsOpaque: bool,
        needsColorXform: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z21SkAnnotateRectWithURLP8SkCanvasRK6SkRectP6SkData"]
    pub fn SkAnnotateRectWithURL(arg1: *mut SkCanvas, arg2: *const SkRect, arg3: *mut SkData);
}
extern "C" {
    #[link_name = "\u{1}__Z26SkAnnotateNamedDestinationP8SkCanvasRK7SkPointP6SkData"]
    pub fn SkAnnotateNamedDestination(arg1: *mut SkCanvas, arg2: *const SkPoint, arg3: *mut SkData);
}
extern "C" {
    #[link_name = "\u{1}__Z27SkAnnotateLinkToDestinationP8SkCanvasRK6SkRectP6SkData"]
    pub fn SkAnnotateLinkToDestination(arg1: *mut SkCanvas, arg2: *const SkRect, arg3: *mut SkData);
}
impl SkBlendMode {
    pub const LastCoeffMode: SkBlendMode = SkBlendMode::Screen;
}
impl SkBlendMode {
    pub const LastSeparableMode: SkBlendMode = SkBlendMode::Multiply;
}
impl SkBlendMode {
    pub const LastMode: SkBlendMode = SkBlendMode::Luminosity;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlendMode {
    Clear = 0,
    Src = 1,
    Dst = 2,
    SrcOver = 3,
    DstOver = 4,
    SrcIn = 5,
    DstIn = 6,
    SrcOut = 7,
    DstOut = 8,
    SrcATop = 9,
    DstATop = 10,
    Xor = 11,
    Plus = 12,
    Modulate = 13,
    Screen = 14,
    Overlay = 15,
    Darken = 16,
    Lighten = 17,
    ColorDodge = 18,
    ColorBurn = 19,
    HardLight = 20,
    SoftLight = 21,
    Difference = 22,
    Exclusion = 23,
    Multiply = 24,
    Hue = 25,
    Saturation = 26,
    Color = 27,
    Luminosity = 28,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlendModeCoeff {
    Zero = 0,
    One = 1,
    SC = 2,
    ISC = 3,
    DC = 4,
    IDC = 5,
    SA = 6,
    ISA = 7,
    DA = 8,
    IDA = 9,
    CoeffCount = 10,
}
extern "C" {
    #[link_name = "\u{1}__Z19SkBlendMode_AsCoeff11SkBlendModeP16SkBlendModeCoeffS1_"]
    pub fn SkBlendMode_AsCoeff(
        mode: SkBlendMode,
        src: *mut SkBlendModeCoeff,
        dst: *mut SkBlendModeCoeff,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z16SkBlendMode_Name11SkBlendMode"]
    pub fn SkBlendMode_Name(blendMode: SkBlendMode) -> *const ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMipmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMaskBuilder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBitmap {
    pub fPixelRef: sk_sp<SkPixelRef>,
    pub fPixmap: SkPixmap,
    pub fMips: sk_sp<SkMipmap>,
}
pub const SkBitmap_AllocFlags_kZeroPixels_AllocFlag: SkBitmap_AllocFlags = 1;
pub type SkBitmap_AllocFlags = ::core::ffi::c_uint;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBitmap_Allocator {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkBitmap_Allocator_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkBitmap_Allocator() {
    assert_eq!(
        ::core::mem::size_of::<SkBitmap_Allocator>(),
        16usize,
        concat!("Size of: ", stringify!(SkBitmap_Allocator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBitmap_Allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBitmap_Allocator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBitmap_HeapAllocator {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkBitmap_HeapAllocator() {
    assert_eq!(
        ::core::mem::size_of::<SkBitmap_HeapAllocator>(),
        16usize,
        concat!("Size of: ", stringify!(SkBitmap_HeapAllocator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBitmap_HeapAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBitmap_HeapAllocator))
    );
}
#[test]
fn bindgen_test_layout_SkBitmap() {
    const UNINIT: ::core::mem::MaybeUninit<SkBitmap> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkBitmap>(),
        56usize,
        concat!("Size of: ", stringify!(SkBitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBitmap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPixelRef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBitmap),
            "::",
            stringify!(fPixelRef)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPixmap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBitmap),
            "::",
            stringify!(fPixmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMips) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBitmap),
            "::",
            stringify!(fMips)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap4swapERS_"]
    pub fn SkBitmap_swap(this: *mut SkBitmap, other: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10colorSpaceEv"]
    pub fn SkBitmap_colorSpace(this: *const SkBitmap) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap13refColorSpaceEv"]
    pub fn SkBitmap_refColorSpace(this: *const SkBitmap) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap12setAlphaTypeE11SkAlphaType"]
    pub fn SkBitmap_setAlphaType(this: *mut SkBitmap, alphaType: SkAlphaType) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap11isImmutableEv"]
    pub fn SkBitmap_isImmutable(this: *const SkBitmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap12setImmutableEv"]
    pub fn SkBitmap_setImmutable(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap5resetEv"]
    pub fn SkBitmap_reset(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap9getBoundsEP6SkRect"]
    pub fn SkBitmap_getBounds(this: *const SkBitmap, bounds: *mut SkRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap9getBoundsEP7SkIRect"]
    pub fn SkBitmap_getBounds1(this: *const SkBitmap, bounds: *mut SkIRect);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap7setInfoERK11SkImageInfom"]
    pub fn SkBitmap_setInfo(
        this: *mut SkBitmap,
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap19tryAllocPixelsFlagsERK11SkImageInfoj"]
    pub fn SkBitmap_tryAllocPixelsFlags(
        this: *mut SkBitmap,
        info: *const SkImageInfo,
        flags: u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap16allocPixelsFlagsERK11SkImageInfoj"]
    pub fn SkBitmap_allocPixelsFlags(this: *mut SkBitmap, info: *const SkImageInfo, flags: u32);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap14tryAllocPixelsERK11SkImageInfom"]
    pub fn SkBitmap_tryAllocPixels(
        this: *mut SkBitmap,
        info: *const SkImageInfo,
        rowBytes: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11allocPixelsERK11SkImageInfom"]
    pub fn SkBitmap_allocPixels(this: *mut SkBitmap, info: *const SkImageInfo, rowBytes: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11allocPixelsERK11SkImageInfo"]
    pub fn SkBitmap_allocPixels1(this: *mut SkBitmap, info: *const SkImageInfo);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap17tryAllocN32PixelsEiib"]
    pub fn SkBitmap_tryAllocN32Pixels(
        this: *mut SkBitmap,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        isOpaque: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap14allocN32PixelsEiib"]
    pub fn SkBitmap_allocN32Pixels(
        this: *mut SkBitmap,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        isOpaque: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap13installPixelsERK11SkImageInfoPvmPFvS3_S3_ES3_"]
    pub fn SkBitmap_installPixels(
        this: *mut SkBitmap,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(addr: *mut ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap13installPixelsERK8SkPixmap"]
    pub fn SkBitmap_installPixels1(this: *mut SkBitmap, pixmap: *const SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap17installMaskPixelsER13SkMaskBuilder"]
    pub fn SkBitmap_installMaskPixels(this: *mut SkBitmap, mask: *mut SkMaskBuilder) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap9setPixelsEPv"]
    pub fn SkBitmap_setPixels(this: *mut SkBitmap, pixels: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11allocPixelsEv"]
    pub fn SkBitmap_allocPixels2(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap14tryAllocPixelsEPNS_9AllocatorE"]
    pub fn SkBitmap_tryAllocPixels1(
        this: *mut SkBitmap,
        allocator: *mut SkBitmap_Allocator,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11allocPixelsEPNS_9AllocatorE"]
    pub fn SkBitmap_allocPixels3(this: *mut SkBitmap, allocator: *mut SkBitmap_Allocator);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap14pixelRefOriginEv"]
    pub fn SkBitmap_pixelRefOrigin(this: *const SkBitmap) -> SkIPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11setPixelRefE5sk_spI10SkPixelRefEii"]
    pub fn SkBitmap_setPixelRef(
        this: *mut SkBitmap,
        pixelRef: sk_sp<SkPixelRef>,
        dx: ::core::ffi::c_int,
        dy: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap15getGenerationIDEv"]
    pub fn SkBitmap_getGenerationID(this: *const SkBitmap) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap19notifyPixelsChangedEv"]
    pub fn SkBitmap_notifyPixelsChanged(this: *const SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10eraseColorE8SkRGBA4fIL11SkAlphaType3EE"]
    pub fn SkBitmap_eraseColor(this: *const SkBitmap, arg1: SkColor4f);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10eraseColorEj"]
    pub fn SkBitmap_eraseColor1(this: *const SkBitmap, c: SkColor);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap5eraseE8SkRGBA4fIL11SkAlphaType3EERK7SkIRect"]
    pub fn SkBitmap_erase(this: *const SkBitmap, c: SkColor4f, area: *const SkIRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap5eraseEjRK7SkIRect"]
    pub fn SkBitmap_erase1(this: *const SkBitmap, c: SkColor, area: *const SkIRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap7getAddrEii"]
    pub fn SkBitmap_getAddr(
        this: *const SkBitmap,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap13extractSubsetEPS_RK7SkIRect"]
    pub fn SkBitmap_extractSubset(
        this: *const SkBitmap,
        dst: *mut SkBitmap,
        subset: *const SkIRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkBitmap_readPixels(
        this: *const SkBitmap,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10readPixelsERK8SkPixmapii"]
    pub fn SkBitmap_readPixels1(
        this: *const SkBitmap,
        dst: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11writePixelsERK8SkPixmapii"]
    pub fn SkBitmap_writePixels(
        this: *mut SkBitmap,
        src: *const SkPixmap,
        dstX: ::core::ffi::c_int,
        dstY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap12extractAlphaEPS_PK7SkPaintPNS_9AllocatorEP8SkIPoint"]
    pub fn SkBitmap_extractAlpha(
        this: *const SkBitmap,
        dst: *mut SkBitmap,
        paint: *const SkPaint,
        allocator: *mut SkBitmap_Allocator,
        offset: *mut SkIPoint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10peekPixelsEP8SkPixmap"]
    pub fn SkBitmap_peekPixels(this: *const SkBitmap, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10makeShaderE10SkTileModeS0_RK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkBitmap_makeShader(
        this: *const SkBitmap,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10makeShaderE10SkTileModeS0_RK17SkSamplingOptionsRK8SkMatrix"]
    pub fn SkBitmap_makeShader1(
        this: *const SkBitmap,
        tmx: SkTileMode,
        tmy: SkTileMode,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10makeShaderERK17SkSamplingOptionsRK8SkMatrix"]
    pub fn SkBitmap_makeShader2(
        this: *const SkBitmap,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10makeShaderERK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkBitmap_makeShader3(
        this: *const SkBitmap,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap7asImageEv"]
    pub fn SkBitmap_asImage(this: *const SkBitmap) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmapC1Ev"]
    pub fn SkBitmap_SkBitmap(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmapC1ERKS_"]
    pub fn SkBitmap_SkBitmap1(this: *mut SkBitmap, src: *const SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmapC1EOS_"]
    pub fn SkBitmap_SkBitmap2(this: *mut SkBitmap, src: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmapD1Ev"]
    pub fn SkBitmap_SkBitmap_destructor(this: *mut SkBitmap);
}
impl SkBitmap {
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkBitmap) {
        SkBitmap_swap(self, other)
    }
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkBitmap_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkBitmap_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn setAlphaType(&mut self, alphaType: SkAlphaType) -> bool {
        SkBitmap_setAlphaType(self, alphaType)
    }
    #[inline]
    pub unsafe fn isImmutable(&self) -> bool {
        SkBitmap_isImmutable(self)
    }
    #[inline]
    pub unsafe fn setImmutable(&mut self) {
        SkBitmap_setImmutable(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkBitmap_reset(self)
    }
    #[inline]
    pub unsafe fn getBounds(&self, bounds: *mut SkRect) {
        SkBitmap_getBounds(self, bounds)
    }
    #[inline]
    pub unsafe fn getBounds1(&self, bounds: *mut SkIRect) {
        SkBitmap_getBounds1(self, bounds)
    }
    #[inline]
    pub unsafe fn setInfo(&mut self, imageInfo: *const SkImageInfo, rowBytes: usize) -> bool {
        SkBitmap_setInfo(self, imageInfo, rowBytes)
    }
    #[inline]
    pub unsafe fn tryAllocPixelsFlags(&mut self, info: *const SkImageInfo, flags: u32) -> bool {
        SkBitmap_tryAllocPixelsFlags(self, info, flags)
    }
    #[inline]
    pub unsafe fn allocPixelsFlags(&mut self, info: *const SkImageInfo, flags: u32) {
        SkBitmap_allocPixelsFlags(self, info, flags)
    }
    #[inline]
    pub unsafe fn tryAllocPixels(&mut self, info: *const SkImageInfo, rowBytes: usize) -> bool {
        SkBitmap_tryAllocPixels(self, info, rowBytes)
    }
    #[inline]
    pub unsafe fn allocPixels(&mut self, info: *const SkImageInfo, rowBytes: usize) {
        SkBitmap_allocPixels(self, info, rowBytes)
    }
    #[inline]
    pub unsafe fn allocPixels1(&mut self, info: *const SkImageInfo) {
        SkBitmap_allocPixels1(self, info)
    }
    #[inline]
    pub unsafe fn tryAllocN32Pixels(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        isOpaque: bool,
    ) -> bool {
        SkBitmap_tryAllocN32Pixels(self, width, height, isOpaque)
    }
    #[inline]
    pub unsafe fn allocN32Pixels(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        isOpaque: bool,
    ) {
        SkBitmap_allocN32Pixels(self, width, height, isOpaque)
    }
    #[inline]
    pub unsafe fn installPixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(addr: *mut ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> bool {
        SkBitmap_installPixels(self, info, pixels, rowBytes, releaseProc, context)
    }
    #[inline]
    pub unsafe fn installPixels1(&mut self, pixmap: *const SkPixmap) -> bool {
        SkBitmap_installPixels1(self, pixmap)
    }
    #[inline]
    pub unsafe fn installMaskPixels(&mut self, mask: *mut SkMaskBuilder) -> bool {
        SkBitmap_installMaskPixels(self, mask)
    }
    #[inline]
    pub unsafe fn setPixels(&mut self, pixels: *mut ::core::ffi::c_void) {
        SkBitmap_setPixels(self, pixels)
    }
    #[inline]
    pub unsafe fn allocPixels2(&mut self) {
        SkBitmap_allocPixels2(self)
    }
    #[inline]
    pub unsafe fn tryAllocPixels1(&mut self, allocator: *mut SkBitmap_Allocator) -> bool {
        SkBitmap_tryAllocPixels1(self, allocator)
    }
    #[inline]
    pub unsafe fn allocPixels3(&mut self, allocator: *mut SkBitmap_Allocator) {
        SkBitmap_allocPixels3(self, allocator)
    }
    #[inline]
    pub unsafe fn pixelRefOrigin(&self) -> SkIPoint {
        SkBitmap_pixelRefOrigin(self)
    }
    #[inline]
    pub unsafe fn setPixelRef(
        &mut self,
        pixelRef: sk_sp<SkPixelRef>,
        dx: ::core::ffi::c_int,
        dy: ::core::ffi::c_int,
    ) {
        SkBitmap_setPixelRef(self, pixelRef, dx, dy)
    }
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkBitmap_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn notifyPixelsChanged(&self) {
        SkBitmap_notifyPixelsChanged(self)
    }
    #[inline]
    pub unsafe fn eraseColor(&self, arg1: SkColor4f) {
        SkBitmap_eraseColor(self, arg1)
    }
    #[inline]
    pub unsafe fn eraseColor1(&self, c: SkColor) {
        SkBitmap_eraseColor1(self, c)
    }
    #[inline]
    pub unsafe fn erase(&self, c: SkColor4f, area: *const SkIRect) {
        SkBitmap_erase(self, c, area)
    }
    #[inline]
    pub unsafe fn erase1(&self, c: SkColor, area: *const SkIRect) {
        SkBitmap_erase1(self, c, area)
    }
    #[inline]
    pub unsafe fn getAddr(
        &self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void {
        SkBitmap_getAddr(self, x, y)
    }
    #[inline]
    pub unsafe fn extractSubset(&self, dst: *mut SkBitmap, subset: *const SkIRect) -> bool {
        SkBitmap_extractSubset(self, dst, subset)
    }
    #[inline]
    pub unsafe fn readPixels(
        &self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool {
        SkBitmap_readPixels(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &self,
        dst: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool {
        SkBitmap_readPixels1(self, dst, srcX, srcY)
    }
    #[inline]
    pub unsafe fn writePixels(
        &mut self,
        src: *const SkPixmap,
        dstX: ::core::ffi::c_int,
        dstY: ::core::ffi::c_int,
    ) -> bool {
        SkBitmap_writePixels(self, src, dstX, dstY)
    }
    #[inline]
    pub unsafe fn extractAlpha(
        &self,
        dst: *mut SkBitmap,
        paint: *const SkPaint,
        allocator: *mut SkBitmap_Allocator,
        offset: *mut SkIPoint,
    ) -> bool {
        SkBitmap_extractAlpha(self, dst, paint, allocator, offset)
    }
    #[inline]
    pub unsafe fn peekPixels(&self, pixmap: *mut SkPixmap) -> bool {
        SkBitmap_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkBitmap_makeShader(self, tmx, tmy, arg1, localMatrix)
    }
    #[inline]
    pub unsafe fn makeShader1(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkBitmap_makeShader1(self, tmx, tmy, sampling, lm)
    }
    #[inline]
    pub unsafe fn makeShader2(
        &self,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkBitmap_makeShader2(self, sampling, lm)
    }
    #[inline]
    pub unsafe fn makeShader3(
        &self,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkBitmap_makeShader3(self, sampling, lm)
    }
    #[inline]
    pub unsafe fn asImage(&self) -> sk_sp<SkImage> {
        SkBitmap_asImage(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkBitmap_SkBitmap(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(src: *const SkBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkBitmap_SkBitmap1(__bindgen_tmp.as_mut_ptr(), src);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(src: *mut SkBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkBitmap_SkBitmap2(__bindgen_tmp.as_mut_ptr(), src);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkBitmap_SkBitmap_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap13HeapAllocator13allocPixelRefEPS_"]
    pub fn SkBitmap_HeapAllocator_allocPixelRef(
        this: *mut ::core::ffi::c_void,
        bitmap: *mut SkBitmap,
    ) -> bool;
}
impl SkBlurStyle {
    pub const LastEnum: SkBlurStyle = SkBlurStyle::Inner;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlurStyle {
    Normal = 0,
    Solid = 1,
    Outer = 2,
    Inner = 3,
}
impl SkClipOp {
    pub const Max_EnumValue: SkClipOp = SkClipOp::Intersect;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkClipOp {
    Difference = 0,
    Intersect = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextEncoding {
    kUTF8 = 0,
    kUTF16 = 1,
    kUTF32 = 2,
    kGlyphID = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontHinting {
    None = 0,
    Slight = 1,
    Normal = 2,
    Full = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkReadBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkWriteBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeserialProcs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSerialProcs {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkFlattenable {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFlattenable_Type {
    SkColorFilter = 0,
    SkBlender = 1,
    SkDrawable = 2,
    SkDrawLooper = 3,
    SkImageFilter = 4,
    SkMaskFilter = 5,
    SkPathEffect = 6,
    SkShader = 7,
}
pub type SkFlattenable_Factory =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut SkReadBuffer) -> sk_sp<SkFlattenable>>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFlattenable_PrivateInitializer {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkFlattenable_PrivateInitializer() {
    assert_eq!(
        ::core::mem::size_of::<SkFlattenable_PrivateInitializer>(),
        1usize,
        concat!("Size of: ", stringify!(SkFlattenable_PrivateInitializer))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFlattenable_PrivateInitializer>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SkFlattenable_PrivateInitializer)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable18PrivateInitializer11InitEffectsEv"]
    pub fn SkFlattenable_PrivateInitializer_InitEffects();
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable18PrivateInitializer16InitImageFiltersEv"]
    pub fn SkFlattenable_PrivateInitializer_InitImageFilters();
}
impl SkFlattenable_PrivateInitializer {
    #[inline]
    pub unsafe fn InitEffects() {
        SkFlattenable_PrivateInitializer_InitEffects()
    }
    #[inline]
    pub unsafe fn InitImageFilters() {
        SkFlattenable_PrivateInitializer_InitImageFilters()
    }
}
pub type SkFlattenable_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkFlattenable() {
    assert_eq!(
        ::core::mem::size_of::<SkFlattenable>(),
        16usize,
        concat!("Size of: ", stringify!(SkFlattenable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFlattenable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFlattenable))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable13NameToFactoryEPKc"]
    pub fn SkFlattenable_NameToFactory(name: *const ::core::ffi::c_char) -> SkFlattenable_Factory;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable13FactoryToNameEPF5sk_spIS_ER12SkReadBufferE"]
    pub fn SkFlattenable_FactoryToName(arg1: SkFlattenable_Factory) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable8RegisterEPKcPF5sk_spIS_ER12SkReadBufferE"]
    pub fn SkFlattenable_Register(name: *const ::core::ffi::c_char, arg1: SkFlattenable_Factory);
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkFlattenable9serializeEPK13SkSerialProcs"]
    pub fn SkFlattenable_serialize(
        this: *const SkFlattenable,
        arg1: *const SkSerialProcs,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkFlattenable9serializeEPvmPK13SkSerialProcs"]
    pub fn SkFlattenable_serialize1(
        this: *const SkFlattenable,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
        arg1: *const SkSerialProcs,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable11DeserializeENS_4TypeEPKvmPK15SkDeserialProcs"]
    pub fn SkFlattenable_Deserialize(
        arg1: SkFlattenable_Type,
        data: *const ::core::ffi::c_void,
        length: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkFlattenable>;
}
impl SkFlattenable {
    #[inline]
    pub unsafe fn NameToFactory(name: *const ::core::ffi::c_char) -> SkFlattenable_Factory {
        SkFlattenable_NameToFactory(name)
    }
    #[inline]
    pub unsafe fn FactoryToName(arg1: SkFlattenable_Factory) -> *const ::core::ffi::c_char {
        SkFlattenable_FactoryToName(arg1)
    }
    #[inline]
    pub unsafe fn Register(name: *const ::core::ffi::c_char, arg1: SkFlattenable_Factory) {
        SkFlattenable_Register(name, arg1)
    }
    #[inline]
    pub unsafe fn serialize(&self, arg1: *const SkSerialProcs) -> sk_sp<SkData> {
        SkFlattenable_serialize(self, arg1)
    }
    #[inline]
    pub unsafe fn serialize1(
        &self,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
        arg1: *const SkSerialProcs,
    ) -> usize {
        SkFlattenable_serialize1(self, memory, memory_size, arg1)
    }
    #[inline]
    pub unsafe fn Deserialize(
        arg1: SkFlattenable_Type,
        data: *const ::core::ffi::c_void,
        length: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkFlattenable> {
        SkFlattenable_Deserialize(arg1, data, length, procs)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImageFilter {
    pub _base: SkFlattenable,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImageFilter_MapDirection {
    Forward = 0,
    Reverse = 1,
}
pub type SkImageFilter_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkImageFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkImageFilter>(),
        16usize,
        concat!("Size of: ", stringify!(SkImageFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImageFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter12filterBoundsERK7SkIRectRK8SkMatrixNS_12MapDirectionEPS1_"]
    pub fn SkImageFilter_filterBounds(
        this: *const SkImageFilter,
        src: *const SkIRect,
        ctm: *const SkMatrix,
        arg1: SkImageFilter_MapDirection,
        inputRect: *const SkIRect,
    ) -> SkIRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter17isColorFilterNodeEPP13SkColorFilter"]
    pub fn SkImageFilter_isColorFilterNode(
        this: *const SkImageFilter,
        filterPtr: *mut *mut SkColorFilter,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter14asAColorFilterEPP13SkColorFilter"]
    pub fn SkImageFilter_asAColorFilter(
        this: *const SkImageFilter,
        filterPtr: *mut *mut SkColorFilter,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter11countInputsEv"]
    pub fn SkImageFilter_countInputs(this: *const SkImageFilter) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter8getInputEi"]
    pub fn SkImageFilter_getInput(
        this: *const SkImageFilter,
        i: ::core::ffi::c_int,
    ) -> *const SkImageFilter;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter20canComputeFastBoundsEv"]
    pub fn SkImageFilter_canComputeFastBounds(this: *const SkImageFilter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter19makeWithLocalMatrixERK8SkMatrix"]
    pub fn SkImageFilter_makeWithLocalMatrix(
        this: *const SkImageFilter,
        matrix: *const SkMatrix,
    ) -> sk_sp<SkImageFilter>;
}
impl SkImageFilter {
    #[inline]
    pub unsafe fn filterBounds(
        &self,
        src: *const SkIRect,
        ctm: *const SkMatrix,
        arg1: SkImageFilter_MapDirection,
        inputRect: *const SkIRect,
    ) -> SkIRect {
        SkImageFilter_filterBounds(self, src, ctm, arg1, inputRect)
    }
    #[inline]
    pub unsafe fn isColorFilterNode(&self, filterPtr: *mut *mut SkColorFilter) -> bool {
        SkImageFilter_isColorFilterNode(self, filterPtr)
    }
    #[inline]
    pub unsafe fn asAColorFilter(&self, filterPtr: *mut *mut SkColorFilter) -> bool {
        SkImageFilter_asAColorFilter(self, filterPtr)
    }
    #[inline]
    pub unsafe fn countInputs(&self) -> ::core::ffi::c_int {
        SkImageFilter_countInputs(self)
    }
    #[inline]
    pub unsafe fn getInput(&self, i: ::core::ffi::c_int) -> *const SkImageFilter {
        SkImageFilter_getInput(self, i)
    }
    #[inline]
    pub unsafe fn canComputeFastBounds(&self) -> bool {
        SkImageFilter_canComputeFastBounds(self)
    }
    #[inline]
    pub unsafe fn makeWithLocalMatrix(&self, matrix: *const SkMatrix) -> sk_sp<SkImageFilter> {
        SkImageFilter_makeWithLocalMatrix(self, matrix)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter17computeFastBoundsERK6SkRect"]
    pub fn SkImageFilter_computeFastBounds(
        this: *mut ::core::ffi::c_void,
        bounds: *const SkRect,
    ) -> SkRect;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkV2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SkV2() {
    const UNINIT: ::core::mem::MaybeUninit<SkV2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkV2>(),
        8usize,
        concat!("Size of: ", stringify!(SkV2))
    );
    assert_eq!(
        ::core::mem::align_of::<SkV2>(),
        4usize,
        concat!("Alignment of ", stringify!(SkV2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(SkV2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(SkV2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkV3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_SkV3() {
    const UNINIT: ::core::mem::MaybeUninit<SkV3> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkV3>(),
        12usize,
        concat!("Size of: ", stringify!(SkV3))
    );
    assert_eq!(
        ::core::mem::align_of::<SkV3>(),
        4usize,
        concat!("Alignment of ", stringify!(SkV3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(SkV3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(SkV3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(SkV3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkV4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_SkV4() {
    const UNINIT: ::core::mem::MaybeUninit<SkV4> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkV4>(),
        16usize,
        concat!("Size of: ", stringify!(SkV4))
    );
    assert_eq!(
        ::core::mem::align_of::<SkV4>(),
        4usize,
        concat!("Alignment of ", stringify!(SkV4))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkM44 {
    pub fMat: [SkScalar; 16usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkM44_Uninitialized_Constructor {
    kUninitialized_Constructor = 0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkM44_NaN_Constructor {
    kNaN_Constructor = 0,
}
#[test]
fn bindgen_test_layout_SkM44() {
    const UNINIT: ::core::mem::MaybeUninit<SkM44> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkM44>(),
        64usize,
        concat!("Size of: ", stringify!(SkM44))
    );
    assert_eq!(
        ::core::mem::align_of::<SkM44>(),
        4usize,
        concat!("Alignment of ", stringify!(SkM44))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkM44),
            "::",
            stringify!(fMat)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4410RectToRectERK6SkRectS2_"]
    pub fn SkM44_RectToRect(src: *const SkRect, dst: *const SkRect) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM446LookAtERK4SkV3S2_S2_"]
    pub fn SkM44_LookAt(eye: *const SkV3, center: *const SkV3, up: *const SkV3) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4411PerspectiveEfff"]
    pub fn SkM44_Perspective(near: f32, far: f32, angle: f32) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM4411getRowMajorEPf"]
    pub fn SkM44_getRowMajor(this: *const SkM44, v: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4419setRotateUnitSinCosE4SkV3ff"]
    pub fn SkM44_setRotateUnitSinCos(
        this: *mut SkM44,
        axis: SkV3,
        sinAngle: SkScalar,
        cosAngle: SkScalar,
    ) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM449setRotateE4SkV3f"]
    pub fn SkM44_setRotate(this: *mut SkM44, axis: SkV3, radians: SkScalar) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM449setConcatERKS_S1_"]
    pub fn SkM44_setConcat(this: *mut SkM44, a: *const SkM44, b: *const SkM44) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4420normalizePerspectiveEv"]
    pub fn SkM44_normalizePerspective(this: *mut SkM44);
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM446invertEPS_"]
    pub fn SkM44_invert(this: *const SkM44, inverse: *mut SkM44) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM449transposeEv"]
    pub fn SkM44_transpose(this: *const SkM44) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM444dumpEv"]
    pub fn SkM44_dump(this: *const SkM44);
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM443mapEffff"]
    pub fn SkM44_map(this: *const SkM44, x: f32, y: f32, z: f32, w: f32) -> SkV4;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4412preTranslateEfff"]
    pub fn SkM44_preTranslate(
        this: *mut SkM44,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
    ) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4413postTranslateEfff"]
    pub fn SkM44_postTranslate(
        this: *mut SkM44,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
    ) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM448preScaleEff"]
    pub fn SkM44_preScale(this: *mut SkM44, x: SkScalar, y: SkScalar) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM448preScaleEfff"]
    pub fn SkM44_preScale1(this: *mut SkM44, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM449preConcatERK8SkMatrix"]
    pub fn SkM44_preConcat(this: *mut SkM44, arg1: *const SkMatrix) -> *mut SkM44;
}
impl SkM44 {
    #[inline]
    pub unsafe fn RectToRect(src: *const SkRect, dst: *const SkRect) -> SkM44 {
        SkM44_RectToRect(src, dst)
    }
    #[inline]
    pub unsafe fn LookAt(eye: *const SkV3, center: *const SkV3, up: *const SkV3) -> SkM44 {
        SkM44_LookAt(eye, center, up)
    }
    #[inline]
    pub unsafe fn Perspective(near: f32, far: f32, angle: f32) -> SkM44 {
        SkM44_Perspective(near, far, angle)
    }
    #[inline]
    pub unsafe fn getRowMajor(&self, v: *mut SkScalar) {
        SkM44_getRowMajor(self, v)
    }
    #[inline]
    pub unsafe fn setRotateUnitSinCos(
        &mut self,
        axis: SkV3,
        sinAngle: SkScalar,
        cosAngle: SkScalar,
    ) -> *mut SkM44 {
        SkM44_setRotateUnitSinCos(self, axis, sinAngle, cosAngle)
    }
    #[inline]
    pub unsafe fn setRotate(&mut self, axis: SkV3, radians: SkScalar) -> *mut SkM44 {
        SkM44_setRotate(self, axis, radians)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkM44, b: *const SkM44) -> *mut SkM44 {
        SkM44_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn normalizePerspective(&mut self) {
        SkM44_normalizePerspective(self)
    }
    #[inline]
    pub unsafe fn invert(&self, inverse: *mut SkM44) -> bool {
        SkM44_invert(self, inverse)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> SkM44 {
        SkM44_transpose(self)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkM44_dump(self)
    }
    #[inline]
    pub unsafe fn map(&self, x: f32, y: f32, z: f32, w: f32) -> SkV4 {
        SkM44_map(self, x, y, z, w)
    }
    #[inline]
    pub unsafe fn preTranslate(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44 {
        SkM44_preTranslate(self, x, y, z)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44 {
        SkM44_postTranslate(self, x, y, z)
    }
    #[inline]
    pub unsafe fn preScale(&mut self, x: SkScalar, y: SkScalar) -> *mut SkM44 {
        SkM44_preScale(self, x, y)
    }
    #[inline]
    pub unsafe fn preScale1(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44 {
        SkM44_preScale1(self, x, y, z)
    }
    #[inline]
    pub unsafe fn preConcat(&mut self, arg1: *const SkMatrix) -> *mut SkM44 {
        SkM44_preConcat(self, arg1)
    }
}
#[repr(C)]
pub struct SkPaint {
    pub fPathEffect: sk_sp<SkPathEffect>,
    pub fShader: sk_sp<SkShader>,
    pub fMaskFilter: sk_sp<SkMaskFilter>,
    pub fColorFilter: sk_sp<SkColorFilter>,
    pub fImageFilter: sk_sp<SkImageFilter>,
    pub fBlender: sk_sp<SkBlender>,
    pub fColor4f: SkColor4f,
    pub fWidth: SkScalar,
    pub fMiterLimit: SkScalar,
    pub __bindgen_anon_1: SkPaint__bindgen_ty_1,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPaint_Style {
    Fill = 0,
    Stroke = 1,
    StrokeAndFill = 2,
}
impl SkPaint_Cap {
    pub const Last: SkPaint_Cap = SkPaint_Cap::Square;
}
impl SkPaint_Cap {
    pub const Default: SkPaint_Cap = SkPaint_Cap::Butt;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPaint_Cap {
    Butt = 0,
    Round = 1,
    Square = 2,
}
impl SkPaint_Join {
    pub const Last: SkPaint_Join = SkPaint_Join::Bevel;
}
impl SkPaint_Join {
    pub const Default: SkPaint_Join = SkPaint_Join::Miter;
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPaint_Join {
    Miter = 0,
    Round = 1,
    Bevel = 2,
}
pub type SkPaint_sk_is_trivially_relocatable = std_true_type;
#[repr(C)]
#[derive(Copy, Clone)]
pub union SkPaint__bindgen_ty_1 {
    pub fBitfields: SkPaint__bindgen_ty_1__bindgen_ty_1,
    pub fBitfieldsUInt: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SkPaint__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SkPaint__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SkPaint__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SkPaint__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl SkPaint__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn fAntiAlias(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fAntiAlias(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fDither(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fDither(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fCapType(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fCapType(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fJoinType(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fJoinType(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fStyle(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fStyle(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fPadding(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_fPadding(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fAntiAlias: ::core::ffi::c_uint,
        fDither: ::core::ffi::c_uint,
        fCapType: ::core::ffi::c_uint,
        fJoinType: ::core::ffi::c_uint,
        fStyle: ::core::ffi::c_uint,
        fPadding: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fAntiAlias: u32 = unsafe { ::core::mem::transmute(fAntiAlias) };
            fAntiAlias as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fDither: u32 = unsafe { ::core::mem::transmute(fDither) };
            fDither as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fCapType: u32 = unsafe { ::core::mem::transmute(fCapType) };
            fCapType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let fJoinType: u32 = unsafe { ::core::mem::transmute(fJoinType) };
            fJoinType as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let fStyle: u32 = unsafe { ::core::mem::transmute(fStyle) };
            fStyle as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let fPadding: u32 = unsafe { ::core::mem::transmute(fPadding) };
            fPadding as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SkPaint__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SkPaint__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPaint__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SkPaint__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPaint__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPaint__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBitfields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint__bindgen_ty_1),
            "::",
            stringify!(fBitfields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBitfieldsUInt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint__bindgen_ty_1),
            "::",
            stringify!(fBitfieldsUInt)
        )
    );
}
pub const SkPaint_kStyleCount: ::core::ffi::c_int = 3;
pub const SkPaint_kCapCount: ::core::ffi::c_int = 3;
pub const SkPaint_kJoinCount: ::core::ffi::c_int = 3;
#[test]
fn bindgen_test_layout_SkPaint() {
    const UNINIT: ::core::mem::MaybeUninit<SkPaint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPaint>(),
        80usize,
        concat!("Size of: ", stringify!(SkPaint))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPaint>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPaint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPathEffect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fPathEffect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fShader) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fShader)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaskFilter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fMaskFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorFilter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fColorFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fImageFilter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fImageFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBlender) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fBlender)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColor4f) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fColor4f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMiterLimit) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPaint),
            "::",
            stringify!(fMiterLimit)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint5resetEv"]
    pub fn SkPaint_reset(this: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint8setStyleENS_5StyleE"]
    pub fn SkPaint_setStyle(this: *mut SkPaint, style: SkPaint_Style);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint9setStrokeEb"]
    pub fn SkPaint_setStroke(this: *mut SkPaint, arg1: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint8setColorEj"]
    pub fn SkPaint_setColor(this: *mut SkPaint, color: SkColor);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint8setColorERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpace"]
    pub fn SkPaint_setColor1(
        this: *mut SkPaint,
        color: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint9setAlphafEf"]
    pub fn SkPaint_setAlphaf(this: *mut SkPaint, a: f32);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint7setARGBEjjjj"]
    pub fn SkPaint_setARGB(this: *mut SkPaint, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint14setStrokeWidthEf"]
    pub fn SkPaint_setStrokeWidth(this: *mut SkPaint, width: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint14setStrokeMiterEf"]
    pub fn SkPaint_setStrokeMiter(this: *mut SkPaint, miter: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint12setStrokeCapENS_3CapE"]
    pub fn SkPaint_setStrokeCap(this: *mut SkPaint, cap: SkPaint_Cap);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint13setStrokeJoinENS_4JoinE"]
    pub fn SkPaint_setStrokeJoin(this: *mut SkPaint, join: SkPaint_Join);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint9refShaderEv"]
    pub fn SkPaint_refShader(this: *const SkPaint) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint9setShaderE5sk_spI8SkShaderE"]
    pub fn SkPaint_setShader(this: *mut SkPaint, shader: sk_sp<SkShader>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint14refColorFilterEv"]
    pub fn SkPaint_refColorFilter(this: *const SkPaint) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint14setColorFilterE5sk_spI13SkColorFilterE"]
    pub fn SkPaint_setColorFilter(this: *mut SkPaint, colorFilter: sk_sp<SkColorFilter>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint11asBlendModeEv"]
    pub fn SkPaint_asBlendMode(this: *const SkPaint) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint15getBlendMode_orE11SkBlendMode"]
    pub fn SkPaint_getBlendMode_or(this: *const SkPaint, defaultMode: SkBlendMode) -> SkBlendMode;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint9isSrcOverEv"]
    pub fn SkPaint_isSrcOver(this: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint12setBlendModeE11SkBlendMode"]
    pub fn SkPaint_setBlendMode(this: *mut SkPaint, mode: SkBlendMode);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint10refBlenderEv"]
    pub fn SkPaint_refBlender(this: *const SkPaint) -> sk_sp<SkBlender>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint10setBlenderE5sk_spI9SkBlenderE"]
    pub fn SkPaint_setBlender(this: *mut SkPaint, blender: sk_sp<SkBlender>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint13refPathEffectEv"]
    pub fn SkPaint_refPathEffect(this: *const SkPaint) -> sk_sp<SkPathEffect>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint13setPathEffectE5sk_spI12SkPathEffectE"]
    pub fn SkPaint_setPathEffect(this: *mut SkPaint, pathEffect: sk_sp<SkPathEffect>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint13refMaskFilterEv"]
    pub fn SkPaint_refMaskFilter(this: *const SkPaint) -> sk_sp<SkMaskFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint13setMaskFilterE5sk_spI12SkMaskFilterE"]
    pub fn SkPaint_setMaskFilter(this: *mut SkPaint, maskFilter: sk_sp<SkMaskFilter>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint14refImageFilterEv"]
    pub fn SkPaint_refImageFilter(this: *const SkPaint) -> sk_sp<SkImageFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint14setImageFilterE5sk_spI13SkImageFilterE"]
    pub fn SkPaint_setImageFilter(this: *mut SkPaint, imageFilter: sk_sp<SkImageFilter>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint13nothingToDrawEv"]
    pub fn SkPaint_nothingToDraw(this: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint20canComputeFastBoundsEv"]
    pub fn SkPaint_canComputeFastBounds(this: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint17computeFastBoundsERK6SkRectPS0_"]
    pub fn SkPaint_computeFastBounds(
        this: *const SkPaint,
        orig: *const SkRect,
        storage: *mut SkRect,
    ) -> *const SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint19doComputeFastBoundsERK6SkRectPS0_NS_5StyleE"]
    pub fn SkPaint_doComputeFastBounds(
        this: *const SkPaint,
        orig: *const SkRect,
        storage: *mut SkRect,
        style: SkPaint_Style,
    ) -> *const SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintC1Ev"]
    pub fn SkPaint_SkPaint(this: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintC1ERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpace"]
    pub fn SkPaint_SkPaint1(
        this: *mut SkPaint,
        color: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintC1ERKS_"]
    pub fn SkPaint_SkPaint2(this: *mut SkPaint, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintC1EOS_"]
    pub fn SkPaint_SkPaint3(this: *mut SkPaint, paint: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintD1Ev"]
    pub fn SkPaint_SkPaint_destructor(this: *mut SkPaint);
}
impl SkPaint {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPaint_reset(self)
    }
    #[inline]
    pub unsafe fn setStyle(&mut self, style: SkPaint_Style) {
        SkPaint_setStyle(self, style)
    }
    #[inline]
    pub unsafe fn setStroke(&mut self, arg1: bool) {
        SkPaint_setStroke(self, arg1)
    }
    #[inline]
    pub unsafe fn setColor(&mut self, color: SkColor) {
        SkPaint_setColor(self, color)
    }
    #[inline]
    pub unsafe fn setColor1(&mut self, color: *const SkColor4f, colorSpace: *mut SkColorSpace) {
        SkPaint_setColor1(self, color, colorSpace)
    }
    #[inline]
    pub unsafe fn setAlphaf(&mut self, a: f32) {
        SkPaint_setAlphaf(self, a)
    }
    #[inline]
    pub unsafe fn setARGB(&mut self, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) {
        SkPaint_setARGB(self, a, r, g, b)
    }
    #[inline]
    pub unsafe fn setStrokeWidth(&mut self, width: SkScalar) {
        SkPaint_setStrokeWidth(self, width)
    }
    #[inline]
    pub unsafe fn setStrokeMiter(&mut self, miter: SkScalar) {
        SkPaint_setStrokeMiter(self, miter)
    }
    #[inline]
    pub unsafe fn setStrokeCap(&mut self, cap: SkPaint_Cap) {
        SkPaint_setStrokeCap(self, cap)
    }
    #[inline]
    pub unsafe fn setStrokeJoin(&mut self, join: SkPaint_Join) {
        SkPaint_setStrokeJoin(self, join)
    }
    #[inline]
    pub unsafe fn refShader(&self) -> sk_sp<SkShader> {
        SkPaint_refShader(self)
    }
    #[inline]
    pub unsafe fn setShader(&mut self, shader: sk_sp<SkShader>) {
        SkPaint_setShader(self, shader)
    }
    #[inline]
    pub unsafe fn refColorFilter(&self) -> sk_sp<SkColorFilter> {
        SkPaint_refColorFilter(self)
    }
    #[inline]
    pub unsafe fn setColorFilter(&mut self, colorFilter: sk_sp<SkColorFilter>) {
        SkPaint_setColorFilter(self, colorFilter)
    }
    #[inline]
    pub unsafe fn asBlendMode(&self) -> [u32; 2usize] {
        SkPaint_asBlendMode(self)
    }
    #[inline]
    pub unsafe fn getBlendMode_or(&self, defaultMode: SkBlendMode) -> SkBlendMode {
        SkPaint_getBlendMode_or(self, defaultMode)
    }
    #[inline]
    pub unsafe fn isSrcOver(&self) -> bool {
        SkPaint_isSrcOver(self)
    }
    #[inline]
    pub unsafe fn setBlendMode(&mut self, mode: SkBlendMode) {
        SkPaint_setBlendMode(self, mode)
    }
    #[inline]
    pub unsafe fn refBlender(&self) -> sk_sp<SkBlender> {
        SkPaint_refBlender(self)
    }
    #[inline]
    pub unsafe fn setBlender(&mut self, blender: sk_sp<SkBlender>) {
        SkPaint_setBlender(self, blender)
    }
    #[inline]
    pub unsafe fn refPathEffect(&self) -> sk_sp<SkPathEffect> {
        SkPaint_refPathEffect(self)
    }
    #[inline]
    pub unsafe fn setPathEffect(&mut self, pathEffect: sk_sp<SkPathEffect>) {
        SkPaint_setPathEffect(self, pathEffect)
    }
    #[inline]
    pub unsafe fn refMaskFilter(&self) -> sk_sp<SkMaskFilter> {
        SkPaint_refMaskFilter(self)
    }
    #[inline]
    pub unsafe fn setMaskFilter(&mut self, maskFilter: sk_sp<SkMaskFilter>) {
        SkPaint_setMaskFilter(self, maskFilter)
    }
    #[inline]
    pub unsafe fn refImageFilter(&self) -> sk_sp<SkImageFilter> {
        SkPaint_refImageFilter(self)
    }
    #[inline]
    pub unsafe fn setImageFilter(&mut self, imageFilter: sk_sp<SkImageFilter>) {
        SkPaint_setImageFilter(self, imageFilter)
    }
    #[inline]
    pub unsafe fn nothingToDraw(&self) -> bool {
        SkPaint_nothingToDraw(self)
    }
    #[inline]
    pub unsafe fn canComputeFastBounds(&self) -> bool {
        SkPaint_canComputeFastBounds(self)
    }
    #[inline]
    pub unsafe fn computeFastBounds(
        &self,
        orig: *const SkRect,
        storage: *mut SkRect,
    ) -> *const SkRect {
        SkPaint_computeFastBounds(self, orig, storage)
    }
    #[inline]
    pub unsafe fn doComputeFastBounds(
        &self,
        orig: *const SkRect,
        storage: *mut SkRect,
        style: SkPaint_Style,
    ) -> *const SkRect {
        SkPaint_doComputeFastBounds(self, orig, storage, style)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(color: *const SkColor4f, colorSpace: *mut SkColorSpace) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint1(__bindgen_tmp.as_mut_ptr(), color, colorSpace);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(paint: *const SkPaint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint2(__bindgen_tmp.as_mut_ptr(), paint);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(paint: *mut SkPaint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint3(__bindgen_tmp.as_mut_ptr(), paint);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPaint_SkPaint_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkRasterHandleAllocator {
    pub _bindgen_opaque_blob: u64,
}
pub type SkRasterHandleAllocator_Handle = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRasterHandleAllocator_Rec {
    pub fReleaseProc: ::core::option::Option<
        unsafe extern "C" fn(pixels: *mut ::core::ffi::c_void, ctx: *mut ::core::ffi::c_void),
    >,
    pub fReleaseCtx: *mut ::core::ffi::c_void,
    pub fPixels: *mut ::core::ffi::c_void,
    pub fRowBytes: usize,
    pub fHandle: SkRasterHandleAllocator_Handle,
}
#[test]
fn bindgen_test_layout_SkRasterHandleAllocator_Rec() {
    const UNINIT: ::core::mem::MaybeUninit<SkRasterHandleAllocator_Rec> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRasterHandleAllocator_Rec>(),
        40usize,
        concat!("Size of: ", stringify!(SkRasterHandleAllocator_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRasterHandleAllocator_Rec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRasterHandleAllocator_Rec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fReleaseProc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fReleaseProc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fReleaseCtx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fReleaseCtx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPixels) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fPixels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRowBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fRowBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHandle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRasterHandleAllocator_Rec),
            "::",
            stringify!(fHandle)
        )
    );
}
#[test]
fn bindgen_test_layout_SkRasterHandleAllocator() {
    assert_eq!(
        ::core::mem::size_of::<SkRasterHandleAllocator>(),
        8usize,
        concat!("Size of: ", stringify!(SkRasterHandleAllocator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRasterHandleAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRasterHandleAllocator))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkRasterHandleAllocator10MakeCanvasENSt3__110unique_ptrIS_NS0_14default_deleteIS_EEEERK11SkImageInfoPKNS_3RecEPK14SkSurfaceProps"]
    pub fn SkRasterHandleAllocator_MakeCanvas(
        arg1: u64,
        arg2: *const SkImageInfo,
        rec: *const SkRasterHandleAllocator_Rec,
        props: *const SkSurfaceProps,
    ) -> u64;
}
impl SkRasterHandleAllocator {
    #[inline]
    pub unsafe fn MakeCanvas(
        arg1: u64,
        arg2: *const SkImageInfo,
        rec: *const SkRasterHandleAllocator_Rec,
        props: *const SkSurfaceProps,
    ) -> u64 {
        SkRasterHandleAllocator_MakeCanvas(arg1, arg2, rec, props)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPixelGeometry {
    kUnknown_SkPixelGeometry = 0,
    kRGB_H_SkPixelGeometry = 1,
    kBGR_H_SkPixelGeometry = 2,
    kRGB_V_SkPixelGeometry = 3,
    kBGR_V_SkPixelGeometry = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSurfaceProps {
    pub fFlags: u32,
    pub fPixelGeometry: SkPixelGeometry,
}
pub const SkSurfaceProps_Flags_kUseDeviceIndependentFonts_Flag: SkSurfaceProps_Flags = 1;
pub const SkSurfaceProps_Flags_kDynamicMSAA_Flag: SkSurfaceProps_Flags = 2;
pub const SkSurfaceProps_Flags_kAlwaysDither_Flag: SkSurfaceProps_Flags = 4;
pub type SkSurfaceProps_Flags = ::core::ffi::c_uint;
extern "C" {
    #[link_name = "\u{1}__ZN14SkSurfaceProps27kUseDistanceFieldFonts_FlagE"]
    pub static SkSurfaceProps_kUseDistanceFieldFonts_Flag: SkSurfaceProps_Flags;
}
#[test]
fn bindgen_test_layout_SkSurfaceProps() {
    const UNINIT: ::core::mem::MaybeUninit<SkSurfaceProps> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkSurfaceProps>(),
        8usize,
        concat!("Size of: ", stringify!(SkSurfaceProps))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSurfaceProps>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSurfaceProps))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSurfaceProps),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPixelGeometry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkSurfaceProps),
            "::",
            stringify!(fPixelGeometry)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkSurfacePropsC1Ev"]
    pub fn SkSurfaceProps_SkSurfaceProps(this: *mut SkSurfaceProps);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkSurfacePropsC1Ej15SkPixelGeometry"]
    pub fn SkSurfaceProps_SkSurfaceProps1(
        this: *mut SkSurfaceProps,
        flags: u32,
        arg1: SkPixelGeometry,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkSurfacePropsC1ERKS_"]
    pub fn SkSurfaceProps_SkSurfaceProps2(this: *mut SkSurfaceProps, arg1: *const SkSurfaceProps);
}
impl SkSurfaceProps {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurfaceProps_SkSurfaceProps(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(flags: u32, arg1: SkPixelGeometry) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurfaceProps_SkSurfaceProps1(__bindgen_tmp.as_mut_ptr(), flags, arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkSurfaceProps) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurfaceProps_SkSurfaceProps2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque {
    pub _bindgen_opaque_blob: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque_Block {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque_Iter {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkDeque_Iter_IterStart {
    kFront_IterStart = 0,
    kBack_IterStart = 1,
}
#[test]
fn bindgen_test_layout_SkDeque_Iter() {
    assert_eq!(
        ::core::mem::size_of::<SkDeque_Iter>(),
        24usize,
        concat!("Size of: ", stringify!(SkDeque_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeque_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDeque_Iter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4Iter4nextEv"]
    pub fn SkDeque_Iter_next(this: *mut SkDeque_Iter) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4Iter4prevEv"]
    pub fn SkDeque_Iter_prev(this: *mut SkDeque_Iter) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4Iter5resetERKS_NS0_9IterStartE"]
    pub fn SkDeque_Iter_reset(
        this: *mut SkDeque_Iter,
        d: *const SkDeque,
        startLoc: SkDeque_Iter_IterStart,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4IterC1Ev"]
    pub fn SkDeque_Iter_Iter(this: *mut SkDeque_Iter);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4IterC1ERKS_NS0_9IterStartE"]
    pub fn SkDeque_Iter_Iter1(
        this: *mut SkDeque_Iter,
        d: *const SkDeque,
        startLoc: SkDeque_Iter_IterStart,
    );
}
impl SkDeque_Iter {
    #[inline]
    pub unsafe fn next(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_Iter_next(self)
    }
    #[inline]
    pub unsafe fn prev(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_Iter_prev(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, d: *const SkDeque, startLoc: SkDeque_Iter_IterStart) {
        SkDeque_Iter_reset(self, d, startLoc)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_Iter_Iter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(d: *const SkDeque, startLoc: SkDeque_Iter_IterStart) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_Iter_Iter1(__bindgen_tmp.as_mut_ptr(), d, startLoc);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque_F2BIter {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
pub type SkDeque_F2BIter_INHERITED = SkDeque_Iter;
#[test]
fn bindgen_test_layout_SkDeque_F2BIter() {
    assert_eq!(
        ::core::mem::size_of::<SkDeque_F2BIter>(),
        24usize,
        concat!("Size of: ", stringify!(SkDeque_F2BIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeque_F2BIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDeque_F2BIter))
    );
}
#[test]
fn bindgen_test_layout_SkDeque() {
    assert_eq!(
        ::core::mem::size_of::<SkDeque>(),
        56usize,
        concat!("Size of: ", stringify!(SkDeque))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeque>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDeque))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque10push_frontEv"]
    pub fn SkDeque_push_front(this: *mut SkDeque) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque9push_backEv"]
    pub fn SkDeque_push_back(this: *mut SkDeque) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque9pop_frontEv"]
    pub fn SkDeque_pop_front(this: *mut SkDeque);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque8pop_backEv"]
    pub fn SkDeque_pop_back(this: *mut SkDeque);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDequeC1Emi"]
    pub fn SkDeque_SkDeque(this: *mut SkDeque, elemSize: usize, allocCount: ::core::ffi::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDequeC1EmPvmi"]
    pub fn SkDeque_SkDeque1(
        this: *mut SkDeque,
        elemSize: usize,
        storage: *mut ::core::ffi::c_void,
        storageSize: usize,
        allocCount: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDequeD1Ev"]
    pub fn SkDeque_SkDeque_destructor(this: *mut SkDeque);
}
impl SkDeque {
    #[inline]
    pub unsafe fn push_front(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_push_front(self)
    }
    #[inline]
    pub unsafe fn push_back(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_push_back(self)
    }
    #[inline]
    pub unsafe fn pop_front(&mut self) {
        SkDeque_pop_front(self)
    }
    #[inline]
    pub unsafe fn pop_back(&mut self) {
        SkDeque_pop_back(self)
    }
    #[inline]
    pub unsafe fn new(elemSize: usize, allocCount: ::core::ffi::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_SkDeque(__bindgen_tmp.as_mut_ptr(), elemSize, allocCount);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        elemSize: usize,
        storage: *mut ::core::ffi::c_void,
        storageSize: usize,
        allocCount: ::core::ffi::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_SkDeque1(
            __bindgen_tmp.as_mut_ptr(),
            elemSize,
            storage,
            storageSize,
            allocCount,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkDeque_SkDeque_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sktext_GlyphRunBuilder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sktext_GlyphRunList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sktext_gpu_Slug {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sktext_gpu_SubRunAllocator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sktext_gpu_TextBlobRedrawCoordinator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBaseDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMesh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSpecialImage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSurface_Base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawShadowRec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skgpu_graphite_Recorder {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skgpu_BackendApi {
    Dawn = 0,
    Metal = 1,
    Vulkan = 2,
    Mock = 3,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skgpu_Budgeted {
    kNo = 0,
    kYes = 1,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skgpu_Mipmapped {
    No = 0,
    Yes = 1,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skgpu_Protected {
    No = 0,
    Yes = 1,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skgpu_Renderable {
    No = 0,
    Yes = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skgpu_MutableTextureStateRef {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skgpu_ganesh_SmallPathAtlasMgr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skgpu_MutableTextureState {
    pub __bindgen_anon_1: skgpu_MutableTextureState__bindgen_ty_1,
    pub fBackend: skgpu_BackendApi,
    pub fIsValid: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skgpu_MutableTextureState__bindgen_ty_1 {
    pub fPlaceholder: ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_skgpu_MutableTextureState__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<skgpu_MutableTextureState__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skgpu_MutableTextureState__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(skgpu_MutableTextureState__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skgpu_MutableTextureState__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(skgpu_MutableTextureState__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPlaceholder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skgpu_MutableTextureState__bindgen_ty_1),
            "::",
            stringify!(fPlaceholder)
        )
    );
}
#[test]
fn bindgen_test_layout_skgpu_MutableTextureState() {
    const UNINIT: ::core::mem::MaybeUninit<skgpu_MutableTextureState> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skgpu_MutableTextureState>(),
        12usize,
        concat!("Size of: ", stringify!(skgpu_MutableTextureState))
    );
    assert_eq!(
        ::core::mem::align_of::<skgpu_MutableTextureState>(),
        4usize,
        concat!("Alignment of ", stringify!(skgpu_MutableTextureState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBackend) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skgpu_MutableTextureState),
            "::",
            stringify!(fBackend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsValid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skgpu_MutableTextureState),
            "::",
            stringify!(fIsValid)
        )
    );
}
#[repr(C)]
pub struct SkCanvas__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas {
    pub vtable_: *const SkCanvas__bindgen_vtable,
    pub fMCRecStorage: [isize; 384usize],
    pub fMCStack: SkDeque,
    pub fMCRec: *mut SkCanvas_MCRec,
    pub fBaseDevice: sk_sp<SkBaseDevice>,
    pub fProps: SkSurfaceProps,
    pub fSaveCount: ::core::ffi::c_int,
    pub fAllocator: u64,
    pub fSurfaceBase: *mut SkSurface_Base,
    pub fClipRestrictionRect: SkIRect,
    pub fClipRestrictionSaveCount: ::core::ffi::c_int,
    pub fQuickRejectBounds: SkRect,
    pub fScratchGlyphRunBuilder: u64,
}
pub const SkCanvas_SaveLayerFlagsSet_kPreserveLCDText_SaveLayerFlag: SkCanvas_SaveLayerFlagsSet = 2;
pub const SkCanvas_SaveLayerFlagsSet_kInitWithPrevious_SaveLayerFlag: SkCanvas_SaveLayerFlagsSet =
    4;
pub const SkCanvas_SaveLayerFlagsSet_kF16ColorType: SkCanvas_SaveLayerFlagsSet = 16;
pub type SkCanvas_SaveLayerFlagsSet = ::core::ffi::c_uint;
pub type SkCanvas_SaveLayerFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_SaveLayerRec {
    pub fBounds: *const SkRect,
    pub fPaint: *const SkPaint,
    pub fBackdrop: *const SkImageFilter,
    pub fSaveLayerFlags: SkCanvas_SaveLayerFlags,
    pub fExperimentalBackdropScale: SkScalar,
}
#[test]
fn bindgen_test_layout_SkCanvas_SaveLayerRec() {
    const UNINIT: ::core::mem::MaybeUninit<SkCanvas_SaveLayerRec> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_SaveLayerRec>(),
        32usize,
        concat!("Size of: ", stringify!(SkCanvas_SaveLayerRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_SaveLayerRec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_SaveLayerRec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_SaveLayerRec),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPaint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_SaveLayerRec),
            "::",
            stringify!(fPaint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBackdrop) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_SaveLayerRec),
            "::",
            stringify!(fBackdrop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSaveLayerFlags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_SaveLayerRec),
            "::",
            stringify!(fSaveLayerFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fExperimentalBackdropScale) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_SaveLayerRec),
            "::",
            stringify!(fExperimentalBackdropScale)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_PointMode {
    Points = 0,
    Lines = 1,
    Polygon = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_SrcRectConstraint {
    Strict = 0,
    Fast = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_Lattice {
    pub fXDivs: *const ::core::ffi::c_int,
    pub fYDivs: *const ::core::ffi::c_int,
    pub fRectTypes: *const SkCanvas_Lattice_RectType,
    pub fXCount: ::core::ffi::c_int,
    pub fYCount: ::core::ffi::c_int,
    pub fBounds: *const SkIRect,
    pub fColors: *const SkColor,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_Lattice_RectType {
    Default = 0,
    Transparent = 1,
    FixedColor = 2,
}
#[test]
fn bindgen_test_layout_SkCanvas_Lattice() {
    const UNINIT: ::core::mem::MaybeUninit<SkCanvas_Lattice> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_Lattice>(),
        48usize,
        concat!("Size of: ", stringify!(SkCanvas_Lattice))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_Lattice>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_Lattice))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fXDivs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fXDivs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fYDivs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fYDivs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRectTypes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fRectTypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fXCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fXCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fYCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fYCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Lattice),
            "::",
            stringify!(fColors)
        )
    );
}
pub const SkCanvas_QuadAAFlags_kLeft_QuadAAFlag: SkCanvas_QuadAAFlags = 1;
pub const SkCanvas_QuadAAFlags_kTop_QuadAAFlag: SkCanvas_QuadAAFlags = 2;
pub const SkCanvas_QuadAAFlags_kRight_QuadAAFlag: SkCanvas_QuadAAFlags = 4;
pub const SkCanvas_QuadAAFlags_kBottom_QuadAAFlag: SkCanvas_QuadAAFlags = 8;
pub const SkCanvas_QuadAAFlags_kNone_QuadAAFlags: SkCanvas_QuadAAFlags = 0;
pub const SkCanvas_QuadAAFlags_kAll_QuadAAFlags: SkCanvas_QuadAAFlags = 15;
pub type SkCanvas_QuadAAFlags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas_ImageSetEntry {
    pub fImage: sk_sp<SkImage>,
    pub fSrcRect: SkRect,
    pub fDstRect: SkRect,
    pub fMatrixIndex: ::core::ffi::c_int,
    pub fAlpha: f32,
    pub fAAFlags: ::core::ffi::c_uint,
    pub fHasClip: bool,
}
#[test]
fn bindgen_test_layout_SkCanvas_ImageSetEntry() {
    const UNINIT: ::core::mem::MaybeUninit<SkCanvas_ImageSetEntry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_ImageSetEntry>(),
        56usize,
        concat!("Size of: ", stringify!(SkCanvas_ImageSetEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_ImageSetEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_ImageSetEntry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fImage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fImage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSrcRect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fSrcRect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDstRect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fDstRect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMatrixIndex) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fMatrixIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAlpha) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fAlpha)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAAFlags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fAAFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHasClip) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_ImageSetEntry),
            "::",
            stringify!(fHasClip)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryC1E5sk_spIK7SkImageERK6SkRectS7_ifjb"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry(
        this: *mut SkCanvas_ImageSetEntry,
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        matrixIndex: ::core::ffi::c_int,
        alpha: f32,
        aaFlags: ::core::ffi::c_uint,
        hasClip: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryC1E5sk_spIK7SkImageERK6SkRectS7_fj"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry1(
        this: *mut SkCanvas_ImageSetEntry,
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        alpha: f32,
        aaFlags: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryC1Ev"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry2(this: *mut SkCanvas_ImageSetEntry);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryC1ERKS0_"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry3(
        this: *mut SkCanvas_ImageSetEntry,
        arg1: *const SkCanvas_ImageSetEntry,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryD1Ev"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry_destructor(this: *mut SkCanvas_ImageSetEntry);
}
impl SkCanvas_ImageSetEntry {
    #[inline]
    pub unsafe fn new(
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        matrixIndex: ::core::ffi::c_int,
        alpha: f32,
        aaFlags: ::core::ffi::c_uint,
        hasClip: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry(
            __bindgen_tmp.as_mut_ptr(),
            image,
            srcRect,
            dstRect,
            matrixIndex,
            alpha,
            aaFlags,
            hasClip,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        alpha: f32,
        aaFlags: ::core::ffi::c_uint,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry1(
            __bindgen_tmp.as_mut_ptr(),
            image,
            srcRect,
            dstRect,
            alpha,
            aaFlags,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry2(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const SkCanvas_ImageSetEntry) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkCanvas_ImageSetEntry_ImageSetEntry_destructor(self)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_SaveLayerStrategy {
    kFullLayer_SaveLayerStrategy = 0,
    kNoLayer_SaveLayerStrategy = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_ClipEdgeStyle {
    kHard_ClipEdgeStyle = 0,
    kSoft_ClipEdgeStyle = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_ShaderOverrideOpacity {
    kNone_ShaderOverrideOpacity = 0,
    kOpaque_ShaderOverrideOpacity = 1,
    kNotOpaque_ShaderOverrideOpacity = 2,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_CheckForOverwrite {
    kNo = 0,
    kYes = 1,
}
#[repr(C)]
pub struct SkCanvas_Layer {
    pub fDevice: sk_sp<SkBaseDevice>,
    pub fImageFilter: sk_sp<SkImageFilter>,
    pub fPaint: SkPaint,
    pub fDiscard: bool,
}
#[test]
fn bindgen_test_layout_SkCanvas_Layer() {
    const UNINIT: ::core::mem::MaybeUninit<SkCanvas_Layer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_Layer>(),
        104usize,
        concat!("Size of: ", stringify!(SkCanvas_Layer))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_Layer>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_Layer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDevice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Layer),
            "::",
            stringify!(fDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fImageFilter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Layer),
            "::",
            stringify!(fImageFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPaint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Layer),
            "::",
            stringify!(fPaint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDiscard) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_Layer),
            "::",
            stringify!(fDiscard)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5LayerC1E5sk_spI12SkBaseDeviceES1_I13SkImageFilterERK7SkPaint"]
    pub fn SkCanvas_Layer_Layer(
        this: *mut SkCanvas_Layer,
        device: sk_sp<SkBaseDevice>,
        imageFilter: sk_sp<SkImageFilter>,
        paint: *const SkPaint,
    );
}
impl SkCanvas_Layer {
    #[inline]
    pub unsafe fn new(
        device: sk_sp<SkBaseDevice>,
        imageFilter: sk_sp<SkImageFilter>,
        paint: *const SkPaint,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_Layer_Layer(__bindgen_tmp.as_mut_ptr(), device, imageFilter, paint);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas_BackImage {
    pub fImage: sk_sp<SkSpecialImage>,
    pub fLoc: SkIPoint,
}
#[test]
fn bindgen_test_layout_SkCanvas_BackImage() {
    const UNINIT: ::core::mem::MaybeUninit<SkCanvas_BackImage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_BackImage>(),
        16usize,
        concat!("Size of: ", stringify!(SkCanvas_BackImage))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_BackImage>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_BackImage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fImage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_BackImage),
            "::",
            stringify!(fImage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLoc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_BackImage),
            "::",
            stringify!(fLoc)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9BackImageC1E5sk_spI14SkSpecialImageE8SkIPoint"]
    pub fn SkCanvas_BackImage_BackImage(
        this: *mut SkCanvas_BackImage,
        arg1: sk_sp<SkSpecialImage>,
        arg2: SkIPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9BackImageC1ERKS0_"]
    pub fn SkCanvas_BackImage_BackImage1(
        this: *mut SkCanvas_BackImage,
        arg1: *const SkCanvas_BackImage,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9BackImageC1EOS0_"]
    pub fn SkCanvas_BackImage_BackImage2(
        this: *mut SkCanvas_BackImage,
        arg1: *mut SkCanvas_BackImage,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9BackImageD1Ev"]
    pub fn SkCanvas_BackImage_BackImage_destructor(this: *mut SkCanvas_BackImage);
}
impl SkCanvas_BackImage {
    #[inline]
    pub unsafe fn new(arg1: sk_sp<SkSpecialImage>, arg2: SkIPoint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_BackImage_BackImage(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const SkCanvas_BackImage) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_BackImage_BackImage1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut SkCanvas_BackImage) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_BackImage_BackImage2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkCanvas_BackImage_BackImage_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas_MCRec {
    pub fLayer: u64,
    pub fDevice: *mut SkBaseDevice,
    pub fBackImage: u64,
    pub fMatrix: SkM44,
    pub fDeferredSaveCount: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_SkCanvas_MCRec() {
    const UNINIT: ::core::mem::MaybeUninit<SkCanvas_MCRec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_MCRec>(),
        96usize,
        concat!("Size of: ", stringify!(SkCanvas_MCRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_MCRec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_MCRec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLayer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_MCRec),
            "::",
            stringify!(fLayer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDevice) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_MCRec),
            "::",
            stringify!(fDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBackImage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_MCRec),
            "::",
            stringify!(fBackImage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMatrix) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_MCRec),
            "::",
            stringify!(fMatrix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDeferredSaveCount) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas_MCRec),
            "::",
            stringify!(fDeferredSaveCount)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRec8newLayerE5sk_spI12SkBaseDeviceES1_I13SkImageFilterERK7SkPaint"]
    pub fn SkCanvas_MCRec_newLayer(
        this: *mut SkCanvas_MCRec,
        layerDevice: sk_sp<SkBaseDevice>,
        filter: sk_sp<SkImageFilter>,
        restorePaint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRec5resetEP12SkBaseDevice"]
    pub fn SkCanvas_MCRec_reset(this: *mut SkCanvas_MCRec, device: *mut SkBaseDevice);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRecC1EP12SkBaseDevice"]
    pub fn SkCanvas_MCRec_MCRec(this: *mut SkCanvas_MCRec, device: *mut SkBaseDevice);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRecC1EPKS0_"]
    pub fn SkCanvas_MCRec_MCRec1(this: *mut SkCanvas_MCRec, prev: *const SkCanvas_MCRec);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRecD1Ev"]
    pub fn SkCanvas_MCRec_MCRec_destructor(this: *mut SkCanvas_MCRec);
}
impl SkCanvas_MCRec {
    #[inline]
    pub unsafe fn newLayer(
        &mut self,
        layerDevice: sk_sp<SkBaseDevice>,
        filter: sk_sp<SkImageFilter>,
        restorePaint: *const SkPaint,
    ) {
        SkCanvas_MCRec_newLayer(self, layerDevice, filter, restorePaint)
    }
    #[inline]
    pub unsafe fn reset(&mut self, device: *mut SkBaseDevice) {
        SkCanvas_MCRec_reset(self, device)
    }
    #[inline]
    pub unsafe fn new(device: *mut SkBaseDevice) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_MCRec_MCRec(__bindgen_tmp.as_mut_ptr(), device);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(prev: *const SkCanvas_MCRec) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_MCRec_MCRec1(__bindgen_tmp.as_mut_ptr(), prev);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkCanvas_MCRec_MCRec_destructor(self)
    }
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_DeviceCompatibleWithFilter {
    kUnknown = 0,
    kYes = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_AutoUpdateQRBounds {
    _unused: [u8; 0],
}
pub const SkCanvas_kMCRecSize: ::core::ffi::c_int = 96;
pub const SkCanvas_kMCRecCount: ::core::ffi::c_int = 32;
#[test]
fn bindgen_test_layout_SkCanvas() {
    const UNINIT: ::core::mem::MaybeUninit<SkCanvas> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCanvas>(),
        3232usize,
        concat!("Size of: ", stringify!(SkCanvas))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMCRecStorage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fMCRecStorage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMCStack) as usize - ptr as usize },
        3080usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fMCStack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMCRec) as usize - ptr as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fMCRec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBaseDevice) as usize - ptr as usize },
        3144usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fBaseDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProps) as usize - ptr as usize },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fProps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSaveCount) as usize - ptr as usize },
        3160usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fSaveCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAllocator) as usize - ptr as usize },
        3168usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fAllocator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSurfaceBase) as usize - ptr as usize },
        3176usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fSurfaceBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fClipRestrictionRect) as usize - ptr as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fClipRestrictionRect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fClipRestrictionSaveCount) as usize - ptr as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fClipRestrictionSaveCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fQuickRejectBounds) as usize - ptr as usize },
        3204usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fQuickRejectBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fScratchGlyphRunBuilder) as usize - ptr as usize },
        3224usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCanvas),
            "::",
            stringify!(fScratchGlyphRunBuilder)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16MakeRasterDirectERK11SkImageInfoPvmPK14SkSurfaceProps"]
    pub fn SkCanvas_MakeRasterDirect(
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        props: *const SkSurfaceProps,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas9imageInfoEv"]
    pub fn SkCanvas_imageInfo(this: *const SkCanvas) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas8getPropsEP14SkSurfaceProps"]
    pub fn SkCanvas_getProps(this: *const SkCanvas, props: *mut SkSurfaceProps) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas12getBasePropsEv"]
    pub fn SkCanvas_getBaseProps(this: *const SkCanvas) -> SkSurfaceProps;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11getTopPropsEv"]
    pub fn SkCanvas_getTopProps(this: *const SkCanvas) -> SkSurfaceProps;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11makeSurfaceERK11SkImageInfoPK14SkSurfaceProps"]
    pub fn SkCanvas_makeSurface(
        this: *mut SkCanvas,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas10getSurfaceEv"]
    pub fn SkCanvas_getSurface(this: *const SkCanvas) -> *mut SkSurface;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas20accessTopLayerPixelsEP11SkImageInfoPmP8SkIPoint"]
    pub fn SkCanvas_accessTopLayerPixels(
        this: *mut SkCanvas,
        info: *mut SkImageInfo,
        rowBytes: *mut usize,
        origin: *mut SkIPoint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas21accessTopRasterHandleEv"]
    pub fn SkCanvas_accessTopRasterHandle(this: *const SkCanvas) -> SkRasterHandleAllocator_Handle;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10peekPixelsEP8SkPixmap"]
    pub fn SkCanvas_peekPixels(this: *mut SkCanvas, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkCanvas_readPixels(
        this: *mut SkCanvas,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10readPixelsERK8SkPixmapii"]
    pub fn SkCanvas_readPixels1(
        this: *mut SkCanvas,
        pixmap: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10readPixelsERK8SkBitmapii"]
    pub fn SkCanvas_readPixels2(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11writePixelsERK11SkImageInfoPKvmii"]
    pub fn SkCanvas_writePixels(
        this: *mut SkCanvas,
        info: *const SkImageInfo,
        pixels: *const ::core::ffi::c_void,
        rowBytes: usize,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11writePixelsERK8SkBitmapii"]
    pub fn SkCanvas_writePixels1(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas4saveEv"]
    pub fn SkCanvas_save(this: *mut SkCanvas) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9saveLayerEPK6SkRectPK7SkPaint"]
    pub fn SkCanvas_saveLayer(
        this: *mut SkCanvas,
        bounds: *const SkRect,
        paint: *const SkPaint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas15saveLayerAlphafEPK6SkRectf"]
    pub fn SkCanvas_saveLayerAlphaf(
        this: *mut SkCanvas,
        bounds: *const SkRect,
        alpha: f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9saveLayerERKNS_12SaveLayerRecE"]
    pub fn SkCanvas_saveLayer1(
        this: *mut SkCanvas,
        layerRec: *const SkCanvas_SaveLayerRec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas7restoreEv"]
    pub fn SkCanvas_restore(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas12getSaveCountEv"]
    pub fn SkCanvas_getSaveCount(this: *const SkCanvas) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14restoreToCountEi"]
    pub fn SkCanvas_restoreToCount(this: *mut SkCanvas, saveCount: ::core::ffi::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9translateEff"]
    pub fn SkCanvas_translate(this: *mut SkCanvas, dx: SkScalar, dy: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5scaleEff"]
    pub fn SkCanvas_scale(this: *mut SkCanvas, sx: SkScalar, sy: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas6rotateEf"]
    pub fn SkCanvas_rotate(this: *mut SkCanvas, degrees: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas6rotateEfff"]
    pub fn SkCanvas_rotate1(this: *mut SkCanvas, degrees: SkScalar, px: SkScalar, py: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas4skewEff"]
    pub fn SkCanvas_skew(this: *mut SkCanvas, sx: SkScalar, sy: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas6concatERK8SkMatrix"]
    pub fn SkCanvas_concat(this: *mut SkCanvas, matrix: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas6concatERK5SkM44"]
    pub fn SkCanvas_concat1(this: *mut SkCanvas, arg1: *const SkM44);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9setMatrixERK5SkM44"]
    pub fn SkCanvas_setMatrix(this: *mut SkCanvas, matrix: *const SkM44);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9setMatrixERK8SkMatrix"]
    pub fn SkCanvas_setMatrix1(this: *mut SkCanvas, matrix: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11resetMatrixEv"]
    pub fn SkCanvas_resetMatrix(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8clipRectERK6SkRect8SkClipOpb"]
    pub fn SkCanvas_clipRect(
        this: *mut SkCanvas,
        rect: *const SkRect,
        op: SkClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas41androidFramework_setDeviceClipRestrictionERK7SkIRect"]
    pub fn SkCanvas_androidFramework_setDeviceClipRestriction(
        this: *mut SkCanvas,
        rect: *const SkIRect,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9clipRRectERK7SkRRect8SkClipOpb"]
    pub fn SkCanvas_clipRRect(
        this: *mut SkCanvas,
        rrect: *const SkRRect,
        op: SkClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8clipPathERK6SkPath8SkClipOpb"]
    pub fn SkCanvas_clipPath(
        this: *mut SkCanvas,
        path: *const SkPath,
        op: SkClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10clipShaderE5sk_spI8SkShaderE8SkClipOp"]
    pub fn SkCanvas_clipShader(this: *mut SkCanvas, arg1: sk_sp<SkShader>, arg2: SkClipOp);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10clipRegionERK8SkRegion8SkClipOp"]
    pub fn SkCanvas_clipRegion(this: *mut SkCanvas, deviceRgn: *const SkRegion, op: SkClipOp);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11quickRejectERK6SkRect"]
    pub fn SkCanvas_quickReject(this: *const SkCanvas, rect: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11quickRejectERK6SkPath"]
    pub fn SkCanvas_quickReject1(this: *const SkCanvas, path: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas18getLocalClipBoundsEv"]
    pub fn SkCanvas_getLocalClipBounds(this: *const SkCanvas) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas19getDeviceClipBoundsEv"]
    pub fn SkCanvas_getDeviceClipBounds(this: *const SkCanvas) -> SkIRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawColorERK8SkRGBA4fIL11SkAlphaType3EE11SkBlendMode"]
    pub fn SkCanvas_drawColor(this: *mut SkCanvas, color: *const SkColor4f, mode: SkBlendMode);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawPaintERK7SkPaint"]
    pub fn SkCanvas_drawPaint(this: *mut SkCanvas, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawPointsENS_9PointModeEmPK7SkPointRK7SkPaint"]
    pub fn SkCanvas_drawPoints(
        this: *mut SkCanvas,
        mode: SkCanvas_PointMode,
        count: usize,
        pts: *const SkPoint,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawPointEffRK7SkPaint"]
    pub fn SkCanvas_drawPoint(this: *mut SkCanvas, x: SkScalar, y: SkScalar, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawLineEffffRK7SkPaint"]
    pub fn SkCanvas_drawLine(
        this: *mut SkCanvas,
        x0: SkScalar,
        y0: SkScalar,
        x1: SkScalar,
        y1: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawRectERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_drawRect(this: *mut SkCanvas, rect: *const SkRect, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawRegionERK8SkRegionRK7SkPaint"]
    pub fn SkCanvas_drawRegion(this: *mut SkCanvas, region: *const SkRegion, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawOvalERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_drawOval(this: *mut SkCanvas, oval: *const SkRect, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawRRectERK7SkRRectRK7SkPaint"]
    pub fn SkCanvas_drawRRect(this: *mut SkCanvas, rrect: *const SkRRect, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawDRRectERK7SkRRectS2_RK7SkPaint"]
    pub fn SkCanvas_drawDRRect(
        this: *mut SkCanvas,
        outer: *const SkRRect,
        inner: *const SkRRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawCircleEfffRK7SkPaint"]
    pub fn SkCanvas_drawCircle(
        this: *mut SkCanvas,
        cx: SkScalar,
        cy: SkScalar,
        radius: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas7drawArcERK6SkRectffbRK7SkPaint"]
    pub fn SkCanvas_drawArc(
        this: *mut SkCanvas,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        useCenter: bool,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13drawRoundRectERK6SkRectffRK7SkPaint"]
    pub fn SkCanvas_drawRoundRect(
        this: *mut SkCanvas,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawPathERK6SkPathRK7SkPaint"]
    pub fn SkCanvas_drawPath(this: *mut SkCanvas, path: *const SkPath, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawImageEPK7SkImageffRK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkCanvas_drawImage(
        this: *mut SkCanvas,
        arg1: *const SkImage,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13drawImageRectEPK7SkImageRK6SkRectS5_RK17SkSamplingOptionsPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_drawImageRect(
        this: *mut SkCanvas,
        arg1: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
        arg4: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13drawImageRectEPK7SkImageRK6SkRectRK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkCanvas_drawImageRect1(
        this: *mut SkCanvas,
        arg1: *const SkImage,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13drawImageNineEPK7SkImageRK7SkIRectRK6SkRect12SkFilterModePK7SkPaint"]
    pub fn SkCanvas_drawImageNine(
        this: *mut SkCanvas,
        image: *const SkImage,
        center: *const SkIRect,
        dst: *const SkRect,
        filter: SkFilterMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16drawImageLatticeEPK7SkImageRKNS_7LatticeERK6SkRect12SkFilterModePK7SkPaint"]
    pub fn SkCanvas_drawImageLattice(
        this: *mut SkCanvas,
        image: *const SkImage,
        lattice: *const SkCanvas_Lattice,
        dst: *const SkRect,
        filter: SkFilterMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas27experimental_DrawEdgeAAQuadERK6SkRectPK7SkPointNS_11QuadAAFlagsERK8SkRGBA4fIL11SkAlphaType3EE11SkBlendMode"]
    pub fn SkCanvas_experimental_DrawEdgeAAQuad(
        this: *mut SkCanvas,
        rect: *const SkRect,
        clip: *const SkPoint,
        aaFlags: SkCanvas_QuadAAFlags,
        color: *const SkColor4f,
        mode: SkBlendMode,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas31experimental_DrawEdgeAAImageSetEPKNS_13ImageSetEntryEiPK7SkPointPK8SkMatrixRK17SkSamplingOptionsPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_experimental_DrawEdgeAAImageSet(
        this: *mut SkCanvas,
        imageSet: *const SkCanvas_ImageSetEntry,
        cnt: ::core::ffi::c_int,
        dstClips: *const SkPoint,
        preViewMatrices: *const SkMatrix,
        arg1: *const SkSamplingOptions,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14drawSimpleTextEPKvm14SkTextEncodingffRK6SkFontRK7SkPaint"]
    pub fn SkCanvas_drawSimpleText(
        this: *mut SkCanvas,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        font: *const SkFont,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawGlyphsEiPKtPK7SkPointPKjiPKcS2_RK6SkFontRK7SkPaint"]
    pub fn SkCanvas_drawGlyphs(
        this: *mut SkCanvas,
        count: ::core::ffi::c_int,
        glyphs: *const SkGlyphID,
        positions: *const SkPoint,
        clusters: *const u32,
        textByteCount: ::core::ffi::c_int,
        utf8text: *const ::core::ffi::c_char,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawGlyphsEiPKtPK7SkPointS2_RK6SkFontRK7SkPaint"]
    pub fn SkCanvas_drawGlyphs1(
        this: *mut SkCanvas,
        count: ::core::ffi::c_int,
        glyphs: *const SkGlyphID,
        positions: *const SkPoint,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawGlyphsEiPKtPK9SkRSXform7SkPointRK6SkFontRK7SkPaint"]
    pub fn SkCanvas_drawGlyphs2(
        this: *mut SkCanvas,
        count: ::core::ffi::c_int,
        glyphs: *const SkGlyphID,
        xforms: *const SkRSXform,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawTextBlobEPK10SkTextBlobffRK7SkPaint"]
    pub fn SkCanvas_drawTextBlob(
        this: *mut SkCanvas,
        blob: *const SkTextBlob,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11drawPictureEPK9SkPicturePK8SkMatrixPK7SkPaint"]
    pub fn SkCanvas_drawPicture(
        this: *mut SkCanvas,
        picture: *const SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawVerticesEPK10SkVertices11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_drawVertices(
        this: *mut SkCanvas,
        vertices: *const SkVertices,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawVerticesERK5sk_spI10SkVerticesE11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_drawVertices1(
        this: *mut SkCanvas,
        vertices: *const sk_sp<SkVertices>,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawMeshERK6SkMesh5sk_spI9SkBlenderERK7SkPaint"]
    pub fn SkCanvas_drawMesh(
        this: *mut SkCanvas,
        mesh: *const SkMesh,
        blender: sk_sp<SkBlender>,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawPatchEPK7SkPointPKjS2_11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_drawPatch(
        this: *mut SkCanvas,
        cubics: *const SkPoint,
        colors: *const SkColor,
        texCoords: *const SkPoint,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawAtlasEPK7SkImagePK9SkRSXformPK6SkRectPKji11SkBlendModeRK17SkSamplingOptionsS8_PK7SkPaint"]
    pub fn SkCanvas_drawAtlas(
        this: *mut SkCanvas,
        atlas: *const SkImage,
        xform: *const SkRSXform,
        tex: *const SkRect,
        colors: *const SkColor,
        count: ::core::ffi::c_int,
        mode: SkBlendMode,
        sampling: *const SkSamplingOptions,
        cullRect: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawDrawableEP10SkDrawablePK8SkMatrix"]
    pub fn SkCanvas_drawDrawable(
        this: *mut SkCanvas,
        drawable: *mut SkDrawable,
        matrix: *const SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawDrawableEP10SkDrawableff"]
    pub fn SkCanvas_drawDrawable1(
        this: *mut SkCanvas,
        drawable: *mut SkDrawable,
        x: SkScalar,
        y: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14drawAnnotationERK6SkRectPKcP6SkData"]
    pub fn SkCanvas_drawAnnotation(
        this: *mut SkCanvas,
        rect: *const SkRect,
        key: *const ::core::ffi::c_char,
        value: *mut SkData,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas16getLocalToDeviceEv"]
    pub fn SkCanvas_getLocalToDevice(this: *const SkCanvas) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas14getTotalMatrixEv"]
    pub fn SkCanvas_getTotalMatrix(this: *const SkCanvas) -> SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas29temporary_internal_getRgnClipEP8SkRegion"]
    pub fn SkCanvas_temporary_internal_getRgnClip(this: *mut SkCanvas, region: *mut SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas23private_draw_shadow_recERK6SkPathRK15SkDrawShadowRec"]
    pub fn SkCanvas_private_draw_shadow_rec(
        this: *mut SkCanvas,
        arg1: *const SkPath,
        arg2: *const SkDrawShadowRec,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1Ev"]
    pub fn SkCanvas_SkCanvas(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1EiiPK14SkSurfaceProps"]
    pub fn SkCanvas_SkCanvas1(
        this: *mut SkCanvas,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        props: *const SkSurfaceProps,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1E5sk_spI12SkBaseDeviceE"]
    pub fn SkCanvas_SkCanvas2(this: *mut SkCanvas, device: sk_sp<SkBaseDevice>);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1ERK8SkBitmap"]
    pub fn SkCanvas_SkCanvas3(this: *mut SkCanvas, bitmap: *const SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1ERK8SkBitmapRK14SkSurfaceProps"]
    pub fn SkCanvas_SkCanvas4(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        props: *const SkSurfaceProps,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1ERK7SkIRect"]
    pub fn SkCanvas_SkCanvas5(this: *mut SkCanvas, bounds: *const SkIRect);
}
impl SkCanvas {
    #[inline]
    pub unsafe fn MakeRasterDirect(
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        props: *const SkSurfaceProps,
    ) -> u64 {
        SkCanvas_MakeRasterDirect(info, pixels, rowBytes, props)
    }
    #[inline]
    pub unsafe fn imageInfo(&self) -> SkImageInfo {
        SkCanvas_imageInfo(self)
    }
    #[inline]
    pub unsafe fn getProps(&self, props: *mut SkSurfaceProps) -> bool {
        SkCanvas_getProps(self, props)
    }
    #[inline]
    pub unsafe fn getBaseProps(&self) -> SkSurfaceProps {
        SkCanvas_getBaseProps(self)
    }
    #[inline]
    pub unsafe fn getTopProps(&self) -> SkSurfaceProps {
        SkCanvas_getTopProps(self)
    }
    #[inline]
    pub unsafe fn makeSurface(
        &mut self,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkCanvas_makeSurface(self, info, props)
    }
    #[inline]
    pub unsafe fn getSurface(&self) -> *mut SkSurface {
        SkCanvas_getSurface(self)
    }
    #[inline]
    pub unsafe fn accessTopLayerPixels(
        &mut self,
        info: *mut SkImageInfo,
        rowBytes: *mut usize,
        origin: *mut SkIPoint,
    ) -> *mut ::core::ffi::c_void {
        SkCanvas_accessTopLayerPixels(self, info, rowBytes, origin)
    }
    #[inline]
    pub unsafe fn accessTopRasterHandle(&self) -> SkRasterHandleAllocator_Handle {
        SkCanvas_accessTopRasterHandle(self)
    }
    #[inline]
    pub unsafe fn peekPixels(&mut self, pixmap: *mut SkPixmap) -> bool {
        SkCanvas_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn readPixels(
        &mut self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool {
        SkCanvas_readPixels(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &mut self,
        pixmap: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool {
        SkCanvas_readPixels1(self, pixmap, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels2(
        &mut self,
        bitmap: *const SkBitmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool {
        SkCanvas_readPixels2(self, bitmap, srcX, srcY)
    }
    #[inline]
    pub unsafe fn writePixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *const ::core::ffi::c_void,
        rowBytes: usize,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> bool {
        SkCanvas_writePixels(self, info, pixels, rowBytes, x, y)
    }
    #[inline]
    pub unsafe fn writePixels1(
        &mut self,
        bitmap: *const SkBitmap,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> bool {
        SkCanvas_writePixels1(self, bitmap, x, y)
    }
    #[inline]
    pub unsafe fn save(&mut self) -> ::core::ffi::c_int {
        SkCanvas_save(self)
    }
    #[inline]
    pub unsafe fn saveLayer(
        &mut self,
        bounds: *const SkRect,
        paint: *const SkPaint,
    ) -> ::core::ffi::c_int {
        SkCanvas_saveLayer(self, bounds, paint)
    }
    #[inline]
    pub unsafe fn saveLayerAlphaf(
        &mut self,
        bounds: *const SkRect,
        alpha: f32,
    ) -> ::core::ffi::c_int {
        SkCanvas_saveLayerAlphaf(self, bounds, alpha)
    }
    #[inline]
    pub unsafe fn saveLayer1(
        &mut self,
        layerRec: *const SkCanvas_SaveLayerRec,
    ) -> ::core::ffi::c_int {
        SkCanvas_saveLayer1(self, layerRec)
    }
    #[inline]
    pub unsafe fn restore(&mut self) {
        SkCanvas_restore(self)
    }
    #[inline]
    pub unsafe fn getSaveCount(&self) -> ::core::ffi::c_int {
        SkCanvas_getSaveCount(self)
    }
    #[inline]
    pub unsafe fn restoreToCount(&mut self, saveCount: ::core::ffi::c_int) {
        SkCanvas_restoreToCount(self, saveCount)
    }
    #[inline]
    pub unsafe fn translate(&mut self, dx: SkScalar, dy: SkScalar) {
        SkCanvas_translate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn scale(&mut self, sx: SkScalar, sy: SkScalar) {
        SkCanvas_scale(self, sx, sy)
    }
    #[inline]
    pub unsafe fn rotate(&mut self, degrees: SkScalar) {
        SkCanvas_rotate(self, degrees)
    }
    #[inline]
    pub unsafe fn rotate1(&mut self, degrees: SkScalar, px: SkScalar, py: SkScalar) {
        SkCanvas_rotate1(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn skew(&mut self, sx: SkScalar, sy: SkScalar) {
        SkCanvas_skew(self, sx, sy)
    }
    #[inline]
    pub unsafe fn concat(&mut self, matrix: *const SkMatrix) {
        SkCanvas_concat(self, matrix)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, arg1: *const SkM44) {
        SkCanvas_concat1(self, arg1)
    }
    #[inline]
    pub unsafe fn setMatrix(&mut self, matrix: *const SkM44) {
        SkCanvas_setMatrix(self, matrix)
    }
    #[inline]
    pub unsafe fn setMatrix1(&mut self, matrix: *const SkMatrix) {
        SkCanvas_setMatrix1(self, matrix)
    }
    #[inline]
    pub unsafe fn resetMatrix(&mut self) {
        SkCanvas_resetMatrix(self)
    }
    #[inline]
    pub unsafe fn clipRect(&mut self, rect: *const SkRect, op: SkClipOp, doAntiAlias: bool) {
        SkCanvas_clipRect(self, rect, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn androidFramework_setDeviceClipRestriction(&mut self, rect: *const SkIRect) {
        SkCanvas_androidFramework_setDeviceClipRestriction(self, rect)
    }
    #[inline]
    pub unsafe fn clipRRect(&mut self, rrect: *const SkRRect, op: SkClipOp, doAntiAlias: bool) {
        SkCanvas_clipRRect(self, rrect, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn clipPath(&mut self, path: *const SkPath, op: SkClipOp, doAntiAlias: bool) {
        SkCanvas_clipPath(self, path, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn clipShader(&mut self, arg1: sk_sp<SkShader>, arg2: SkClipOp) {
        SkCanvas_clipShader(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn clipRegion(&mut self, deviceRgn: *const SkRegion, op: SkClipOp) {
        SkCanvas_clipRegion(self, deviceRgn, op)
    }
    #[inline]
    pub unsafe fn quickReject(&self, rect: *const SkRect) -> bool {
        SkCanvas_quickReject(self, rect)
    }
    #[inline]
    pub unsafe fn quickReject1(&self, path: *const SkPath) -> bool {
        SkCanvas_quickReject1(self, path)
    }
    #[inline]
    pub unsafe fn getLocalClipBounds(&self) -> SkRect {
        SkCanvas_getLocalClipBounds(self)
    }
    #[inline]
    pub unsafe fn getDeviceClipBounds(&self) -> SkIRect {
        SkCanvas_getDeviceClipBounds(self)
    }
    #[inline]
    pub unsafe fn drawColor(&mut self, color: *const SkColor4f, mode: SkBlendMode) {
        SkCanvas_drawColor(self, color, mode)
    }
    #[inline]
    pub unsafe fn drawPaint(&mut self, paint: *const SkPaint) {
        SkCanvas_drawPaint(self, paint)
    }
    #[inline]
    pub unsafe fn drawPoints(
        &mut self,
        mode: SkCanvas_PointMode,
        count: usize,
        pts: *const SkPoint,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawPoints(self, mode, count, pts, paint)
    }
    #[inline]
    pub unsafe fn drawPoint(&mut self, x: SkScalar, y: SkScalar, paint: *const SkPaint) {
        SkCanvas_drawPoint(self, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawLine(
        &mut self,
        x0: SkScalar,
        y0: SkScalar,
        x1: SkScalar,
        y1: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawLine(self, x0, y0, x1, y1, paint)
    }
    #[inline]
    pub unsafe fn drawRect(&mut self, rect: *const SkRect, paint: *const SkPaint) {
        SkCanvas_drawRect(self, rect, paint)
    }
    #[inline]
    pub unsafe fn drawRegion(&mut self, region: *const SkRegion, paint: *const SkPaint) {
        SkCanvas_drawRegion(self, region, paint)
    }
    #[inline]
    pub unsafe fn drawOval(&mut self, oval: *const SkRect, paint: *const SkPaint) {
        SkCanvas_drawOval(self, oval, paint)
    }
    #[inline]
    pub unsafe fn drawRRect(&mut self, rrect: *const SkRRect, paint: *const SkPaint) {
        SkCanvas_drawRRect(self, rrect, paint)
    }
    #[inline]
    pub unsafe fn drawDRRect(
        &mut self,
        outer: *const SkRRect,
        inner: *const SkRRect,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawDRRect(self, outer, inner, paint)
    }
    #[inline]
    pub unsafe fn drawCircle(
        &mut self,
        cx: SkScalar,
        cy: SkScalar,
        radius: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawCircle(self, cx, cy, radius, paint)
    }
    #[inline]
    pub unsafe fn drawArc(
        &mut self,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        useCenter: bool,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawArc(self, oval, startAngle, sweepAngle, useCenter, paint)
    }
    #[inline]
    pub unsafe fn drawRoundRect(
        &mut self,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawRoundRect(self, rect, rx, ry, paint)
    }
    #[inline]
    pub unsafe fn drawPath(&mut self, path: *const SkPath, paint: *const SkPaint) {
        SkCanvas_drawPath(self, path, paint)
    }
    #[inline]
    pub unsafe fn drawImage(
        &mut self,
        arg1: *const SkImage,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    ) {
        SkCanvas_drawImage(self, arg1, x, y, arg2, arg3)
    }
    #[inline]
    pub unsafe fn drawImageRect(
        &mut self,
        arg1: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
        arg4: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_drawImageRect(self, arg1, src, dst, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn drawImageRect1(
        &mut self,
        arg1: *const SkImage,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    ) {
        SkCanvas_drawImageRect1(self, arg1, dst, arg2, arg3)
    }
    #[inline]
    pub unsafe fn drawImageNine(
        &mut self,
        image: *const SkImage,
        center: *const SkIRect,
        dst: *const SkRect,
        filter: SkFilterMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawImageNine(self, image, center, dst, filter, paint)
    }
    #[inline]
    pub unsafe fn drawImageLattice(
        &mut self,
        image: *const SkImage,
        lattice: *const SkCanvas_Lattice,
        dst: *const SkRect,
        filter: SkFilterMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawImageLattice(self, image, lattice, dst, filter, paint)
    }
    #[inline]
    pub unsafe fn experimental_DrawEdgeAAQuad(
        &mut self,
        rect: *const SkRect,
        clip: *const SkPoint,
        aaFlags: SkCanvas_QuadAAFlags,
        color: *const SkColor4f,
        mode: SkBlendMode,
    ) {
        SkCanvas_experimental_DrawEdgeAAQuad(self, rect, clip, aaFlags, color, mode)
    }
    #[inline]
    pub unsafe fn experimental_DrawEdgeAAImageSet(
        &mut self,
        imageSet: *const SkCanvas_ImageSetEntry,
        cnt: ::core::ffi::c_int,
        dstClips: *const SkPoint,
        preViewMatrices: *const SkMatrix,
        arg1: *const SkSamplingOptions,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_experimental_DrawEdgeAAImageSet(
            self,
            imageSet,
            cnt,
            dstClips,
            preViewMatrices,
            arg1,
            paint,
            constraint,
        )
    }
    #[inline]
    pub unsafe fn drawSimpleText(
        &mut self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        font: *const SkFont,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawSimpleText(self, text, byteLength, encoding, x, y, font, paint)
    }
    #[inline]
    pub unsafe fn drawGlyphs(
        &mut self,
        count: ::core::ffi::c_int,
        glyphs: *const SkGlyphID,
        positions: *const SkPoint,
        clusters: *const u32,
        textByteCount: ::core::ffi::c_int,
        utf8text: *const ::core::ffi::c_char,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawGlyphs(
            self,
            count,
            glyphs,
            positions,
            clusters,
            textByteCount,
            utf8text,
            origin,
            font,
            paint,
        )
    }
    #[inline]
    pub unsafe fn drawGlyphs1(
        &mut self,
        count: ::core::ffi::c_int,
        glyphs: *const SkGlyphID,
        positions: *const SkPoint,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawGlyphs1(self, count, glyphs, positions, origin, font, paint)
    }
    #[inline]
    pub unsafe fn drawGlyphs2(
        &mut self,
        count: ::core::ffi::c_int,
        glyphs: *const SkGlyphID,
        xforms: *const SkRSXform,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawGlyphs2(self, count, glyphs, xforms, origin, font, paint)
    }
    #[inline]
    pub unsafe fn drawTextBlob(
        &mut self,
        blob: *const SkTextBlob,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawTextBlob(self, blob, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawPicture(
        &mut self,
        picture: *const SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawPicture(self, picture, matrix, paint)
    }
    #[inline]
    pub unsafe fn drawVertices(
        &mut self,
        vertices: *const SkVertices,
        mode: SkBlendMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawVertices(self, vertices, mode, paint)
    }
    #[inline]
    pub unsafe fn drawVertices1(
        &mut self,
        vertices: *const sk_sp<SkVertices>,
        mode: SkBlendMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawVertices1(self, vertices, mode, paint)
    }
    #[inline]
    pub unsafe fn drawMesh(
        &mut self,
        mesh: *const SkMesh,
        blender: sk_sp<SkBlender>,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawMesh(self, mesh, blender, paint)
    }
    #[inline]
    pub unsafe fn drawPatch(
        &mut self,
        cubics: *const SkPoint,
        colors: *const SkColor,
        texCoords: *const SkPoint,
        mode: SkBlendMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawPatch(self, cubics, colors, texCoords, mode, paint)
    }
    #[inline]
    pub unsafe fn drawAtlas(
        &mut self,
        atlas: *const SkImage,
        xform: *const SkRSXform,
        tex: *const SkRect,
        colors: *const SkColor,
        count: ::core::ffi::c_int,
        mode: SkBlendMode,
        sampling: *const SkSamplingOptions,
        cullRect: *const SkRect,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawAtlas(
            self, atlas, xform, tex, colors, count, mode, sampling, cullRect, paint,
        )
    }
    #[inline]
    pub unsafe fn drawDrawable(&mut self, drawable: *mut SkDrawable, matrix: *const SkMatrix) {
        SkCanvas_drawDrawable(self, drawable, matrix)
    }
    #[inline]
    pub unsafe fn drawDrawable1(&mut self, drawable: *mut SkDrawable, x: SkScalar, y: SkScalar) {
        SkCanvas_drawDrawable1(self, drawable, x, y)
    }
    #[inline]
    pub unsafe fn drawAnnotation(
        &mut self,
        rect: *const SkRect,
        key: *const ::core::ffi::c_char,
        value: *mut SkData,
    ) {
        SkCanvas_drawAnnotation(self, rect, key, value)
    }
    #[inline]
    pub unsafe fn getLocalToDevice(&self) -> SkM44 {
        SkCanvas_getLocalToDevice(self)
    }
    #[inline]
    pub unsafe fn getTotalMatrix(&self) -> SkMatrix {
        SkCanvas_getTotalMatrix(self)
    }
    #[inline]
    pub unsafe fn temporary_internal_getRgnClip(&mut self, region: *mut SkRegion) {
        SkCanvas_temporary_internal_getRgnClip(self, region)
    }
    #[inline]
    pub unsafe fn private_draw_shadow_rec(
        &mut self,
        arg1: *const SkPath,
        arg2: *const SkDrawShadowRec,
    ) {
        SkCanvas_private_draw_shadow_rec(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        props: *const SkSurfaceProps,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas1(__bindgen_tmp.as_mut_ptr(), width, height, props);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(device: sk_sp<SkBaseDevice>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas2(__bindgen_tmp.as_mut_ptr(), device);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(bitmap: *const SkBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas3(__bindgen_tmp.as_mut_ptr(), bitmap);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(bitmap: *const SkBitmap, props: *const SkSurfaceProps) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas4(__bindgen_tmp.as_mut_ptr(), bitmap, props);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(bounds: *const SkIRect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas5(__bindgen_tmp.as_mut_ptr(), bounds);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasD1Ev"]
    pub fn SkCanvas_SkCanvas_destructor(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas16getBaseLayerSizeEv"]
    pub fn SkCanvas_getBaseLayerSize(this: *mut ::core::ffi::c_void) -> SkISize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas16recordingContextEv"]
    pub fn SkCanvas_recordingContext(this: *mut ::core::ffi::c_void) -> *mut GrRecordingContext;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas8recorderEv"]
    pub fn SkCanvas_recorder(this: *mut ::core::ffi::c_void) -> *mut skgpu_graphite_Recorder;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11isClipEmptyEv"]
    pub fn SkCanvas_isClipEmpty(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas10isClipRectEv"]
    pub fn SkCanvas_isClipRect(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onNewSurfaceERK11SkImageInfoRK14SkSurfaceProps"]
    pub fn SkCanvas_onNewSurface(
        this: *mut ::core::ffi::c_void,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onPeekPixelsEP8SkPixmap"]
    pub fn SkCanvas_onPeekPixels(this: *mut ::core::ffi::c_void, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas22onAccessTopLayerPixelsEP8SkPixmap"]
    pub fn SkCanvas_onAccessTopLayerPixels(
        this: *mut ::core::ffi::c_void,
        pixmap: *mut SkPixmap,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11onImageInfoEv"]
    pub fn SkCanvas_onImageInfo(this: *mut ::core::ffi::c_void) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas10onGetPropsEP14SkSurfacePropsb"]
    pub fn SkCanvas_onGetProps(
        this: *mut ::core::ffi::c_void,
        props: *mut SkSurfaceProps,
        top: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onDrawPaintERK7SkPaint"]
    pub fn SkCanvas_onDrawPaint(this: *mut ::core::ffi::c_void, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawBehindERK7SkPaint"]
    pub fn SkCanvas_onDrawBehind(this: *mut ::core::ffi::c_void, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onDrawRectERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_onDrawRect(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onDrawRRectERK7SkRRectRK7SkPaint"]
    pub fn SkCanvas_onDrawRRect(
        this: *mut ::core::ffi::c_void,
        rrect: *const SkRRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawDRRectERK7SkRRectS2_RK7SkPaint"]
    pub fn SkCanvas_onDrawDRRect(
        this: *mut ::core::ffi::c_void,
        outer: *const SkRRect,
        inner: *const SkRRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onDrawOvalERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_onDrawOval(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9onDrawArcERK6SkRectffbRK7SkPaint"]
    pub fn SkCanvas_onDrawArc(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        useCenter: bool,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onDrawPathERK6SkPathRK7SkPaint"]
    pub fn SkCanvas_onDrawPath(
        this: *mut ::core::ffi::c_void,
        path: *const SkPath,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawRegionERK8SkRegionRK7SkPaint"]
    pub fn SkCanvas_onDrawRegion(
        this: *mut ::core::ffi::c_void,
        region: *const SkRegion,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14onDrawTextBlobEPK10SkTextBlobffRK7SkPaint"]
    pub fn SkCanvas_onDrawTextBlob(
        this: *mut ::core::ffi::c_void,
        blob: *const SkTextBlob,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas18onDrawGlyphRunListERKN6sktext12GlyphRunListERK7SkPaint"]
    pub fn SkCanvas_onDrawGlyphRunList(
        this: *mut ::core::ffi::c_void,
        glyphRunList: *const sktext_GlyphRunList,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onDrawPatchEPK7SkPointPKjS2_11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_onDrawPatch(
        this: *mut ::core::ffi::c_void,
        cubics: *const SkPoint,
        colors: *const SkColor,
        texCoords: *const SkPoint,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawPointsENS_9PointModeEmPK7SkPointRK7SkPaint"]
    pub fn SkCanvas_onDrawPoints(
        this: *mut ::core::ffi::c_void,
        mode: SkCanvas_PointMode,
        count: usize,
        pts: *const SkPoint,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawImage2EPK7SkImageffRK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkCanvas_onDrawImage2(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkImage,
        dx: SkScalar,
        dy: SkScalar,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16onDrawImageRect2EPK7SkImageRK6SkRectS5_RK17SkSamplingOptionsPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_onDrawImageRect2(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
        arg4: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas19onDrawImageLattice2EPK7SkImageRKNS_7LatticeERK6SkRect12SkFilterModePK7SkPaint"]
    pub fn SkCanvas_onDrawImageLattice2(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkImage,
        arg2: *const SkCanvas_Lattice,
        dst: *const SkRect,
        arg3: SkFilterMode,
        arg4: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawAtlas2EPK7SkImagePK9SkRSXformPK6SkRectPKji11SkBlendModeRK17SkSamplingOptionsS8_PK7SkPaint"]
    pub fn SkCanvas_onDrawAtlas2(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkImage,
        arg2: *const SkRSXform,
        src: *const SkRect,
        arg3: *const SkColor,
        count: ::core::ffi::c_int,
        arg4: SkBlendMode,
        arg5: *const SkSamplingOptions,
        cull: *const SkRect,
        arg6: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas21onDrawEdgeAAImageSet2EPKNS_13ImageSetEntryEiPK7SkPointPK8SkMatrixRK17SkSamplingOptionsPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_onDrawEdgeAAImageSet2(
        this: *mut ::core::ffi::c_void,
        imageSet: *const SkCanvas_ImageSetEntry,
        count: ::core::ffi::c_int,
        dstClips: *const SkPoint,
        preViewMatrices: *const SkMatrix,
        arg1: *const SkSamplingOptions,
        arg2: *const SkPaint,
        arg3: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas20onDrawVerticesObjectEPK10SkVertices11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_onDrawVerticesObject(
        this: *mut ::core::ffi::c_void,
        vertices: *const SkVertices,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onDrawMeshERK6SkMesh5sk_spI9SkBlenderERK7SkPaint"]
    pub fn SkCanvas_onDrawMesh(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkMesh,
        arg2: sk_sp<SkBlender>,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16onDrawAnnotationERK6SkRectPKcP6SkData"]
    pub fn SkCanvas_onDrawAnnotation(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        key: *const ::core::ffi::c_char,
        value: *mut SkData,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas15onDrawShadowRecERK6SkPathRK15SkDrawShadowRec"]
    pub fn SkCanvas_onDrawShadowRec(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkPath,
        arg2: *const SkDrawShadowRec,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14onDrawDrawableEP10SkDrawablePK8SkMatrix"]
    pub fn SkCanvas_onDrawDrawable(
        this: *mut ::core::ffi::c_void,
        drawable: *mut SkDrawable,
        matrix: *const SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13onDrawPictureEPK9SkPicturePK8SkMatrixPK7SkPaint"]
    pub fn SkCanvas_onDrawPicture(
        this: *mut ::core::ffi::c_void,
        picture: *const SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16onDrawEdgeAAQuadERK6SkRectPK7SkPointNS_11QuadAAFlagsERK8SkRGBA4fIL11SkAlphaType3EE11SkBlendMode"]
    pub fn SkCanvas_onDrawEdgeAAQuad(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        clip: *const SkPoint,
        aaFlags: SkCanvas_QuadAAFlags,
        color: *const SkColor4f,
        mode: SkBlendMode,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onClipRectERK6SkRect8SkClipOpNS_13ClipEdgeStyleE"]
    pub fn SkCanvas_onClipRect(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        op: SkClipOp,
        edgeStyle: SkCanvas_ClipEdgeStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onClipRRectERK7SkRRect8SkClipOpNS_13ClipEdgeStyleE"]
    pub fn SkCanvas_onClipRRect(
        this: *mut ::core::ffi::c_void,
        rrect: *const SkRRect,
        op: SkClipOp,
        edgeStyle: SkCanvas_ClipEdgeStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onClipPathERK6SkPath8SkClipOpNS_13ClipEdgeStyleE"]
    pub fn SkCanvas_onClipPath(
        this: *mut ::core::ffi::c_void,
        path: *const SkPath,
        op: SkClipOp,
        edgeStyle: SkCanvas_ClipEdgeStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onClipShaderE5sk_spI8SkShaderE8SkClipOp"]
    pub fn SkCanvas_onClipShader(
        this: *mut ::core::ffi::c_void,
        arg1: sk_sp<SkShader>,
        arg2: SkClipOp,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onClipRegionERK8SkRegion8SkClipOp"]
    pub fn SkCanvas_onClipRegion(
        this: *mut ::core::ffi::c_void,
        deviceRgn: *const SkRegion,
        op: SkClipOp,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onResetClipEv"]
    pub fn SkCanvas_onResetClip(this: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9onDiscardEv"]
    pub fn SkCanvas_onDiscard(this: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas27onConvertGlyphRunListToSlugERKN6sktext12GlyphRunListERK7SkPaint"]
    pub fn SkCanvas_onConvertGlyphRunListToSlug(
        this: *mut ::core::ffi::c_void,
        glyphRunList: *const sktext_GlyphRunList,
        paint: *const SkPaint,
    ) -> sk_sp<sktext_gpu_Slug>;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onDrawSlugEPKN6sktext3gpu4SlugE"]
    pub fn SkCanvas_onDrawSlug(this: *mut ::core::ffi::c_void, slug: *const sktext_gpu_Slug);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkAutoCanvasRestore {
    pub fCanvas: *mut SkCanvas,
    pub fSaveCount: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_SkAutoCanvasRestore() {
    const UNINIT: ::core::mem::MaybeUninit<SkAutoCanvasRestore> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkAutoCanvasRestore>(),
        16usize,
        concat!("Size of: ", stringify!(SkAutoCanvasRestore))
    );
    assert_eq!(
        ::core::mem::align_of::<SkAutoCanvasRestore>(),
        8usize,
        concat!("Alignment of ", stringify!(SkAutoCanvasRestore))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCanvas) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkAutoCanvasRestore),
            "::",
            stringify!(fCanvas)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSaveCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkAutoCanvasRestore),
            "::",
            stringify!(fSaveCount)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkColorFilter {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkColorFilter_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkColorFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkColorFilter>(),
        16usize,
        concat!("Size of: ", stringify!(SkColorFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkColorFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter12asAColorModeEPjP11SkBlendMode"]
    pub fn SkColorFilter_asAColorMode(
        this: *const SkColorFilter,
        color: *mut SkColor,
        mode: *mut SkBlendMode,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter14asAColorMatrixEPf"]
    pub fn SkColorFilter_asAColorMatrix(this: *const SkColorFilter, matrix: *mut f32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter16isAlphaUnchangedEv"]
    pub fn SkColorFilter_isAlphaUnchanged(this: *const SkColorFilter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter11filterColorEj"]
    pub fn SkColorFilter_filterColor(this: *const SkColorFilter, arg1: SkColor) -> SkColor;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter13filterColor4fERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpaceS6_"]
    pub fn SkColorFilter_filterColor4f(
        this: *const SkColorFilter,
        srcColor: *const SkColor4f,
        srcCS: *mut SkColorSpace,
        dstCS: *mut SkColorSpace,
    ) -> SkColor4f;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter12makeComposedE5sk_spIS_E"]
    pub fn SkColorFilter_makeComposed(
        this: *const SkColorFilter,
        inner: sk_sp<SkColorFilter>,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorFilter11DeserializeEPKvmPK15SkDeserialProcs"]
    pub fn SkColorFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkColorFilter>;
}
impl SkColorFilter {
    #[inline]
    pub unsafe fn asAColorMode(&self, color: *mut SkColor, mode: *mut SkBlendMode) -> bool {
        SkColorFilter_asAColorMode(self, color, mode)
    }
    #[inline]
    pub unsafe fn asAColorMatrix(&self, matrix: *mut f32) -> bool {
        SkColorFilter_asAColorMatrix(self, matrix)
    }
    #[inline]
    pub unsafe fn isAlphaUnchanged(&self) -> bool {
        SkColorFilter_isAlphaUnchanged(self)
    }
    #[inline]
    pub unsafe fn filterColor(&self, arg1: SkColor) -> SkColor {
        SkColorFilter_filterColor(self, arg1)
    }
    #[inline]
    pub unsafe fn filterColor4f(
        &self,
        srcColor: *const SkColor4f,
        srcCS: *mut SkColorSpace,
        dstCS: *mut SkColorSpace,
    ) -> SkColor4f {
        SkColorFilter_filterColor4f(self, srcColor, srcCS, dstCS)
    }
    #[inline]
    pub unsafe fn makeComposed(&self, inner: sk_sp<SkColorFilter>) -> sk_sp<SkColorFilter> {
        SkColorFilter_makeComposed(self, inner)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkColorFilter> {
        SkColorFilter_Deserialize(data, size, procs)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkColorTable {
    pub _base: SkRefCnt,
    pub fTable: SkBitmap,
}
#[test]
fn bindgen_test_layout_SkColorTable() {
    const UNINIT: ::core::mem::MaybeUninit<SkColorTable> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkColorTable>(),
        72usize,
        concat!("Size of: ", stringify!(SkColorTable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorTable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkColorTable))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorTable),
            "::",
            stringify!(fTable)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorTable4MakeEPKhS1_S1_S1_"]
    pub fn SkColorTable_Make(
        tableA: *const u8,
        tableR: *const u8,
        tableG: *const u8,
        tableB: *const u8,
    ) -> sk_sp<SkColorTable>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorTable7flattenER13SkWriteBuffer"]
    pub fn SkColorTable_flatten(this: *const SkColorTable, buffer: *mut SkWriteBuffer);
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorTable11DeserializeER12SkReadBuffer"]
    pub fn SkColorTable_Deserialize(buffer: *mut SkReadBuffer) -> sk_sp<SkColorTable>;
}
impl SkColorTable {
    #[inline]
    pub unsafe fn Make(
        tableA: *const u8,
        tableR: *const u8,
        tableG: *const u8,
        tableB: *const u8,
    ) -> sk_sp<SkColorTable> {
        SkColorTable_Make(tableA, tableR, tableG, tableB)
    }
    #[inline]
    pub unsafe fn flatten(&self, buffer: *mut SkWriteBuffer) {
        SkColorTable_flatten(self, buffer)
    }
    #[inline]
    pub unsafe fn Deserialize(buffer: *mut SkReadBuffer) -> sk_sp<SkColorTable> {
        SkColorTable_Deserialize(buffer)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathFillType {
    Winding = 0,
    EvenOdd = 1,
    InverseWinding = 2,
    InverseEvenOdd = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathDirection {
    CW = 0,
    CCW = 1,
}
pub const SkPathSegmentMask_kLine_SkPathSegmentMask: SkPathSegmentMask = 1;
pub const SkPathSegmentMask_kQuad_SkPathSegmentMask: SkPathSegmentMask = 2;
pub const SkPathSegmentMask_kConic_SkPathSegmentMask: SkPathSegmentMask = 4;
pub const SkPathSegmentMask_kCubic_SkPathSegmentMask: SkPathSegmentMask = 8;
pub type SkPathSegmentMask = ::core::ffi::c_uint;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathVerb {
    Move = 0,
    Line = 1,
    Quad = 2,
    Conic = 3,
    Cubic = 4,
    Close = 5,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPath {
    pub fPathRef: sk_sp<SkPathRef>,
    pub fLastMoveToIndex: ::core::ffi::c_int,
    pub fConvexity: u8,
    pub fFirstDirection: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_ArcSize {
    Small = 0,
    Large = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_AddPathMode {
    Append = 0,
    Extend = 1,
}
pub const SkPath_SegmentMask_kLine_SegmentMask: SkPath_SegmentMask = 1;
pub const SkPath_SegmentMask_kQuad_SegmentMask: SkPath_SegmentMask = 2;
pub const SkPath_SegmentMask_kConic_SegmentMask: SkPath_SegmentMask = 4;
pub const SkPath_SegmentMask_kCubic_SegmentMask: SkPath_SegmentMask = 8;
pub type SkPath_SegmentMask = ::core::ffi::c_uint;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_Verb {
    Move = 0,
    Line = 1,
    Quad = 2,
    Conic = 3,
    Cubic = 4,
    Close = 5,
    Done = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPath_Iter {
    pub fPts: *const SkPoint,
    pub fVerbs: *const u8,
    pub fVerbStop: *const u8,
    pub fConicWeights: *const SkScalar,
    pub fMoveTo: SkPoint,
    pub fLastPt: SkPoint,
    pub fForceClose: bool,
    pub fNeedClose: bool,
    pub fCloseLine: bool,
}
#[test]
fn bindgen_test_layout_SkPath_Iter() {
    const UNINIT: ::core::mem::MaybeUninit<SkPath_Iter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPath_Iter>(),
        56usize,
        concat!("Size of: ", stringify!(SkPath_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath_Iter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fPts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVerbs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fVerbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVerbStop) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fVerbStop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fConicWeights) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fConicWeights)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMoveTo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fMoveTo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLastPt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fLastPt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fForceClose) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fForceClose)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fNeedClose) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fNeedClose)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCloseLine) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_Iter),
            "::",
            stringify!(fCloseLine)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4Iter7setPathERKS_b"]
    pub fn SkPath_Iter_setPath(this: *mut SkPath_Iter, path: *const SkPath, forceClose: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4Iter4nextEP7SkPoint"]
    pub fn SkPath_Iter_next(this: *mut SkPath_Iter, pts: *mut SkPoint) -> SkPath_Verb;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath4Iter15isClosedContourEv"]
    pub fn SkPath_Iter_isClosedContour(this: *const SkPath_Iter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4IterC1Ev"]
    pub fn SkPath_Iter_Iter(this: *mut SkPath_Iter);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4IterC1ERKS_b"]
    pub fn SkPath_Iter_Iter1(this: *mut SkPath_Iter, path: *const SkPath, forceClose: bool);
}
impl SkPath_Iter {
    #[inline]
    pub unsafe fn setPath(&mut self, path: *const SkPath, forceClose: bool) {
        SkPath_Iter_setPath(self, path, forceClose)
    }
    #[inline]
    pub unsafe fn next(&mut self, pts: *mut SkPoint) -> SkPath_Verb {
        SkPath_Iter_next(self, pts)
    }
    #[inline]
    pub unsafe fn isClosedContour(&self) -> bool {
        SkPath_Iter_isClosedContour(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_Iter_Iter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath, forceClose: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_Iter_Iter1(__bindgen_tmp.as_mut_ptr(), path, forceClose);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPath_RangeIter {
    pub fVerb: *const u8,
    pub fPoints: *const SkPoint,
    pub fWeights: *const SkScalar,
}
#[test]
fn bindgen_test_layout_SkPath_RangeIter() {
    const UNINIT: ::core::mem::MaybeUninit<SkPath_RangeIter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPath_RangeIter>(),
        24usize,
        concat!("Size of: ", stringify!(SkPath_RangeIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath_RangeIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath_RangeIter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVerb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RangeIter),
            "::",
            stringify!(fVerb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPoints) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RangeIter),
            "::",
            stringify!(fPoints)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWeights) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RangeIter),
            "::",
            stringify!(fWeights)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPath_RawIter {
    pub fIter: SkPath_RangeIter,
    pub fEnd: SkPath_RangeIter,
    pub fConicWeight: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPath_RawIter() {
    const UNINIT: ::core::mem::MaybeUninit<SkPath_RawIter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPath_RawIter>(),
        56usize,
        concat!("Size of: ", stringify!(SkPath_RawIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath_RawIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath_RawIter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RawIter),
            "::",
            stringify!(fIter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEnd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RawIter),
            "::",
            stringify!(fEnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fConicWeight) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath_RawIter),
            "::",
            stringify!(fConicWeight)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7RawIter7setPathERKS_"]
    pub fn SkPath_RawIter_setPath(this: *mut SkPath_RawIter, arg1: *const SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7RawIter4nextEP7SkPoint"]
    pub fn SkPath_RawIter_next(this: *mut SkPath_RawIter, arg1: *mut SkPoint) -> SkPath_Verb;
}
impl SkPath_RawIter {
    #[inline]
    pub unsafe fn setPath(&mut self, arg1: *const SkPath) {
        SkPath_RawIter_setPath(self, arg1)
    }
    #[inline]
    pub unsafe fn next(&mut self, arg1: *mut SkPoint) -> SkPath_Verb {
        SkPath_RawIter_next(self, arg1)
    }
}
pub type SkPath_sk_is_trivially_relocatable = std_true_type;
#[test]
fn bindgen_test_layout_SkPath() {
    const UNINIT: ::core::mem::MaybeUninit<SkPath> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPath>(),
        16usize,
        concat!("Size of: ", stringify!(SkPath))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPathRef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath),
            "::",
            stringify!(fPathRef)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLastMoveToIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath),
            "::",
            stringify!(fLastMoveToIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fConvexity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath),
            "::",
            stringify!(fConvexity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFirstDirection) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPath),
            "::",
            stringify!(fFirstDirection)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4MakeEPK7SkPointiPKhiPKfi14SkPathFillTypeb"]
    pub fn SkPath_Make(
        arg1: *const SkPoint,
        pointCount: ::core::ffi::c_int,
        arg2: *const u8,
        verbCount: ::core::ffi::c_int,
        arg3: *const SkScalar,
        conicWeightCount: ::core::ffi::c_int,
        arg4: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4RectERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_Rect(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4OvalERK6SkRect15SkPathDirection"]
    pub fn SkPath_Oval(arg1: *const SkRect, arg2: SkPathDirection) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4OvalERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_Oval1(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6CircleEfff15SkPathDirection"]
    pub fn SkPath_Circle(
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5RRectERK7SkRRect15SkPathDirection"]
    pub fn SkPath_RRect(arg1: *const SkRRect, dir: SkPathDirection) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5RRectERK7SkRRect15SkPathDirectionj"]
    pub fn SkPath_RRect1(
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5RRectERK6SkRectff15SkPathDirection"]
    pub fn SkPath_RRect2(
        bounds: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7PolygonEPK7SkPointib14SkPathFillTypeb"]
    pub fn SkPath_Polygon(
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
        isClosed: bool,
        arg1: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath16isInterpolatableERKS_"]
    pub fn SkPath_isInterpolatable(this: *const SkPath, compare: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath11interpolateERKS_fPS_"]
    pub fn SkPath_interpolate(
        this: *const SkPath,
        ending: *const SkPath,
        weight: SkScalar,
        out: *mut SkPath,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8isConvexEv"]
    pub fn SkPath_isConvex(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath6isOvalEP6SkRect"]
    pub fn SkPath_isOval(this: *const SkPath, bounds: *mut SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath7isRRectEP7SkRRect"]
    pub fn SkPath_isRRect(this: *const SkPath, rrect: *mut SkRRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5resetEv"]
    pub fn SkPath_reset(this: *mut SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6rewindEv"]
    pub fn SkPath_rewind(this: *mut SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath7isEmptyEv"]
    pub fn SkPath_isEmpty(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath19isLastContourClosedEv"]
    pub fn SkPath_isLastContourClosed(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8isFiniteEv"]
    pub fn SkPath_isFinite(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath16IsLineDegenerateERK7SkPointS2_b"]
    pub fn SkPath_IsLineDegenerate(p1: *const SkPoint, p2: *const SkPoint, exact: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath16IsQuadDegenerateERK7SkPointS2_S2_b"]
    pub fn SkPath_IsQuadDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        exact: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath17IsCubicDegenerateERK7SkPointS2_S2_S2_b"]
    pub fn SkPath_IsCubicDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        p4: *const SkPoint,
        exact: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath6isLineEP7SkPoint"]
    pub fn SkPath_isLine(this: *const SkPath, line: *mut SkPoint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath11countPointsEv"]
    pub fn SkPath_countPoints(this: *const SkPath) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8getPointEi"]
    pub fn SkPath_getPoint(this: *const SkPath, index: ::core::ffi::c_int) -> SkPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9getPointsEP7SkPointi"]
    pub fn SkPath_getPoints(
        this: *const SkPath,
        points: *mut SkPoint,
        max: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath10countVerbsEv"]
    pub fn SkPath_countVerbs(this: *const SkPath) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8getVerbsEPhi"]
    pub fn SkPath_getVerbs(
        this: *const SkPath,
        verbs: *mut u8,
        max: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath20approximateBytesUsedEv"]
    pub fn SkPath_approximateBytesUsed(this: *const SkPath) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4swapERS_"]
    pub fn SkPath_swap(this: *mut SkPath, other: *mut SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9getBoundsEv"]
    pub fn SkPath_getBounds(this: *const SkPath) -> *const SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath18computeTightBoundsEv"]
    pub fn SkPath_computeTightBounds(this: *const SkPath) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath26conservativelyContainsRectERK6SkRect"]
    pub fn SkPath_conservativelyContainsRect(this: *const SkPath, rect: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath10incReserveEi"]
    pub fn SkPath_incReserve(this: *mut SkPath, extraPtCount: ::core::ffi::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6moveToEff"]
    pub fn SkPath_moveTo(this: *mut SkPath, x: SkScalar, y: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7rMoveToEff"]
    pub fn SkPath_rMoveTo(this: *mut SkPath, dx: SkScalar, dy: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6lineToEff"]
    pub fn SkPath_lineTo(this: *mut SkPath, x: SkScalar, y: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7rLineToEff"]
    pub fn SkPath_rLineTo(this: *mut SkPath, dx: SkScalar, dy: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6quadToEffff"]
    pub fn SkPath_quadTo(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7rQuadToEffff"]
    pub fn SkPath_rQuadTo(
        this: *mut SkPath,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7conicToEfffff"]
    pub fn SkPath_conicTo(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath8rConicToEfffff"]
    pub fn SkPath_rConicTo(
        this: *mut SkPath,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7cubicToEffffff"]
    pub fn SkPath_cubicTo(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        x3: SkScalar,
        y3: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath8rCubicToEffffff"]
    pub fn SkPath_rCubicTo(
        this: *mut SkPath,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        dx3: SkScalar,
        dy3: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5arcToERK6SkRectffb"]
    pub fn SkPath_arcTo(
        this: *mut SkPath,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5arcToEfffff"]
    pub fn SkPath_arcTo1(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        radius: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5arcToEfffNS_7ArcSizeE15SkPathDirectionff"]
    pub fn SkPath_arcTo2(
        this: *mut SkPath,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        x: SkScalar,
        y: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6rArcToEfffNS_7ArcSizeE15SkPathDirectionff"]
    pub fn SkPath_rArcTo(
        this: *mut SkPath,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5closeEv"]
    pub fn SkPath_close(this: *mut SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath19ConvertConicToQuadsERK7SkPointS2_S2_fPS0_i"]
    pub fn SkPath_ConvertConicToQuads(
        p0: *const SkPoint,
        p1: *const SkPoint,
        p2: *const SkPoint,
        w: SkScalar,
        pts: *mut SkPoint,
        pow2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath6isRectEP6SkRectPbP15SkPathDirection"]
    pub fn SkPath_isRect(
        this: *const SkPath,
        rect: *mut SkRect,
        isClosed: *mut bool,
        direction: *mut SkPathDirection,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addRectERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_addRect(
        this: *mut SkPath,
        rect: *const SkRect,
        dir: SkPathDirection,
        start: ::core::ffi::c_uint,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addOvalERK6SkRect15SkPathDirection"]
    pub fn SkPath_addOval(
        this: *mut SkPath,
        oval: *const SkRect,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addOvalERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_addOval1(
        this: *mut SkPath,
        oval: *const SkRect,
        dir: SkPathDirection,
        start: ::core::ffi::c_uint,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath9addCircleEfff15SkPathDirection"]
    pub fn SkPath_addCircle(
        this: *mut SkPath,
        x: SkScalar,
        y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6addArcERK6SkRectff"]
    pub fn SkPath_addArc(
        this: *mut SkPath,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath12addRoundRectERK6SkRectff15SkPathDirection"]
    pub fn SkPath_addRoundRect(
        this: *mut SkPath,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath12addRoundRectERK6SkRectPKf15SkPathDirection"]
    pub fn SkPath_addRoundRect1(
        this: *mut SkPath,
        rect: *const SkRect,
        radii: *const SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath8addRRectERK7SkRRect15SkPathDirection"]
    pub fn SkPath_addRRect(
        this: *mut SkPath,
        rrect: *const SkRRect,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath8addRRectERK7SkRRect15SkPathDirectionj"]
    pub fn SkPath_addRRect1(
        this: *mut SkPath,
        rrect: *const SkRRect,
        dir: SkPathDirection,
        start: ::core::ffi::c_uint,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addPolyEPK7SkPointib"]
    pub fn SkPath_addPoly(
        this: *mut SkPath,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
        close: bool,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addPathERKS_ffNS_11AddPathModeE"]
    pub fn SkPath_addPath(
        this: *mut SkPath,
        src: *const SkPath,
        dx: SkScalar,
        dy: SkScalar,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addPathERKS_RK8SkMatrixNS_11AddPathModeE"]
    pub fn SkPath_addPath1(
        this: *mut SkPath,
        src: *const SkPath,
        matrix: *const SkMatrix,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath14reverseAddPathERKS_"]
    pub fn SkPath_reverseAddPath(this: *mut SkPath, src: *const SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath6offsetEffPS_"]
    pub fn SkPath_offset(this: *const SkPath, dx: SkScalar, dy: SkScalar, dst: *mut SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9transformERK8SkMatrixPS_22SkApplyPerspectiveClip"]
    pub fn SkPath_transform(
        this: *const SkPath,
        matrix: *const SkMatrix,
        dst: *mut SkPath,
        pc: SkApplyPerspectiveClip,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9getLastPtEP7SkPoint"]
    pub fn SkPath_getLastPt(this: *const SkPath, lastPt: *mut SkPoint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath9setLastPtEff"]
    pub fn SkPath_setLastPt(this: *mut SkPath, x: SkScalar, y: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath15getSegmentMasksEv"]
    pub fn SkPath_getSegmentMasks(this: *const SkPath) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8containsEff"]
    pub fn SkPath_contains(this: *const SkPath, x: SkScalar, y: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath4dumpEP9SkWStreamb"]
    pub fn SkPath_dump(this: *const SkPath, stream: *mut SkWStream, dumpAsHex: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath10dumpArraysEP9SkWStreamb"]
    pub fn SkPath_dumpArrays(this: *const SkPath, stream: *mut SkWStream, dumpAsHex: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath13writeToMemoryEPv"]
    pub fn SkPath_writeToMemory(this: *const SkPath, buffer: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9serializeEv"]
    pub fn SkPath_serialize(this: *const SkPath) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath14readFromMemoryEPKvm"]
    pub fn SkPath_readFromMemory(
        this: *mut SkPath,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath15getGenerationIDEv"]
    pub fn SkPath_getGenerationID(this: *const SkPath) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath7isValidEv"]
    pub fn SkPath_isValid(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPathC1Ev"]
    pub fn SkPath_SkPath(this: *mut SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPathC1ERKS_"]
    pub fn SkPath_SkPath1(this: *mut SkPath, path: *const SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPathD1Ev"]
    pub fn SkPath_SkPath_destructor(this: *mut SkPath);
}
impl SkPath {
    #[inline]
    pub fn fFillType(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fFillType(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fIsVolatile(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fIsVolatile(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fFillType: u8, fIsVolatile: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let fFillType: u8 = unsafe { ::core::mem::transmute(fFillType) };
            fFillType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fIsVolatile: u8 = unsafe { ::core::mem::transmute(fIsVolatile) };
            fIsVolatile as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn Make(
        arg1: *const SkPoint,
        pointCount: ::core::ffi::c_int,
        arg2: *const u8,
        verbCount: ::core::ffi::c_int,
        arg3: *const SkScalar,
        conicWeightCount: ::core::ffi::c_int,
        arg4: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath {
        SkPath_Make(
            arg1,
            pointCount,
            arg2,
            verbCount,
            arg3,
            conicWeightCount,
            arg4,
            isVolatile,
        )
    }
    #[inline]
    pub unsafe fn Rect(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> SkPath {
        SkPath_Rect(arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn Oval(arg1: *const SkRect, arg2: SkPathDirection) -> SkPath {
        SkPath_Oval(arg1, arg2)
    }
    #[inline]
    pub unsafe fn Oval1(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> SkPath {
        SkPath_Oval1(arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn Circle(
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath {
        SkPath_Circle(center_x, center_y, radius, dir)
    }
    #[inline]
    pub unsafe fn RRect(arg1: *const SkRRect, dir: SkPathDirection) -> SkPath {
        SkPath_RRect(arg1, dir)
    }
    #[inline]
    pub unsafe fn RRect1(
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> SkPath {
        SkPath_RRect1(arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn RRect2(
        bounds: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath {
        SkPath_RRect2(bounds, rx, ry, dir)
    }
    #[inline]
    pub unsafe fn Polygon(
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
        isClosed: bool,
        arg1: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath {
        SkPath_Polygon(pts, count, isClosed, arg1, isVolatile)
    }
    #[inline]
    pub unsafe fn isInterpolatable(&self, compare: *const SkPath) -> bool {
        SkPath_isInterpolatable(self, compare)
    }
    #[inline]
    pub unsafe fn interpolate(
        &self,
        ending: *const SkPath,
        weight: SkScalar,
        out: *mut SkPath,
    ) -> bool {
        SkPath_interpolate(self, ending, weight, out)
    }
    #[inline]
    pub unsafe fn isConvex(&self) -> bool {
        SkPath_isConvex(self)
    }
    #[inline]
    pub unsafe fn isOval(&self, bounds: *mut SkRect) -> bool {
        SkPath_isOval(self, bounds)
    }
    #[inline]
    pub unsafe fn isRRect(&self, rrect: *mut SkRRect) -> bool {
        SkPath_isRRect(self, rrect)
    }
    #[inline]
    pub unsafe fn reset(&mut self) -> *mut SkPath {
        SkPath_reset(self)
    }
    #[inline]
    pub unsafe fn rewind(&mut self) -> *mut SkPath {
        SkPath_rewind(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        SkPath_isEmpty(self)
    }
    #[inline]
    pub unsafe fn isLastContourClosed(&self) -> bool {
        SkPath_isLastContourClosed(self)
    }
    #[inline]
    pub unsafe fn isFinite(&self) -> bool {
        SkPath_isFinite(self)
    }
    #[inline]
    pub unsafe fn IsLineDegenerate(p1: *const SkPoint, p2: *const SkPoint, exact: bool) -> bool {
        SkPath_IsLineDegenerate(p1, p2, exact)
    }
    #[inline]
    pub unsafe fn IsQuadDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        exact: bool,
    ) -> bool {
        SkPath_IsQuadDegenerate(p1, p2, p3, exact)
    }
    #[inline]
    pub unsafe fn IsCubicDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        p4: *const SkPoint,
        exact: bool,
    ) -> bool {
        SkPath_IsCubicDegenerate(p1, p2, p3, p4, exact)
    }
    #[inline]
    pub unsafe fn isLine(&self, line: *mut SkPoint) -> bool {
        SkPath_isLine(self, line)
    }
    #[inline]
    pub unsafe fn countPoints(&self) -> ::core::ffi::c_int {
        SkPath_countPoints(self)
    }
    #[inline]
    pub unsafe fn getPoint(&self, index: ::core::ffi::c_int) -> SkPoint {
        SkPath_getPoint(self, index)
    }
    #[inline]
    pub unsafe fn getPoints(
        &self,
        points: *mut SkPoint,
        max: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        SkPath_getPoints(self, points, max)
    }
    #[inline]
    pub unsafe fn countVerbs(&self) -> ::core::ffi::c_int {
        SkPath_countVerbs(self)
    }
    #[inline]
    pub unsafe fn getVerbs(&self, verbs: *mut u8, max: ::core::ffi::c_int) -> ::core::ffi::c_int {
        SkPath_getVerbs(self, verbs, max)
    }
    #[inline]
    pub unsafe fn approximateBytesUsed(&self) -> usize {
        SkPath_approximateBytesUsed(self)
    }
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkPath) {
        SkPath_swap(self, other)
    }
    #[inline]
    pub unsafe fn getBounds(&self) -> *const SkRect {
        SkPath_getBounds(self)
    }
    #[inline]
    pub unsafe fn computeTightBounds(&self) -> SkRect {
        SkPath_computeTightBounds(self)
    }
    #[inline]
    pub unsafe fn conservativelyContainsRect(&self, rect: *const SkRect) -> bool {
        SkPath_conservativelyContainsRect(self, rect)
    }
    #[inline]
    pub unsafe fn incReserve(&mut self, extraPtCount: ::core::ffi::c_int) {
        SkPath_incReserve(self, extraPtCount)
    }
    #[inline]
    pub unsafe fn moveTo(&mut self, x: SkScalar, y: SkScalar) -> *mut SkPath {
        SkPath_moveTo(self, x, y)
    }
    #[inline]
    pub unsafe fn rMoveTo(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkPath {
        SkPath_rMoveTo(self, dx, dy)
    }
    #[inline]
    pub unsafe fn lineTo(&mut self, x: SkScalar, y: SkScalar) -> *mut SkPath {
        SkPath_lineTo(self, x, y)
    }
    #[inline]
    pub unsafe fn rLineTo(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkPath {
        SkPath_rLineTo(self, dx, dy)
    }
    #[inline]
    pub unsafe fn quadTo(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
    ) -> *mut SkPath {
        SkPath_quadTo(self, x1, y1, x2, y2)
    }
    #[inline]
    pub unsafe fn rQuadTo(
        &mut self,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
    ) -> *mut SkPath {
        SkPath_rQuadTo(self, dx1, dy1, dx2, dy2)
    }
    #[inline]
    pub unsafe fn conicTo(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath {
        SkPath_conicTo(self, x1, y1, x2, y2, w)
    }
    #[inline]
    pub unsafe fn rConicTo(
        &mut self,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath {
        SkPath_rConicTo(self, dx1, dy1, dx2, dy2, w)
    }
    #[inline]
    pub unsafe fn cubicTo(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        x3: SkScalar,
        y3: SkScalar,
    ) -> *mut SkPath {
        SkPath_cubicTo(self, x1, y1, x2, y2, x3, y3)
    }
    #[inline]
    pub unsafe fn rCubicTo(
        &mut self,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        dx3: SkScalar,
        dy3: SkScalar,
    ) -> *mut SkPath {
        SkPath_rCubicTo(self, dx1, dy1, dx2, dy2, dx3, dy3)
    }
    #[inline]
    pub unsafe fn arcTo(
        &mut self,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPath {
        SkPath_arcTo(self, oval, startAngle, sweepAngle, forceMoveTo)
    }
    #[inline]
    pub unsafe fn arcTo1(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        radius: SkScalar,
    ) -> *mut SkPath {
        SkPath_arcTo1(self, x1, y1, x2, y2, radius)
    }
    #[inline]
    pub unsafe fn arcTo2(
        &mut self,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        x: SkScalar,
        y: SkScalar,
    ) -> *mut SkPath {
        SkPath_arcTo2(self, rx, ry, xAxisRotate, largeArc, sweep, x, y)
    }
    #[inline]
    pub unsafe fn rArcTo(
        &mut self,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkPath {
        SkPath_rArcTo(self, rx, ry, xAxisRotate, largeArc, sweep, dx, dy)
    }
    #[inline]
    pub unsafe fn close(&mut self) -> *mut SkPath {
        SkPath_close(self)
    }
    #[inline]
    pub unsafe fn ConvertConicToQuads(
        p0: *const SkPoint,
        p1: *const SkPoint,
        p2: *const SkPoint,
        w: SkScalar,
        pts: *mut SkPoint,
        pow2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        SkPath_ConvertConicToQuads(p0, p1, p2, w, pts, pow2)
    }
    #[inline]
    pub unsafe fn isRect(
        &self,
        rect: *mut SkRect,
        isClosed: *mut bool,
        direction: *mut SkPathDirection,
    ) -> bool {
        SkPath_isRect(self, rect, isClosed, direction)
    }
    #[inline]
    pub unsafe fn addRect(
        &mut self,
        rect: *const SkRect,
        dir: SkPathDirection,
        start: ::core::ffi::c_uint,
    ) -> *mut SkPath {
        SkPath_addRect(self, rect, dir, start)
    }
    #[inline]
    pub unsafe fn addOval(&mut self, oval: *const SkRect, dir: SkPathDirection) -> *mut SkPath {
        SkPath_addOval(self, oval, dir)
    }
    #[inline]
    pub unsafe fn addOval1(
        &mut self,
        oval: *const SkRect,
        dir: SkPathDirection,
        start: ::core::ffi::c_uint,
    ) -> *mut SkPath {
        SkPath_addOval1(self, oval, dir, start)
    }
    #[inline]
    pub unsafe fn addCircle(
        &mut self,
        x: SkScalar,
        y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath {
        SkPath_addCircle(self, x, y, radius, dir)
    }
    #[inline]
    pub unsafe fn addArc(
        &mut self,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
    ) -> *mut SkPath {
        SkPath_addArc(self, oval, startAngle, sweepAngle)
    }
    #[inline]
    pub unsafe fn addRoundRect(
        &mut self,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath {
        SkPath_addRoundRect(self, rect, rx, ry, dir)
    }
    #[inline]
    pub unsafe fn addRoundRect1(
        &mut self,
        rect: *const SkRect,
        radii: *const SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath {
        SkPath_addRoundRect1(self, rect, radii, dir)
    }
    #[inline]
    pub unsafe fn addRRect(&mut self, rrect: *const SkRRect, dir: SkPathDirection) -> *mut SkPath {
        SkPath_addRRect(self, rrect, dir)
    }
    #[inline]
    pub unsafe fn addRRect1(
        &mut self,
        rrect: *const SkRRect,
        dir: SkPathDirection,
        start: ::core::ffi::c_uint,
    ) -> *mut SkPath {
        SkPath_addRRect1(self, rrect, dir, start)
    }
    #[inline]
    pub unsafe fn addPoly(
        &mut self,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
        close: bool,
    ) -> *mut SkPath {
        SkPath_addPoly(self, pts, count, close)
    }
    #[inline]
    pub unsafe fn addPath(
        &mut self,
        src: *const SkPath,
        dx: SkScalar,
        dy: SkScalar,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath {
        SkPath_addPath(self, src, dx, dy, mode)
    }
    #[inline]
    pub unsafe fn addPath1(
        &mut self,
        src: *const SkPath,
        matrix: *const SkMatrix,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath {
        SkPath_addPath1(self, src, matrix, mode)
    }
    #[inline]
    pub unsafe fn reverseAddPath(&mut self, src: *const SkPath) -> *mut SkPath {
        SkPath_reverseAddPath(self, src)
    }
    #[inline]
    pub unsafe fn offset(&self, dx: SkScalar, dy: SkScalar, dst: *mut SkPath) {
        SkPath_offset(self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn transform(
        &self,
        matrix: *const SkMatrix,
        dst: *mut SkPath,
        pc: SkApplyPerspectiveClip,
    ) {
        SkPath_transform(self, matrix, dst, pc)
    }
    #[inline]
    pub unsafe fn getLastPt(&self, lastPt: *mut SkPoint) -> bool {
        SkPath_getLastPt(self, lastPt)
    }
    #[inline]
    pub unsafe fn setLastPt(&mut self, x: SkScalar, y: SkScalar) {
        SkPath_setLastPt(self, x, y)
    }
    #[inline]
    pub unsafe fn getSegmentMasks(&self) -> u32 {
        SkPath_getSegmentMasks(self)
    }
    #[inline]
    pub unsafe fn contains(&self, x: SkScalar, y: SkScalar) -> bool {
        SkPath_contains(self, x, y)
    }
    #[inline]
    pub unsafe fn dump(&self, stream: *mut SkWStream, dumpAsHex: bool) {
        SkPath_dump(self, stream, dumpAsHex)
    }
    #[inline]
    pub unsafe fn dumpArrays(&self, stream: *mut SkWStream, dumpAsHex: bool) {
        SkPath_dumpArrays(self, stream, dumpAsHex)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::core::ffi::c_void) -> usize {
        SkPath_writeToMemory(self, buffer)
    }
    #[inline]
    pub unsafe fn serialize(&self) -> sk_sp<SkData> {
        SkPath_serialize(self)
    }
    #[inline]
    pub unsafe fn readFromMemory(
        &mut self,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize {
        SkPath_readFromMemory(self, buffer, length)
    }
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkPath_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        SkPath_isValid(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_SkPath(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_SkPath1(__bindgen_tmp.as_mut_ptr(), path);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPath_SkPath_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTDStorage {
    pub fSizeOfT: ::core::ffi::c_int,
    pub fStorage: *mut std_byte,
    pub fCapacity: ::core::ffi::c_int,
    pub fSize: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_SkTDStorage() {
    const UNINIT: ::core::mem::MaybeUninit<SkTDStorage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTDStorage>(),
        24usize,
        concat!("Size of: ", stringify!(SkTDStorage))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTDStorage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSizeOfT) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTDStorage),
            "::",
            stringify!(fSizeOfT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStorage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTDStorage),
            "::",
            stringify!(fStorage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCapacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTDStorage),
            "::",
            stringify!(fCapacity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTDStorage),
            "::",
            stringify!(fSize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage5resetEv"]
    pub fn SkTDStorage_reset(this: *mut SkTDStorage);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage4swapERS_"]
    pub fn SkTDStorage_swap(this: *mut SkTDStorage, that: *mut SkTDStorage);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage6resizeEi"]
    pub fn SkTDStorage_resize(this: *mut SkTDStorage, newSize: ::core::ffi::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage7reserveEi"]
    pub fn SkTDStorage_reserve(this: *mut SkTDStorage, newCapacity: ::core::ffi::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage13shrink_to_fitEv"]
    pub fn SkTDStorage_shrink_to_fit(this: *mut SkTDStorage);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage5eraseEii"]
    pub fn SkTDStorage_erase(
        this: *mut SkTDStorage,
        index: ::core::ffi::c_int,
        count: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage13removeShuffleEi"]
    pub fn SkTDStorage_removeShuffle(this: *mut SkTDStorage, index: ::core::ffi::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage7prependEv"]
    pub fn SkTDStorage_prepend(this: *mut SkTDStorage) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage6appendEv"]
    pub fn SkTDStorage_append(this: *mut SkTDStorage);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage6appendEi"]
    pub fn SkTDStorage_append1(this: *mut SkTDStorage, count: ::core::ffi::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage6appendEPKvi"]
    pub fn SkTDStorage_append2(
        this: *mut SkTDStorage,
        src: *const ::core::ffi::c_void,
        count: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage6insertEi"]
    pub fn SkTDStorage_insert(
        this: *mut SkTDStorage,
        index: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorage6insertEiiPKv"]
    pub fn SkTDStorage_insert1(
        this: *mut SkTDStorage,
        index: ::core::ffi::c_int,
        count: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorageC1Ei"]
    pub fn SkTDStorage_SkTDStorage(this: *mut SkTDStorage, sizeOfT: ::core::ffi::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorageC1EPKvii"]
    pub fn SkTDStorage_SkTDStorage1(
        this: *mut SkTDStorage,
        src: *const ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        sizeOfT: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorageC1ERKS_"]
    pub fn SkTDStorage_SkTDStorage2(this: *mut SkTDStorage, that: *const SkTDStorage);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorageC1EOS_"]
    pub fn SkTDStorage_SkTDStorage3(this: *mut SkTDStorage, that: *mut SkTDStorage);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTDStorageD1Ev"]
    pub fn SkTDStorage_SkTDStorage_destructor(this: *mut SkTDStorage);
}
impl SkTDStorage {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkTDStorage_reset(self)
    }
    #[inline]
    pub unsafe fn swap(&mut self, that: *mut SkTDStorage) {
        SkTDStorage_swap(self, that)
    }
    #[inline]
    pub unsafe fn resize(&mut self, newSize: ::core::ffi::c_int) {
        SkTDStorage_resize(self, newSize)
    }
    #[inline]
    pub unsafe fn reserve(&mut self, newCapacity: ::core::ffi::c_int) {
        SkTDStorage_reserve(self, newCapacity)
    }
    #[inline]
    pub unsafe fn shrink_to_fit(&mut self) {
        SkTDStorage_shrink_to_fit(self)
    }
    #[inline]
    pub unsafe fn erase(&mut self, index: ::core::ffi::c_int, count: ::core::ffi::c_int) {
        SkTDStorage_erase(self, index, count)
    }
    #[inline]
    pub unsafe fn removeShuffle(&mut self, index: ::core::ffi::c_int) {
        SkTDStorage_removeShuffle(self, index)
    }
    #[inline]
    pub unsafe fn prepend(&mut self) -> *mut ::core::ffi::c_void {
        SkTDStorage_prepend(self)
    }
    #[inline]
    pub unsafe fn append(&mut self) {
        SkTDStorage_append(self)
    }
    #[inline]
    pub unsafe fn append1(&mut self, count: ::core::ffi::c_int) {
        SkTDStorage_append1(self, count)
    }
    #[inline]
    pub unsafe fn append2(
        &mut self,
        src: *const ::core::ffi::c_void,
        count: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void {
        SkTDStorage_append2(self, src, count)
    }
    #[inline]
    pub unsafe fn insert(&mut self, index: ::core::ffi::c_int) -> *mut ::core::ffi::c_void {
        SkTDStorage_insert(self, index)
    }
    #[inline]
    pub unsafe fn insert1(
        &mut self,
        index: ::core::ffi::c_int,
        count: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void {
        SkTDStorage_insert1(self, index, count, src)
    }
    #[inline]
    pub unsafe fn new(sizeOfT: ::core::ffi::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTDStorage_SkTDStorage(__bindgen_tmp.as_mut_ptr(), sizeOfT);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        src: *const ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        sizeOfT: ::core::ffi::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTDStorage_SkTDStorage1(__bindgen_tmp.as_mut_ptr(), src, size, sizeOfT);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(that: *const SkTDStorage) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTDStorage_SkTDStorage2(__bindgen_tmp.as_mut_ptr(), that);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(that: *mut SkTDStorage) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTDStorage_SkTDStorage3(__bindgen_tmp.as_mut_ptr(), that);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkTDStorage_SkTDStorage_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTDArray {
    pub fStorage: SkTDStorage,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkContourMeasure {
    pub _bindgen_opaque_blob: [u64; 9usize],
}
pub const SkContourMeasure_MatrixFlags_kGetPosition_MatrixFlag: SkContourMeasure_MatrixFlags = 1;
pub const SkContourMeasure_MatrixFlags_kGetTangent_MatrixFlag: SkContourMeasure_MatrixFlags = 2;
pub const SkContourMeasure_MatrixFlags_kGetPosAndTan_MatrixFlag: SkContourMeasure_MatrixFlags = 3;
pub type SkContourMeasure_MatrixFlags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkContourMeasure_Segment {
    pub fDistance: SkScalar,
    pub fPtIndex: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SkContourMeasure_Segment() {
    const UNINIT: ::core::mem::MaybeUninit<SkContourMeasure_Segment> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkContourMeasure_Segment>(),
        12usize,
        concat!("Size of: ", stringify!(SkContourMeasure_Segment))
    );
    assert_eq!(
        ::core::mem::align_of::<SkContourMeasure_Segment>(),
        4usize,
        concat!("Alignment of ", stringify!(SkContourMeasure_Segment))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDistance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkContourMeasure_Segment),
            "::",
            stringify!(fDistance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPtIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkContourMeasure_Segment),
            "::",
            stringify!(fPtIndex)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkContourMeasure7Segment10getScalarTEv"]
    pub fn SkContourMeasure_Segment_getScalarT(this: *const SkContourMeasure_Segment) -> SkScalar;
}
impl SkContourMeasure_Segment {
    #[inline]
    pub fn fTValue(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_fTValue(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn fType(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fType(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fTValue: ::core::ffi::c_uint,
        fType: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let fTValue: u32 = unsafe { ::core::mem::transmute(fTValue) };
            fTValue as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let fType: u32 = unsafe { ::core::mem::transmute(fType) };
            fType as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getScalarT(&self) -> SkScalar {
        SkContourMeasure_Segment_getScalarT(self)
    }
}
#[test]
fn bindgen_test_layout_SkContourMeasure() {
    assert_eq!(
        ::core::mem::size_of::<SkContourMeasure>(),
        72usize,
        concat!("Size of: ", stringify!(SkContourMeasure))
    );
    assert_eq!(
        ::core::mem::align_of::<SkContourMeasure>(),
        8usize,
        concat!("Alignment of ", stringify!(SkContourMeasure))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkContourMeasure9getPosTanEfP7SkPointS1_"]
    pub fn SkContourMeasure_getPosTan(
        this: *const SkContourMeasure,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkContourMeasure9getMatrixEfP8SkMatrixNS_11MatrixFlagsE"]
    pub fn SkContourMeasure_getMatrix(
        this: *const SkContourMeasure,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkContourMeasure_MatrixFlags,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkContourMeasure10getSegmentEffP6SkPathb"]
    pub fn SkContourMeasure_getSegment(
        this: *const SkContourMeasure,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool;
}
impl SkContourMeasure {
    #[inline]
    pub unsafe fn getPosTan(
        &self,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool {
        SkContourMeasure_getPosTan(self, distance, position, tangent)
    }
    #[inline]
    pub unsafe fn getMatrix(
        &self,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkContourMeasure_MatrixFlags,
    ) -> bool {
        SkContourMeasure_getMatrix(self, distance, matrix, flags)
    }
    #[inline]
    pub unsafe fn getSegment(
        &self,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool {
        SkContourMeasure_getSegment(self, startD, stopD, dst, startWithMoveTo)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkContourMeasureIter {
    pub fImpl: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkContourMeasureIter_Impl {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_SkContourMeasureIter() {
    const UNINIT: ::core::mem::MaybeUninit<SkContourMeasureIter> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkContourMeasureIter>(),
        8usize,
        concat!("Size of: ", stringify!(SkContourMeasureIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkContourMeasureIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkContourMeasureIter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fImpl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkContourMeasureIter),
            "::",
            stringify!(fImpl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIter5resetERK6SkPathbf"]
    pub fn SkContourMeasureIter_reset(
        this: *mut SkContourMeasureIter,
        path: *const SkPath,
        forceClosed: bool,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIter4nextEv"]
    pub fn SkContourMeasureIter_next(this: *mut SkContourMeasureIter) -> sk_sp<SkContourMeasure>;
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIterC1Ev"]
    pub fn SkContourMeasureIter_SkContourMeasureIter(this: *mut SkContourMeasureIter);
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIterC1ERK6SkPathbf"]
    pub fn SkContourMeasureIter_SkContourMeasureIter1(
        this: *mut SkContourMeasureIter,
        path: *const SkPath,
        forceClosed: bool,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIterC1EOS_"]
    pub fn SkContourMeasureIter_SkContourMeasureIter2(
        this: *mut SkContourMeasureIter,
        arg1: *mut SkContourMeasureIter,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIterD1Ev"]
    pub fn SkContourMeasureIter_SkContourMeasureIter_destructor(this: *mut SkContourMeasureIter);
}
impl SkContourMeasureIter {
    #[inline]
    pub unsafe fn reset(&mut self, path: *const SkPath, forceClosed: bool, resScale: SkScalar) {
        SkContourMeasureIter_reset(self, path, forceClosed, resScale)
    }
    #[inline]
    pub unsafe fn next(&mut self) -> sk_sp<SkContourMeasure> {
        SkContourMeasureIter_next(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkContourMeasureIter_SkContourMeasureIter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath, forceClosed: bool, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkContourMeasureIter_SkContourMeasureIter1(
            __bindgen_tmp.as_mut_ptr(),
            path,
            forceClosed,
            resScale,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut SkContourMeasureIter) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkContourMeasureIter_SkContourMeasureIter2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkContourMeasureIter_SkContourMeasureIter_destructor(self)
    }
}
impl SkCoverageMode {
    pub const Last: SkCoverageMode = SkCoverageMode::Xor;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCoverageMode {
    Union = 0,
    Intersect = 1,
    Difference = 2,
    ReverseDifference = 3,
    Xor = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCubicMap {
    pub fCoeff: [SkPoint; 3usize],
    pub fType: SkCubicMap_Type,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCubicMap_Type {
    Line = 0,
    CubeRoot = 1,
    Solver = 2,
}
#[test]
fn bindgen_test_layout_SkCubicMap() {
    const UNINIT: ::core::mem::MaybeUninit<SkCubicMap> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCubicMap>(),
        28usize,
        concat!("Size of: ", stringify!(SkCubicMap))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCubicMap>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCubicMap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCoeff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCubicMap),
            "::",
            stringify!(fCoeff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCubicMap),
            "::",
            stringify!(fType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkCubicMap13computeYFromXEf"]
    pub fn SkCubicMap_computeYFromX(this: *const SkCubicMap, x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkCubicMap12computeFromTEf"]
    pub fn SkCubicMap_computeFromT(this: *const SkCubicMap, t: f32) -> SkPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkCubicMapC1E7SkPointS0_"]
    pub fn SkCubicMap_SkCubicMap(this: *mut SkCubicMap, p1: SkPoint, p2: SkPoint);
}
impl SkCubicMap {
    #[inline]
    pub unsafe fn computeYFromX(&self, x: f32) -> f32 {
        SkCubicMap_computeYFromX(self, x)
    }
    #[inline]
    pub unsafe fn computeFromT(&self, t: f32) -> SkPoint {
        SkCubicMap_computeFromT(self, t)
    }
    #[inline]
    pub unsafe fn new(p1: SkPoint, p2: SkPoint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCubicMap_SkCubicMap(__bindgen_tmp.as_mut_ptr(), p1, p2);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDataTable {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
pub type SkDataTable_FreeProc =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDataTable_Dir {
    pub fPtr: *const ::core::ffi::c_void,
    pub fSize: usize,
}
#[test]
fn bindgen_test_layout_SkDataTable_Dir() {
    const UNINIT: ::core::mem::MaybeUninit<SkDataTable_Dir> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkDataTable_Dir>(),
        16usize,
        concat!("Size of: ", stringify!(SkDataTable_Dir))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDataTable_Dir>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDataTable_Dir))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDataTable_Dir),
            "::",
            stringify!(fPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDataTable_Dir),
            "::",
            stringify!(fSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SkDataTable__bindgen_ty_1 {
    pub fDir: *const SkDataTable_Dir,
    pub fElems: *const ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_SkDataTable__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SkDataTable__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkDataTable__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(SkDataTable__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDataTable__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDataTable__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDataTable__bindgen_ty_1),
            "::",
            stringify!(fDir)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fElems) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDataTable__bindgen_ty_1),
            "::",
            stringify!(fElems)
        )
    );
}
pub type SkDataTable_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkDataTable() {
    assert_eq!(
        ::core::mem::size_of::<SkDataTable>(),
        48usize,
        concat!("Size of: ", stringify!(SkDataTable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDataTable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDataTable))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkDataTable6atSizeEi"]
    pub fn SkDataTable_atSize(this: *const SkDataTable, index: ::core::ffi::c_int) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkDataTable2atEiPm"]
    pub fn SkDataTable_at(
        this: *const SkDataTable,
        index: ::core::ffi::c_int,
        size: *mut usize,
    ) -> *const ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkDataTable9MakeEmptyEv"]
    pub fn SkDataTable_MakeEmpty() -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkDataTable14MakeCopyArraysEPKPKvPKmi"]
    pub fn SkDataTable_MakeCopyArrays(
        ptrs: *const *const ::core::ffi::c_void,
        sizes: *const usize,
        count: ::core::ffi::c_int,
    ) -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkDataTable13MakeCopyArrayEPKvmi"]
    pub fn SkDataTable_MakeCopyArray(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::core::ffi::c_int,
    ) -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkDataTable13MakeArrayProcEPKvmiPFvPvES2_"]
    pub fn SkDataTable_MakeArrayProc(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::core::ffi::c_int,
        proc_: SkDataTable_FreeProc,
        context: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkDataTable>;
}
impl SkDataTable {
    #[inline]
    pub unsafe fn atSize(&self, index: ::core::ffi::c_int) -> usize {
        SkDataTable_atSize(self, index)
    }
    #[inline]
    pub unsafe fn at(
        &self,
        index: ::core::ffi::c_int,
        size: *mut usize,
    ) -> *const ::core::ffi::c_void {
        SkDataTable_at(self, index, size)
    }
    #[inline]
    pub unsafe fn MakeEmpty() -> sk_sp<SkDataTable> {
        SkDataTable_MakeEmpty()
    }
    #[inline]
    pub unsafe fn MakeCopyArrays(
        ptrs: *const *const ::core::ffi::c_void,
        sizes: *const usize,
        count: ::core::ffi::c_int,
    ) -> sk_sp<SkDataTable> {
        SkDataTable_MakeCopyArrays(ptrs, sizes, count)
    }
    #[inline]
    pub unsafe fn MakeCopyArray(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::core::ffi::c_int,
    ) -> sk_sp<SkDataTable> {
        SkDataTable_MakeCopyArray(array, elemSize, count)
    }
    #[inline]
    pub unsafe fn MakeArrayProc(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::core::ffi::c_int,
        proc_: SkDataTable_FreeProc,
        context: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkDataTable> {
        SkDataTable_MakeArrayProc(array, elemSize, count, proc_, context)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawable {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawable_GpuDrawHandler {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkDrawable_GpuDrawHandler() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawable_GpuDrawHandler>(),
        8usize,
        concat!("Size of: ", stringify!(SkDrawable_GpuDrawHandler))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawable_GpuDrawHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDrawable_GpuDrawHandler))
    );
}
#[test]
fn bindgen_test_layout_SkDrawable() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawable>(),
        16usize,
        concat!("Size of: ", stringify!(SkDrawable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDrawable))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable4drawEP8SkCanvasPK8SkMatrix"]
    pub fn SkDrawable_draw(this: *mut SkDrawable, arg1: *mut SkCanvas, arg2: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable4drawEP8SkCanvasff"]
    pub fn SkDrawable_draw1(this: *mut SkDrawable, arg1: *mut SkCanvas, x: SkScalar, y: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable19makePictureSnapshotEv"]
    pub fn SkDrawable_makePictureSnapshot(this: *mut SkDrawable) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable15getGenerationIDEv"]
    pub fn SkDrawable_getGenerationID(this: *mut SkDrawable) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable9getBoundsEv"]
    pub fn SkDrawable_getBounds(this: *mut SkDrawable) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable20approximateBytesUsedEv"]
    pub fn SkDrawable_approximateBytesUsed(this: *mut SkDrawable) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable20notifyDrawingChangedEv"]
    pub fn SkDrawable_notifyDrawingChanged(this: *mut SkDrawable);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawableC2Ev"]
    pub fn SkDrawable_SkDrawable(this: *mut SkDrawable);
}
impl SkDrawable {
    #[inline]
    pub unsafe fn draw(&mut self, arg1: *mut SkCanvas, arg2: *const SkMatrix) {
        SkDrawable_draw(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn draw1(&mut self, arg1: *mut SkCanvas, x: SkScalar, y: SkScalar) {
        SkDrawable_draw1(self, arg1, x, y)
    }
    #[inline]
    pub unsafe fn makePictureSnapshot(&mut self) -> sk_sp<SkPicture> {
        SkDrawable_makePictureSnapshot(self)
    }
    #[inline]
    pub unsafe fn getGenerationID(&mut self) -> u32 {
        SkDrawable_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn getBounds(&mut self) -> SkRect {
        SkDrawable_getBounds(self)
    }
    #[inline]
    pub unsafe fn approximateBytesUsed(&mut self) -> usize {
        SkDrawable_approximateBytesUsed(self)
    }
    #[inline]
    pub unsafe fn notifyDrawingChanged(&mut self) {
        SkDrawable_notifyDrawingChanged(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDrawable_SkDrawable(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable22onApproximateBytesUsedEv"]
    pub fn SkDrawable_onApproximateBytesUsed(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable21onMakePictureSnapshotEv"]
    pub fn SkDrawable_onMakePictureSnapshot(this: *mut ::core::ffi::c_void) -> sk_sp<SkPicture>;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDocument {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkDocument_State {
    kBetweenPages_State = 0,
    kInPage_State = 1,
    kClosed_State = 2,
}
pub type SkDocument_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkDocument() {
    assert_eq!(
        ::core::mem::size_of::<SkDocument>(),
        32usize,
        concat!("Size of: ", stringify!(SkDocument))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDocument>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDocument))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocument9beginPageEffPK6SkRect"]
    pub fn SkDocument_beginPage(
        this: *mut SkDocument,
        width: SkScalar,
        height: SkScalar,
        content: *const SkRect,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocument7endPageEv"]
    pub fn SkDocument_endPage(this: *mut SkDocument);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocument5closeEv"]
    pub fn SkDocument_close(this: *mut SkDocument);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocument5abortEv"]
    pub fn SkDocument_abort(this: *mut SkDocument);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocumentC2EP9SkWStream"]
    pub fn SkDocument_SkDocument(this: *mut SkDocument, arg1: *mut SkWStream);
}
impl SkDocument {
    #[inline]
    pub unsafe fn beginPage(
        &mut self,
        width: SkScalar,
        height: SkScalar,
        content: *const SkRect,
    ) -> *mut SkCanvas {
        SkDocument_beginPage(self, width, height, content)
    }
    #[inline]
    pub unsafe fn endPage(&mut self) {
        SkDocument_endPage(self)
    }
    #[inline]
    pub unsafe fn close(&mut self) {
        SkDocument_close(self)
    }
    #[inline]
    pub unsafe fn abort(&mut self) {
        SkDocument_abort(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut SkWStream) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDocument_SkDocument(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocumentD1Ev"]
    pub fn SkDocument_SkDocument_destructor(this: *mut SkDocument);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedImageFormat {
    BMP = 0,
    GIF = 1,
    ICO = 2,
    JPEG = 3,
    PNG = 4,
    WBMP = 5,
    WEBP = 6,
    PKM = 7,
    KTX = 8,
    ASTC = 9,
    DNG = 10,
    HEIF = 11,
    AVIF = 12,
    JPEGXL = 13,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments {
    pub fCollectionIndex: ::core::ffi::c_int,
    pub fVariationDesignPosition: SkFontArguments_VariationPosition,
    pub fPalette: SkFontArguments_Palette,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_VariationPosition {
    pub coordinates: *const SkFontArguments_VariationPosition_Coordinate,
    pub coordinateCount: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_VariationPosition_Coordinate {
    pub axis: SkFourByteTag,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_SkFontArguments_VariationPosition_Coordinate() {
    const UNINIT: ::core::mem::MaybeUninit<SkFontArguments_VariationPosition_Coordinate> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_VariationPosition_Coordinate>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SkFontArguments_VariationPosition_Coordinate)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_VariationPosition_Coordinate>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SkFontArguments_VariationPosition_Coordinate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_VariationPosition_Coordinate),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_VariationPosition_Coordinate),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_SkFontArguments_VariationPosition() {
    const UNINIT: ::core::mem::MaybeUninit<SkFontArguments_VariationPosition> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_VariationPosition>(),
        16usize,
        concat!("Size of: ", stringify!(SkFontArguments_VariationPosition))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_VariationPosition>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkFontArguments_VariationPosition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coordinates) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_VariationPosition),
            "::",
            stringify!(coordinates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coordinateCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_VariationPosition),
            "::",
            stringify!(coordinateCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_Palette {
    pub index: ::core::ffi::c_int,
    pub overrides: *const SkFontArguments_Palette_Override,
    pub overrideCount: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_Palette_Override {
    pub index: ::core::ffi::c_int,
    pub color: SkColor,
}
#[test]
fn bindgen_test_layout_SkFontArguments_Palette_Override() {
    const UNINIT: ::core::mem::MaybeUninit<SkFontArguments_Palette_Override> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_Palette_Override>(),
        8usize,
        concat!("Size of: ", stringify!(SkFontArguments_Palette_Override))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_Palette_Override>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SkFontArguments_Palette_Override)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_Palette_Override),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_Palette_Override),
            "::",
            stringify!(color)
        )
    );
}
#[test]
fn bindgen_test_layout_SkFontArguments_Palette() {
    const UNINIT: ::core::mem::MaybeUninit<SkFontArguments_Palette> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_Palette>(),
        24usize,
        concat!("Size of: ", stringify!(SkFontArguments_Palette))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_Palette>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontArguments_Palette))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_Palette),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overrides) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_Palette),
            "::",
            stringify!(overrides)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overrideCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments_Palette),
            "::",
            stringify!(overrideCount)
        )
    );
}
#[test]
fn bindgen_test_layout_SkFontArguments() {
    const UNINIT: ::core::mem::MaybeUninit<SkFontArguments> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments>(),
        48usize,
        concat!("Size of: ", stringify!(SkFontArguments))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontArguments))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCollectionIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments),
            "::",
            stringify!(fCollectionIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVariationDesignPosition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments),
            "::",
            stringify!(fVariationDesignPosition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPalette) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontArguments),
            "::",
            stringify!(fPalette)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontParameters_Variation_Axis {
    pub tag: SkFourByteTag,
    pub min: f32,
    pub def: f32,
    pub max: f32,
    pub flags: u16,
}
pub const SkFontParameters_Variation_Axis_HIDDEN: u16 = 1;
#[test]
fn bindgen_test_layout_SkFontParameters_Variation_Axis() {
    const UNINIT: ::core::mem::MaybeUninit<SkFontParameters_Variation_Axis> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFontParameters_Variation_Axis>(),
        20usize,
        concat!("Size of: ", stringify!(SkFontParameters_Variation_Axis))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontParameters_Variation_Axis>(),
        4usize,
        concat!("Alignment of ", stringify!(SkFontParameters_Variation_Axis))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).def) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontParameters_Variation_Axis),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontStyle {
    pub fValue: i32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontStyle_Weight {
    kInvisible_Weight = 0,
    kThin_Weight = 100,
    kExtraLight_Weight = 200,
    kLight_Weight = 300,
    kNormal_Weight = 400,
    kMedium_Weight = 500,
    kSemiBold_Weight = 600,
    kBold_Weight = 700,
    kExtraBold_Weight = 800,
    kBlack_Weight = 900,
    kExtraBlack_Weight = 1000,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontStyle_Width {
    kUltraCondensed_Width = 1,
    kExtraCondensed_Width = 2,
    kCondensed_Width = 3,
    kSemiCondensed_Width = 4,
    kNormal_Width = 5,
    kSemiExpanded_Width = 6,
    kExpanded_Width = 7,
    kExtraExpanded_Width = 8,
    kUltraExpanded_Width = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontStyle_Slant {
    Upright = 0,
    Italic = 1,
    Oblique = 2,
}
#[test]
fn bindgen_test_layout_SkFontStyle() {
    const UNINIT: ::core::mem::MaybeUninit<SkFontStyle> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFontStyle>(),
        4usize,
        concat!("Size of: ", stringify!(SkFontStyle))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontStyle>(),
        4usize,
        concat!("Alignment of ", stringify!(SkFontStyle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontStyle),
            "::",
            stringify!(fValue)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkWeakRefCnt {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkWeakRefCnt_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkWeakRefCnt() {
    assert_eq!(
        ::core::mem::size_of::<SkWeakRefCnt>(),
        16usize,
        concat!("Size of: ", stringify!(SkWeakRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkWeakRefCnt>(),
        8usize,
        concat!("Alignment of ", stringify!(SkWeakRefCnt))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDescriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkScalerContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkAdvancedTypefaceMetrics {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkScalerContextEffects {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkScalerContextRec {
    _unused: [u8; 0],
}
pub type SkTypefaceID = u32;
pub type SkFontTableTag = u32;
#[repr(C)]
#[derive(Debug)]
pub struct SkTypeface {
    pub _base: SkWeakRefCnt,
    pub fUniqueID: SkTypefaceID,
    pub fStyle: SkFontStyle,
    pub fBounds: SkRect,
    pub fBoundsOnce: SkOnce,
    pub fIsFixedPitch: bool,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTypeface_SerializeBehavior {
    DoIncludeData = 0,
    DontIncludeData = 1,
    IncludeDataIfLocal = 2,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTypeface_LocalizedString {
    pub fString: SkString,
    pub fLanguage: SkString,
}
#[test]
fn bindgen_test_layout_SkTypeface_LocalizedString() {
    const UNINIT: ::core::mem::MaybeUninit<SkTypeface_LocalizedString> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTypeface_LocalizedString>(),
        16usize,
        concat!("Size of: ", stringify!(SkTypeface_LocalizedString))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTypeface_LocalizedString>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTypeface_LocalizedString))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface_LocalizedString),
            "::",
            stringify!(fString)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLanguage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface_LocalizedString),
            "::",
            stringify!(fLanguage)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkTypeface_LocalizedStrings {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkTypeface_LocalizedStrings() {
    assert_eq!(
        ::core::mem::size_of::<SkTypeface_LocalizedStrings>(),
        8usize,
        concat!("Size of: ", stringify!(SkTypeface_LocalizedStrings))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTypeface_LocalizedStrings>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTypeface_LocalizedStrings))
    );
}
pub type SkTypeface_FactoryId = SkFourByteTag;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTypeface_Style {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    BoldItalic = 3,
}
pub type SkTypeface_INHERITED = SkWeakRefCnt;
#[test]
fn bindgen_test_layout_SkTypeface() {
    const UNINIT: ::core::mem::MaybeUninit<SkTypeface> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTypeface>(),
        48usize,
        concat!("Size of: ", stringify!(SkTypeface))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTypeface>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTypeface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fUniqueID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStyle) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBoundsOnce) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fBoundsOnce)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsFixedPitch) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTypeface),
            "::",
            stringify!(fIsFixedPitch)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface26getVariationDesignPositionEPN15SkFontArguments17VariationPosition10CoordinateEi"]
    pub fn SkTypeface_getVariationDesignPosition(
        this: *const SkTypeface,
        coordinates: *mut SkFontArguments_VariationPosition_Coordinate,
        coordinateCount: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface28getVariationDesignParametersEPN16SkFontParameters9Variation4AxisEi"]
    pub fn SkTypeface_getVariationDesignParameters(
        this: *const SkTypeface,
        parameters: *mut SkFontParameters_Variation_Axis,
        parameterCount: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface8UniqueIDEPKS_"]
    pub fn SkTypeface_UniqueID(face: *const SkTypeface) -> SkTypefaceID;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface5EqualEPKS_S1_"]
    pub fn SkTypeface_Equal(facea: *const SkTypeface, faceb: *const SkTypeface) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface11MakeDefaultEv"]
    pub fn SkTypeface_MakeDefault() -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface12MakeFromNameEPKc11SkFontStyle"]
    pub fn SkTypeface_MakeFromName(
        familyName: *const ::core::ffi::c_char,
        fontStyle: SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface12MakeFromFileEPKci"]
    pub fn SkTypeface_MakeFromFile(
        path: *const ::core::ffi::c_char,
        index: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface14MakeFromStreamENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEEi"]
    pub fn SkTypeface_MakeFromStream(stream: u64, index: ::core::ffi::c_int) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface12MakeFromDataE5sk_spI6SkDataEi"]
    pub fn SkTypeface_MakeFromData(
        arg1: sk_sp<SkData>,
        index: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface9makeCloneERK15SkFontArguments"]
    pub fn SkTypeface_makeClone(
        this: *const SkTypeface,
        arg1: *const SkFontArguments,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface9serializeEP9SkWStreamNS_17SerializeBehaviorE"]
    pub fn SkTypeface_serialize(
        this: *const SkTypeface,
        arg1: *mut SkWStream,
        arg2: SkTypeface_SerializeBehavior,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface9serializeENS_17SerializeBehaviorE"]
    pub fn SkTypeface_serialize1(
        this: *const SkTypeface,
        arg1: SkTypeface_SerializeBehavior,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface15MakeDeserializeEP8SkStream"]
    pub fn SkTypeface_MakeDeserialize(arg1: *mut SkStream) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface16unicharsToGlyphsEPKiiPt"]
    pub fn SkTypeface_unicharsToGlyphs(
        this: *const SkTypeface,
        uni: *const SkUnichar,
        count: ::core::ffi::c_int,
        glyphs: *mut SkGlyphID,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface12textToGlyphsEPKvm14SkTextEncodingPti"]
    pub fn SkTypeface_textToGlyphs(
        this: *const SkTypeface,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface14unicharToGlyphEi"]
    pub fn SkTypeface_unicharToGlyph(this: *const SkTypeface, unichar: SkUnichar) -> SkGlyphID;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface11countGlyphsEv"]
    pub fn SkTypeface_countGlyphs(this: *const SkTypeface) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface11countTablesEv"]
    pub fn SkTypeface_countTables(this: *const SkTypeface) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface12getTableTagsEPj"]
    pub fn SkTypeface_getTableTags(
        this: *const SkTypeface,
        tags: *mut SkFontTableTag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface12getTableSizeEj"]
    pub fn SkTypeface_getTableSize(this: *const SkTypeface, arg1: SkFontTableTag) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface12getTableDataEjmmPv"]
    pub fn SkTypeface_getTableData(
        this: *const SkTypeface,
        tag: SkFontTableTag,
        offset: usize,
        length: usize,
        data: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface13copyTableDataEj"]
    pub fn SkTypeface_copyTableData(this: *const SkTypeface, tag: SkFontTableTag) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface13getUnitsPerEmEv"]
    pub fn SkTypeface_getUnitsPerEm(this: *const SkTypeface) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface25getKerningPairAdjustmentsEPKtiPi"]
    pub fn SkTypeface_getKerningPairAdjustments(
        this: *const SkTypeface,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        adjustments: *mut i32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface24createFamilyNameIteratorEv"]
    pub fn SkTypeface_createFamilyNameIterator(
        this: *const SkTypeface,
    ) -> *mut SkTypeface_LocalizedStrings;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface13getFamilyNameEP8SkString"]
    pub fn SkTypeface_getFamilyName(this: *const SkTypeface, name: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface17getPostScriptNameEP8SkString"]
    pub fn SkTypeface_getPostScriptName(this: *const SkTypeface, name: *mut SkString) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface10openStreamEPi"]
    pub fn SkTypeface_openStream(this: *const SkTypeface, ttcIndex: *mut ::core::ffi::c_int)
        -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface18openExistingStreamEPi"]
    pub fn SkTypeface_openExistingStream(
        this: *const SkTypeface,
        ttcIndex: *mut ::core::ffi::c_int,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface19createScalerContextERK22SkScalerContextEffectsPK12SkDescriptor"]
    pub fn SkTypeface_createScalerContext(
        this: *const SkTypeface,
        arg1: *const SkScalerContextEffects,
        arg2: *const SkDescriptor,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface9getBoundsEv"]
    pub fn SkTypeface_getBounds(this: *const SkTypeface) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface8RegisterEjPF5sk_spIS_ENSt3__110unique_ptrI13SkStreamAssetNS2_14default_deleteIS4_EEEERK15SkFontArgumentsE"]
    pub fn SkTypeface_Register(
        id: SkTypeface_FactoryId,
        make: ::core::option::Option<
            unsafe extern "C" fn(arg1: u64, arg2: *const SkFontArguments) -> sk_sp<SkTypeface>,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypefaceC2ERK11SkFontStyleb"]
    pub fn SkTypeface_SkTypeface(
        this: *mut SkTypeface,
        style: *const SkFontStyle,
        isFixedPitch: bool,
    );
}
impl SkTypeface {
    #[inline]
    pub unsafe fn getVariationDesignPosition(
        &self,
        coordinates: *mut SkFontArguments_VariationPosition_Coordinate,
        coordinateCount: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        SkTypeface_getVariationDesignPosition(self, coordinates, coordinateCount)
    }
    #[inline]
    pub unsafe fn getVariationDesignParameters(
        &self,
        parameters: *mut SkFontParameters_Variation_Axis,
        parameterCount: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        SkTypeface_getVariationDesignParameters(self, parameters, parameterCount)
    }
    #[inline]
    pub unsafe fn UniqueID(face: *const SkTypeface) -> SkTypefaceID {
        SkTypeface_UniqueID(face)
    }
    #[inline]
    pub unsafe fn Equal(facea: *const SkTypeface, faceb: *const SkTypeface) -> bool {
        SkTypeface_Equal(facea, faceb)
    }
    #[inline]
    pub unsafe fn MakeDefault() -> sk_sp<SkTypeface> {
        SkTypeface_MakeDefault()
    }
    #[inline]
    pub unsafe fn MakeFromName(
        familyName: *const ::core::ffi::c_char,
        fontStyle: SkFontStyle,
    ) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromName(familyName, fontStyle)
    }
    #[inline]
    pub unsafe fn MakeFromFile(
        path: *const ::core::ffi::c_char,
        index: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromFile(path, index)
    }
    #[inline]
    pub unsafe fn MakeFromStream(stream: u64, index: ::core::ffi::c_int) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromStream(stream, index)
    }
    #[inline]
    pub unsafe fn MakeFromData(
        arg1: sk_sp<SkData>,
        index: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromData(arg1, index)
    }
    #[inline]
    pub unsafe fn makeClone(&self, arg1: *const SkFontArguments) -> sk_sp<SkTypeface> {
        SkTypeface_makeClone(self, arg1)
    }
    #[inline]
    pub unsafe fn serialize(&self, arg1: *mut SkWStream, arg2: SkTypeface_SerializeBehavior) {
        SkTypeface_serialize(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn serialize1(&self, arg1: SkTypeface_SerializeBehavior) -> sk_sp<SkData> {
        SkTypeface_serialize1(self, arg1)
    }
    #[inline]
    pub unsafe fn MakeDeserialize(arg1: *mut SkStream) -> sk_sp<SkTypeface> {
        SkTypeface_MakeDeserialize(arg1)
    }
    #[inline]
    pub unsafe fn unicharsToGlyphs(
        &self,
        uni: *const SkUnichar,
        count: ::core::ffi::c_int,
        glyphs: *mut SkGlyphID,
    ) {
        SkTypeface_unicharsToGlyphs(self, uni, count, glyphs)
    }
    #[inline]
    pub unsafe fn textToGlyphs(
        &self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        SkTypeface_textToGlyphs(self, text, byteLength, encoding, glyphs, maxGlyphCount)
    }
    #[inline]
    pub unsafe fn unicharToGlyph(&self, unichar: SkUnichar) -> SkGlyphID {
        SkTypeface_unicharToGlyph(self, unichar)
    }
    #[inline]
    pub unsafe fn countGlyphs(&self) -> ::core::ffi::c_int {
        SkTypeface_countGlyphs(self)
    }
    #[inline]
    pub unsafe fn countTables(&self) -> ::core::ffi::c_int {
        SkTypeface_countTables(self)
    }
    #[inline]
    pub unsafe fn getTableTags(&self, tags: *mut SkFontTableTag) -> ::core::ffi::c_int {
        SkTypeface_getTableTags(self, tags)
    }
    #[inline]
    pub unsafe fn getTableSize(&self, arg1: SkFontTableTag) -> usize {
        SkTypeface_getTableSize(self, arg1)
    }
    #[inline]
    pub unsafe fn getTableData(
        &self,
        tag: SkFontTableTag,
        offset: usize,
        length: usize,
        data: *mut ::core::ffi::c_void,
    ) -> usize {
        SkTypeface_getTableData(self, tag, offset, length, data)
    }
    #[inline]
    pub unsafe fn copyTableData(&self, tag: SkFontTableTag) -> sk_sp<SkData> {
        SkTypeface_copyTableData(self, tag)
    }
    #[inline]
    pub unsafe fn getUnitsPerEm(&self) -> ::core::ffi::c_int {
        SkTypeface_getUnitsPerEm(self)
    }
    #[inline]
    pub unsafe fn getKerningPairAdjustments(
        &self,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        adjustments: *mut i32,
    ) -> bool {
        SkTypeface_getKerningPairAdjustments(self, glyphs, count, adjustments)
    }
    #[inline]
    pub unsafe fn createFamilyNameIterator(&self) -> *mut SkTypeface_LocalizedStrings {
        SkTypeface_createFamilyNameIterator(self)
    }
    #[inline]
    pub unsafe fn getFamilyName(&self, name: *mut SkString) {
        SkTypeface_getFamilyName(self, name)
    }
    #[inline]
    pub unsafe fn getPostScriptName(&self, name: *mut SkString) -> bool {
        SkTypeface_getPostScriptName(self, name)
    }
    #[inline]
    pub unsafe fn openStream(&self, ttcIndex: *mut ::core::ffi::c_int) -> u64 {
        SkTypeface_openStream(self, ttcIndex)
    }
    #[inline]
    pub unsafe fn openExistingStream(&self, ttcIndex: *mut ::core::ffi::c_int) -> u64 {
        SkTypeface_openExistingStream(self, ttcIndex)
    }
    #[inline]
    pub unsafe fn createScalerContext(
        &self,
        arg1: *const SkScalerContextEffects,
        arg2: *const SkDescriptor,
    ) -> u8 {
        SkTypeface_createScalerContext(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getBounds(&self) -> SkRect {
        SkTypeface_getBounds(self)
    }
    #[inline]
    pub unsafe fn Register(
        id: SkTypeface_FactoryId,
        make: ::core::option::Option<
            unsafe extern "C" fn(arg1: u64, arg2: *const SkFontArguments) -> sk_sp<SkTypeface>,
        >,
    ) {
        SkTypeface_Register(id, make)
    }
    #[inline]
    pub unsafe fn new(style: *const SkFontStyle, isFixedPitch: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTypeface_SkTypeface(__bindgen_tmp.as_mut_ptr(), style, isFixedPitch);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypefaceD1Ev"]
    pub fn SkTypeface_SkTypeface_destructor(this: *mut SkTypeface);
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface20onOpenExistingStreamEPi"]
    pub fn SkTypeface_onOpenExistingStream(
        this: *mut ::core::ffi::c_void,
        ttcIndex: *mut ::core::ffi::c_int,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface27onGetKerningPairAdjustmentsEPKtiPi"]
    pub fn SkTypeface_onGetKerningPairAdjustments(
        this: *mut ::core::ffi::c_void,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        adjustments: *mut i32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface15onCopyTableDataEj"]
    pub fn SkTypeface_onCopyTableData(
        this: *mut ::core::ffi::c_void,
        arg1: SkFontTableTag,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface15onComputeBoundsEP6SkRect"]
    pub fn SkTypeface_onComputeBounds(this: *mut ::core::ffi::c_void, arg1: *mut SkRect) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_private_AutoTMalloc {
    pub _address: u8,
}
#[repr(C)]
pub struct skia_private_AutoSTMalloc__bindgen_ty_1<T> {
    pub fStorage32: __BindgenUnionField<*mut u32>,
    pub fTStorage: __BindgenUnionField<[T; 1usize]>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
pub type skia_private_TArray_value_type<T> = T;
pub type skia_private_STArray_Storage = u8;
#[repr(C)]
#[derive(Debug)]
pub struct skia_private_THashTable {
    pub fCount: ::core::ffi::c_int,
    pub fCapacity: ::core::ffi::c_int,
    pub fSlots: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_private_THashTable_Iter {
    pub fTable: *const skia_private_THashTable_Iter_TTable,
    pub fSlot: ::core::ffi::c_int,
}
pub type skia_private_THashTable_Iter_TTable = skia_private_THashTable;
#[repr(C)]
pub struct skia_private_THashTable_Slot<T> {
    pub fHash: u32,
    pub fVal: skia_private_THashTable_Slot_Storage<T>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[repr(align(1))]
pub struct skia_private_THashTable_Slot_Storage<T> {
    pub fStorage: __BindgenUnionField<T>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_private_THashMap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_private_THashMap_Pair<K, V> {
    pub _base: std_pair<K, V>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<K>>,
    pub _phantom_1: ::core::marker::PhantomData<::core::cell::UnsafeCell<V>>,
}
pub type skia_private_THashMap_Iter = skia_private_THashTable;
#[repr(C)]
#[derive(Debug)]
pub struct SkFont {
    pub fTypeface: sk_sp<SkTypeface>,
    pub fSize: SkScalar,
    pub fScaleX: SkScalar,
    pub fSkewX: SkScalar,
    pub fFlags: u8,
    pub fEdging: u8,
    pub fHinting: u8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFont_Edging {
    Alias = 0,
    AntiAlias = 1,
    SubpixelAntiAlias = 2,
}
pub type SkFont_sk_is_trivially_relocatable = std_true_type;
pub const SkFont_PrivFlags_kForceAutoHinting_PrivFlag: SkFont_PrivFlags = 1;
pub const SkFont_PrivFlags_kEmbeddedBitmaps_PrivFlag: SkFont_PrivFlags = 2;
pub const SkFont_PrivFlags_kSubpixel_PrivFlag: SkFont_PrivFlags = 4;
pub const SkFont_PrivFlags_kLinearMetrics_PrivFlag: SkFont_PrivFlags = 8;
pub const SkFont_PrivFlags_kEmbolden_PrivFlag: SkFont_PrivFlags = 16;
pub const SkFont_PrivFlags_kBaselineSnap_PrivFlag: SkFont_PrivFlags = 32;
pub type SkFont_PrivFlags = ::core::ffi::c_uint;
pub const SkFont_kAllFlags: ::core::ffi::c_uint = 63;
#[test]
fn bindgen_test_layout_SkFont() {
    const UNINIT: ::core::mem::MaybeUninit<SkFont> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFont>(),
        24usize,
        concat!("Size of: ", stringify!(SkFont))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFont>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFont))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTypeface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fTypeface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fScaleX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fScaleX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSkewX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fSkewX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFlags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEdging) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fEdging)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHinting) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFont),
            "::",
            stringify!(fHinting)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont19setForceAutoHintingEb"]
    pub fn SkFont_setForceAutoHinting(this: *mut SkFont, forceAutoHinting: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont18setEmbeddedBitmapsEb"]
    pub fn SkFont_setEmbeddedBitmaps(this: *mut SkFont, embeddedBitmaps: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont11setSubpixelEb"]
    pub fn SkFont_setSubpixel(this: *mut SkFont, subpixel: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont16setLinearMetricsEb"]
    pub fn SkFont_setLinearMetrics(this: *mut SkFont, linearMetrics: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont11setEmboldenEb"]
    pub fn SkFont_setEmbolden(this: *mut SkFont, embolden: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont15setBaselineSnapEb"]
    pub fn SkFont_setBaselineSnap(this: *mut SkFont, baselineSnap: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont9setEdgingENS_6EdgingE"]
    pub fn SkFont_setEdging(this: *mut SkFont, edging: SkFont_Edging);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont10setHintingE13SkFontHinting"]
    pub fn SkFont_setHinting(this: *mut SkFont, hintingLevel: SkFontHinting);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont12makeWithSizeEf"]
    pub fn SkFont_makeWithSize(this: *const SkFont, size: SkScalar) -> SkFont;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont20getTypefaceOrDefaultEv"]
    pub fn SkFont_getTypefaceOrDefault(this: *const SkFont) -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont20refTypefaceOrDefaultEv"]
    pub fn SkFont_refTypefaceOrDefault(this: *const SkFont) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont7setSizeEf"]
    pub fn SkFont_setSize(this: *mut SkFont, textSize: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont9setScaleXEf"]
    pub fn SkFont_setScaleX(this: *mut SkFont, scaleX: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont8setSkewXEf"]
    pub fn SkFont_setSkewX(this: *mut SkFont, skewX: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont12textToGlyphsEPKvm14SkTextEncodingPti"]
    pub fn SkFont_textToGlyphs(
        this: *const SkFont,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont14unicharToGlyphEi"]
    pub fn SkFont_unicharToGlyph(this: *const SkFont, uni: SkUnichar) -> SkGlyphID;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont16unicharsToGlyphsEPKiiPt"]
    pub fn SkFont_unicharsToGlyphs(
        this: *const SkFont,
        uni: *const SkUnichar,
        count: ::core::ffi::c_int,
        glyphs: *mut SkGlyphID,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont11measureTextEPKvm14SkTextEncodingP6SkRectPK7SkPaint"]
    pub fn SkFont_measureText(
        this: *const SkFont,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont15getWidthsBoundsEPKtiPfP6SkRectPK7SkPaint"]
    pub fn SkFont_getWidthsBounds(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        widths: *mut SkScalar,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont6getPosEPKtiP7SkPointS2_"]
    pub fn SkFont_getPos(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        pos: *mut SkPoint,
        origin: SkPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont7getXPosEPKtiPff"]
    pub fn SkFont_getXPos(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        xpos: *mut SkScalar,
        origin: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont13getInterceptsEPKtiPK7SkPointffPK7SkPaint"]
    pub fn SkFont_getIntercepts(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        pos: *const SkPoint,
        top: SkScalar,
        bottom: SkScalar,
        arg1: *const SkPaint,
    ) -> [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont7getPathEtP6SkPath"]
    pub fn SkFont_getPath(this: *const SkFont, glyphID: SkGlyphID, path: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont8getPathsEPKtiPFvPK6SkPathRK8SkMatrixPvES8_"]
    pub fn SkFont_getPaths(
        this: *const SkFont,
        glyphIDs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        glyphPathProc: ::core::option::Option<
            unsafe extern "C" fn(
                pathOrNull: *const SkPath,
                mx: *const SkMatrix,
                ctx: *mut ::core::ffi::c_void,
            ),
        >,
        ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont10getMetricsEP13SkFontMetrics"]
    pub fn SkFont_getMetrics(this: *const SkFont, metrics: *mut SkFontMetrics) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont4dumpEv"]
    pub fn SkFont_dump(this: *const SkFont);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFontC1Ev"]
    pub fn SkFont_SkFont(this: *mut SkFont);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFontC1E5sk_spI10SkTypefaceEf"]
    pub fn SkFont_SkFont1(this: *mut SkFont, typeface: sk_sp<SkTypeface>, size: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFontC1E5sk_spI10SkTypefaceE"]
    pub fn SkFont_SkFont2(this: *mut SkFont, typeface: sk_sp<SkTypeface>);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFontC1E5sk_spI10SkTypefaceEfff"]
    pub fn SkFont_SkFont3(
        this: *mut SkFont,
        typeface: sk_sp<SkTypeface>,
        size: SkScalar,
        scaleX: SkScalar,
        skewX: SkScalar,
    );
}
impl SkFont {
    #[inline]
    pub unsafe fn setForceAutoHinting(&mut self, forceAutoHinting: bool) {
        SkFont_setForceAutoHinting(self, forceAutoHinting)
    }
    #[inline]
    pub unsafe fn setEmbeddedBitmaps(&mut self, embeddedBitmaps: bool) {
        SkFont_setEmbeddedBitmaps(self, embeddedBitmaps)
    }
    #[inline]
    pub unsafe fn setSubpixel(&mut self, subpixel: bool) {
        SkFont_setSubpixel(self, subpixel)
    }
    #[inline]
    pub unsafe fn setLinearMetrics(&mut self, linearMetrics: bool) {
        SkFont_setLinearMetrics(self, linearMetrics)
    }
    #[inline]
    pub unsafe fn setEmbolden(&mut self, embolden: bool) {
        SkFont_setEmbolden(self, embolden)
    }
    #[inline]
    pub unsafe fn setBaselineSnap(&mut self, baselineSnap: bool) {
        SkFont_setBaselineSnap(self, baselineSnap)
    }
    #[inline]
    pub unsafe fn setEdging(&mut self, edging: SkFont_Edging) {
        SkFont_setEdging(self, edging)
    }
    #[inline]
    pub unsafe fn setHinting(&mut self, hintingLevel: SkFontHinting) {
        SkFont_setHinting(self, hintingLevel)
    }
    #[inline]
    pub unsafe fn makeWithSize(&self, size: SkScalar) -> SkFont {
        SkFont_makeWithSize(self, size)
    }
    #[inline]
    pub unsafe fn getTypefaceOrDefault(&self) -> *mut SkTypeface {
        SkFont_getTypefaceOrDefault(self)
    }
    #[inline]
    pub unsafe fn refTypefaceOrDefault(&self) -> sk_sp<SkTypeface> {
        SkFont_refTypefaceOrDefault(self)
    }
    #[inline]
    pub unsafe fn setSize(&mut self, textSize: SkScalar) {
        SkFont_setSize(self, textSize)
    }
    #[inline]
    pub unsafe fn setScaleX(&mut self, scaleX: SkScalar) {
        SkFont_setScaleX(self, scaleX)
    }
    #[inline]
    pub unsafe fn setSkewX(&mut self, skewX: SkScalar) {
        SkFont_setSkewX(self, skewX)
    }
    #[inline]
    pub unsafe fn textToGlyphs(
        &self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        SkFont_textToGlyphs(self, text, byteLength, encoding, glyphs, maxGlyphCount)
    }
    #[inline]
    pub unsafe fn unicharToGlyph(&self, uni: SkUnichar) -> SkGlyphID {
        SkFont_unicharToGlyph(self, uni)
    }
    #[inline]
    pub unsafe fn unicharsToGlyphs(
        &self,
        uni: *const SkUnichar,
        count: ::core::ffi::c_int,
        glyphs: *mut SkGlyphID,
    ) {
        SkFont_unicharsToGlyphs(self, uni, count, glyphs)
    }
    #[inline]
    pub unsafe fn measureText(
        &self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    ) -> SkScalar {
        SkFont_measureText(self, text, byteLength, encoding, bounds, paint)
    }
    #[inline]
    pub unsafe fn getWidthsBounds(
        &self,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        widths: *mut SkScalar,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    ) {
        SkFont_getWidthsBounds(self, glyphs, count, widths, bounds, paint)
    }
    #[inline]
    pub unsafe fn getPos(
        &self,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        pos: *mut SkPoint,
        origin: SkPoint,
    ) {
        SkFont_getPos(self, glyphs, count, pos, origin)
    }
    #[inline]
    pub unsafe fn getXPos(
        &self,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        xpos: *mut SkScalar,
        origin: SkScalar,
    ) {
        SkFont_getXPos(self, glyphs, count, xpos, origin)
    }
    #[inline]
    pub unsafe fn getIntercepts(
        &self,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        pos: *const SkPoint,
        top: SkScalar,
        bottom: SkScalar,
        arg1: *const SkPaint,
    ) -> [u64; 3usize] {
        SkFont_getIntercepts(self, glyphs, count, pos, top, bottom, arg1)
    }
    #[inline]
    pub unsafe fn getPath(&self, glyphID: SkGlyphID, path: *mut SkPath) -> bool {
        SkFont_getPath(self, glyphID, path)
    }
    #[inline]
    pub unsafe fn getPaths(
        &self,
        glyphIDs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        glyphPathProc: ::core::option::Option<
            unsafe extern "C" fn(
                pathOrNull: *const SkPath,
                mx: *const SkMatrix,
                ctx: *mut ::core::ffi::c_void,
            ),
        >,
        ctx: *mut ::core::ffi::c_void,
    ) {
        SkFont_getPaths(self, glyphIDs, count, glyphPathProc, ctx)
    }
    #[inline]
    pub unsafe fn getMetrics(&self, metrics: *mut SkFontMetrics) -> SkScalar {
        SkFont_getMetrics(self, metrics)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkFont_dump(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(typeface: sk_sp<SkTypeface>, size: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont1(__bindgen_tmp.as_mut_ptr(), typeface, size);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(typeface: sk_sp<SkTypeface>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont2(__bindgen_tmp.as_mut_ptr(), typeface);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        typeface: sk_sp<SkTypeface>,
        size: SkScalar,
        scaleX: SkScalar,
        skewX: SkScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont3(__bindgen_tmp.as_mut_ptr(), typeface, size, scaleX, skewX);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontMetrics {
    pub fFlags: u32,
    pub fTop: SkScalar,
    pub fAscent: SkScalar,
    pub fDescent: SkScalar,
    pub fBottom: SkScalar,
    pub fLeading: SkScalar,
    pub fAvgCharWidth: SkScalar,
    pub fMaxCharWidth: SkScalar,
    pub fXMin: SkScalar,
    pub fXMax: SkScalar,
    pub fXHeight: SkScalar,
    pub fCapHeight: SkScalar,
    pub fUnderlineThickness: SkScalar,
    pub fUnderlinePosition: SkScalar,
    pub fStrikeoutThickness: SkScalar,
    pub fStrikeoutPosition: SkScalar,
}
pub const SkFontMetrics_FontMetricsFlags_kUnderlineThicknessIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 1;
pub const SkFontMetrics_FontMetricsFlags_kUnderlinePositionIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 2;
pub const SkFontMetrics_FontMetricsFlags_kStrikeoutThicknessIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 4;
pub const SkFontMetrics_FontMetricsFlags_kStrikeoutPositionIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 8;
pub const SkFontMetrics_FontMetricsFlags_kBoundsInvalid_Flag: SkFontMetrics_FontMetricsFlags = 16;
pub type SkFontMetrics_FontMetricsFlags = ::core::ffi::c_uint;
#[test]
fn bindgen_test_layout_SkFontMetrics() {
    const UNINIT: ::core::mem::MaybeUninit<SkFontMetrics> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFontMetrics>(),
        64usize,
        concat!("Size of: ", stringify!(SkFontMetrics))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontMetrics>(),
        4usize,
        concat!("Alignment of ", stringify!(SkFontMetrics))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTop) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fTop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAscent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fAscent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDescent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fDescent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBottom) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fBottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLeading) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fLeading)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAvgCharWidth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fAvgCharWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxCharWidth) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fMaxCharWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fXMin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fXMin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fXMax) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fXMax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fXHeight) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fXHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCapHeight) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fCapHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUnderlineThickness) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fUnderlineThickness)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUnderlinePosition) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fUnderlinePosition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStrikeoutThickness) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fStrikeoutThickness)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStrikeoutPosition) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontMetrics),
            "::",
            stringify!(fStrikeoutPosition)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkFontStyleSet {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkFontStyleSet() {
    assert_eq!(
        ::core::mem::size_of::<SkFontStyleSet>(),
        16usize,
        concat!("Size of: ", stringify!(SkFontStyleSet))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontStyleSet>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontStyleSet))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkFontStyleSet11CreateEmptyEv"]
    pub fn SkFontStyleSet_CreateEmpty() -> sk_sp<SkFontStyleSet>;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkFontStyleSet14matchStyleCSS3ERK11SkFontStyle"]
    pub fn SkFontStyleSet_matchStyleCSS3(
        this: *mut SkFontStyleSet,
        pattern: *const SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
impl SkFontStyleSet {
    #[inline]
    pub unsafe fn CreateEmpty() -> sk_sp<SkFontStyleSet> {
        SkFontStyleSet_CreateEmpty()
    }
    #[inline]
    pub unsafe fn matchStyleCSS3(&mut self, pattern: *const SkFontStyle) -> sk_sp<SkTypeface> {
        SkFontStyleSet_matchStyleCSS3(self, pattern)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkFontMgr {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkFontMgr() {
    assert_eq!(
        ::core::mem::size_of::<SkFontMgr>(),
        16usize,
        concat!("Size of: ", stringify!(SkFontMgr))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontMgr>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontMgr))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr13countFamiliesEv"]
    pub fn SkFontMgr_countFamilies(this: *const SkFontMgr) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr13getFamilyNameEiP8SkString"]
    pub fn SkFontMgr_getFamilyName(
        this: *const SkFontMgr,
        index: ::core::ffi::c_int,
        familyName: *mut SkString,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr14createStyleSetEi"]
    pub fn SkFontMgr_createStyleSet(
        this: *const SkFontMgr,
        index: ::core::ffi::c_int,
    ) -> sk_sp<SkFontStyleSet>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr11matchFamilyEPKc"]
    pub fn SkFontMgr_matchFamily(
        this: *const SkFontMgr,
        familyName: *const ::core::ffi::c_char,
    ) -> sk_sp<SkFontStyleSet>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr16matchFamilyStyleEPKcRK11SkFontStyle"]
    pub fn SkFontMgr_matchFamilyStyle(
        this: *const SkFontMgr,
        familyName: *const ::core::ffi::c_char,
        arg1: *const SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr25matchFamilyStyleCharacterEPKcRK11SkFontStylePS1_ii"]
    pub fn SkFontMgr_matchFamilyStyleCharacter(
        this: *const SkFontMgr,
        familyName: *const ::core::ffi::c_char,
        arg1: *const SkFontStyle,
        bcp47: *mut *const ::core::ffi::c_char,
        bcp47Count: ::core::ffi::c_int,
        character: SkUnichar,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr12makeFromDataE5sk_spI6SkDataEi"]
    pub fn SkFontMgr_makeFromData(
        this: *const SkFontMgr,
        arg1: sk_sp<SkData>,
        ttcIndex: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr14makeFromStreamENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEEi"]
    pub fn SkFontMgr_makeFromStream(
        this: *const SkFontMgr,
        arg1: u64,
        ttcIndex: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr14makeFromStreamENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEERK15SkFontArguments"]
    pub fn SkFontMgr_makeFromStream1(
        this: *const SkFontMgr,
        arg1: u64,
        arg2: *const SkFontArguments,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr12makeFromFileEPKci"]
    pub fn SkFontMgr_makeFromFile(
        this: *const SkFontMgr,
        path: *const ::core::ffi::c_char,
        ttcIndex: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr18legacyMakeTypefaceEPKc11SkFontStyle"]
    pub fn SkFontMgr_legacyMakeTypeface(
        this: *const SkFontMgr,
        familyName: *const ::core::ffi::c_char,
        style: SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkFontMgr10RefDefaultEv"]
    pub fn SkFontMgr_RefDefault() -> sk_sp<SkFontMgr>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkFontMgr8RefEmptyEv"]
    pub fn SkFontMgr_RefEmpty() -> sk_sp<SkFontMgr>;
}
impl SkFontMgr {
    #[inline]
    pub unsafe fn countFamilies(&self) -> ::core::ffi::c_int {
        SkFontMgr_countFamilies(self)
    }
    #[inline]
    pub unsafe fn getFamilyName(&self, index: ::core::ffi::c_int, familyName: *mut SkString) {
        SkFontMgr_getFamilyName(self, index, familyName)
    }
    #[inline]
    pub unsafe fn createStyleSet(&self, index: ::core::ffi::c_int) -> sk_sp<SkFontStyleSet> {
        SkFontMgr_createStyleSet(self, index)
    }
    #[inline]
    pub unsafe fn matchFamily(
        &self,
        familyName: *const ::core::ffi::c_char,
    ) -> sk_sp<SkFontStyleSet> {
        SkFontMgr_matchFamily(self, familyName)
    }
    #[inline]
    pub unsafe fn matchFamilyStyle(
        &self,
        familyName: *const ::core::ffi::c_char,
        arg1: *const SkFontStyle,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_matchFamilyStyle(self, familyName, arg1)
    }
    #[inline]
    pub unsafe fn matchFamilyStyleCharacter(
        &self,
        familyName: *const ::core::ffi::c_char,
        arg1: *const SkFontStyle,
        bcp47: *mut *const ::core::ffi::c_char,
        bcp47Count: ::core::ffi::c_int,
        character: SkUnichar,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_matchFamilyStyleCharacter(self, familyName, arg1, bcp47, bcp47Count, character)
    }
    #[inline]
    pub unsafe fn makeFromData(
        &self,
        arg1: sk_sp<SkData>,
        ttcIndex: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromData(self, arg1, ttcIndex)
    }
    #[inline]
    pub unsafe fn makeFromStream(
        &self,
        arg1: u64,
        ttcIndex: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromStream(self, arg1, ttcIndex)
    }
    #[inline]
    pub unsafe fn makeFromStream1(
        &self,
        arg1: u64,
        arg2: *const SkFontArguments,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromStream1(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn makeFromFile(
        &self,
        path: *const ::core::ffi::c_char,
        ttcIndex: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromFile(self, path, ttcIndex)
    }
    #[inline]
    pub unsafe fn legacyMakeTypeface(
        &self,
        familyName: *const ::core::ffi::c_char,
        style: SkFontStyle,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_legacyMakeTypeface(self, familyName, style)
    }
    #[inline]
    pub unsafe fn RefDefault() -> sk_sp<SkFontMgr> {
        SkFontMgr_RefDefault()
    }
    #[inline]
    pub unsafe fn RefEmpty() -> sk_sp<SkFontMgr> {
        SkFontMgr_RefEmpty()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkOpenTypeSVGDecoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTraceMemoryDump {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkGraphics {
    pub _address: u8,
}
pub type SkGraphics_ImageGeneratorFromEncodedDataFactory =
    ::core::option::Option<unsafe extern "C" fn(arg1: sk_sp<SkData>) -> u64>;
pub type SkGraphics_OpenTypeSVGDecoderFactory =
    ::core::option::Option<unsafe extern "C" fn(svg: *const u8, length: usize) -> u8>;
#[test]
fn bindgen_test_layout_SkGraphics() {
    assert_eq!(
        ::core::mem::size_of::<SkGraphics>(),
        1usize,
        concat!("Size of: ", stringify!(SkGraphics))
    );
    assert_eq!(
        ::core::mem::align_of::<SkGraphics>(),
        1usize,
        concat!("Alignment of ", stringify!(SkGraphics))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics4InitEv"]
    pub fn SkGraphics_Init();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics17GetFontCacheLimitEv"]
    pub fn SkGraphics_GetFontCacheLimit() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics17SetFontCacheLimitEm"]
    pub fn SkGraphics_SetFontCacheLimit(bytes: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics16GetFontCacheUsedEv"]
    pub fn SkGraphics_GetFontCacheUsed() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics21GetFontCacheCountUsedEv"]
    pub fn SkGraphics_GetFontCacheCountUsed() -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics22GetFontCacheCountLimitEv"]
    pub fn SkGraphics_GetFontCacheCountLimit() -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics22SetFontCacheCountLimitEi"]
    pub fn SkGraphics_SetFontCacheCountLimit(count: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics14PurgeFontCacheEv"]
    pub fn SkGraphics_PurgeFontCache();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics20PurgePinnedFontCacheEv"]
    pub fn SkGraphics_PurgePinnedFontCache();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics30GetResourceCacheTotalBytesUsedEv"]
    pub fn SkGraphics_GetResourceCacheTotalBytesUsed() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics30GetResourceCacheTotalByteLimitEv"]
    pub fn SkGraphics_GetResourceCacheTotalByteLimit() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics30SetResourceCacheTotalByteLimitEm"]
    pub fn SkGraphics_SetResourceCacheTotalByteLimit(newLimit: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics18PurgeResourceCacheEv"]
    pub fn SkGraphics_PurgeResourceCache();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics41GetResourceCacheSingleAllocationByteLimitEv"]
    pub fn SkGraphics_GetResourceCacheSingleAllocationByteLimit() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics41SetResourceCacheSingleAllocationByteLimitEm"]
    pub fn SkGraphics_SetResourceCacheSingleAllocationByteLimit(newLimit: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics20DumpMemoryStatisticsEP17SkTraceMemoryDump"]
    pub fn SkGraphics_DumpMemoryStatistics(dump: *mut SkTraceMemoryDump);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics14PurgeAllCachesEv"]
    pub fn SkGraphics_PurgeAllCaches();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics39SetImageGeneratorFromEncodedDataFactoryEPFNSt3__110unique_ptrI16SkImageGeneratorNS0_14default_deleteIS2_EEEE5sk_spI6SkDataEE"]
    pub fn SkGraphics_SetImageGeneratorFromEncodedDataFactory(
        arg1: SkGraphics_ImageGeneratorFromEncodedDataFactory,
    ) -> SkGraphics_ImageGeneratorFromEncodedDataFactory;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics28SetOpenTypeSVGDecoderFactoryEPFNSt3__110unique_ptrI20SkOpenTypeSVGDecoderNS0_14default_deleteIS2_EEEEPKhmE"]
    pub fn SkGraphics_SetOpenTypeSVGDecoderFactory(
        arg1: SkGraphics_OpenTypeSVGDecoderFactory,
    ) -> SkGraphics_OpenTypeSVGDecoderFactory;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics28GetOpenTypeSVGDecoderFactoryEv"]
    pub fn SkGraphics_GetOpenTypeSVGDecoderFactory() -> SkGraphics_OpenTypeSVGDecoderFactory;
}
impl SkGraphics {
    #[inline]
    pub unsafe fn Init() {
        SkGraphics_Init()
    }
    #[inline]
    pub unsafe fn GetFontCacheLimit() -> usize {
        SkGraphics_GetFontCacheLimit()
    }
    #[inline]
    pub unsafe fn SetFontCacheLimit(bytes: usize) -> usize {
        SkGraphics_SetFontCacheLimit(bytes)
    }
    #[inline]
    pub unsafe fn GetFontCacheUsed() -> usize {
        SkGraphics_GetFontCacheUsed()
    }
    #[inline]
    pub unsafe fn GetFontCacheCountUsed() -> ::core::ffi::c_int {
        SkGraphics_GetFontCacheCountUsed()
    }
    #[inline]
    pub unsafe fn GetFontCacheCountLimit() -> ::core::ffi::c_int {
        SkGraphics_GetFontCacheCountLimit()
    }
    #[inline]
    pub unsafe fn SetFontCacheCountLimit(count: ::core::ffi::c_int) -> ::core::ffi::c_int {
        SkGraphics_SetFontCacheCountLimit(count)
    }
    #[inline]
    pub unsafe fn PurgeFontCache() {
        SkGraphics_PurgeFontCache()
    }
    #[inline]
    pub unsafe fn PurgePinnedFontCache() {
        SkGraphics_PurgePinnedFontCache()
    }
    #[inline]
    pub unsafe fn GetResourceCacheTotalBytesUsed() -> usize {
        SkGraphics_GetResourceCacheTotalBytesUsed()
    }
    #[inline]
    pub unsafe fn GetResourceCacheTotalByteLimit() -> usize {
        SkGraphics_GetResourceCacheTotalByteLimit()
    }
    #[inline]
    pub unsafe fn SetResourceCacheTotalByteLimit(newLimit: usize) -> usize {
        SkGraphics_SetResourceCacheTotalByteLimit(newLimit)
    }
    #[inline]
    pub unsafe fn PurgeResourceCache() {
        SkGraphics_PurgeResourceCache()
    }
    #[inline]
    pub unsafe fn GetResourceCacheSingleAllocationByteLimit() -> usize {
        SkGraphics_GetResourceCacheSingleAllocationByteLimit()
    }
    #[inline]
    pub unsafe fn SetResourceCacheSingleAllocationByteLimit(newLimit: usize) -> usize {
        SkGraphics_SetResourceCacheSingleAllocationByteLimit(newLimit)
    }
    #[inline]
    pub unsafe fn DumpMemoryStatistics(dump: *mut SkTraceMemoryDump) {
        SkGraphics_DumpMemoryStatistics(dump)
    }
    #[inline]
    pub unsafe fn PurgeAllCaches() {
        SkGraphics_PurgeAllCaches()
    }
    #[inline]
    pub unsafe fn SetImageGeneratorFromEncodedDataFactory(
        arg1: SkGraphics_ImageGeneratorFromEncodedDataFactory,
    ) -> SkGraphics_ImageGeneratorFromEncodedDataFactory {
        SkGraphics_SetImageGeneratorFromEncodedDataFactory(arg1)
    }
    #[inline]
    pub unsafe fn SetOpenTypeSVGDecoderFactory(
        arg1: SkGraphics_OpenTypeSVGDecoderFactory,
    ) -> SkGraphics_OpenTypeSVGDecoderFactory {
        SkGraphics_SetOpenTypeSVGDecoderFactory(arg1)
    }
    #[inline]
    pub unsafe fn GetOpenTypeSVGDecoderFactory() -> SkGraphics_OpenTypeSVGDecoderFactory {
        SkGraphics_GetOpenTypeSVGDecoderFactory()
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImages_BitDepth {
    U8 = 0,
    F16 = 1,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkImage {
    pub _base: SkRefCnt,
    pub fInfo: SkImageInfo,
    pub fUniqueID: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_CachingHint {
    Allow = 0,
    Disallow = 1,
}
#[repr(C)]
pub struct SkImage_AsyncReadResult__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkImage_AsyncReadResult {
    pub vtable_: *const SkImage_AsyncReadResult__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkImage_AsyncReadResult() {
    assert_eq!(
        ::core::mem::size_of::<SkImage_AsyncReadResult>(),
        8usize,
        concat!("Size of: ", stringify!(SkImage_AsyncReadResult))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImage_AsyncReadResult>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImage_AsyncReadResult))
    );
}
pub type SkImage_ReadPixelsContext = *mut ::core::ffi::c_void;
pub type SkImage_ReadPixelsCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: SkImage_ReadPixelsContext, arg2: u8)>;
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_RescaleGamma {
    kSrc = 0,
    kLinear = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_RescaleMode {
    kNearest = 0,
    kLinear = 1,
    kRepeatedLinear = 2,
    kRepeatedCubic = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImage_RequiredProperties {
    pub fMipmapped: bool,
}
#[test]
fn bindgen_test_layout_SkImage_RequiredProperties() {
    const UNINIT: ::core::mem::MaybeUninit<SkImage_RequiredProperties> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkImage_RequiredProperties>(),
        1usize,
        concat!("Size of: ", stringify!(SkImage_RequiredProperties))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImage_RequiredProperties>(),
        1usize,
        concat!("Alignment of ", stringify!(SkImage_RequiredProperties))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMipmapped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImage_RequiredProperties),
            "::",
            stringify!(fMipmapped)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_LegacyBitmapMode {
    kRO_LegacyBitmapMode = 0,
}
pub type SkImage_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkImage() {
    const UNINIT: ::core::mem::MaybeUninit<SkImage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkImage>(),
        48usize,
        concat!("Size of: ", stringify!(SkImage))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImage>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImage),
            "::",
            stringify!(fInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImage),
            "::",
            stringify!(fUniqueID)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage9alphaTypeEv"]
    pub fn SkImage_alphaType(this: *const SkImage) -> SkAlphaType;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage9colorTypeEv"]
    pub fn SkImage_colorType(this: *const SkImage) -> SkColorType;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10colorSpaceEv"]
    pub fn SkImage_colorSpace(this: *const SkImage) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage13refColorSpaceEv"]
    pub fn SkImage_refColorSpace(this: *const SkImage) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage11isAlphaOnlyEv"]
    pub fn SkImage_isAlphaOnly(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10makeShaderE10SkTileModeS0_RK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkImage_makeShader(
        this: *const SkImage,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10makeShaderE10SkTileModeS0_RK17SkSamplingOptionsRK8SkMatrix"]
    pub fn SkImage_makeShader1(
        this: *const SkImage,
        tmx: SkTileMode,
        tmy: SkTileMode,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10makeShaderERK17SkSamplingOptionsRK8SkMatrix"]
    pub fn SkImage_makeShader2(
        this: *const SkImage,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10makeShaderERK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkImage_makeShader3(
        this: *const SkImage,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage13makeRawShaderE10SkTileModeS0_RK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkImage_makeRawShader(
        this: *const SkImage,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage13makeRawShaderE10SkTileModeS0_RK17SkSamplingOptionsRK8SkMatrix"]
    pub fn SkImage_makeRawShader1(
        this: *const SkImage,
        tmx: SkTileMode,
        tmy: SkTileMode,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage13makeRawShaderERK17SkSamplingOptionsRK8SkMatrix"]
    pub fn SkImage_makeRawShader2(
        this: *const SkImage,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage13makeRawShaderERK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkImage_makeRawShader3(
        this: *const SkImage,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10peekPixelsEP8SkPixmap"]
    pub fn SkImage_peekPixels(this: *const SkImage, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10readPixelsEP15GrDirectContextRK11SkImageInfoPvmiiNS_11CachingHintE"]
    pub fn SkImage_readPixels(
        this: *const SkImage,
        context: *mut GrDirectContext,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10readPixelsEP15GrDirectContextRK8SkPixmapiiNS_11CachingHintE"]
    pub fn SkImage_readPixels1(
        this: *const SkImage,
        context: *mut GrDirectContext,
        dst: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10readPixelsERK11SkImageInfoPvmiiNS_11CachingHintE"]
    pub fn SkImage_readPixels2(
        this: *const SkImage,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10readPixelsERK8SkPixmapiiNS_11CachingHintE"]
    pub fn SkImage_readPixels3(
        this: *const SkImage,
        dst: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage25asyncRescaleAndReadPixelsERK11SkImageInfoRK7SkIRectNS_12RescaleGammaENS_11RescaleModeEPFvPvNSt3__110unique_ptrIKNS_15AsyncReadResultENS9_14default_deleteISC_EEEEES8_"]
    pub fn SkImage_asyncRescaleAndReadPixels(
        this: *const SkImage,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage31asyncRescaleAndReadPixelsYUV420E15SkYUVColorSpace5sk_spI12SkColorSpaceERK7SkIRectRK7SkISizeNS_12RescaleGammaENS_11RescaleModeEPFvPvNSt3__110unique_ptrIKNS_15AsyncReadResultENSD_14default_deleteISG_EEEEESC_"]
    pub fn SkImage_asyncRescaleAndReadPixelsYUV420(
        this: *const SkImage,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage32asyncRescaleAndReadPixelsYUVA420E15SkYUVColorSpace5sk_spI12SkColorSpaceERK7SkIRectRK7SkISizeNS_12RescaleGammaENS_11RescaleModeEPFvPvNSt3__110unique_ptrIKNS_15AsyncReadResultENSD_14default_deleteISG_EEEEESC_"]
    pub fn SkImage_asyncRescaleAndReadPixelsYUVA420(
        this: *const SkImage,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage11scalePixelsERK8SkPixmapRK17SkSamplingOptionsNS_11CachingHintE"]
    pub fn SkImage_scalePixels(
        this: *const SkImage,
        dst: *const SkPixmap,
        arg1: *const SkSamplingOptions,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage14refEncodedDataEv"]
    pub fn SkImage_refEncodedData(this: *const SkImage) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10hasMipmapsEv"]
    pub fn SkImage_hasMipmaps(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage18withDefaultMipmapsEv"]
    pub fn SkImage_withDefaultMipmaps(this: *const SkImage) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage19makeNonTextureImageEP15GrDirectContext"]
    pub fn SkImage_makeNonTextureImage(
        this: *const SkImage,
        arg1: *mut GrDirectContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage15makeRasterImageEP15GrDirectContextNS_11CachingHintE"]
    pub fn SkImage_makeRasterImage(
        this: *const SkImage,
        arg1: *mut GrDirectContext,
        cachingHint: SkImage_CachingHint,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage14makeWithFilterEP18GrRecordingContextPK13SkImageFilterRK7SkIRectS7_PS5_P8SkIPoint"]
    pub fn SkImage_makeWithFilter(
        this: *const SkImage,
        context: *mut GrRecordingContext,
        filter: *const SkImageFilter,
        subset: *const SkIRect,
        clipBounds: *const SkIRect,
        outSubset: *mut SkIRect,
        offset: *mut SkIPoint,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage14asLegacyBitmapEP8SkBitmapNS_16LegacyBitmapModeE"]
    pub fn SkImage_asLegacyBitmap(
        this: *const SkImage,
        bitmap: *mut SkBitmap,
        legacyBitmapMode: SkImage_LegacyBitmapMode,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage21reinterpretColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkImage_reinterpretColorSpace(
        this: *const SkImage,
        newColorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage>;
}
impl SkImage {
    #[inline]
    pub unsafe fn alphaType(&self) -> SkAlphaType {
        SkImage_alphaType(self)
    }
    #[inline]
    pub unsafe fn colorType(&self) -> SkColorType {
        SkImage_colorType(self)
    }
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkImage_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkImage_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn isAlphaOnly(&self) -> bool {
        SkImage_isAlphaOnly(self)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeShader(self, tmx, tmy, arg1, localMatrix)
    }
    #[inline]
    pub unsafe fn makeShader1(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeShader1(self, tmx, tmy, sampling, lm)
    }
    #[inline]
    pub unsafe fn makeShader2(
        &self,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeShader2(self, sampling, lm)
    }
    #[inline]
    pub unsafe fn makeShader3(
        &self,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeShader3(self, sampling, lm)
    }
    #[inline]
    pub unsafe fn makeRawShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeRawShader(self, tmx, tmy, arg1, localMatrix)
    }
    #[inline]
    pub unsafe fn makeRawShader1(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeRawShader1(self, tmx, tmy, sampling, lm)
    }
    #[inline]
    pub unsafe fn makeRawShader2(
        &self,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeRawShader2(self, sampling, lm)
    }
    #[inline]
    pub unsafe fn makeRawShader3(
        &self,
        sampling: *const SkSamplingOptions,
        lm: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeRawShader3(self, sampling, lm)
    }
    #[inline]
    pub unsafe fn peekPixels(&self, pixmap: *mut SkPixmap) -> bool {
        SkImage_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn readPixels(
        &self,
        context: *mut GrDirectContext,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels(
            self,
            context,
            dstInfo,
            dstPixels,
            dstRowBytes,
            srcX,
            srcY,
            cachingHint,
        )
    }
    #[inline]
    pub unsafe fn readPixels1(
        &self,
        context: *mut GrDirectContext,
        dst: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels1(self, context, dst, srcX, srcY, cachingHint)
    }
    #[inline]
    pub unsafe fn readPixels2(
        &self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels2(
            self,
            dstInfo,
            dstPixels,
            dstRowBytes,
            srcX,
            srcY,
            cachingHint,
        )
    }
    #[inline]
    pub unsafe fn readPixels3(
        &self,
        dst: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels3(self, dst, srcX, srcY, cachingHint)
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixels(
        &self,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    ) {
        SkImage_asyncRescaleAndReadPixels(
            self,
            info,
            srcRect,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixelsYUV420(
        &self,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    ) {
        SkImage_asyncRescaleAndReadPixelsYUV420(
            self,
            yuvColorSpace,
            dstColorSpace,
            srcRect,
            dstSize,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixelsYUVA420(
        &self,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    ) {
        SkImage_asyncRescaleAndReadPixelsYUVA420(
            self,
            yuvColorSpace,
            dstColorSpace,
            srcRect,
            dstSize,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn scalePixels(
        &self,
        dst: *const SkPixmap,
        arg1: *const SkSamplingOptions,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_scalePixels(self, dst, arg1, cachingHint)
    }
    #[inline]
    pub unsafe fn refEncodedData(&self) -> sk_sp<SkData> {
        SkImage_refEncodedData(self)
    }
    #[inline]
    pub unsafe fn hasMipmaps(&self) -> bool {
        SkImage_hasMipmaps(self)
    }
    #[inline]
    pub unsafe fn withDefaultMipmaps(&self) -> sk_sp<SkImage> {
        SkImage_withDefaultMipmaps(self)
    }
    #[inline]
    pub unsafe fn makeNonTextureImage(&self, arg1: *mut GrDirectContext) -> sk_sp<SkImage> {
        SkImage_makeNonTextureImage(self, arg1)
    }
    #[inline]
    pub unsafe fn makeRasterImage(
        &self,
        arg1: *mut GrDirectContext,
        cachingHint: SkImage_CachingHint,
    ) -> sk_sp<SkImage> {
        SkImage_makeRasterImage(self, arg1, cachingHint)
    }
    #[inline]
    pub unsafe fn makeWithFilter(
        &self,
        context: *mut GrRecordingContext,
        filter: *const SkImageFilter,
        subset: *const SkIRect,
        clipBounds: *const SkIRect,
        outSubset: *mut SkIRect,
        offset: *mut SkIPoint,
    ) -> sk_sp<SkImage> {
        SkImage_makeWithFilter(self, context, filter, subset, clipBounds, outSubset, offset)
    }
    #[inline]
    pub unsafe fn asLegacyBitmap(
        &self,
        bitmap: *mut SkBitmap,
        legacyBitmapMode: SkImage_LegacyBitmapMode,
    ) -> bool {
        SkImage_asLegacyBitmap(self, bitmap, legacyBitmapMode)
    }
    #[inline]
    pub unsafe fn reinterpretColorSpace(
        &self,
        newColorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage> {
        SkImage_reinterpretColorSpace(self, newColorSpace)
    }
}
#[repr(C)]
pub struct SkImageGenerator__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkImageGenerator {
    pub vtable_: *const SkImageGenerator__bindgen_vtable,
    pub fInfo: SkImageInfo,
    pub fUniqueID: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImageGenerator_Options {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkImageGenerator_Options() {
    assert_eq!(
        ::core::mem::size_of::<SkImageGenerator_Options>(),
        1usize,
        concat!("Size of: ", stringify!(SkImageGenerator_Options))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageGenerator_Options>(),
        1usize,
        concat!("Alignment of ", stringify!(SkImageGenerator_Options))
    );
}
pub const SkImageGenerator_kNeedNewImageUniqueID: ::core::ffi::c_int = 0;
#[test]
fn bindgen_test_layout_SkImageGenerator() {
    const UNINIT: ::core::mem::MaybeUninit<SkImageGenerator> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkImageGenerator>(),
        40usize,
        concat!("Size of: ", stringify!(SkImageGenerator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageGenerator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImageGenerator))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageGenerator),
            "::",
            stringify!(fInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageGenerator),
            "::",
            stringify!(fUniqueID)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkImageGenerator9getPixelsERK11SkImageInfoPvm"]
    pub fn SkImageGenerator_getPixels(
        this: *mut SkImageGenerator,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkImageGenerator13queryYUVAInfoERKN16SkYUVAPixmapInfo18SupportedDataTypesEPS0_"]
    pub fn SkImageGenerator_queryYUVAInfo(
        this: *const SkImageGenerator,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkImageGenerator13getYUVAPlanesERK13SkYUVAPixmaps"]
    pub fn SkImageGenerator_getYUVAPlanes(
        this: *mut SkImageGenerator,
        yuvaPixmaps: *const SkYUVAPixmaps,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkImageGeneratorC1ERK11SkImageInfoj"]
    pub fn SkImageGenerator_SkImageGenerator(
        this: *mut SkImageGenerator,
        info: *const SkImageInfo,
        uniqueId: u32,
    );
}
impl SkImageGenerator {
    #[inline]
    pub unsafe fn getPixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
    ) -> bool {
        SkImageGenerator_getPixels(self, info, pixels, rowBytes)
    }
    #[inline]
    pub unsafe fn queryYUVAInfo(
        &self,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool {
        SkImageGenerator_queryYUVAInfo(self, supportedDataTypes, yuvaPixmapInfo)
    }
    #[inline]
    pub unsafe fn getYUVAPlanes(&mut self, yuvaPixmaps: *const SkYUVAPixmaps) -> bool {
        SkImageGenerator_getYUVAPlanes(self, yuvaPixmaps)
    }
    #[inline]
    pub unsafe fn new(info: *const SkImageInfo, uniqueId: u32) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkImageGenerator_SkImageGenerator(__bindgen_tmp.as_mut_ptr(), info, uniqueId);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkMaskFilter {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkMaskFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkMaskFilter>(),
        16usize,
        concat!("Size of: ", stringify!(SkMaskFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMaskFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkMaskFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkMaskFilter8MakeBlurE11SkBlurStylefb"]
    pub fn SkMaskFilter_MakeBlur(
        style: SkBlurStyle,
        sigma: SkScalar,
        respectCTM: bool,
    ) -> sk_sp<SkMaskFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkMaskFilter25approximateFilteredBoundsERK6SkRect"]
    pub fn SkMaskFilter_approximateFilteredBounds(
        this: *const SkMaskFilter,
        src: *const SkRect,
    ) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkMaskFilter11DeserializeEPKvmPK15SkDeserialProcs"]
    pub fn SkMaskFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkMaskFilter>;
}
impl SkMaskFilter {
    #[inline]
    pub unsafe fn MakeBlur(
        style: SkBlurStyle,
        sigma: SkScalar,
        respectCTM: bool,
    ) -> sk_sp<SkMaskFilter> {
        SkMaskFilter_MakeBlur(style, sigma, respectCTM)
    }
    #[inline]
    pub unsafe fn approximateFilteredBounds(&self, src: *const SkRect) -> SkRect {
        SkMaskFilter_approximateFilteredBounds(self, src)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkMaskFilter> {
        SkMaskFilter_Deserialize(data, size, procs)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkMutex {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkMutex() {
    assert_eq!(
        ::core::mem::size_of::<SkMutex>(),
        16usize,
        concat!("Size of: ", stringify!(SkMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(SkMutex))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSpan<T> {
    pub fPtr: *mut T,
    pub fSize: usize,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkIDChangeListener {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkIDChangeListener_List {
    pub fMutex: SkMutex,
    pub fListeners: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_SkIDChangeListener_List() {
    const UNINIT: ::core::mem::MaybeUninit<SkIDChangeListener_List> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkIDChangeListener_List>(),
        40usize,
        concat!("Size of: ", stringify!(SkIDChangeListener_List))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIDChangeListener_List>(),
        8usize,
        concat!("Alignment of ", stringify!(SkIDChangeListener_List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIDChangeListener_List),
            "::",
            stringify!(fMutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fListeners) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkIDChangeListener_List),
            "::",
            stringify!(fListeners)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4List3addE5sk_spIS_E"]
    pub fn SkIDChangeListener_List_add(
        this: *mut SkIDChangeListener_List,
        listener: sk_sp<SkIDChangeListener>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK18SkIDChangeListener4List5countEv"]
    pub fn SkIDChangeListener_List_count(
        this: *const SkIDChangeListener_List,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4List7changedEv"]
    pub fn SkIDChangeListener_List_changed(this: *mut SkIDChangeListener_List);
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4List5resetEv"]
    pub fn SkIDChangeListener_List_reset(this: *mut SkIDChangeListener_List);
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4ListC1Ev"]
    pub fn SkIDChangeListener_List_List(this: *mut SkIDChangeListener_List);
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4ListD1Ev"]
    pub fn SkIDChangeListener_List_List_destructor(this: *mut SkIDChangeListener_List);
}
impl SkIDChangeListener_List {
    #[inline]
    pub unsafe fn add(&mut self, listener: sk_sp<SkIDChangeListener>) {
        SkIDChangeListener_List_add(self, listener)
    }
    #[inline]
    pub unsafe fn count(&self) -> ::core::ffi::c_int {
        SkIDChangeListener_List_count(self)
    }
    #[inline]
    pub unsafe fn changed(&mut self) {
        SkIDChangeListener_List_changed(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkIDChangeListener_List_reset(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkIDChangeListener_List_List(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkIDChangeListener_List_List_destructor(self)
    }
}
#[test]
fn bindgen_test_layout_SkIDChangeListener() {
    assert_eq!(
        ::core::mem::size_of::<SkIDChangeListener>(),
        16usize,
        concat!("Size of: ", stringify!(SkIDChangeListener))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIDChangeListener>(),
        8usize,
        concat!("Alignment of ", stringify!(SkIDChangeListener))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListenerC2Ev"]
    pub fn SkIDChangeListener_SkIDChangeListener(this: *mut SkIDChangeListener);
}
impl SkIDChangeListener {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkIDChangeListener_SkIDChangeListener(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListenerD1Ev"]
    pub fn SkIDChangeListener_SkIDChangeListener_destructor(this: *mut SkIDChangeListener);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPathRef {
    pub _bindgen_opaque_blob: [u64; 22usize],
}
pub type SkPathRef_PointsArray = [u64; 6usize];
pub type SkPathRef_VerbsArray = [u64; 3usize];
pub type SkPathRef_ConicWeightsArray = [u64; 3usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPathRef_Iter {
    pub fPts: *const SkPoint,
    pub fVerbs: *const u8,
    pub fVerbStop: *const u8,
    pub fConicWeights: *const SkScalar,
}
#[test]
fn bindgen_test_layout_SkPathRef_Iter() {
    const UNINIT: ::core::mem::MaybeUninit<SkPathRef_Iter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPathRef_Iter>(),
        32usize,
        concat!("Size of: ", stringify!(SkPathRef_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathRef_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathRef_Iter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathRef_Iter),
            "::",
            stringify!(fPts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVerbs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathRef_Iter),
            "::",
            stringify!(fVerbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVerbStop) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathRef_Iter),
            "::",
            stringify!(fVerbStop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fConicWeights) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathRef_Iter),
            "::",
            stringify!(fConicWeights)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef4Iter10setPathRefERKS_"]
    pub fn SkPathRef_Iter_setPathRef(this: *mut SkPathRef_Iter, arg1: *const SkPathRef);
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef4Iter4nextEP7SkPoint"]
    pub fn SkPathRef_Iter_next(this: *mut SkPathRef_Iter, pts: *mut SkPoint) -> u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPathRef4Iter4peekEv"]
    pub fn SkPathRef_Iter_peek(this: *const SkPathRef_Iter) -> u8;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef4IterC1Ev"]
    pub fn SkPathRef_Iter_Iter(this: *mut SkPathRef_Iter);
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef4IterC1ERKS_"]
    pub fn SkPathRef_Iter_Iter1(this: *mut SkPathRef_Iter, arg1: *const SkPathRef);
}
impl SkPathRef_Iter {
    #[inline]
    pub unsafe fn setPathRef(&mut self, arg1: *const SkPathRef) {
        SkPathRef_Iter_setPathRef(self, arg1)
    }
    #[inline]
    pub unsafe fn next(&mut self, pts: *mut SkPoint) -> u8 {
        SkPathRef_Iter_next(self, pts)
    }
    #[inline]
    pub unsafe fn peek(&self) -> u8 {
        SkPathRef_Iter_peek(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathRef_Iter_Iter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const SkPathRef) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathRef_Iter_Iter1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathRef_SerializationOffsets {
    kLegacyRRectOrOvalStartIdx_SerializationShift = 28,
    kLegacyRRectOrOvalIsCCW_SerializationShift = 27,
    kLegacyIsRRect_SerializationShift = 26,
    kIsFinite_SerializationShift = 25,
    kLegacyIsOval_SerializationShift = 24,
    kSegmentMask_SerializationShift = 0,
}
pub const SkPathRef_kMinSize: SkPathRef__bindgen_ty_1 = SkPathRef__bindgen_ty_1::kMinSize;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathRef__bindgen_ty_1 {
    kMinSize = 256,
}
pub const SkPathRef_kEmptyGenID: SkPathRef__bindgen_ty_2 = SkPathRef__bindgen_ty_2::kEmptyGenID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathRef__bindgen_ty_2 {
    kEmptyGenID = 1,
}
#[test]
fn bindgen_test_layout_SkPathRef() {
    assert_eq!(
        ::core::mem::size_of::<SkPathRef>(),
        176usize,
        concat!("Size of: ", stringify!(SkPathRef))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathRef>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathRef))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef11CreateEmptyEv"]
    pub fn SkPathRef_CreateEmpty() -> *mut SkPathRef;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPathRef7isRRectEP7SkRRectPbPj"]
    pub fn SkPathRef_isRRect(
        this: *const SkPathRef,
        rrect: *mut SkRRect,
        isCCW: *mut bool,
        start: *mut ::core::ffi::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPathRef8getRRectEv"]
    pub fn SkPathRef_getRRect(this: *const SkPathRef) -> SkRRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef21CreateTransformedCopyEP5sk_spIS_ERKS_RK8SkMatrix"]
    pub fn SkPathRef_CreateTransformedCopy(
        dst: *mut sk_sp<SkPathRef>,
        src: *const SkPathRef,
        matrix: *const SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef6RewindEP5sk_spIS_E"]
    pub fn SkPathRef_Rewind(pathRef: *mut sk_sp<SkPathRef>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPathRef20approximateBytesUsedEv"]
    pub fn SkPathRef_approximateBytesUsed(this: *const SkPathRef) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPathRef11interpolateERKS_fPS_"]
    pub fn SkPathRef_interpolate(
        this: *const SkPathRef,
        ending: *const SkPathRef,
        weight: SkScalar,
        out: *mut SkPathRef,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPathRef5genIDEh"]
    pub fn SkPathRef_genID(this: *const SkPathRef, fillType: u8) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef22addGenIDChangeListenerE5sk_spI18SkIDChangeListenerE"]
    pub fn SkPathRef_addGenIDChangeListener(this: *mut SkPathRef, arg1: sk_sp<SkIDChangeListener>);
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef24genIDChangeListenerCountEv"]
    pub fn SkPathRef_genIDChangeListenerCount(this: *mut SkPathRef) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPathRef16dataMatchesVerbsEv"]
    pub fn SkPathRef_dataMatchesVerbs(this: *const SkPathRef) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPathRef7isValidEv"]
    pub fn SkPathRef_isValid(this: *const SkPathRef) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRef5resetEv"]
    pub fn SkPathRef_reset(this: *mut SkPathRef);
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPathRefD1Ev"]
    pub fn SkPathRef_SkPathRef_destructor(this: *mut SkPathRef);
}
impl SkPathRef {
    #[inline]
    pub unsafe fn CreateEmpty() -> *mut SkPathRef {
        SkPathRef_CreateEmpty()
    }
    #[inline]
    pub unsafe fn isRRect(
        &self,
        rrect: *mut SkRRect,
        isCCW: *mut bool,
        start: *mut ::core::ffi::c_uint,
    ) -> bool {
        SkPathRef_isRRect(self, rrect, isCCW, start)
    }
    #[inline]
    pub unsafe fn getRRect(&self) -> SkRRect {
        SkPathRef_getRRect(self)
    }
    #[inline]
    pub unsafe fn CreateTransformedCopy(
        dst: *mut sk_sp<SkPathRef>,
        src: *const SkPathRef,
        matrix: *const SkMatrix,
    ) {
        SkPathRef_CreateTransformedCopy(dst, src, matrix)
    }
    #[inline]
    pub unsafe fn Rewind(pathRef: *mut sk_sp<SkPathRef>) {
        SkPathRef_Rewind(pathRef)
    }
    #[inline]
    pub unsafe fn approximateBytesUsed(&self) -> usize {
        SkPathRef_approximateBytesUsed(self)
    }
    #[inline]
    pub unsafe fn interpolate(
        &self,
        ending: *const SkPathRef,
        weight: SkScalar,
        out: *mut SkPathRef,
    ) {
        SkPathRef_interpolate(self, ending, weight, out)
    }
    #[inline]
    pub unsafe fn genID(&self, fillType: u8) -> u32 {
        SkPathRef_genID(self, fillType)
    }
    #[inline]
    pub unsafe fn addGenIDChangeListener(&mut self, arg1: sk_sp<SkIDChangeListener>) {
        SkPathRef_addGenIDChangeListener(self, arg1)
    }
    #[inline]
    pub unsafe fn genIDChangeListenerCount(&mut self) -> ::core::ffi::c_int {
        SkPathRef_genIDChangeListenerCount(self)
    }
    #[inline]
    pub unsafe fn dataMatchesVerbs(&self) -> bool {
        SkPathRef_dataMatchesVerbs(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        SkPathRef_isValid(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPathRef_reset(self)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPathRef_SkPathRef_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathBuilder {
    pub fPts: SkPathRef_PointsArray,
    pub fVerbs: SkPathRef_VerbsArray,
    pub fConicWeights: SkPathRef_ConicWeightsArray,
    pub fFillType: SkPathFillType,
    pub fIsVolatile: bool,
    pub fSegmentMask: ::core::ffi::c_uint,
    pub fLastMovePoint: SkPoint,
    pub fLastMoveIndex: ::core::ffi::c_int,
    pub fNeedsMoveVerb: bool,
    pub fIsA: SkPathBuilder_IsA,
    pub fIsAStart: ::core::ffi::c_int,
    pub fIsACCW: bool,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathBuilder_ArcSize {
    Small = 0,
    Large = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathBuilder_IsA {
    kIsA_JustMoves = 0,
    kIsA_MoreThanMoves = 1,
    kIsA_Oval = 2,
    kIsA_RRect = 3,
}
#[test]
fn bindgen_test_layout_SkPathBuilder() {
    const UNINIT: ::core::mem::MaybeUninit<SkPathBuilder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPathBuilder>(),
        136usize,
        concat!("Size of: ", stringify!(SkPathBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathBuilder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fPts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVerbs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fVerbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fConicWeights) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fConicWeights)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFillType) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fFillType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsVolatile) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fIsVolatile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSegmentMask) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fSegmentMask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLastMovePoint) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fLastMovePoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLastMoveIndex) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fLastMoveIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fNeedsMoveVerb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fNeedsMoveVerb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsA) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fIsA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsAStart) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fIsAStart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsACCW) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathBuilder),
            "::",
            stringify!(fIsACCW)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkPathBuilder13computeBoundsEv"]
    pub fn SkPathBuilder_computeBounds(this: *const SkPathBuilder) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkPathBuilder8snapshotEv"]
    pub fn SkPathBuilder_snapshot(this: *const SkPathBuilder) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6detachEv"]
    pub fn SkPathBuilder_detach(this: *mut SkPathBuilder) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5resetEv"]
    pub fn SkPathBuilder_reset(this: *mut SkPathBuilder) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6moveToE7SkPoint"]
    pub fn SkPathBuilder_moveTo(this: *mut SkPathBuilder, pt: SkPoint) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6lineToE7SkPoint"]
    pub fn SkPathBuilder_lineTo(this: *mut SkPathBuilder, pt: SkPoint) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6quadToE7SkPointS0_"]
    pub fn SkPathBuilder_quadTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7conicToE7SkPointS0_f"]
    pub fn SkPathBuilder_conicTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
        w: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7cubicToE7SkPointS0_S0_"]
    pub fn SkPathBuilder_cubicTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5closeEv"]
    pub fn SkPathBuilder_close(this: *mut SkPathBuilder) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder10polylineToEPK7SkPointi"]
    pub fn SkPathBuilder_polylineTo(
        this: *mut SkPathBuilder,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7rLineToE7SkPoint"]
    pub fn SkPathBuilder_rLineTo(this: *mut SkPathBuilder, pt: SkPoint) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7rQuadToE7SkPointS0_"]
    pub fn SkPathBuilder_rQuadTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder8rConicToE7SkPointS0_f"]
    pub fn SkPathBuilder_rConicTo(
        this: *mut SkPathBuilder,
        p1: SkPoint,
        p2: SkPoint,
        w: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder8rCubicToE7SkPointS0_S0_"]
    pub fn SkPathBuilder_rCubicTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5arcToERK6SkRectffb"]
    pub fn SkPathBuilder_arcTo(
        this: *mut SkPathBuilder,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5arcToE7SkPointS0_f"]
    pub fn SkPathBuilder_arcTo1(
        this: *mut SkPathBuilder,
        p1: SkPoint,
        p2: SkPoint,
        radius: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5arcToE7SkPointfNS_7ArcSizeE15SkPathDirectionS0_"]
    pub fn SkPathBuilder_arcTo2(
        this: *mut SkPathBuilder,
        r: SkPoint,
        xAxisRotate: SkScalar,
        largeArc: SkPathBuilder_ArcSize,
        sweep: SkPathDirection,
        xy: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6addArcERK6SkRectff"]
    pub fn SkPathBuilder_addArc(
        this: *mut SkPathBuilder,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7addRectERK6SkRect15SkPathDirectionj"]
    pub fn SkPathBuilder_addRect(
        this: *mut SkPathBuilder,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7addOvalERK6SkRect15SkPathDirectionj"]
    pub fn SkPathBuilder_addOval(
        this: *mut SkPathBuilder,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder8addRRectERK7SkRRect15SkPathDirectionj"]
    pub fn SkPathBuilder_addRRect(
        this: *mut SkPathBuilder,
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder9addCircleEfff15SkPathDirection"]
    pub fn SkPathBuilder_addCircle(
        this: *mut SkPathBuilder,
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder10addPolygonEPK7SkPointib"]
    pub fn SkPathBuilder_addPolygon(
        this: *mut SkPathBuilder,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
        isClosed: bool,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7addPathERK6SkPath"]
    pub fn SkPathBuilder_addPath(
        this: *mut SkPathBuilder,
        arg1: *const SkPath,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder10incReserveEii"]
    pub fn SkPathBuilder_incReserve(
        this: *mut SkPathBuilder,
        extraPtCount: ::core::ffi::c_int,
        extraVerbCount: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6offsetEff"]
    pub fn SkPathBuilder_offset(
        this: *mut SkPathBuilder,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilderC1Ev"]
    pub fn SkPathBuilder_SkPathBuilder(this: *mut SkPathBuilder);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilderC1E14SkPathFillType"]
    pub fn SkPathBuilder_SkPathBuilder1(this: *mut SkPathBuilder, arg1: SkPathFillType);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilderC1ERK6SkPath"]
    pub fn SkPathBuilder_SkPathBuilder2(this: *mut SkPathBuilder, arg1: *const SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilderD1Ev"]
    pub fn SkPathBuilder_SkPathBuilder_destructor(this: *mut SkPathBuilder);
}
impl SkPathBuilder {
    #[inline]
    pub unsafe fn computeBounds(&self) -> SkRect {
        SkPathBuilder_computeBounds(self)
    }
    #[inline]
    pub unsafe fn snapshot(&self) -> SkPath {
        SkPathBuilder_snapshot(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> SkPath {
        SkPathBuilder_detach(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) -> *mut SkPathBuilder {
        SkPathBuilder_reset(self)
    }
    #[inline]
    pub unsafe fn moveTo(&mut self, pt: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_moveTo(self, pt)
    }
    #[inline]
    pub unsafe fn lineTo(&mut self, pt: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_lineTo(self, pt)
    }
    #[inline]
    pub unsafe fn quadTo(&mut self, pt1: SkPoint, pt2: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_quadTo(self, pt1, pt2)
    }
    #[inline]
    pub unsafe fn conicTo(
        &mut self,
        pt1: SkPoint,
        pt2: SkPoint,
        w: SkScalar,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_conicTo(self, pt1, pt2, w)
    }
    #[inline]
    pub unsafe fn cubicTo(
        &mut self,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_cubicTo(self, pt1, pt2, pt3)
    }
    #[inline]
    pub unsafe fn close(&mut self) -> *mut SkPathBuilder {
        SkPathBuilder_close(self)
    }
    #[inline]
    pub unsafe fn polylineTo(
        &mut self,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_polylineTo(self, pts, count)
    }
    #[inline]
    pub unsafe fn rLineTo(&mut self, pt: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_rLineTo(self, pt)
    }
    #[inline]
    pub unsafe fn rQuadTo(&mut self, pt1: SkPoint, pt2: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_rQuadTo(self, pt1, pt2)
    }
    #[inline]
    pub unsafe fn rConicTo(&mut self, p1: SkPoint, p2: SkPoint, w: SkScalar) -> *mut SkPathBuilder {
        SkPathBuilder_rConicTo(self, p1, p2, w)
    }
    #[inline]
    pub unsafe fn rCubicTo(
        &mut self,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_rCubicTo(self, pt1, pt2, pt3)
    }
    #[inline]
    pub unsafe fn arcTo(
        &mut self,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_arcTo(self, oval, startAngleDeg, sweepAngleDeg, forceMoveTo)
    }
    #[inline]
    pub unsafe fn arcTo1(
        &mut self,
        p1: SkPoint,
        p2: SkPoint,
        radius: SkScalar,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_arcTo1(self, p1, p2, radius)
    }
    #[inline]
    pub unsafe fn arcTo2(
        &mut self,
        r: SkPoint,
        xAxisRotate: SkScalar,
        largeArc: SkPathBuilder_ArcSize,
        sweep: SkPathDirection,
        xy: SkPoint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_arcTo2(self, r, xAxisRotate, largeArc, sweep, xy)
    }
    #[inline]
    pub unsafe fn addArc(
        &mut self,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addArc(self, oval, startAngleDeg, sweepAngleDeg)
    }
    #[inline]
    pub unsafe fn addRect(
        &mut self,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addRect(self, arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn addOval(
        &mut self,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addOval(self, arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn addRRect(
        &mut self,
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addRRect(self, arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn addCircle(
        &mut self,
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addCircle(self, center_x, center_y, radius, dir)
    }
    #[inline]
    pub unsafe fn addPolygon(
        &mut self,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
        isClosed: bool,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addPolygon(self, pts, count, isClosed)
    }
    #[inline]
    pub unsafe fn addPath(&mut self, arg1: *const SkPath) -> *mut SkPathBuilder {
        SkPathBuilder_addPath(self, arg1)
    }
    #[inline]
    pub unsafe fn incReserve(
        &mut self,
        extraPtCount: ::core::ffi::c_int,
        extraVerbCount: ::core::ffi::c_int,
    ) {
        SkPathBuilder_incReserve(self, extraPtCount, extraVerbCount)
    }
    #[inline]
    pub unsafe fn offset(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkPathBuilder {
        SkPathBuilder_offset(self, dx, dy)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathBuilder_SkPathBuilder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: SkPathFillType) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathBuilder_SkPathBuilder1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkPath) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathBuilder_SkPathBuilder2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPathBuilder_SkPathBuilder_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathMeasure {
    pub fIter: SkContourMeasureIter,
    pub fContour: sk_sp<SkContourMeasure>,
}
pub const SkPathMeasure_MatrixFlags_kGetPosition_MatrixFlag: SkPathMeasure_MatrixFlags = 1;
pub const SkPathMeasure_MatrixFlags_kGetTangent_MatrixFlag: SkPathMeasure_MatrixFlags = 2;
pub const SkPathMeasure_MatrixFlags_kGetPosAndTan_MatrixFlag: SkPathMeasure_MatrixFlags = 3;
pub type SkPathMeasure_MatrixFlags = ::core::ffi::c_uint;
#[test]
fn bindgen_test_layout_SkPathMeasure() {
    const UNINIT: ::core::mem::MaybeUninit<SkPathMeasure> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPathMeasure>(),
        16usize,
        concat!("Size of: ", stringify!(SkPathMeasure))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathMeasure>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathMeasure))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathMeasure),
            "::",
            stringify!(fIter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fContour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathMeasure),
            "::",
            stringify!(fContour)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure7setPathEPK6SkPathb"]
    pub fn SkPathMeasure_setPath(this: *mut SkPathMeasure, arg1: *const SkPath, forceClosed: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure9getLengthEv"]
    pub fn SkPathMeasure_getLength(this: *mut SkPathMeasure) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure9getPosTanEfP7SkPointS1_"]
    pub fn SkPathMeasure_getPosTan(
        this: *mut SkPathMeasure,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure9getMatrixEfP8SkMatrixNS_11MatrixFlagsE"]
    pub fn SkPathMeasure_getMatrix(
        this: *mut SkPathMeasure,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkPathMeasure_MatrixFlags,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure10getSegmentEffP6SkPathb"]
    pub fn SkPathMeasure_getSegment(
        this: *mut SkPathMeasure,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure8isClosedEv"]
    pub fn SkPathMeasure_isClosed(this: *mut SkPathMeasure) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure11nextContourEv"]
    pub fn SkPathMeasure_nextContour(this: *mut SkPathMeasure) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasureC1Ev"]
    pub fn SkPathMeasure_SkPathMeasure(this: *mut SkPathMeasure);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasureC1ERK6SkPathbf"]
    pub fn SkPathMeasure_SkPathMeasure1(
        this: *mut SkPathMeasure,
        path: *const SkPath,
        forceClosed: bool,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasureD1Ev"]
    pub fn SkPathMeasure_SkPathMeasure_destructor(this: *mut SkPathMeasure);
}
impl SkPathMeasure {
    #[inline]
    pub unsafe fn setPath(&mut self, arg1: *const SkPath, forceClosed: bool) {
        SkPathMeasure_setPath(self, arg1, forceClosed)
    }
    #[inline]
    pub unsafe fn getLength(&mut self) -> SkScalar {
        SkPathMeasure_getLength(self)
    }
    #[inline]
    pub unsafe fn getPosTan(
        &mut self,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool {
        SkPathMeasure_getPosTan(self, distance, position, tangent)
    }
    #[inline]
    pub unsafe fn getMatrix(
        &mut self,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkPathMeasure_MatrixFlags,
    ) -> bool {
        SkPathMeasure_getMatrix(self, distance, matrix, flags)
    }
    #[inline]
    pub unsafe fn getSegment(
        &mut self,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool {
        SkPathMeasure_getSegment(self, startD, stopD, dst, startWithMoveTo)
    }
    #[inline]
    pub unsafe fn isClosed(&mut self) -> bool {
        SkPathMeasure_isClosed(self)
    }
    #[inline]
    pub unsafe fn nextContour(&mut self) -> bool {
        SkPathMeasure_nextContour(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathMeasure_SkPathMeasure(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath, forceClosed: bool, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathMeasure_SkPathMeasure1(__bindgen_tmp.as_mut_ptr(), path, forceClosed, resScale);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPathMeasure_SkPathMeasure_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShader {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkShader_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkShader() {
    assert_eq!(
        ::core::mem::size_of::<SkShader>(),
        16usize,
        concat!("Size of: ", stringify!(SkShader))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShader>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShader))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkShader8isAImageEP8SkMatrixP10SkTileMode"]
    pub fn SkShader_isAImage(
        this: *const SkShader,
        localMatrix: *mut SkMatrix,
        xy: *mut SkTileMode,
    ) -> *mut SkImage;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkShader19makeWithLocalMatrixERK8SkMatrix"]
    pub fn SkShader_makeWithLocalMatrix(
        this: *const SkShader,
        arg1: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkShader19makeWithColorFilterE5sk_spI13SkColorFilterE"]
    pub fn SkShader_makeWithColorFilter(
        this: *const SkShader,
        arg1: sk_sp<SkColorFilter>,
    ) -> sk_sp<SkShader>;
}
impl SkShader {
    #[inline]
    pub unsafe fn isAImage(&self, localMatrix: *mut SkMatrix, xy: *mut SkTileMode) -> *mut SkImage {
        SkShader_isAImage(self, localMatrix, xy)
    }
    #[inline]
    pub unsafe fn makeWithLocalMatrix(&self, arg1: *const SkMatrix) -> sk_sp<SkShader> {
        SkShader_makeWithLocalMatrix(self, arg1)
    }
    #[inline]
    pub unsafe fn makeWithColorFilter(&self, arg1: sk_sp<SkColorFilter>) -> sk_sp<SkShader> {
        SkShader_makeWithColorFilter(self, arg1)
    }
}
impl SkTileMode {
    pub const LastTileMode: SkTileMode = SkTileMode::Decal;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTileMode {
    Clamp = 0,
    Repeat = 1,
    Mirror = 2,
    Decal = 3,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPicture {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPicture_AbortCallback {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkPicture_AbortCallback() {
    assert_eq!(
        ::core::mem::size_of::<SkPicture_AbortCallback>(),
        8usize,
        concat!("Size of: ", stringify!(SkPicture_AbortCallback))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPicture_AbortCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPicture_AbortCallback))
    );
}
#[test]
fn bindgen_test_layout_SkPicture() {
    assert_eq!(
        ::core::mem::size_of::<SkPicture>(),
        24usize,
        concat!("Size of: ", stringify!(SkPicture))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPicture>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPicture))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPicture14MakeFromStreamEP8SkStreamPK15SkDeserialProcs"]
    pub fn SkPicture_MakeFromStream(
        stream: *mut SkStream,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPicture12MakeFromDataEPK6SkDataPK15SkDeserialProcs"]
    pub fn SkPicture_MakeFromData(
        data: *const SkData,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPicture12MakeFromDataEPKvmPK15SkDeserialProcs"]
    pub fn SkPicture_MakeFromData1(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPicture9serializeEPK13SkSerialProcs"]
    pub fn SkPicture_serialize(
        this: *const SkPicture,
        procs: *const SkSerialProcs,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPicture9serializeEP9SkWStreamPK13SkSerialProcs"]
    pub fn SkPicture_serialize1(
        this: *const SkPicture,
        stream: *mut SkWStream,
        procs: *const SkSerialProcs,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPicture15MakePlaceholderE6SkRect"]
    pub fn SkPicture_MakePlaceholder(cull: SkRect) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPicture10makeShaderE10SkTileModeS0_12SkFilterModePK8SkMatrixPK6SkRect"]
    pub fn SkPicture_makeShader(
        this: *const SkPicture,
        tmx: SkTileMode,
        tmy: SkTileMode,
        mode: SkFilterMode,
        localMatrix: *const SkMatrix,
        tileRect: *const SkRect,
    ) -> sk_sp<SkShader>;
}
impl SkPicture {
    #[inline]
    pub unsafe fn MakeFromStream(
        stream: *mut SkStream,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture> {
        SkPicture_MakeFromStream(stream, procs)
    }
    #[inline]
    pub unsafe fn MakeFromData(
        data: *const SkData,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture> {
        SkPicture_MakeFromData(data, procs)
    }
    #[inline]
    pub unsafe fn MakeFromData1(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture> {
        SkPicture_MakeFromData1(data, size, procs)
    }
    #[inline]
    pub unsafe fn serialize(&self, procs: *const SkSerialProcs) -> sk_sp<SkData> {
        SkPicture_serialize(self, procs)
    }
    #[inline]
    pub unsafe fn serialize1(&self, stream: *mut SkWStream, procs: *const SkSerialProcs) {
        SkPicture_serialize1(self, stream, procs)
    }
    #[inline]
    pub unsafe fn MakePlaceholder(cull: SkRect) -> sk_sp<SkPicture> {
        SkPicture_MakePlaceholder(cull)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        mode: SkFilterMode,
        localMatrix: *const SkMatrix,
        tileRect: *const SkRect,
    ) -> sk_sp<SkShader> {
        SkPicture_makeShader(self, tmx, tmy, mode, localMatrix, tileRect)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPictureD1Ev"]
    pub fn SkPicture_SkPicture_destructor(this: *mut SkPicture);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBBHFactory {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBBoxHierarchy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRecord {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRecorder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPictureRecorder {
    pub fActivelyRecording: bool,
    pub fCullRect: SkRect,
    pub fBBH: sk_sp<SkBBoxHierarchy>,
    pub fRecorder: u64,
    pub fRecord: sk_sp<SkRecord>,
}
#[test]
fn bindgen_test_layout_SkPictureRecorder() {
    const UNINIT: ::core::mem::MaybeUninit<SkPictureRecorder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPictureRecorder>(),
        48usize,
        concat!("Size of: ", stringify!(SkPictureRecorder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPictureRecorder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPictureRecorder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fActivelyRecording) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fActivelyRecording)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCullRect) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fCullRect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBBH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fBBH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRecorder) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fRecorder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRecord) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPictureRecorder),
            "::",
            stringify!(fRecord)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder14beginRecordingERK6SkRect5sk_spI15SkBBoxHierarchyE"]
    pub fn SkPictureRecorder_beginRecording(
        this: *mut SkPictureRecorder,
        bounds: *const SkRect,
        bbh: sk_sp<SkBBoxHierarchy>,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder14beginRecordingERK6SkRectP12SkBBHFactory"]
    pub fn SkPictureRecorder_beginRecording1(
        this: *mut SkPictureRecorder,
        bounds: *const SkRect,
        bbhFactory: *mut SkBBHFactory,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder18getRecordingCanvasEv"]
    pub fn SkPictureRecorder_getRecordingCanvas(this: *mut SkPictureRecorder) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder24finishRecordingAsPictureEv"]
    pub fn SkPictureRecorder_finishRecordingAsPicture(
        this: *mut SkPictureRecorder,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder32finishRecordingAsPictureWithCullERK6SkRect"]
    pub fn SkPictureRecorder_finishRecordingAsPictureWithCull(
        this: *mut SkPictureRecorder,
        cullRect: *const SkRect,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder25finishRecordingAsDrawableEv"]
    pub fn SkPictureRecorder_finishRecordingAsDrawable(
        this: *mut SkPictureRecorder,
    ) -> sk_sp<SkDrawable>;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorderC1Ev"]
    pub fn SkPictureRecorder_SkPictureRecorder(this: *mut SkPictureRecorder);
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorderD1Ev"]
    pub fn SkPictureRecorder_SkPictureRecorder_destructor(this: *mut SkPictureRecorder);
}
impl SkPictureRecorder {
    #[inline]
    pub unsafe fn beginRecording(
        &mut self,
        bounds: *const SkRect,
        bbh: sk_sp<SkBBoxHierarchy>,
    ) -> *mut SkCanvas {
        SkPictureRecorder_beginRecording(self, bounds, bbh)
    }
    #[inline]
    pub unsafe fn beginRecording1(
        &mut self,
        bounds: *const SkRect,
        bbhFactory: *mut SkBBHFactory,
    ) -> *mut SkCanvas {
        SkPictureRecorder_beginRecording1(self, bounds, bbhFactory)
    }
    #[inline]
    pub unsafe fn getRecordingCanvas(&mut self) -> *mut SkCanvas {
        SkPictureRecorder_getRecordingCanvas(self)
    }
    #[inline]
    pub unsafe fn finishRecordingAsPicture(&mut self) -> sk_sp<SkPicture> {
        SkPictureRecorder_finishRecordingAsPicture(self)
    }
    #[inline]
    pub unsafe fn finishRecordingAsPictureWithCull(
        &mut self,
        cullRect: *const SkRect,
    ) -> sk_sp<SkPicture> {
        SkPictureRecorder_finishRecordingAsPictureWithCull(self, cullRect)
    }
    #[inline]
    pub unsafe fn finishRecordingAsDrawable(&mut self) -> sk_sp<SkDrawable> {
        SkPictureRecorder_finishRecordingAsDrawable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPictureRecorder_SkPictureRecorder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPictureRecorder_SkPictureRecorder_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPixelRef {
    pub _bindgen_opaque_blob: [u64; 12usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPixelRef_Mutability {
    kMutable = 0,
    kTemporarilyImmutable = 1,
    kImmutable = 2,
}
pub type SkPixelRef_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkPixelRef() {
    assert_eq!(
        ::core::mem::size_of::<SkPixelRef>(),
        96usize,
        concat!("Size of: ", stringify!(SkPixelRef))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPixelRef>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPixelRef))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkPixelRef15getGenerationIDEv"]
    pub fn SkPixelRef_getGenerationID(this: *const SkPixelRef) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRef19notifyPixelsChangedEv"]
    pub fn SkPixelRef_notifyPixelsChanged(this: *mut SkPixelRef);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRef12setImmutableEv"]
    pub fn SkPixelRef_setImmutable(this: *mut SkPixelRef);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRef22addGenIDChangeListenerE5sk_spI18SkIDChangeListenerE"]
    pub fn SkPixelRef_addGenIDChangeListener(
        this: *mut SkPixelRef,
        listener: sk_sp<SkIDChangeListener>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRef18android_only_resetEiim"]
    pub fn SkPixelRef_android_only_reset(
        this: *mut SkPixelRef,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        rowBytes: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRefC1EiiPvm"]
    pub fn SkPixelRef_SkPixelRef(
        this: *mut SkPixelRef,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        addr: *mut ::core::ffi::c_void,
        rowBytes: usize,
    );
}
impl SkPixelRef {
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkPixelRef_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn notifyPixelsChanged(&mut self) {
        SkPixelRef_notifyPixelsChanged(self)
    }
    #[inline]
    pub unsafe fn setImmutable(&mut self) {
        SkPixelRef_setImmutable(self)
    }
    #[inline]
    pub unsafe fn addGenIDChangeListener(&mut self, listener: sk_sp<SkIDChangeListener>) {
        SkPixelRef_addGenIDChangeListener(self, listener)
    }
    #[inline]
    pub unsafe fn android_only_reset(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        rowBytes: usize,
    ) {
        SkPixelRef_android_only_reset(self, width, height, rowBytes)
    }
    #[inline]
    pub unsafe fn new(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        addr: *mut ::core::ffi::c_void,
        rowBytes: usize,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPixelRef_SkPixelRef(__bindgen_tmp.as_mut_ptr(), width, height, addr, rowBytes);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRefD1Ev"]
    pub fn SkPixelRef_SkPixelRef_destructor(this: *mut SkPixelRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPoint3 {
    pub fX: SkScalar,
    pub fY: SkScalar,
    pub fZ: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPoint3() {
    const UNINIT: ::core::mem::MaybeUninit<SkPoint3> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPoint3>(),
        12usize,
        concat!("Size of: ", stringify!(SkPoint3))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPoint3>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPoint3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint3),
            "::",
            stringify!(fX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint3),
            "::",
            stringify!(fY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fZ) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPoint3),
            "::",
            stringify!(fZ)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPoint36LengthEfff"]
    pub fn SkPoint3_Length(x: SkScalar, y: SkScalar, z: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPoint39normalizeEv"]
    pub fn SkPoint3_normalize(this: *mut SkPoint3) -> bool;
}
impl SkPoint3 {
    #[inline]
    pub unsafe fn Length(x: SkScalar, y: SkScalar, z: SkScalar) -> SkScalar {
        SkPoint3_Length(x, y, z)
    }
    #[inline]
    pub unsafe fn normalize(&mut self) -> bool {
        SkPoint3_normalize(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRegion {
    pub fBounds: SkIRect,
    pub fRunHead: *mut SkRegion_RunHead,
}
pub type SkRegion_RunType = i32;
impl SkRegion_Op {
    pub const LastOp: SkRegion_Op = SkRegion_Op::Replace;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRegion_Op {
    Difference = 0,
    Intersect = 1,
    Union = 2,
    XOR = 3,
    ReverseDifference = 4,
    Replace = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_Iterator {
    pub fRgn: *const SkRegion,
    pub fRuns: *const SkRegion_RunType,
    pub fRect: SkIRect,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Iterator() {
    const UNINIT: ::core::mem::MaybeUninit<SkRegion_Iterator> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRegion_Iterator>(),
        40usize,
        concat!("Size of: ", stringify!(SkRegion_Iterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion_Iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion_Iterator))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRgn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Iterator),
            "::",
            stringify!(fRgn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRuns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Iterator),
            "::",
            stringify!(fRuns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Iterator),
            "::",
            stringify!(fRect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDone) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Iterator),
            "::",
            stringify!(fDone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8Iterator6rewindEv"]
    pub fn SkRegion_Iterator_rewind(this: *mut SkRegion_Iterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8Iterator5resetERKS_"]
    pub fn SkRegion_Iterator_reset(this: *mut SkRegion_Iterator, region: *const SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8Iterator4nextEv"]
    pub fn SkRegion_Iterator_next(this: *mut SkRegion_Iterator);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8IteratorC1ERKS_"]
    pub fn SkRegion_Iterator_Iterator(this: *mut SkRegion_Iterator, region: *const SkRegion);
}
impl SkRegion_Iterator {
    #[inline]
    pub unsafe fn rewind(&mut self) -> bool {
        SkRegion_Iterator_rewind(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, region: *const SkRegion) {
        SkRegion_Iterator_reset(self, region)
    }
    #[inline]
    pub unsafe fn next(&mut self) {
        SkRegion_Iterator_next(self)
    }
    #[inline]
    pub unsafe fn new(region: *const SkRegion) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_Iterator_Iterator(__bindgen_tmp.as_mut_ptr(), region);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_Cliperator {
    pub fIter: SkRegion_Iterator,
    pub fClip: SkIRect,
    pub fRect: SkIRect,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Cliperator() {
    const UNINIT: ::core::mem::MaybeUninit<SkRegion_Cliperator> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRegion_Cliperator>(),
        80usize,
        concat!("Size of: ", stringify!(SkRegion_Cliperator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion_Cliperator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion_Cliperator))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Cliperator),
            "::",
            stringify!(fIter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fClip) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Cliperator),
            "::",
            stringify!(fClip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRect) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Cliperator),
            "::",
            stringify!(fRect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDone) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Cliperator),
            "::",
            stringify!(fDone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion10Cliperator4nextEv"]
    pub fn SkRegion_Cliperator_next(this: *mut SkRegion_Cliperator);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion10CliperatorC1ERKS_RK7SkIRect"]
    pub fn SkRegion_Cliperator_Cliperator(
        this: *mut SkRegion_Cliperator,
        region: *const SkRegion,
        clip: *const SkIRect,
    );
}
impl SkRegion_Cliperator {
    #[inline]
    pub unsafe fn next(&mut self) {
        SkRegion_Cliperator_next(self)
    }
    #[inline]
    pub unsafe fn new(region: *const SkRegion, clip: *const SkIRect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_Cliperator_Cliperator(__bindgen_tmp.as_mut_ptr(), region, clip);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_Spanerator {
    pub fRuns: *const SkRegion_RunType,
    pub fLeft: ::core::ffi::c_int,
    pub fRight: ::core::ffi::c_int,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Spanerator() {
    const UNINIT: ::core::mem::MaybeUninit<SkRegion_Spanerator> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRegion_Spanerator>(),
        24usize,
        concat!("Size of: ", stringify!(SkRegion_Spanerator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion_Spanerator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion_Spanerator))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRuns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Spanerator),
            "::",
            stringify!(fRuns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLeft) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Spanerator),
            "::",
            stringify!(fLeft)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRight) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Spanerator),
            "::",
            stringify!(fRight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDone) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion_Spanerator),
            "::",
            stringify!(fDone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion10Spanerator4nextEPiS1_"]
    pub fn SkRegion_Spanerator_next(
        this: *mut SkRegion_Spanerator,
        left: *mut ::core::ffi::c_int,
        right: *mut ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion10SpaneratorC1ERKS_iii"]
    pub fn SkRegion_Spanerator_Spanerator(
        this: *mut SkRegion_Spanerator,
        region: *const SkRegion,
        y: ::core::ffi::c_int,
        left: ::core::ffi::c_int,
        right: ::core::ffi::c_int,
    );
}
impl SkRegion_Spanerator {
    #[inline]
    pub unsafe fn next(
        &mut self,
        left: *mut ::core::ffi::c_int,
        right: *mut ::core::ffi::c_int,
    ) -> bool {
        SkRegion_Spanerator_next(self, left, right)
    }
    #[inline]
    pub unsafe fn new(
        region: *const SkRegion,
        y: ::core::ffi::c_int,
        left: ::core::ffi::c_int,
        right: ::core::ffi::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_Spanerator_Spanerator(__bindgen_tmp.as_mut_ptr(), region, y, left, right);
        __bindgen_tmp.assume_init()
    }
}
pub type SkRegion_sk_is_trivially_relocatable = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_RunHead {
    _unused: [u8; 0],
}
pub const SkRegion_kOpCnt: ::core::ffi::c_int = 6;
pub const SkRegion_kOpCount: ::core::ffi::c_int = 6;
pub const SkRegion_kRectRegionRuns: ::core::ffi::c_int = 7;
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion15kRectRunHeadPtrE"]
    pub static SkRegion_kRectRunHeadPtr: *mut SkRegion_RunHead;
}
#[test]
fn bindgen_test_layout_SkRegion() {
    const UNINIT: ::core::mem::MaybeUninit<SkRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRegion>(),
        24usize,
        concat!("Size of: ", stringify!(SkRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRunHead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRegion),
            "::",
            stringify!(fRunHead)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion4swapERS_"]
    pub fn SkRegion_swap(this: *mut SkRegion, other: *mut SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion23computeRegionComplexityEv"]
    pub fn SkRegion_computeRegionComplexity(this: *const SkRegion) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion15getBoundaryPathEP6SkPath"]
    pub fn SkRegion_getBoundaryPath(this: *const SkRegion, path: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8setEmptyEv"]
    pub fn SkRegion_setEmpty(this: *mut SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion7setRectERK7SkIRect"]
    pub fn SkRegion_setRect(this: *mut SkRegion, rect: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8setRectsEPK7SkIRecti"]
    pub fn SkRegion_setRects(
        this: *mut SkRegion,
        rects: *const SkIRect,
        count: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion9setRegionERKS_"]
    pub fn SkRegion_setRegion(this: *mut SkRegion, region: *const SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion7setPathERK6SkPathRKS_"]
    pub fn SkRegion_setPath(
        this: *mut SkRegion,
        path: *const SkPath,
        clip: *const SkRegion,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion10intersectsERK7SkIRect"]
    pub fn SkRegion_intersects(this: *const SkRegion, rect: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion10intersectsERKS_"]
    pub fn SkRegion_intersects1(this: *const SkRegion, other: *const SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion8containsEii"]
    pub fn SkRegion_contains(this: *const SkRegion, x: i32, y: i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion8containsERK7SkIRect"]
    pub fn SkRegion_contains1(this: *const SkRegion, other: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion8containsERKS_"]
    pub fn SkRegion_contains2(this: *const SkRegion, other: *const SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion9translateEiiPS_"]
    pub fn SkRegion_translate(
        this: *const SkRegion,
        dx: ::core::ffi::c_int,
        dy: ::core::ffi::c_int,
        dst: *mut SkRegion,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion2opERK7SkIRectRKS_NS_2OpE"]
    pub fn SkRegion_op(
        this: *mut SkRegion,
        rect: *const SkIRect,
        rgn: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion2opERKS_RK7SkIRectNS_2OpE"]
    pub fn SkRegion_op1(
        this: *mut SkRegion,
        rgn: *const SkRegion,
        rect: *const SkIRect,
        op: SkRegion_Op,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion2opERKS_S1_NS_2OpE"]
    pub fn SkRegion_op2(
        this: *mut SkRegion,
        rgna: *const SkRegion,
        rgnb: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion13writeToMemoryEPv"]
    pub fn SkRegion_writeToMemory(this: *const SkRegion, buffer: *mut ::core::ffi::c_void)
        -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion14readFromMemoryEPKvm"]
    pub fn SkRegion_readFromMemory(
        this: *mut SkRegion,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegionC1Ev"]
    pub fn SkRegion_SkRegion(this: *mut SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegionC1ERKS_"]
    pub fn SkRegion_SkRegion1(this: *mut SkRegion, region: *const SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegionC1ERK7SkIRect"]
    pub fn SkRegion_SkRegion2(this: *mut SkRegion, rect: *const SkIRect);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegionD1Ev"]
    pub fn SkRegion_SkRegion_destructor(this: *mut SkRegion);
}
impl SkRegion {
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkRegion) {
        SkRegion_swap(self, other)
    }
    #[inline]
    pub unsafe fn computeRegionComplexity(&self) -> ::core::ffi::c_int {
        SkRegion_computeRegionComplexity(self)
    }
    #[inline]
    pub unsafe fn getBoundaryPath(&self, path: *mut SkPath) -> bool {
        SkRegion_getBoundaryPath(self, path)
    }
    #[inline]
    pub unsafe fn setEmpty(&mut self) -> bool {
        SkRegion_setEmpty(self)
    }
    #[inline]
    pub unsafe fn setRect(&mut self, rect: *const SkIRect) -> bool {
        SkRegion_setRect(self, rect)
    }
    #[inline]
    pub unsafe fn setRects(&mut self, rects: *const SkIRect, count: ::core::ffi::c_int) -> bool {
        SkRegion_setRects(self, rects, count)
    }
    #[inline]
    pub unsafe fn setRegion(&mut self, region: *const SkRegion) -> bool {
        SkRegion_setRegion(self, region)
    }
    #[inline]
    pub unsafe fn setPath(&mut self, path: *const SkPath, clip: *const SkRegion) -> bool {
        SkRegion_setPath(self, path, clip)
    }
    #[inline]
    pub unsafe fn intersects(&self, rect: *const SkIRect) -> bool {
        SkRegion_intersects(self, rect)
    }
    #[inline]
    pub unsafe fn intersects1(&self, other: *const SkRegion) -> bool {
        SkRegion_intersects1(self, other)
    }
    #[inline]
    pub unsafe fn contains(&self, x: i32, y: i32) -> bool {
        SkRegion_contains(self, x, y)
    }
    #[inline]
    pub unsafe fn contains1(&self, other: *const SkIRect) -> bool {
        SkRegion_contains1(self, other)
    }
    #[inline]
    pub unsafe fn contains2(&self, other: *const SkRegion) -> bool {
        SkRegion_contains2(self, other)
    }
    #[inline]
    pub unsafe fn translate(
        &self,
        dx: ::core::ffi::c_int,
        dy: ::core::ffi::c_int,
        dst: *mut SkRegion,
    ) {
        SkRegion_translate(self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn op(
        &mut self,
        rect: *const SkIRect,
        rgn: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool {
        SkRegion_op(self, rect, rgn, op)
    }
    #[inline]
    pub unsafe fn op1(
        &mut self,
        rgn: *const SkRegion,
        rect: *const SkIRect,
        op: SkRegion_Op,
    ) -> bool {
        SkRegion_op1(self, rgn, rect, op)
    }
    #[inline]
    pub unsafe fn op2(
        &mut self,
        rgna: *const SkRegion,
        rgnb: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool {
        SkRegion_op2(self, rgna, rgnb, op)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::core::ffi::c_void) -> usize {
        SkRegion_writeToMemory(self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(
        &mut self,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize {
        SkRegion_readFromMemory(self, buffer, length)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_SkRegion(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(region: *const SkRegion) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_SkRegion1(__bindgen_tmp.as_mut_ptr(), region);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rect: *const SkIRect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_SkRegion2(__bindgen_tmp.as_mut_ptr(), rect);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkRegion_SkRegion_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRRect {
    pub fRect: SkRect,
    pub fRadii: [SkVector; 4usize],
    pub fType: i32,
}
impl SkRRect_Type {
    pub const LastType: SkRRect_Type = SkRRect_Type::Complex;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRRect_Type {
    Empty = 0,
    Rect = 1,
    Oval = 2,
    Simple = 3,
    NinePatch = 4,
    Complex = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRRect_Corner {
    UpperLeft = 0,
    UpperRight = 1,
    LowerRight = 2,
    LowerLeft = 3,
}
pub const SkRRect_kSizeInMemory: usize = 48;
#[test]
fn bindgen_test_layout_SkRRect() {
    const UNINIT: ::core::mem::MaybeUninit<SkRRect> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRRect>(),
        52usize,
        concat!("Size of: ", stringify!(SkRRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRRect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRRect),
            "::",
            stringify!(fRect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRadii) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRRect),
            "::",
            stringify!(fRadii)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fType) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRRect),
            "::",
            stringify!(fType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect7setOvalERK6SkRect"]
    pub fn SkRRect_setOval(this: *mut SkRRect, oval: *const SkRect);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect9setRectXYERK6SkRectff"]
    pub fn SkRRect_setRectXY(
        this: *mut SkRRect,
        rect: *const SkRect,
        xRad: SkScalar,
        yRad: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect12setNinePatchERK6SkRectffff"]
    pub fn SkRRect_setNinePatch(
        this: *mut SkRRect,
        rect: *const SkRect,
        leftRad: SkScalar,
        topRad: SkScalar,
        rightRad: SkScalar,
        bottomRad: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect12setRectRadiiERK6SkRectPK7SkPoint"]
    pub fn SkRRect_setRectRadii(this: *mut SkRRect, rect: *const SkRect, radii: *const SkVector);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect5insetEffPS_"]
    pub fn SkRRect_inset(this: *const SkRRect, dx: SkScalar, dy: SkScalar, dst: *mut SkRRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect8containsERK6SkRect"]
    pub fn SkRRect_contains(this: *const SkRRect, rect: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect7isValidEv"]
    pub fn SkRRect_isValid(this: *const SkRRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect13writeToMemoryEPv"]
    pub fn SkRRect_writeToMemory(this: *const SkRRect, buffer: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect14readFromMemoryEPKvm"]
    pub fn SkRRect_readFromMemory(
        this: *mut SkRRect,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect9transformERK8SkMatrixPS_"]
    pub fn SkRRect_transform(
        this: *const SkRRect,
        matrix: *const SkMatrix,
        dst: *mut SkRRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect4dumpEb"]
    pub fn SkRRect_dump(this: *const SkRRect, asHex: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect12dumpToStringEb"]
    pub fn SkRRect_dumpToString(this: *const SkRRect, asHex: bool) -> SkString;
}
impl SkRRect {
    #[inline]
    pub unsafe fn setOval(&mut self, oval: *const SkRect) {
        SkRRect_setOval(self, oval)
    }
    #[inline]
    pub unsafe fn setRectXY(&mut self, rect: *const SkRect, xRad: SkScalar, yRad: SkScalar) {
        SkRRect_setRectXY(self, rect, xRad, yRad)
    }
    #[inline]
    pub unsafe fn setNinePatch(
        &mut self,
        rect: *const SkRect,
        leftRad: SkScalar,
        topRad: SkScalar,
        rightRad: SkScalar,
        bottomRad: SkScalar,
    ) {
        SkRRect_setNinePatch(self, rect, leftRad, topRad, rightRad, bottomRad)
    }
    #[inline]
    pub unsafe fn setRectRadii(&mut self, rect: *const SkRect, radii: *const SkVector) {
        SkRRect_setRectRadii(self, rect, radii)
    }
    #[inline]
    pub unsafe fn inset(&self, dx: SkScalar, dy: SkScalar, dst: *mut SkRRect) {
        SkRRect_inset(self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn contains(&self, rect: *const SkRect) -> bool {
        SkRRect_contains(self, rect)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        SkRRect_isValid(self)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::core::ffi::c_void) -> usize {
        SkRRect_writeToMemory(self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(
        &mut self,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize {
        SkRRect_readFromMemory(self, buffer, length)
    }
    #[inline]
    pub unsafe fn transform(&self, matrix: *const SkMatrix, dst: *mut SkRRect) -> bool {
        SkRRect_transform(self, matrix, dst)
    }
    #[inline]
    pub unsafe fn dump(&self, asHex: bool) {
        SkRRect_dump(self, asHex)
    }
    #[inline]
    pub unsafe fn dumpToString(&self, asHex: bool) -> SkString {
        SkRRect_dumpToString(self, asHex)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRSXform {
    pub fSCos: SkScalar,
    pub fSSin: SkScalar,
    pub fTx: SkScalar,
    pub fTy: SkScalar,
}
#[test]
fn bindgen_test_layout_SkRSXform() {
    const UNINIT: ::core::mem::MaybeUninit<SkRSXform> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRSXform>(),
        16usize,
        concat!("Size of: ", stringify!(SkRSXform))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRSXform>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRSXform))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSCos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRSXform),
            "::",
            stringify!(fSCos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSSin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRSXform),
            "::",
            stringify!(fSSin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRSXform),
            "::",
            stringify!(fTx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTy) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRSXform),
            "::",
            stringify!(fTy)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkRSXform6toQuadEffP7SkPoint"]
    pub fn SkRSXform_toQuad(
        this: *const SkRSXform,
        width: SkScalar,
        height: SkScalar,
        quad: *mut SkPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkRSXform10toTriStripEffP7SkPoint"]
    pub fn SkRSXform_toTriStrip(
        this: *const SkRSXform,
        width: SkScalar,
        height: SkScalar,
        strip: *mut SkPoint,
    );
}
impl SkRSXform {
    #[inline]
    pub unsafe fn toQuad(&self, width: SkScalar, height: SkScalar, quad: *mut SkPoint) {
        SkRSXform_toQuad(self, width, height, quad)
    }
    #[inline]
    pub unsafe fn toTriStrip(&self, width: SkScalar, height: SkScalar, strip: *mut SkPoint) {
        SkRSXform_toTriStrip(self, width, height, strip)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkStream {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkStream() {
    assert_eq!(
        ::core::mem::size_of::<SkStream>(),
        8usize,
        concat!("Size of: ", stringify!(SkStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStream))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream12MakeFromFileEPKc"]
    pub fn SkStream_MakeFromFile(path: *const ::core::ffi::c_char) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream6readS8EPa"]
    pub fn SkStream_readS8(this: *mut SkStream, arg1: *mut i8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream7readS16EPs"]
    pub fn SkStream_readS16(this: *mut SkStream, arg1: *mut i16) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream7readS32EPi"]
    pub fn SkStream_readS32(this: *mut SkStream, arg1: *mut i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream10readScalarEPf"]
    pub fn SkStream_readScalar(this: *mut SkStream, arg1: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream14readPackedUIntEPm"]
    pub fn SkStream_readPackedUInt(this: *mut SkStream, arg1: *mut usize) -> bool;
}
impl SkStream {
    #[inline]
    pub unsafe fn MakeFromFile(path: *const ::core::ffi::c_char) -> u64 {
        SkStream_MakeFromFile(path)
    }
    #[inline]
    pub unsafe fn readS8(&mut self, arg1: *mut i8) -> bool {
        SkStream_readS8(self, arg1)
    }
    #[inline]
    pub unsafe fn readS16(&mut self, arg1: *mut i16) -> bool {
        SkStream_readS16(self, arg1)
    }
    #[inline]
    pub unsafe fn readS32(&mut self, arg1: *mut i32) -> bool {
        SkStream_readS32(self, arg1)
    }
    #[inline]
    pub unsafe fn readScalar(&mut self, arg1: *mut SkScalar) -> bool {
        SkStream_readScalar(self, arg1)
    }
    #[inline]
    pub unsafe fn readPackedUInt(&mut self, arg1: *mut usize) -> bool {
        SkStream_readPackedUInt(self, arg1)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkStreamAsset {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkStreamAsset() {
    assert_eq!(
        ::core::mem::size_of::<SkStreamAsset>(),
        8usize,
        concat!("Size of: ", stringify!(SkStreamAsset))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStreamAsset>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStreamAsset))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkStreamMemory {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkStreamMemory() {
    assert_eq!(
        ::core::mem::size_of::<SkStreamMemory>(),
        8usize,
        concat!("Size of: ", stringify!(SkStreamMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStreamMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStreamMemory))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkWStream {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkWStream() {
    assert_eq!(
        ::core::mem::size_of::<SkWStream>(),
        8usize,
        concat!("Size of: ", stringify!(SkWStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkWStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkWStream))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream14writeDecAsTextEi"]
    pub fn SkWStream_writeDecAsText(this: *mut SkWStream, arg1: i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream17writeBigDecAsTextExi"]
    pub fn SkWStream_writeBigDecAsText(
        this: *mut SkWStream,
        arg1: i64,
        minDigits: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream14writeHexAsTextEji"]
    pub fn SkWStream_writeHexAsText(
        this: *mut SkWStream,
        arg1: u32,
        minDigits: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream17writeScalarAsTextEf"]
    pub fn SkWStream_writeScalarAsText(this: *mut SkWStream, arg1: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream11writeScalarEf"]
    pub fn SkWStream_writeScalar(this: *mut SkWStream, arg1: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream15writePackedUIntEm"]
    pub fn SkWStream_writePackedUInt(this: *mut SkWStream, arg1: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream11writeStreamEP8SkStreamm"]
    pub fn SkWStream_writeStream(this: *mut SkWStream, input: *mut SkStream, length: usize)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream16SizeOfPackedUIntEm"]
    pub fn SkWStream_SizeOfPackedUInt(value: usize) -> ::core::ffi::c_int;
}
impl SkWStream {
    #[inline]
    pub unsafe fn writeDecAsText(&mut self, arg1: i32) -> bool {
        SkWStream_writeDecAsText(self, arg1)
    }
    #[inline]
    pub unsafe fn writeBigDecAsText(&mut self, arg1: i64, minDigits: ::core::ffi::c_int) -> bool {
        SkWStream_writeBigDecAsText(self, arg1, minDigits)
    }
    #[inline]
    pub unsafe fn writeHexAsText(&mut self, arg1: u32, minDigits: ::core::ffi::c_int) -> bool {
        SkWStream_writeHexAsText(self, arg1, minDigits)
    }
    #[inline]
    pub unsafe fn writeScalarAsText(&mut self, arg1: SkScalar) -> bool {
        SkWStream_writeScalarAsText(self, arg1)
    }
    #[inline]
    pub unsafe fn writeScalar(&mut self, arg1: SkScalar) -> bool {
        SkWStream_writeScalar(self, arg1)
    }
    #[inline]
    pub unsafe fn writePackedUInt(&mut self, arg1: usize) -> bool {
        SkWStream_writePackedUInt(self, arg1)
    }
    #[inline]
    pub unsafe fn writeStream(&mut self, input: *mut SkStream, length: usize) -> bool {
        SkWStream_writeStream(self, input, length)
    }
    #[inline]
    pub unsafe fn SizeOfPackedUInt(value: usize) -> ::core::ffi::c_int {
        SkWStream_SizeOfPackedUInt(value)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStreamD1Ev"]
    pub fn SkWStream_SkWStream_destructor(this: *mut SkWStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream5flushEv"]
    pub fn SkWStream_flush(this: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkMemoryStream {
    pub _base: SkStreamMemory,
    pub fData: sk_sp<SkData>,
    pub fOffset: usize,
}
pub type SkMemoryStream_INHERITED = SkStreamMemory;
#[test]
fn bindgen_test_layout_SkMemoryStream() {
    const UNINIT: ::core::mem::MaybeUninit<SkMemoryStream> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkMemoryStream>(),
        24usize,
        concat!("Size of: ", stringify!(SkMemoryStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMemoryStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkMemoryStream))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMemoryStream),
            "::",
            stringify!(fData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkMemoryStream),
            "::",
            stringify!(fOffset)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream8MakeCopyEPKvm"]
    pub fn SkMemoryStream_MakeCopy(data: *const ::core::ffi::c_void, length: usize) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream10MakeDirectEPKvm"]
    pub fn SkMemoryStream_MakeDirect(data: *const ::core::ffi::c_void, length: usize) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream4MakeE5sk_spI6SkDataE"]
    pub fn SkMemoryStream_Make(data: sk_sp<SkData>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream14setMemoryOwnedEPKvm"]
    pub fn SkMemoryStream_setMemoryOwned(
        this: *mut SkMemoryStream,
        data: *const ::core::ffi::c_void,
        length: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream7setDataE5sk_spI6SkDataE"]
    pub fn SkMemoryStream_setData(this: *mut SkMemoryStream, data: sk_sp<SkData>);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream12skipToAlign4Ev"]
    pub fn SkMemoryStream_skipToAlign4(this: *mut SkMemoryStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream8getAtPosEv"]
    pub fn SkMemoryStream_getAtPos(this: *mut SkMemoryStream) -> *const ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStreamC1Ev"]
    pub fn SkMemoryStream_SkMemoryStream(this: *mut SkMemoryStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStreamC1Em"]
    pub fn SkMemoryStream_SkMemoryStream1(this: *mut SkMemoryStream, length: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStreamC1EPKvmb"]
    pub fn SkMemoryStream_SkMemoryStream2(
        this: *mut SkMemoryStream,
        data: *const ::core::ffi::c_void,
        length: usize,
        copyData: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStreamC1E5sk_spI6SkDataE"]
    pub fn SkMemoryStream_SkMemoryStream3(this: *mut SkMemoryStream, data: sk_sp<SkData>);
}
impl SkMemoryStream {
    #[inline]
    pub unsafe fn MakeCopy(data: *const ::core::ffi::c_void, length: usize) -> u64 {
        SkMemoryStream_MakeCopy(data, length)
    }
    #[inline]
    pub unsafe fn MakeDirect(data: *const ::core::ffi::c_void, length: usize) -> u64 {
        SkMemoryStream_MakeDirect(data, length)
    }
    #[inline]
    pub unsafe fn Make(data: sk_sp<SkData>) -> u64 {
        SkMemoryStream_Make(data)
    }
    #[inline]
    pub unsafe fn setMemoryOwned(&mut self, data: *const ::core::ffi::c_void, length: usize) {
        SkMemoryStream_setMemoryOwned(self, data, length)
    }
    #[inline]
    pub unsafe fn setData(&mut self, data: sk_sp<SkData>) {
        SkMemoryStream_setData(self, data)
    }
    #[inline]
    pub unsafe fn skipToAlign4(&mut self) {
        SkMemoryStream_skipToAlign4(self)
    }
    #[inline]
    pub unsafe fn getAtPos(&mut self) -> *const ::core::ffi::c_void {
        SkMemoryStream_getAtPos(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(length: usize) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream1(__bindgen_tmp.as_mut_ptr(), length);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(data: *const ::core::ffi::c_void, length: usize, copyData: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream2(__bindgen_tmp.as_mut_ptr(), data, length, copyData);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(data: sk_sp<SkData>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream3(__bindgen_tmp.as_mut_ptr(), data);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream9setMemoryEPKvmb"]
    pub fn SkMemoryStream_setMemory(
        this: *mut ::core::ffi::c_void,
        data: *const ::core::ffi::c_void,
        length: usize,
        copyData: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream4readEPvm"]
    pub fn SkMemoryStream_read(
        this: *mut ::core::ffi::c_void,
        buffer: *mut ::core::ffi::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK14SkMemoryStream7isAtEndEv"]
    pub fn SkMemoryStream_isAtEnd(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK14SkMemoryStream4peekEPvm"]
    pub fn SkMemoryStream_peek(
        this: *mut ::core::ffi::c_void,
        buffer: *mut ::core::ffi::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream6rewindEv"]
    pub fn SkMemoryStream_rewind(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK14SkMemoryStream11getPositionEv"]
    pub fn SkMemoryStream_getPosition(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream4seekEm"]
    pub fn SkMemoryStream_seek(this: *mut ::core::ffi::c_void, position: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream4moveEl"]
    pub fn SkMemoryStream_move(this: *mut ::core::ffi::c_void, offset: ::core::ffi::c_long)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK14SkMemoryStream9getLengthEv"]
    pub fn SkMemoryStream_getLength(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream13getMemoryBaseEv"]
    pub fn SkMemoryStream_getMemoryBase(
        this: *mut ::core::ffi::c_void,
    ) -> *const ::core::ffi::c_void;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkDynamicMemoryWStream {
    pub _base: SkWStream,
    pub fHead: *mut SkDynamicMemoryWStream_Block,
    pub fTail: *mut SkDynamicMemoryWStream_Block,
    pub fBytesWrittenBeforeTail: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDynamicMemoryWStream_Block {
    _unused: [u8; 0],
}
pub type SkDynamicMemoryWStream_INHERITED = SkWStream;
#[test]
fn bindgen_test_layout_SkDynamicMemoryWStream() {
    const UNINIT: ::core::mem::MaybeUninit<SkDynamicMemoryWStream> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkDynamicMemoryWStream>(),
        32usize,
        concat!("Size of: ", stringify!(SkDynamicMemoryWStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDynamicMemoryWStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDynamicMemoryWStream))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDynamicMemoryWStream),
            "::",
            stringify!(fHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTail) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDynamicMemoryWStream),
            "::",
            stringify!(fTail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBytesWrittenBeforeTail) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkDynamicMemoryWStream),
            "::",
            stringify!(fBytesWrittenBeforeTail)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream4readEPvmm"]
    pub fn SkDynamicMemoryWStream_read(
        this: *mut SkDynamicMemoryWStream,
        buffer: *mut ::core::ffi::c_void,
        offset: usize,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK22SkDynamicMemoryWStream6copyToEPv"]
    pub fn SkDynamicMemoryWStream_copyTo(
        this: *const SkDynamicMemoryWStream,
        dst: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK22SkDynamicMemoryWStream13writeToStreamEP9SkWStream"]
    pub fn SkDynamicMemoryWStream_writeToStream(
        this: *const SkDynamicMemoryWStream,
        dst: *mut SkWStream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream14copyToAndResetEPv"]
    pub fn SkDynamicMemoryWStream_copyToAndReset(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream15writeToAndResetEP9SkWStream"]
    pub fn SkDynamicMemoryWStream_writeToAndReset(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut SkWStream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream15writeToAndResetEPS_"]
    pub fn SkDynamicMemoryWStream_writeToAndReset1(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut SkDynamicMemoryWStream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream17prependToAndResetEPS_"]
    pub fn SkDynamicMemoryWStream_prependToAndReset(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut SkDynamicMemoryWStream,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream12detachAsDataEv"]
    pub fn SkDynamicMemoryWStream_detachAsData(this: *mut SkDynamicMemoryWStream) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream14detachAsStreamEv"]
    pub fn SkDynamicMemoryWStream_detachAsStream(this: *mut SkDynamicMemoryWStream) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream5resetEv"]
    pub fn SkDynamicMemoryWStream_reset(this: *mut SkDynamicMemoryWStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream11padToAlign4Ev"]
    pub fn SkDynamicMemoryWStream_padToAlign4(this: *mut SkDynamicMemoryWStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStreamC1EOS_"]
    pub fn SkDynamicMemoryWStream_SkDynamicMemoryWStream(
        this: *mut SkDynamicMemoryWStream,
        arg1: *mut SkDynamicMemoryWStream,
    );
}
impl SkDynamicMemoryWStream {
    #[inline]
    pub unsafe fn read(
        &mut self,
        buffer: *mut ::core::ffi::c_void,
        offset: usize,
        size: usize,
    ) -> bool {
        SkDynamicMemoryWStream_read(self, buffer, offset, size)
    }
    #[inline]
    pub unsafe fn copyTo(&self, dst: *mut ::core::ffi::c_void) {
        SkDynamicMemoryWStream_copyTo(self, dst)
    }
    #[inline]
    pub unsafe fn writeToStream(&self, dst: *mut SkWStream) -> bool {
        SkDynamicMemoryWStream_writeToStream(self, dst)
    }
    #[inline]
    pub unsafe fn copyToAndReset(&mut self, dst: *mut ::core::ffi::c_void) {
        SkDynamicMemoryWStream_copyToAndReset(self, dst)
    }
    #[inline]
    pub unsafe fn writeToAndReset(&mut self, dst: *mut SkWStream) -> bool {
        SkDynamicMemoryWStream_writeToAndReset(self, dst)
    }
    #[inline]
    pub unsafe fn writeToAndReset1(&mut self, dst: *mut SkDynamicMemoryWStream) -> bool {
        SkDynamicMemoryWStream_writeToAndReset1(self, dst)
    }
    #[inline]
    pub unsafe fn prependToAndReset(&mut self, dst: *mut SkDynamicMemoryWStream) {
        SkDynamicMemoryWStream_prependToAndReset(self, dst)
    }
    #[inline]
    pub unsafe fn detachAsData(&mut self) -> sk_sp<SkData> {
        SkDynamicMemoryWStream_detachAsData(self)
    }
    #[inline]
    pub unsafe fn detachAsStream(&mut self) -> u64 {
        SkDynamicMemoryWStream_detachAsStream(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkDynamicMemoryWStream_reset(self)
    }
    #[inline]
    pub unsafe fn padToAlign4(&mut self) {
        SkDynamicMemoryWStream_padToAlign4(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut SkDynamicMemoryWStream) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDynamicMemoryWStream_SkDynamicMemoryWStream(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStreamD1Ev"]
    pub fn SkDynamicMemoryWStream_SkDynamicMemoryWStream_destructor(
        this: *mut SkDynamicMemoryWStream,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream5writeEPKvm"]
    pub fn SkDynamicMemoryWStream_write(
        this: *mut ::core::ffi::c_void,
        buffer: *const ::core::ffi::c_void,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK22SkDynamicMemoryWStream12bytesWrittenEv"]
    pub fn SkDynamicMemoryWStream_bytesWritten(this: *mut ::core::ffi::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkStrokeRec {
    pub fResScale: SkScalar,
    pub fWidth: SkScalar,
    pub fMiterLimit: SkScalar,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkStrokeRec_InitStyle {
    Hairline = 0,
    Fill = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkStrokeRec_Style {
    Hairline = 0,
    Fill = 1,
    Stroke = 2,
    StrokeAndFill = 3,
}
pub const SkStrokeRec_kStyleCount: ::core::ffi::c_int = 4;
#[test]
fn bindgen_test_layout_SkStrokeRec() {
    const UNINIT: ::core::mem::MaybeUninit<SkStrokeRec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkStrokeRec>(),
        16usize,
        concat!("Size of: ", stringify!(SkStrokeRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStrokeRec>(),
        4usize,
        concat!("Alignment of ", stringify!(SkStrokeRec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fResScale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkStrokeRec),
            "::",
            stringify!(fResScale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkStrokeRec),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMiterLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkStrokeRec),
            "::",
            stringify!(fMiterLimit)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkStrokeRec8getStyleEv"]
    pub fn SkStrokeRec_getStyle(this: *const SkStrokeRec) -> SkStrokeRec_Style;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec12setFillStyleEv"]
    pub fn SkStrokeRec_setFillStyle(this: *mut SkStrokeRec);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec16setHairlineStyleEv"]
    pub fn SkStrokeRec_setHairlineStyle(this: *mut SkStrokeRec);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec14setStrokeStyleEfb"]
    pub fn SkStrokeRec_setStrokeStyle(this: *mut SkStrokeRec, width: SkScalar, strokeAndFill: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkStrokeRec11applyToPathEP6SkPathRKS0_"]
    pub fn SkStrokeRec_applyToPath(
        this: *const SkStrokeRec,
        dst: *mut SkPath,
        src: *const SkPath,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkStrokeRec12applyToPaintEP7SkPaint"]
    pub fn SkStrokeRec_applyToPaint(this: *const SkStrokeRec, paint: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkStrokeRec18getInflationRadiusEv"]
    pub fn SkStrokeRec_getInflationRadius(this: *const SkStrokeRec) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec18GetInflationRadiusERK7SkPaintNS0_5StyleE"]
    pub fn SkStrokeRec_GetInflationRadius(arg1: *const SkPaint, arg2: SkPaint_Style) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec18GetInflationRadiusEN7SkPaint4JoinEfNS0_3CapEf"]
    pub fn SkStrokeRec_GetInflationRadius1(
        arg1: SkPaint_Join,
        miterLimit: SkScalar,
        arg2: SkPaint_Cap,
        strokeWidth: SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRecC1ENS_9InitStyleE"]
    pub fn SkStrokeRec_SkStrokeRec(this: *mut SkStrokeRec, style: SkStrokeRec_InitStyle);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRecC1ERK7SkPaintNS0_5StyleEf"]
    pub fn SkStrokeRec_SkStrokeRec1(
        this: *mut SkStrokeRec,
        arg1: *const SkPaint,
        arg2: SkPaint_Style,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRecC1ERK7SkPaintf"]
    pub fn SkStrokeRec_SkStrokeRec2(
        this: *mut SkStrokeRec,
        arg1: *const SkPaint,
        resScale: SkScalar,
    );
}
impl SkStrokeRec {
    #[inline]
    pub fn fCap(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_fCap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn fJoin(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_fJoin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn fStrokeAndFill(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fStrokeAndFill(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fCap: u32,
        fJoin: u32,
        fStrokeAndFill: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let fCap: u32 = unsafe { ::core::mem::transmute(fCap) };
            fCap as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let fJoin: u32 = unsafe { ::core::mem::transmute(fJoin) };
            fJoin as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let fStrokeAndFill: u32 = unsafe { ::core::mem::transmute(fStrokeAndFill) };
            fStrokeAndFill as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getStyle(&self) -> SkStrokeRec_Style {
        SkStrokeRec_getStyle(self)
    }
    #[inline]
    pub unsafe fn setFillStyle(&mut self) {
        SkStrokeRec_setFillStyle(self)
    }
    #[inline]
    pub unsafe fn setHairlineStyle(&mut self) {
        SkStrokeRec_setHairlineStyle(self)
    }
    #[inline]
    pub unsafe fn setStrokeStyle(&mut self, width: SkScalar, strokeAndFill: bool) {
        SkStrokeRec_setStrokeStyle(self, width, strokeAndFill)
    }
    #[inline]
    pub unsafe fn applyToPath(&self, dst: *mut SkPath, src: *const SkPath) -> bool {
        SkStrokeRec_applyToPath(self, dst, src)
    }
    #[inline]
    pub unsafe fn applyToPaint(&self, paint: *mut SkPaint) {
        SkStrokeRec_applyToPaint(self, paint)
    }
    #[inline]
    pub unsafe fn getInflationRadius(&self) -> SkScalar {
        SkStrokeRec_getInflationRadius(self)
    }
    #[inline]
    pub unsafe fn GetInflationRadius(arg1: *const SkPaint, arg2: SkPaint_Style) -> SkScalar {
        SkStrokeRec_GetInflationRadius(arg1, arg2)
    }
    #[inline]
    pub unsafe fn GetInflationRadius1(
        arg1: SkPaint_Join,
        miterLimit: SkScalar,
        arg2: SkPaint_Cap,
        strokeWidth: SkScalar,
    ) -> SkScalar {
        SkStrokeRec_GetInflationRadius1(arg1, miterLimit, arg2, strokeWidth)
    }
    #[inline]
    pub unsafe fn new(style: SkStrokeRec_InitStyle) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkStrokeRec_SkStrokeRec(__bindgen_tmp.as_mut_ptr(), style);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const SkPaint, arg2: SkPaint_Style, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkStrokeRec_SkStrokeRec1(__bindgen_tmp.as_mut_ptr(), arg1, arg2, resScale);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkPaint, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkStrokeRec_SkStrokeRec2(__bindgen_tmp.as_mut_ptr(), arg1, resScale);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendSemaphore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrSurfaceCharacterization {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCapabilities {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSurfaces_BackendSurfaceAccess {
    NoAccess = 0,
    Present = 1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkSurface {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSurface_ContentChangeMode {
    Discard = 0,
    Retain = 1,
}
impl SkSurface_BackendHandleAccess {
    pub const FlushRead_BackendHandleAccess: SkSurface_BackendHandleAccess =
        SkSurface_BackendHandleAccess::FlushRead;
}
impl SkSurface_BackendHandleAccess {
    pub const FlushWrite_BackendHandleAccess: SkSurface_BackendHandleAccess =
        SkSurface_BackendHandleAccess::FlushWrite;
}
impl SkSurface_BackendHandleAccess {
    pub const DiscardWrite_BackendHandleAccess: SkSurface_BackendHandleAccess =
        SkSurface_BackendHandleAccess::DiscardWrite;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSurface_BackendHandleAccess {
    FlushRead = 0,
    FlushWrite = 1,
    DiscardWrite = 2,
}
pub type SkSurface_ReleaseContext = *mut ::core::ffi::c_void;
pub type SkSurface_TextureReleaseProc =
    ::core::option::Option<unsafe extern "C" fn(arg1: SkSurface_ReleaseContext)>;
pub type SkSurface_AsyncReadResult = SkImage_AsyncReadResult;
pub type SkSurface_ReadPixelsContext = *mut ::core::ffi::c_void;
pub type SkSurface_ReadPixelsCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: SkSurface_ReadPixelsContext, arg2: u8)>;
pub use self::SkImage_RescaleGamma as SkSurface_RescaleGamma;
pub use self::SkImage_RescaleMode as SkSurface_RescaleMode;
pub type SkSurface_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkSurface() {
    assert_eq!(
        ::core::mem::size_of::<SkSurface>(),
        32usize,
        concat!("Size of: ", stringify!(SkSurface))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSurface>(),
        8usize,
        concat!("Alignment of ", stringify!(SkSurface))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkSurface12isCompatibleERK25GrSurfaceCharacterization"]
    pub fn SkSurface_isCompatible(
        this: *const SkSurface,
        characterization: *const GrSurfaceCharacterization,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface12generationIDEv"]
    pub fn SkSurface_generationID(this: *mut SkSurface) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface23notifyContentWillChangeENS_17ContentChangeModeE"]
    pub fn SkSurface_notifyContentWillChange(
        this: *mut SkSurface,
        mode: SkSurface_ContentChangeMode,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkSurface16recordingContextEv"]
    pub fn SkSurface_recordingContext(this: *const SkSurface) -> *mut GrRecordingContext;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkSurface8recorderEv"]
    pub fn SkSurface_recorder(this: *const SkSurface) -> *mut skgpu_graphite_Recorder;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface9getCanvasEv"]
    pub fn SkSurface_getCanvas(this: *mut SkSurface) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface12capabilitiesEv"]
    pub fn SkSurface_capabilities(this: *mut SkSurface) -> sk_sp<SkCapabilities>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface11makeSurfaceERK11SkImageInfo"]
    pub fn SkSurface_makeSurface(
        this: *mut SkSurface,
        imageInfo: *const SkImageInfo,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface11makeSurfaceEii"]
    pub fn SkSurface_makeSurface1(
        this: *mut SkSurface,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface17makeImageSnapshotEv"]
    pub fn SkSurface_makeImageSnapshot(this: *mut SkSurface) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface17makeImageSnapshotERK7SkIRect"]
    pub fn SkSurface_makeImageSnapshot1(
        this: *mut SkSurface,
        bounds: *const SkIRect,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface4drawEP8SkCanvasffRK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkSurface_draw(
        this: *mut SkSurface,
        canvas: *mut SkCanvas,
        x: SkScalar,
        y: SkScalar,
        sampling: *const SkSamplingOptions,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface10peekPixelsEP8SkPixmap"]
    pub fn SkSurface_peekPixels(this: *mut SkSurface, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface10readPixelsERK8SkPixmapii"]
    pub fn SkSurface_readPixels(
        this: *mut SkSurface,
        dst: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkSurface_readPixels1(
        this: *mut SkSurface,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface10readPixelsERK8SkBitmapii"]
    pub fn SkSurface_readPixels2(
        this: *mut SkSurface,
        dst: *const SkBitmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface25asyncRescaleAndReadPixelsERK11SkImageInfoRK7SkIRectN7SkImage12RescaleGammaENS6_11RescaleModeEPFvPvNSt3__110unique_ptrIKNS6_15AsyncReadResultENSA_14default_deleteISD_EEEEES9_"]
    pub fn SkSurface_asyncRescaleAndReadPixels(
        this: *mut SkSurface,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface31asyncRescaleAndReadPixelsYUV420E15SkYUVColorSpace5sk_spI12SkColorSpaceERK7SkIRectRK7SkISizeN7SkImage12RescaleGammaENSA_11RescaleModeEPFvPvNSt3__110unique_ptrIKNSA_15AsyncReadResultENSE_14default_deleteISH_EEEEESD_"]
    pub fn SkSurface_asyncRescaleAndReadPixelsYUV420(
        this: *mut SkSurface,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface32asyncRescaleAndReadPixelsYUVA420E15SkYUVColorSpace5sk_spI12SkColorSpaceERK7SkIRectRK7SkISizeN7SkImage12RescaleGammaENSA_11RescaleModeEPFvPvNSt3__110unique_ptrIKNSA_15AsyncReadResultENSE_14default_deleteISH_EEEEESD_"]
    pub fn SkSurface_asyncRescaleAndReadPixelsYUVA420(
        this: *mut SkSurface,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface11writePixelsERK8SkPixmapii"]
    pub fn SkSurface_writePixels(
        this: *mut SkSurface,
        src: *const SkPixmap,
        dstX: ::core::ffi::c_int,
        dstY: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface11writePixelsERK8SkBitmapii"]
    pub fn SkSurface_writePixels1(
        this: *mut SkSurface,
        src: *const SkBitmap,
        dstX: ::core::ffi::c_int,
        dstY: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface4waitEiPK18GrBackendSemaphoreb"]
    pub fn SkSurface_wait(
        this: *mut SkSurface,
        numSemaphores: ::core::ffi::c_int,
        waitSemaphores: *const GrBackendSemaphore,
        deleteSemaphoresAfterWait: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkSurface12characterizeEP25GrSurfaceCharacterization"]
    pub fn SkSurface_characterize(
        this: *const SkSurface,
        characterization: *mut GrSurfaceCharacterization,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurfaceC2EiiPK14SkSurfaceProps"]
    pub fn SkSurface_SkSurface(
        this: *mut SkSurface,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        surfaceProps: *const SkSurfaceProps,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurfaceC2ERK11SkImageInfoPK14SkSurfaceProps"]
    pub fn SkSurface_SkSurface1(
        this: *mut SkSurface,
        imageInfo: *const SkImageInfo,
        surfaceProps: *const SkSurfaceProps,
    );
}
impl SkSurface {
    #[inline]
    pub unsafe fn isCompatible(&self, characterization: *const GrSurfaceCharacterization) -> bool {
        SkSurface_isCompatible(self, characterization)
    }
    #[inline]
    pub unsafe fn generationID(&mut self) -> u32 {
        SkSurface_generationID(self)
    }
    #[inline]
    pub unsafe fn notifyContentWillChange(&mut self, mode: SkSurface_ContentChangeMode) {
        SkSurface_notifyContentWillChange(self, mode)
    }
    #[inline]
    pub unsafe fn recordingContext(&self) -> *mut GrRecordingContext {
        SkSurface_recordingContext(self)
    }
    #[inline]
    pub unsafe fn recorder(&self) -> *mut skgpu_graphite_Recorder {
        SkSurface_recorder(self)
    }
    #[inline]
    pub unsafe fn getCanvas(&mut self) -> *mut SkCanvas {
        SkSurface_getCanvas(self)
    }
    #[inline]
    pub unsafe fn capabilities(&mut self) -> sk_sp<SkCapabilities> {
        SkSurface_capabilities(self)
    }
    #[inline]
    pub unsafe fn makeSurface(&mut self, imageInfo: *const SkImageInfo) -> sk_sp<SkSurface> {
        SkSurface_makeSurface(self, imageInfo)
    }
    #[inline]
    pub unsafe fn makeSurface1(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> sk_sp<SkSurface> {
        SkSurface_makeSurface1(self, width, height)
    }
    #[inline]
    pub unsafe fn makeImageSnapshot(&mut self) -> sk_sp<SkImage> {
        SkSurface_makeImageSnapshot(self)
    }
    #[inline]
    pub unsafe fn makeImageSnapshot1(&mut self, bounds: *const SkIRect) -> sk_sp<SkImage> {
        SkSurface_makeImageSnapshot1(self, bounds)
    }
    #[inline]
    pub unsafe fn draw(
        &mut self,
        canvas: *mut SkCanvas,
        x: SkScalar,
        y: SkScalar,
        sampling: *const SkSamplingOptions,
        paint: *const SkPaint,
    ) {
        SkSurface_draw(self, canvas, x, y, sampling, paint)
    }
    #[inline]
    pub unsafe fn peekPixels(&mut self, pixmap: *mut SkPixmap) -> bool {
        SkSurface_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn readPixels(
        &mut self,
        dst: *const SkPixmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool {
        SkSurface_readPixels(self, dst, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &mut self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool {
        SkSurface_readPixels1(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels2(
        &mut self,
        dst: *const SkBitmap,
        srcX: ::core::ffi::c_int,
        srcY: ::core::ffi::c_int,
    ) -> bool {
        SkSurface_readPixels2(self, dst, srcX, srcY)
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixels(
        &mut self,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    ) {
        SkSurface_asyncRescaleAndReadPixels(
            self,
            info,
            srcRect,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixelsYUV420(
        &mut self,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    ) {
        SkSurface_asyncRescaleAndReadPixelsYUV420(
            self,
            yuvColorSpace,
            dstColorSpace,
            srcRect,
            dstSize,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixelsYUVA420(
        &mut self,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    ) {
        SkSurface_asyncRescaleAndReadPixelsYUVA420(
            self,
            yuvColorSpace,
            dstColorSpace,
            srcRect,
            dstSize,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn writePixels(
        &mut self,
        src: *const SkPixmap,
        dstX: ::core::ffi::c_int,
        dstY: ::core::ffi::c_int,
    ) {
        SkSurface_writePixels(self, src, dstX, dstY)
    }
    #[inline]
    pub unsafe fn writePixels1(
        &mut self,
        src: *const SkBitmap,
        dstX: ::core::ffi::c_int,
        dstY: ::core::ffi::c_int,
    ) {
        SkSurface_writePixels1(self, src, dstX, dstY)
    }
    #[inline]
    pub unsafe fn wait(
        &mut self,
        numSemaphores: ::core::ffi::c_int,
        waitSemaphores: *const GrBackendSemaphore,
        deleteSemaphoresAfterWait: bool,
    ) -> bool {
        SkSurface_wait(
            self,
            numSemaphores,
            waitSemaphores,
            deleteSemaphoresAfterWait,
        )
    }
    #[inline]
    pub unsafe fn characterize(&self, characterization: *mut GrSurfaceCharacterization) -> bool {
        SkSurface_characterize(self, characterization)
    }
    #[inline]
    pub unsafe fn new(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        surfaceProps: *const SkSurfaceProps,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurface_SkSurface(__bindgen_tmp.as_mut_ptr(), width, height, surfaceProps);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(imageInfo: *const SkImageInfo, surfaceProps: *const SkSurfaceProps) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurface_SkSurface1(__bindgen_tmp.as_mut_ptr(), imageInfo, surfaceProps);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface30kFlushRead_BackendHandleAccessE"]
    pub static SkSurface_kFlushRead_BackendHandleAccess: SkSurface_BackendHandleAccess;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface31kFlushWrite_BackendHandleAccessE"]
    pub static SkSurface_kFlushWrite_BackendHandleAccess: SkSurface_BackendHandleAccess;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface33kDiscardWrite_BackendHandleAccessE"]
    pub static SkSurface_kDiscardWrite_BackendHandleAccess: SkSurface_BackendHandleAccess;
}
extern "C" {
    #[link_name = "\u{1}__Z8SkSwapRBPjPKji"]
    pub fn SkSwapRB(dest: *mut u32, src: *const u32, count: ::core::ffi::c_int);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlob {
    pub _base: SkNVRefCnt,
    pub fBounds: SkRect,
    pub fUniqueID: u32,
    pub fCacheID: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlob_RunRecord {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlob_Iter {
    pub fRunRecord: *const SkTextBlob_RunRecord,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlob_Iter_Run {
    pub fTypeface: *mut SkTypeface,
    pub fGlyphCount: ::core::ffi::c_int,
    pub fGlyphIndices: *const u16,
}
#[test]
fn bindgen_test_layout_SkTextBlob_Iter_Run() {
    const UNINIT: ::core::mem::MaybeUninit<SkTextBlob_Iter_Run> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob_Iter_Run>(),
        24usize,
        concat!("Size of: ", stringify!(SkTextBlob_Iter_Run))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob_Iter_Run>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlob_Iter_Run))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTypeface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_Run),
            "::",
            stringify!(fTypeface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGlyphCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_Run),
            "::",
            stringify!(fGlyphCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGlyphIndices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_Run),
            "::",
            stringify!(fGlyphIndices)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlob_Iter_ExperimentalRun {
    pub font: SkFont,
    pub count: ::core::ffi::c_int,
    pub glyphs: *const u16,
    pub positions: *const SkPoint,
}
#[test]
fn bindgen_test_layout_SkTextBlob_Iter_ExperimentalRun() {
    const UNINIT: ::core::mem::MaybeUninit<SkTextBlob_Iter_ExperimentalRun> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob_Iter_ExperimentalRun>(),
        48usize,
        concat!("Size of: ", stringify!(SkTextBlob_Iter_ExperimentalRun))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob_Iter_ExperimentalRun>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlob_Iter_ExperimentalRun))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_ExperimentalRun),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_ExperimentalRun),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).glyphs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_ExperimentalRun),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).positions) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter_ExperimentalRun),
            "::",
            stringify!(positions)
        )
    );
}
#[test]
fn bindgen_test_layout_SkTextBlob_Iter() {
    const UNINIT: ::core::mem::MaybeUninit<SkTextBlob_Iter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob_Iter>(),
        8usize,
        concat!("Size of: ", stringify!(SkTextBlob_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlob_Iter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRunRecord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob_Iter),
            "::",
            stringify!(fRunRecord)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob4Iter4nextEPNS0_3RunE"]
    pub fn SkTextBlob_Iter_next(this: *mut SkTextBlob_Iter, arg1: *mut SkTextBlob_Iter_Run)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob4Iter16experimentalNextEPNS0_15ExperimentalRunE"]
    pub fn SkTextBlob_Iter_experimentalNext(
        this: *mut SkTextBlob_Iter,
        arg1: *mut SkTextBlob_Iter_ExperimentalRun,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob4IterC1ERKS_"]
    pub fn SkTextBlob_Iter_Iter(this: *mut SkTextBlob_Iter, arg1: *const SkTextBlob);
}
impl SkTextBlob_Iter {
    #[inline]
    pub unsafe fn next(&mut self, arg1: *mut SkTextBlob_Iter_Run) -> bool {
        SkTextBlob_Iter_next(self, arg1)
    }
    #[inline]
    pub unsafe fn experimentalNext(&mut self, arg1: *mut SkTextBlob_Iter_ExperimentalRun) -> bool {
        SkTextBlob_Iter_experimentalNext(self, arg1)
    }
    #[inline]
    pub unsafe fn new(arg1: *const SkTextBlob) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTextBlob_Iter_Iter(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextBlob_GlyphPositioning {
    __bindgen_cannot_repr_c_on_empty_enum = 0,
}
pub type SkTextBlob_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkTextBlob() {
    const UNINIT: ::core::mem::MaybeUninit<SkTextBlob> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob>(),
        28usize,
        concat!("Size of: ", stringify!(SkTextBlob))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob>(),
        4usize,
        concat!("Alignment of ", stringify!(SkTextBlob))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob),
            "::",
            stringify!(fUniqueID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCacheID) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlob),
            "::",
            stringify!(fCacheID)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTextBlob13getInterceptsEPKfPfPK7SkPaint"]
    pub fn SkTextBlob_getIntercepts(
        this: *const SkTextBlob,
        bounds: *const SkScalar,
        intervals: *mut SkScalar,
        paint: *const SkPaint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob12MakeFromTextEPKvmRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob16MakeFromPosTextHEPKvmPKffRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromPosTextH(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xpos: *const SkScalar,
        constY: SkScalar,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob15MakeFromPosTextEPKvmPK7SkPointRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromPosText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        pos: *const SkPoint,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob15MakeFromRSXformEPKvmPK9SkRSXformRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromRSXform(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xform: *const SkRSXform,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTextBlob9serializeERK13SkSerialProcsPvm"]
    pub fn SkTextBlob_serialize(
        this: *const SkTextBlob,
        procs: *const SkSerialProcs,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTextBlob9serializeERK13SkSerialProcs"]
    pub fn SkTextBlob_serialize1(
        this: *const SkTextBlob,
        procs: *const SkSerialProcs,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob11DeserializeEPKvmRK15SkDeserialProcs"]
    pub fn SkTextBlob_Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkTextBlob>;
}
impl SkTextBlob {
    #[inline]
    pub unsafe fn getIntercepts(
        &self,
        bounds: *const SkScalar,
        intervals: *mut SkScalar,
        paint: *const SkPaint,
    ) -> ::core::ffi::c_int {
        SkTextBlob_getIntercepts(self, bounds, intervals, paint)
    }
    #[inline]
    pub unsafe fn MakeFromText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromText(text, byteLength, font, encoding)
    }
    #[inline]
    pub unsafe fn MakeFromPosTextH(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xpos: *const SkScalar,
        constY: SkScalar,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromPosTextH(text, byteLength, xpos, constY, font, encoding)
    }
    #[inline]
    pub unsafe fn MakeFromPosText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        pos: *const SkPoint,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromPosText(text, byteLength, pos, font, encoding)
    }
    #[inline]
    pub unsafe fn MakeFromRSXform(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xform: *const SkRSXform,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromRSXform(text, byteLength, xform, font, encoding)
    }
    #[inline]
    pub unsafe fn serialize(
        &self,
        procs: *const SkSerialProcs,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
    ) -> usize {
        SkTextBlob_serialize(self, procs, memory, memory_size)
    }
    #[inline]
    pub unsafe fn serialize1(&self, procs: *const SkSerialProcs) -> sk_sp<SkData> {
        SkTextBlob_serialize1(self, procs)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_Deserialize(data, size, procs)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlobBuilder {
    pub fStorage: u64,
    pub fStorageSize: usize,
    pub fStorageUsed: usize,
    pub fBounds: SkRect,
    pub fRunCount: ::core::ffi::c_int,
    pub fDeferredBounds: bool,
    pub fLastRun: usize,
    pub fCurrentRunBuffer: SkTextBlobBuilder_RunBuffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlobBuilder_RunBuffer {
    pub glyphs: *mut SkGlyphID,
    pub pos: *mut SkScalar,
    pub utf8text: *mut ::core::ffi::c_char,
    pub clusters: *mut u32,
}
#[test]
fn bindgen_test_layout_SkTextBlobBuilder_RunBuffer() {
    const UNINIT: ::core::mem::MaybeUninit<SkTextBlobBuilder_RunBuffer> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTextBlobBuilder_RunBuffer>(),
        32usize,
        concat!("Size of: ", stringify!(SkTextBlobBuilder_RunBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlobBuilder_RunBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlobBuilder_RunBuffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).glyphs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder_RunBuffer),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder_RunBuffer),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).utf8text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder_RunBuffer),
            "::",
            stringify!(utf8text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clusters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder_RunBuffer),
            "::",
            stringify!(clusters)
        )
    );
}
#[test]
fn bindgen_test_layout_SkTextBlobBuilder() {
    const UNINIT: ::core::mem::MaybeUninit<SkTextBlobBuilder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTextBlobBuilder>(),
        88usize,
        concat!("Size of: ", stringify!(SkTextBlobBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlobBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlobBuilder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStorage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fStorage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStorageSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fStorageSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStorageUsed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fStorageUsed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRunCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fRunCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDeferredBounds) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fDeferredBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLastRun) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fLastRun)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCurrentRunBuffer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilder),
            "::",
            stringify!(fCurrentRunBuffer)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder4makeEv"]
    pub fn SkTextBlobBuilder_make(this: *mut SkTextBlobBuilder) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder8allocRunERK6SkFontiffPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRun(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        x: SkScalar,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder12allocRunPosHERK6SkFontifPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunPosH(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder11allocRunPosERK6SkFontiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunPos(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder15allocRunRSXformERK6SkFonti"]
    pub fn SkTextBlobBuilder_allocRunRSXform(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::core::ffi::c_int,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder12allocRunTextERK6SkFontiffiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunText(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        x: SkScalar,
        y: SkScalar,
        textByteCount: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder16allocRunTextPosHERK6SkFontifiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunTextPosH(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        y: SkScalar,
        textByteCount: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder15allocRunTextPosERK6SkFontiiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunTextPos(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        textByteCount: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder19allocRunTextRSXformERK6SkFontiiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunTextRSXform(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        textByteCount: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilderC1Ev"]
    pub fn SkTextBlobBuilder_SkTextBlobBuilder(this: *mut SkTextBlobBuilder);
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilderD1Ev"]
    pub fn SkTextBlobBuilder_SkTextBlobBuilder_destructor(this: *mut SkTextBlobBuilder);
}
impl SkTextBlobBuilder {
    #[inline]
    pub unsafe fn make(&mut self) -> sk_sp<SkTextBlob> {
        SkTextBlobBuilder_make(self)
    }
    #[inline]
    pub unsafe fn allocRun(
        &mut self,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        x: SkScalar,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRun(self, font, count, x, y, bounds)
    }
    #[inline]
    pub unsafe fn allocRunPosH(
        &mut self,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunPosH(self, font, count, y, bounds)
    }
    #[inline]
    pub unsafe fn allocRunPos(
        &mut self,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunPos(self, font, count, bounds)
    }
    #[inline]
    pub unsafe fn allocRunRSXform(
        &mut self,
        font: *const SkFont,
        count: ::core::ffi::c_int,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunRSXform(self, font, count)
    }
    #[inline]
    pub unsafe fn allocRunText(
        &mut self,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        x: SkScalar,
        y: SkScalar,
        textByteCount: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunText(self, font, count, x, y, textByteCount, bounds)
    }
    #[inline]
    pub unsafe fn allocRunTextPosH(
        &mut self,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        y: SkScalar,
        textByteCount: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunTextPosH(self, font, count, y, textByteCount, bounds)
    }
    #[inline]
    pub unsafe fn allocRunTextPos(
        &mut self,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        textByteCount: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunTextPos(self, font, count, textByteCount, bounds)
    }
    #[inline]
    pub unsafe fn allocRunTextRSXform(
        &mut self,
        font: *const SkFont,
        count: ::core::ffi::c_int,
        textByteCount: ::core::ffi::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunTextRSXform(self, font, count, textByteCount, bounds)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTextBlobBuilder_SkTextBlobBuilder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkTextBlobBuilder_SkTextBlobBuilder_destructor(self)
    }
}
impl SkTextureCompressionType {
    pub const Last: SkTextureCompressionType = SkTextureCompressionType::BC1_RGBA8_UNORM;
}
impl SkTextureCompressionType {
    pub const ETC1_RGB8: SkTextureCompressionType = SkTextureCompressionType::ETC2_RGB8_UNORM;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextureCompressionType {
    None = 0,
    ETC2_RGB8_UNORM = 1,
    BC1_RGB8_UNORM = 2,
    BC1_RGBA8_UNORM = 3,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkVertices {
    pub _base: SkNVRefCnt,
    pub fUniqueID: u32,
    pub fPositions: *mut SkPoint,
    pub fIndices: *mut u16,
    pub fTexs: *mut SkPoint,
    pub fColors: *mut SkColor,
    pub fBounds: SkRect,
    pub fVertexCount: ::core::ffi::c_int,
    pub fIndexCount: ::core::ffi::c_int,
    pub fMode: SkVertices_VertexMode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkVertices_Desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkVertices_Sizes {
    _unused: [u8; 0],
}
impl SkVertices_VertexMode {
    pub const Last: SkVertices_VertexMode = SkVertices_VertexMode::TriangleFan;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkVertices_VertexMode {
    Triangles = 0,
    TriangleStrip = 1,
    TriangleFan = 2,
}
pub const SkVertices_BuilderFlags_kHasTexCoords_BuilderFlag: SkVertices_BuilderFlags = 1;
pub const SkVertices_BuilderFlags_kHasColors_BuilderFlag: SkVertices_BuilderFlags = 2;
pub type SkVertices_BuilderFlags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct SkVertices_Builder {
    pub fVertices: sk_sp<SkVertices>,
    pub fIntermediateFanIndices: u64,
}
#[test]
fn bindgen_test_layout_SkVertices_Builder() {
    const UNINIT: ::core::mem::MaybeUninit<SkVertices_Builder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkVertices_Builder>(),
        16usize,
        concat!("Size of: ", stringify!(SkVertices_Builder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkVertices_Builder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkVertices_Builder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVertices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices_Builder),
            "::",
            stringify!(fVertices)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIntermediateFanIndices) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices_Builder),
            "::",
            stringify!(fIntermediateFanIndices)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder9positionsEv"]
    pub fn SkVertices_Builder_positions(this: *mut SkVertices_Builder) -> *mut SkPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder7indicesEv"]
    pub fn SkVertices_Builder_indices(this: *mut SkVertices_Builder) -> *mut u16;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder9texCoordsEv"]
    pub fn SkVertices_Builder_texCoords(this: *mut SkVertices_Builder) -> *mut SkPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder6colorsEv"]
    pub fn SkVertices_Builder_colors(this: *mut SkVertices_Builder) -> *mut SkColor;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder6detachEv"]
    pub fn SkVertices_Builder_detach(this: *mut SkVertices_Builder) -> sk_sp<SkVertices>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7BuilderC1ENS_10VertexModeEiij"]
    pub fn SkVertices_Builder_Builder(
        this: *mut SkVertices_Builder,
        mode: SkVertices_VertexMode,
        vertexCount: ::core::ffi::c_int,
        indexCount: ::core::ffi::c_int,
        flags: u32,
    );
}
impl SkVertices_Builder {
    #[inline]
    pub unsafe fn positions(&mut self) -> *mut SkPoint {
        SkVertices_Builder_positions(self)
    }
    #[inline]
    pub unsafe fn indices(&mut self) -> *mut u16 {
        SkVertices_Builder_indices(self)
    }
    #[inline]
    pub unsafe fn texCoords(&mut self) -> *mut SkPoint {
        SkVertices_Builder_texCoords(self)
    }
    #[inline]
    pub unsafe fn colors(&mut self) -> *mut SkColor {
        SkVertices_Builder_colors(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> sk_sp<SkVertices> {
        SkVertices_Builder_detach(self)
    }
    #[inline]
    pub unsafe fn new(
        mode: SkVertices_VertexMode,
        vertexCount: ::core::ffi::c_int,
        indexCount: ::core::ffi::c_int,
        flags: u32,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkVertices_Builder_Builder(
            __bindgen_tmp.as_mut_ptr(),
            mode,
            vertexCount,
            indexCount,
            flags,
        );
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn bindgen_test_layout_SkVertices() {
    const UNINIT: ::core::mem::MaybeUninit<SkVertices> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkVertices>(),
        72usize,
        concat!("Size of: ", stringify!(SkVertices))
    );
    assert_eq!(
        ::core::mem::align_of::<SkVertices>(),
        8usize,
        concat!("Alignment of ", stringify!(SkVertices))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fUniqueID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPositions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fPositions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIndices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fIndices)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTexs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fTexs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColors) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fColors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVertexCount) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fVertexCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIndexCount) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fIndexCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkVertices),
            "::",
            stringify!(fMode)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices8MakeCopyENS_10VertexModeEiPK7SkPointS3_PKjiPKt"]
    pub fn SkVertices_MakeCopy(
        mode: SkVertices_VertexMode,
        vertexCount: ::core::ffi::c_int,
        positions: *const SkPoint,
        texs: *const SkPoint,
        colors: *const SkColor,
        indexCount: ::core::ffi::c_int,
        indices: *const u16,
    ) -> sk_sp<SkVertices>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkVertices15approximateSizeEv"]
    pub fn SkVertices_approximateSize(this: *const SkVertices) -> usize;
}
impl SkVertices {
    #[inline]
    pub unsafe fn MakeCopy(
        mode: SkVertices_VertexMode,
        vertexCount: ::core::ffi::c_int,
        positions: *const SkPoint,
        texs: *const SkPoint,
        colors: *const SkColor,
        indexCount: ::core::ffi::c_int,
        indices: *const u16,
    ) -> sk_sp<SkVertices> {
        SkVertices_MakeCopy(
            mode,
            vertexCount,
            positions,
            texs,
            colors,
            indexCount,
            indices,
        )
    }
    #[inline]
    pub unsafe fn approximateSize(&self) -> usize {
        SkVertices_approximateSize(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTime_DateTime {
    pub fTimeZoneMinutes: i16,
    pub fYear: u16,
    pub fMonth: u8,
    pub fDayOfWeek: u8,
    pub fDay: u8,
    pub fHour: u8,
    pub fMinute: u8,
    pub fSecond: u8,
}
#[test]
fn bindgen_test_layout_SkTime_DateTime() {
    const UNINIT: ::core::mem::MaybeUninit<SkTime_DateTime> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTime_DateTime>(),
        10usize,
        concat!("Size of: ", stringify!(SkTime_DateTime))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTime_DateTime>(),
        2usize,
        concat!("Alignment of ", stringify!(SkTime_DateTime))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTimeZoneMinutes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fTimeZoneMinutes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fYear) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fYear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMonth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fMonth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDayOfWeek) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fDayOfWeek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDay) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fDay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHour) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fHour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMinute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fMinute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSecond) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTime_DateTime),
            "::",
            stringify!(fSecond)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkTime8DateTime9toISO8601EP8SkString"]
    pub fn SkTime_DateTime_toISO8601(this: *const SkTime_DateTime, dst: *mut SkString);
}
impl SkTime_DateTime {
    #[inline]
    pub unsafe fn toISO8601(&self, dst: *mut SkString) {
        SkTime_DateTime_toISO8601(self, dst)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkExecutor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPDFArray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPDF_AttributeList {
    pub fAttrs: u64,
}
#[test]
fn bindgen_test_layout_SkPDF_AttributeList() {
    const UNINIT: ::core::mem::MaybeUninit<SkPDF_AttributeList> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPDF_AttributeList>(),
        8usize,
        concat!("Size of: ", stringify!(SkPDF_AttributeList))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPDF_AttributeList>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPDF_AttributeList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAttrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_AttributeList),
            "::",
            stringify!(fAttrs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList9appendIntEPKcS2_i"]
    pub fn SkPDF_AttributeList_appendInt(
        this: *mut SkPDF_AttributeList,
        owner: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        value: ::core::ffi::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList11appendFloatEPKcS2_f"]
    pub fn SkPDF_AttributeList_appendFloat(
        this: *mut SkPDF_AttributeList,
        owner: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        value: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList10appendNameEPKcS2_S2_"]
    pub fn SkPDF_AttributeList_appendName(
        this: *mut SkPDF_AttributeList,
        owner: *const ::core::ffi::c_char,
        attrName: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList16appendFloatArrayEPKcS2_RKNSt3__16vectorIfNS3_9allocatorIfEEEE"]
    pub fn SkPDF_AttributeList_appendFloatArray(
        this: *mut SkPDF_AttributeList,
        owner: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        value: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList17appendNodeIdArrayEPKcS2_RKNSt3__16vectorIiNS3_9allocatorIiEEEE"]
    pub fn SkPDF_AttributeList_appendNodeIdArray(
        this: *mut SkPDF_AttributeList,
        owner: *const ::core::ffi::c_char,
        attrName: *const ::core::ffi::c_char,
        nodeIds: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeListC1Ev"]
    pub fn SkPDF_AttributeList_AttributeList(this: *mut SkPDF_AttributeList);
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeListD1Ev"]
    pub fn SkPDF_AttributeList_AttributeList_destructor(this: *mut SkPDF_AttributeList);
}
impl SkPDF_AttributeList {
    #[inline]
    pub unsafe fn appendInt(
        &mut self,
        owner: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        value: ::core::ffi::c_int,
    ) {
        SkPDF_AttributeList_appendInt(self, owner, name, value)
    }
    #[inline]
    pub unsafe fn appendFloat(
        &mut self,
        owner: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        value: f32,
    ) {
        SkPDF_AttributeList_appendFloat(self, owner, name, value)
    }
    #[inline]
    pub unsafe fn appendName(
        &mut self,
        owner: *const ::core::ffi::c_char,
        attrName: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) {
        SkPDF_AttributeList_appendName(self, owner, attrName, value)
    }
    #[inline]
    pub unsafe fn appendFloatArray(
        &mut self,
        owner: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        value: *const [u64; 3usize],
    ) {
        SkPDF_AttributeList_appendFloatArray(self, owner, name, value)
    }
    #[inline]
    pub unsafe fn appendNodeIdArray(
        &mut self,
        owner: *const ::core::ffi::c_char,
        attrName: *const ::core::ffi::c_char,
        nodeIds: *const [u64; 3usize],
    ) {
        SkPDF_AttributeList_appendNodeIdArray(self, owner, attrName, nodeIds)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPDF_AttributeList_AttributeList(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPDF_AttributeList_AttributeList_destructor(self)
    }
}
#[repr(C)]
pub struct SkPDF_StructureElementNode {
    pub fTypeString: SkString,
    pub fChildVector: [u64; 3usize],
    pub fNodeId: ::core::ffi::c_int,
    pub fAdditionalNodeIds: [u64; 3usize],
    pub fAttributes: SkPDF_AttributeList,
    pub fAlt: SkString,
    pub fLang: SkString,
}
#[test]
fn bindgen_test_layout_SkPDF_StructureElementNode() {
    const UNINIT: ::core::mem::MaybeUninit<SkPDF_StructureElementNode> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPDF_StructureElementNode>(),
        88usize,
        concat!("Size of: ", stringify!(SkPDF_StructureElementNode))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPDF_StructureElementNode>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPDF_StructureElementNode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTypeString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fTypeString)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fChildVector) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fChildVector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fNodeId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fNodeId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAdditionalNodeIds) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fAdditionalNodeIds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAttributes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAlt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fAlt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLang) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_StructureElementNode),
            "::",
            stringify!(fLang)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPDF_Metadata {
    pub fTitle: SkString,
    pub fAuthor: SkString,
    pub fSubject: SkString,
    pub fKeywords: SkString,
    pub fCreator: SkString,
    pub fProducer: SkString,
    pub fCreation: SkTime_DateTime,
    pub fModified: SkTime_DateTime,
    pub fRasterDPI: SkScalar,
    pub fPDFA: bool,
    pub fEncodingQuality: ::core::ffi::c_int,
    pub fStructureElementTreeRoot: *mut SkPDF_StructureElementNode,
    pub fExecutor: *mut SkExecutor,
    pub fCompressionLevel: SkPDF_Metadata_CompressionLevel,
    pub fSubsetter: SkPDF_Metadata_Subsetter,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPDF_Metadata_CompressionLevel {
    Default = -1,
    None = 0,
    LowButFast = 1,
    Average = 6,
    HighButSlow = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPDF_Metadata_Subsetter {
    kHarfbuzz_Subsetter = 0,
    kSfntly_Subsetter = 1,
}
#[test]
fn bindgen_test_layout_SkPDF_Metadata() {
    const UNINIT: ::core::mem::MaybeUninit<SkPDF_Metadata> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPDF_Metadata>(),
        104usize,
        concat!("Size of: ", stringify!(SkPDF_Metadata))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPDF_Metadata>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPDF_Metadata))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTitle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fTitle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAuthor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fAuthor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSubject) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fSubject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fKeywords) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fKeywords)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCreator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fCreator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProducer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fProducer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCreation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fCreation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fModified) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fModified)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRasterDPI) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fRasterDPI)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPDFA) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fPDFA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEncodingQuality) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fEncodingQuality)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStructureElementTreeRoot) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fStructureElementTreeRoot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fExecutor) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fExecutor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCompressionLevel) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fCompressionLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSubsetter) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPDF_Metadata),
            "::",
            stringify!(fSubsetter)
        )
    );
}
impl SkPath1DPathEffect_Style {
    pub const LastEnum: SkPath1DPathEffect_Style = SkPath1DPathEffect_Style::Morph;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath1DPathEffect_Style {
    Translate = 0,
    Rotate = 1,
    Morph = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBlender {
    pub _base: SkFlattenable,
}
#[test]
fn bindgen_test_layout_SkBlender() {
    assert_eq!(
        ::core::mem::size_of::<SkBlender>(),
        16usize,
        concat!("Size of: ", stringify!(SkBlender))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBlender>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBlender))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkBlender4ModeE11SkBlendMode"]
    pub fn SkBlender_Mode(mode: SkBlendMode) -> sk_sp<SkBlender>;
}
impl SkBlender {
    #[inline]
    pub unsafe fn Mode(mode: SkBlendMode) -> sk_sp<SkBlender> {
        SkBlender_Mode(mode)
    }
}
#[repr(C)]
pub struct SkColorMatrix {
    pub fMat: [u32; 20usize],
}
#[test]
fn bindgen_test_layout_SkColorMatrix() {
    const UNINIT: ::core::mem::MaybeUninit<SkColorMatrix> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkColorMatrix>(),
        80usize,
        concat!("Size of: ", stringify!(SkColorMatrix))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorMatrix>(),
        4usize,
        concat!("Alignment of ", stringify!(SkColorMatrix))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkColorMatrix),
            "::",
            stringify!(fMat)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix8RGBtoYUVE15SkYUVColorSpace"]
    pub fn SkColorMatrix_RGBtoYUV(arg1: SkYUVColorSpace) -> SkColorMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix8YUVtoRGBE15SkYUVColorSpace"]
    pub fn SkColorMatrix_YUVtoRGB(arg1: SkYUVColorSpace) -> SkColorMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix11setIdentityEv"]
    pub fn SkColorMatrix_setIdentity(this: *mut SkColorMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix8setScaleEffff"]
    pub fn SkColorMatrix_setScale(
        this: *mut SkColorMatrix,
        rScale: f32,
        gScale: f32,
        bScale: f32,
        aScale: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix13postTranslateEffff"]
    pub fn SkColorMatrix_postTranslate(
        this: *mut SkColorMatrix,
        dr: f32,
        dg: f32,
        db: f32,
        da: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix9setConcatERKS_S1_"]
    pub fn SkColorMatrix_setConcat(
        this: *mut SkColorMatrix,
        a: *const SkColorMatrix,
        b: *const SkColorMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix13setSaturationEf"]
    pub fn SkColorMatrix_setSaturation(this: *mut SkColorMatrix, sat: f32);
}
impl SkColorMatrix {
    #[inline]
    pub unsafe fn RGBtoYUV(arg1: SkYUVColorSpace) -> SkColorMatrix {
        SkColorMatrix_RGBtoYUV(arg1)
    }
    #[inline]
    pub unsafe fn YUVtoRGB(arg1: SkYUVColorSpace) -> SkColorMatrix {
        SkColorMatrix_YUVtoRGB(arg1)
    }
    #[inline]
    pub unsafe fn setIdentity(&mut self) {
        SkColorMatrix_setIdentity(self)
    }
    #[inline]
    pub unsafe fn setScale(&mut self, rScale: f32, gScale: f32, bScale: f32, aScale: f32) {
        SkColorMatrix_setScale(self, rScale, gScale, bScale, aScale)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, dr: f32, dg: f32, db: f32, da: f32) {
        SkColorMatrix_postTranslate(self, dr, dg, db, da)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkColorMatrix, b: *const SkColorMatrix) {
        SkColorMatrix_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn setSaturation(&mut self, sat: f32) {
        SkColorMatrix_setSaturation(self, sat)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPathEffect {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathEffect_DashType {
    kNone_DashType = 0,
    kDash_DashType = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPathEffect_DashInfo {
    pub fIntervals: *mut SkScalar,
    pub fCount: i32,
    pub fPhase: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPathEffect_DashInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SkPathEffect_DashInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPathEffect_DashInfo>(),
        16usize,
        concat!("Size of: ", stringify!(SkPathEffect_DashInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathEffect_DashInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathEffect_DashInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIntervals) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_DashInfo),
            "::",
            stringify!(fIntervals)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_DashInfo),
            "::",
            stringify!(fCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPhase) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPathEffect_DashInfo),
            "::",
            stringify!(fPhase)
        )
    );
}
pub type SkPathEffect_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkPathEffect() {
    assert_eq!(
        ::core::mem::size_of::<SkPathEffect>(),
        16usize,
        concat!("Size of: ", stringify!(SkPathEffect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathEffect))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkPathEffect7MakeSumE5sk_spIS_ES1_"]
    pub fn SkPathEffect_MakeSum(
        first: sk_sp<SkPathEffect>,
        second: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkPathEffect11MakeComposeE5sk_spIS_ES1_"]
    pub fn SkPathEffect_MakeCompose(
        outer: sk_sp<SkPathEffect>,
        inner: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkPathEffect7asADashEPNS_8DashInfoE"]
    pub fn SkPathEffect_asADash(
        this: *const SkPathEffect,
        info: *mut SkPathEffect_DashInfo,
    ) -> SkPathEffect_DashType;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkPathEffect10filterPathEP6SkPathRKS0_P11SkStrokeRecPK6SkRect"]
    pub fn SkPathEffect_filterPath(
        this: *const SkPathEffect,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkPathEffect10filterPathEP6SkPathRKS0_P11SkStrokeRecPK6SkRectRK8SkMatrix"]
    pub fn SkPathEffect_filterPath1(
        this: *const SkPathEffect,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
        ctm: *const SkMatrix,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkPathEffect8needsCTMEv"]
    pub fn SkPathEffect_needsCTM(this: *const SkPathEffect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkPathEffect11DeserializeEPKvmPK15SkDeserialProcs"]
    pub fn SkPathEffect_Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPathEffect>;
}
impl SkPathEffect {
    #[inline]
    pub unsafe fn MakeSum(
        first: sk_sp<SkPathEffect>,
        second: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect> {
        SkPathEffect_MakeSum(first, second)
    }
    #[inline]
    pub unsafe fn MakeCompose(
        outer: sk_sp<SkPathEffect>,
        inner: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect> {
        SkPathEffect_MakeCompose(outer, inner)
    }
    #[inline]
    pub unsafe fn asADash(&self, info: *mut SkPathEffect_DashInfo) -> SkPathEffect_DashType {
        SkPathEffect_asADash(self, info)
    }
    #[inline]
    pub unsafe fn filterPath(
        &self,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
    ) -> bool {
        SkPathEffect_filterPath(self, dst, src, arg1, cullR)
    }
    #[inline]
    pub unsafe fn filterPath1(
        &self,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
        ctm: *const SkMatrix,
    ) -> bool {
        SkPathEffect_filterPath1(self, dst, src, arg1, cullR, ctm)
    }
    #[inline]
    pub unsafe fn needsCTM(&self) -> bool {
        SkPathEffect_needsCTM(self)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPathEffect> {
        SkPathEffect_Deserialize(data, size, procs)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkGradientShader {
    pub _address: u8,
}
pub const SkGradientShader_Flags_kInterpolateColorsInPremul_Flag: SkGradientShader_Flags = 1;
pub type SkGradientShader_Flags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkGradientShader_Interpolation {
    pub fInPremul: SkGradientShader_Interpolation_InPremul,
    pub fColorSpace: SkGradientShader_Interpolation_ColorSpace,
    pub fHueMethod: SkGradientShader_Interpolation_HueMethod,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkGradientShader_Interpolation_InPremul {
    No = 0,
    Yes = 1,
}
impl SkGradientShader_Interpolation_ColorSpace {
    pub const LastColorSpace: SkGradientShader_Interpolation_ColorSpace =
        SkGradientShader_Interpolation_ColorSpace::HWB;
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkGradientShader_Interpolation_ColorSpace {
    Destination = 0,
    SRGBLinear = 1,
    Lab = 2,
    OKLab = 3,
    LCH = 4,
    OKLCH = 5,
    SRGB = 6,
    HSL = 7,
    HWB = 8,
}
impl SkGradientShader_Interpolation_HueMethod {
    pub const LastHueMethod: SkGradientShader_Interpolation_HueMethod =
        SkGradientShader_Interpolation_HueMethod::Decreasing;
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkGradientShader_Interpolation_HueMethod {
    Shorter = 0,
    Longer = 1,
    Increasing = 2,
    Decreasing = 3,
}
pub const SkGradientShader_Interpolation_kColorSpaceCount: ::core::ffi::c_int = 9;
pub const SkGradientShader_Interpolation_kHueMethodCount: ::core::ffi::c_int = 4;
#[test]
fn bindgen_test_layout_SkGradientShader_Interpolation() {
    const UNINIT: ::core::mem::MaybeUninit<SkGradientShader_Interpolation> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkGradientShader_Interpolation>(),
        3usize,
        concat!("Size of: ", stringify!(SkGradientShader_Interpolation))
    );
    assert_eq!(
        ::core::mem::align_of::<SkGradientShader_Interpolation>(),
        1usize,
        concat!("Alignment of ", stringify!(SkGradientShader_Interpolation))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInPremul) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkGradientShader_Interpolation),
            "::",
            stringify!(fInPremul)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorSpace) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SkGradientShader_Interpolation),
            "::",
            stringify!(fColorSpace)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHueMethod) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SkGradientShader_Interpolation),
            "::",
            stringify!(fHueMethod)
        )
    );
}
#[test]
fn bindgen_test_layout_SkGradientShader() {
    assert_eq!(
        ::core::mem::size_of::<SkGradientShader>(),
        1usize,
        concat!("Size of: ", stringify!(SkGradientShader))
    );
    assert_eq!(
        ::core::mem::align_of::<SkGradientShader>(),
        1usize,
        concat!("Alignment of ", stringify!(SkGradientShader))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeLinearEPK7SkPointPKjPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeLinear(
        pts: *const SkPoint,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeLinearEPK7SkPointPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModeRKNS_13InterpolationEPK8SkMatrix"]
    pub fn SkGradientShader_MakeLinear1(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeRadialERK7SkPointfPKjPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeRadial(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeRadialERK7SkPointfPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModeRKNS_13InterpolationEPK8SkMatrix"]
    pub fn SkGradientShader_MakeRadial1(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader19MakeTwoPointConicalERK7SkPointfS2_fPKjPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeTwoPointConical(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader19MakeTwoPointConicalERK7SkPointfS2_fPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModeRKNS_13InterpolationEPK8SkMatrix"]
    pub fn SkGradientShader_MakeTwoPointConical1(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader9MakeSweepEffPKjPKfi10SkTileModeffjPK8SkMatrix"]
    pub fn SkGradientShader_MakeSweep(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader9MakeSweepEffPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModeffRKNS_13InterpolationEPK8SkMatrix"]
    pub fn SkGradientShader_MakeSweep1(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
impl SkGradientShader {
    #[inline]
    pub unsafe fn MakeLinear(
        pts: *const SkPoint,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeLinear(pts, colors, pos, count, mode, flags, localMatrix)
    }
    #[inline]
    pub unsafe fn MakeLinear1(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeLinear1(
            pts,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            interpolation,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeRadial(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeRadial(center, radius, colors, pos, count, mode, flags, localMatrix)
    }
    #[inline]
    pub unsafe fn MakeRadial1(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeRadial1(
            center,
            radius,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            interpolation,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeTwoPointConical(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeTwoPointConical(
            start,
            startRadius,
            end,
            endRadius,
            colors,
            pos,
            count,
            mode,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeTwoPointConical1(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeTwoPointConical1(
            start,
            startRadius,
            end,
            endRadius,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            interpolation,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeSweep(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeSweep(
            cx,
            cy,
            colors,
            pos,
            count,
            mode,
            startAngle,
            endAngle,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeSweep1(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeSweep1(
            cx,
            cy,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            startAngle,
            endAngle,
            interpolation,
            localMatrix,
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkHighContrastConfig {
    pub fGrayscale: bool,
    pub fInvertStyle: SkHighContrastConfig_InvertStyle,
    pub fContrast: SkScalar,
}
impl SkHighContrastConfig_InvertStyle {
    pub const Last: SkHighContrastConfig_InvertStyle =
        SkHighContrastConfig_InvertStyle::InvertLightness;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkHighContrastConfig_InvertStyle {
    NoInvert = 0,
    InvertBrightness = 1,
    InvertLightness = 2,
}
#[test]
fn bindgen_test_layout_SkHighContrastConfig() {
    const UNINIT: ::core::mem::MaybeUninit<SkHighContrastConfig> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkHighContrastConfig>(),
        12usize,
        concat!("Size of: ", stringify!(SkHighContrastConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<SkHighContrastConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(SkHighContrastConfig))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGrayscale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkHighContrastConfig),
            "::",
            stringify!(fGrayscale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInvertStyle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkHighContrastConfig),
            "::",
            stringify!(fInvertStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fContrast) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkHighContrastConfig),
            "::",
            stringify!(fContrast)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImageFilters_CropRect {
    pub fCropRect: SkRect,
}
#[test]
fn bindgen_test_layout_SkImageFilters_CropRect() {
    const UNINIT: ::core::mem::MaybeUninit<SkImageFilters_CropRect> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkImageFilters_CropRect>(),
        16usize,
        concat!("Size of: ", stringify!(SkImageFilters_CropRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageFilters_CropRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkImageFilters_CropRect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCropRect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkImageFilters_CropRect),
            "::",
            stringify!(fCropRect)
        )
    );
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImageFilters_Dither {
    No = 0,
    Yes = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathOp {
    Difference = 0,
    Intersect = 1,
    Union = 2,
    XOR = 3,
    ReverseDifference = 4,
}
extern "C" {
    #[link_name = "\u{1}__Z2OpRK6SkPathS1_8SkPathOpPS_"]
    pub fn Op(one: *const SkPath, two: *const SkPath, op: SkPathOp, result: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z8SimplifyRK6SkPathPS_"]
    pub fn Simplify(path: *const SkPath, result: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z11TightBoundsRK6SkPathP6SkRect"]
    pub fn TightBounds(path: *const SkPath, result: *mut SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z9AsWindingRK6SkPathPS_"]
    pub fn AsWinding(path: *const SkPath, result: *mut SkPath) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkOpBuilder {
    pub fPathRefs: [u64; 2usize],
    pub fOps: SkTDArray,
}
#[test]
fn bindgen_test_layout_SkOpBuilder() {
    const UNINIT: ::core::mem::MaybeUninit<SkOpBuilder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkOpBuilder>(),
        40usize,
        concat!("Size of: ", stringify!(SkOpBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkOpBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkOpBuilder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPathRefs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkOpBuilder),
            "::",
            stringify!(fPathRefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOps) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkOpBuilder),
            "::",
            stringify!(fOps)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkOpBuilder3addERK6SkPath8SkPathOp"]
    pub fn SkOpBuilder_add(this: *mut SkOpBuilder, path: *const SkPath, _operator: SkPathOp);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkOpBuilder7resolveEP6SkPath"]
    pub fn SkOpBuilder_resolve(this: *mut SkOpBuilder, result: *mut SkPath) -> bool;
}
impl SkOpBuilder {
    #[inline]
    pub unsafe fn add(&mut self, path: *const SkPath, _operator: SkPathOp) {
        SkOpBuilder_add(self, path, _operator)
    }
    #[inline]
    pub unsafe fn resolve(&mut self, result: *mut SkPath) -> bool {
        SkOpBuilder_resolve(self, result)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkSL_DebugTrace {
    pub _base: SkRefCnt,
}
#[test]
fn bindgen_test_layout_SkSL_DebugTrace() {
    assert_eq!(
        ::core::mem::size_of::<SkSL_DebugTrace>(),
        16usize,
        concat!("Size of: ", stringify!(SkSL_DebugTrace))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSL_DebugTrace>(),
        8usize,
        concat!("Alignment of ", stringify!(SkSL_DebugTrace))
    );
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSL_Version {
    k100 = 0,
    k300 = 1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkRuntimeEffect {
    pub _bindgen_opaque_blob: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRuntimeEffect_Uniform {
    pub name: std_string_view,
    pub offset: usize,
    pub type_: SkRuntimeEffect_Uniform_Type,
    pub count: ::core::ffi::c_int,
    pub flags: u32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRuntimeEffect_Uniform_Type {
    Float = 0,
    Float2 = 1,
    Float3 = 2,
    Float4 = 3,
    Float2x2 = 4,
    Float3x3 = 5,
    Float4x4 = 6,
    Int = 7,
    Int2 = 8,
    Int3 = 9,
    Int4 = 10,
}
pub const SkRuntimeEffect_Uniform_Flags_kArray_Flag: SkRuntimeEffect_Uniform_Flags = 1;
pub const SkRuntimeEffect_Uniform_Flags_kColor_Flag: SkRuntimeEffect_Uniform_Flags = 2;
pub const SkRuntimeEffect_Uniform_Flags_kVertex_Flag: SkRuntimeEffect_Uniform_Flags = 4;
pub const SkRuntimeEffect_Uniform_Flags_kFragment_Flag: SkRuntimeEffect_Uniform_Flags = 8;
pub const SkRuntimeEffect_Uniform_Flags_kHalfPrecision_Flag: SkRuntimeEffect_Uniform_Flags = 16;
pub type SkRuntimeEffect_Uniform_Flags = ::core::ffi::c_uint;
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Uniform() {
    const UNINIT: ::core::mem::MaybeUninit<SkRuntimeEffect_Uniform> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Uniform>(),
        40usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Uniform))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Uniform>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Uniform))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Uniform),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect7Uniform11sizeInBytesEv"]
    pub fn SkRuntimeEffect_Uniform_sizeInBytes(this: *const SkRuntimeEffect_Uniform) -> usize;
}
impl SkRuntimeEffect_Uniform {
    #[inline]
    pub unsafe fn sizeInBytes(&self) -> usize {
        SkRuntimeEffect_Uniform_sizeInBytes(self)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRuntimeEffect_ChildType {
    Shader = 0,
    ColorFilter = 1,
    Blender = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRuntimeEffect_Child {
    pub name: std_string_view,
    pub type_: SkRuntimeEffect_ChildType,
    pub index: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Child() {
    const UNINIT: ::core::mem::MaybeUninit<SkRuntimeEffect_Child> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Child>(),
        24usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Child))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Child>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Child))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Child),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Child),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Child),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRuntimeEffect_Options {
    pub forceUnoptimized: bool,
    pub allowPrivateAccess: bool,
    pub maxVersionAllowed: SkSL_Version,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Options() {
    const UNINIT: ::core::mem::MaybeUninit<SkRuntimeEffect_Options> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Options>(),
        8usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Options))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Options>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Options))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).forceUnoptimized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Options),
            "::",
            stringify!(forceUnoptimized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allowPrivateAccess) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Options),
            "::",
            stringify!(allowPrivateAccess)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxVersionAllowed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Options),
            "::",
            stringify!(maxVersionAllowed)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRuntimeEffect_Result {
    pub effect: sk_sp<SkRuntimeEffect>,
    pub errorText: SkString,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Result() {
    const UNINIT: ::core::mem::MaybeUninit<SkRuntimeEffect_Result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Result>(),
        16usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Result))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Result>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Result))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).effect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Result),
            "::",
            stringify!(effect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errorText) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_Result),
            "::",
            stringify!(errorText)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRuntimeEffect_ChildPtr {
    pub fChild: sk_sp<SkFlattenable>,
}
pub type SkRuntimeEffect_ChildPtr_sk_is_trivially_relocatable = std_true_type;
#[test]
fn bindgen_test_layout_SkRuntimeEffect_ChildPtr() {
    const UNINIT: ::core::mem::MaybeUninit<SkRuntimeEffect_ChildPtr> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_ChildPtr>(),
        8usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_ChildPtr))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_ChildPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_ChildPtr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fChild) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_ChildPtr),
            "::",
            stringify!(fChild)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect8ChildPtr4typeEv"]
    pub fn SkRuntimeEffect_ChildPtr_type(this: *const SkRuntimeEffect_ChildPtr) -> u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect8ChildPtr6shaderEv"]
    pub fn SkRuntimeEffect_ChildPtr_shader(this: *const SkRuntimeEffect_ChildPtr) -> *mut SkShader;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect8ChildPtr11colorFilterEv"]
    pub fn SkRuntimeEffect_ChildPtr_colorFilter(
        this: *const SkRuntimeEffect_ChildPtr,
    ) -> *mut SkColorFilter;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect8ChildPtr7blenderEv"]
    pub fn SkRuntimeEffect_ChildPtr_blender(
        this: *const SkRuntimeEffect_ChildPtr,
    ) -> *mut SkBlender;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect8ChildPtrC1E5sk_spI13SkFlattenableE"]
    pub fn SkRuntimeEffect_ChildPtr_ChildPtr(
        this: *mut SkRuntimeEffect_ChildPtr,
        f: sk_sp<SkFlattenable>,
    );
}
impl SkRuntimeEffect_ChildPtr {
    #[inline]
    pub unsafe fn type_(&self) -> u8 {
        SkRuntimeEffect_ChildPtr_type(self)
    }
    #[inline]
    pub unsafe fn shader(&self) -> *mut SkShader {
        SkRuntimeEffect_ChildPtr_shader(self)
    }
    #[inline]
    pub unsafe fn colorFilter(&self) -> *mut SkColorFilter {
        SkRuntimeEffect_ChildPtr_colorFilter(self)
    }
    #[inline]
    pub unsafe fn blender(&self) -> *mut SkBlender {
        SkRuntimeEffect_ChildPtr_blender(self)
    }
    #[inline]
    pub unsafe fn new(f: sk_sp<SkFlattenable>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRuntimeEffect_ChildPtr_ChildPtr(__bindgen_tmp.as_mut_ptr(), f);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRuntimeEffect_TracedShader {
    pub shader: sk_sp<SkShader>,
    pub debugTrace: sk_sp<SkSL_DebugTrace>,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_TracedShader() {
    const UNINIT: ::core::mem::MaybeUninit<SkRuntimeEffect_TracedShader> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_TracedShader>(),
        16usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_TracedShader))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_TracedShader>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_TracedShader))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shader) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_TracedShader),
            "::",
            stringify!(shader)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).debugTrace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkRuntimeEffect_TracedShader),
            "::",
            stringify!(debugTrace)
        )
    );
}
pub const SkRuntimeEffect_Flags_kUsesSampleCoords_Flag: SkRuntimeEffect_Flags = 1;
pub const SkRuntimeEffect_Flags_kAllowColorFilter_Flag: SkRuntimeEffect_Flags = 2;
pub const SkRuntimeEffect_Flags_kAllowShader_Flag: SkRuntimeEffect_Flags = 4;
pub const SkRuntimeEffect_Flags_kAllowBlender_Flag: SkRuntimeEffect_Flags = 8;
pub const SkRuntimeEffect_Flags_kSamplesOutsideMain_Flag: SkRuntimeEffect_Flags = 16;
pub const SkRuntimeEffect_Flags_kUsesColorTransform_Flag: SkRuntimeEffect_Flags = 32;
pub const SkRuntimeEffect_Flags_kAlwaysOpaque_Flag: SkRuntimeEffect_Flags = 64;
pub const SkRuntimeEffect_Flags_kAlphaUnchanged_Flag: SkRuntimeEffect_Flags = 128;
pub const SkRuntimeEffect_Flags_kDisableOptimization_Flag: SkRuntimeEffect_Flags = 256;
pub type SkRuntimeEffect_Flags = ::core::ffi::c_uint;
#[test]
fn bindgen_test_layout_SkRuntimeEffect() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect>(),
        128usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect18MakeForColorFilterE8SkStringRKNS_7OptionsE"]
    pub fn SkRuntimeEffect_MakeForColorFilter(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect13MakeForShaderE8SkStringRKNS_7OptionsE"]
    pub fn SkRuntimeEffect_MakeForShader(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect14MakeForBlenderE8SkStringRKNS_7OptionsE"]
    pub fn SkRuntimeEffect_MakeForBlender(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect10makeShaderE5sk_spIK6SkDataEPS0_I8SkShaderEmPK8SkMatrix"]
    pub fn SkRuntimeEffect_makeShader(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkShader>,
        childCount: usize,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect10makeShaderE5sk_spIK6SkDataE6SkSpanIKNS_8ChildPtrEEPK8SkMatrix"]
    pub fn SkRuntimeEffect_makeShader1(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect15makeColorFilterE5sk_spIK6SkDataE"]
    pub fn SkRuntimeEffect_makeColorFilter(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect15makeColorFilterE5sk_spIK6SkDataEPS0_I13SkColorFilterEm"]
    pub fn SkRuntimeEffect_makeColorFilter1(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkColorFilter>,
        childCount: usize,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect15makeColorFilterE5sk_spIK6SkDataE6SkSpanIKNS_8ChildPtrEE"]
    pub fn SkRuntimeEffect_makeColorFilter2(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect11makeBlenderE5sk_spIK6SkDataE6SkSpanIKNS_8ChildPtrEE"]
    pub fn SkRuntimeEffect_makeBlender(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
    ) -> sk_sp<SkBlender>;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect10MakeTracedE5sk_spI8SkShaderERK8SkIPoint"]
    pub fn SkRuntimeEffect_MakeTraced(
        shader: sk_sp<SkShader>,
        traceCoord: *const SkIPoint,
    ) -> SkRuntimeEffect_TracedShader;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect6sourceEv"]
    pub fn SkRuntimeEffect_source(this: *const SkRuntimeEffect) -> *const std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect11uniformSizeEv"]
    pub fn SkRuntimeEffect_uniformSize(this: *const SkRuntimeEffect) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect11findUniformENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE"]
    pub fn SkRuntimeEffect_findUniform(
        this: *const SkRuntimeEffect,
        name: std_string_view,
    ) -> *const SkRuntimeEffect_Uniform;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect9findChildENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE"]
    pub fn SkRuntimeEffect_findChild(
        this: *const SkRuntimeEffect,
        name: std_string_view,
    ) -> *const SkRuntimeEffect_Child;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect20RegisterFlattenablesEv"]
    pub fn SkRuntimeEffect_RegisterFlattenables();
}
impl SkRuntimeEffect {
    #[inline]
    pub unsafe fn MakeForColorFilter(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result {
        SkRuntimeEffect_MakeForColorFilter(sksl, arg1)
    }
    #[inline]
    pub unsafe fn MakeForShader(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result {
        SkRuntimeEffect_MakeForShader(sksl, arg1)
    }
    #[inline]
    pub unsafe fn MakeForBlender(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result {
        SkRuntimeEffect_MakeForBlender(sksl, arg1)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkShader>,
        childCount: usize,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkRuntimeEffect_makeShader(self, uniforms, children, childCount, localMatrix)
    }
    #[inline]
    pub unsafe fn makeShader1(
        &self,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkRuntimeEffect_makeShader1(self, uniforms, children, localMatrix)
    }
    #[inline]
    pub unsafe fn makeColorFilter(&self, uniforms: sk_sp<SkData>) -> sk_sp<SkColorFilter> {
        SkRuntimeEffect_makeColorFilter(self, uniforms)
    }
    #[inline]
    pub unsafe fn makeColorFilter1(
        &self,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkColorFilter>,
        childCount: usize,
    ) -> sk_sp<SkColorFilter> {
        SkRuntimeEffect_makeColorFilter1(self, uniforms, children, childCount)
    }
    #[inline]
    pub unsafe fn makeColorFilter2(
        &self,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
    ) -> sk_sp<SkColorFilter> {
        SkRuntimeEffect_makeColorFilter2(self, uniforms, children)
    }
    #[inline]
    pub unsafe fn makeBlender(
        &self,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
    ) -> sk_sp<SkBlender> {
        SkRuntimeEffect_makeBlender(self, uniforms, children)
    }
    #[inline]
    pub unsafe fn MakeTraced(
        shader: sk_sp<SkShader>,
        traceCoord: *const SkIPoint,
    ) -> SkRuntimeEffect_TracedShader {
        SkRuntimeEffect_MakeTraced(shader, traceCoord)
    }
    #[inline]
    pub unsafe fn source(&self) -> *const std_string {
        SkRuntimeEffect_source(self)
    }
    #[inline]
    pub unsafe fn uniformSize(&self) -> usize {
        SkRuntimeEffect_uniformSize(self)
    }
    #[inline]
    pub unsafe fn findUniform(&self, name: std_string_view) -> *const SkRuntimeEffect_Uniform {
        SkRuntimeEffect_findUniform(self, name)
    }
    #[inline]
    pub unsafe fn findChild(&self, name: std_string_view) -> *const SkRuntimeEffect_Child {
        SkRuntimeEffect_findChild(self, name)
    }
    #[inline]
    pub unsafe fn RegisterFlattenables() {
        SkRuntimeEffect_RegisterFlattenables()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffectD1Ev"]
    pub fn SkRuntimeEffect_SkRuntimeEffect_destructor(this: *mut SkRuntimeEffect);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTableMaskFilter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkTableMaskFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkTableMaskFilter>(),
        1usize,
        concat!("Size of: ", stringify!(SkTableMaskFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTableMaskFilter>(),
        1usize,
        concat!("Alignment of ", stringify!(SkTableMaskFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter14MakeGammaTableEPhf"]
    pub fn SkTableMaskFilter_MakeGammaTable(table: *mut u8, gamma: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter13MakeClipTableEPhhh"]
    pub fn SkTableMaskFilter_MakeClipTable(table: *mut u8, min: u8, max: u8);
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter6CreateEPKh"]
    pub fn SkTableMaskFilter_Create(table: *const u8) -> *mut SkMaskFilter;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter11CreateGammaEf"]
    pub fn SkTableMaskFilter_CreateGamma(gamma: SkScalar) -> *mut SkMaskFilter;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter10CreateClipEhh"]
    pub fn SkTableMaskFilter_CreateClip(min: u8, max: u8) -> *mut SkMaskFilter;
}
impl SkTableMaskFilter {
    #[inline]
    pub unsafe fn MakeGammaTable(table: *mut u8, gamma: SkScalar) {
        SkTableMaskFilter_MakeGammaTable(table, gamma)
    }
    #[inline]
    pub unsafe fn MakeClipTable(table: *mut u8, min: u8, max: u8) {
        SkTableMaskFilter_MakeClipTable(table, min, max)
    }
    #[inline]
    pub unsafe fn Create(table: *const u8) -> *mut SkMaskFilter {
        SkTableMaskFilter_Create(table)
    }
    #[inline]
    pub unsafe fn CreateGamma(gamma: SkScalar) -> *mut SkMaskFilter {
        SkTableMaskFilter_CreateGamma(gamma)
    }
    #[inline]
    pub unsafe fn CreateClip(min: u8, max: u8) -> *mut SkMaskFilter {
        SkTableMaskFilter_CreateClip(min, max)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTrimPathEffect_Mode {
    Normal = 0,
    Inverted = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPngEncoder_FilterFlag {
    kZero = 0,
    kNone = 8,
    kSub = 16,
    kUp = 32,
    kAvg = 64,
    kPaeth = 128,
    kAll = 248,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkJpegEncoder_AlphaOption {
    Ignore = 0,
    BlendOnBlack = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkJpegEncoder_Downsample {
    k420 = 0,
    k422 = 1,
    k444 = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSVGCanvas {
    pub _address: u8,
}
pub const SkSVGCanvas_kConvertTextToPaths_Flag: SkSVGCanvas__bindgen_ty_1 =
    SkSVGCanvas__bindgen_ty_1::kConvertTextToPaths_Flag;
pub const SkSVGCanvas_kNoPrettyXML_Flag: SkSVGCanvas__bindgen_ty_1 =
    SkSVGCanvas__bindgen_ty_1::kNoPrettyXML_Flag;
pub const SkSVGCanvas_kRelativePathEncoding_Flag: SkSVGCanvas__bindgen_ty_1 =
    SkSVGCanvas__bindgen_ty_1::kRelativePathEncoding_Flag;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSVGCanvas__bindgen_ty_1 {
    kConvertTextToPaths_Flag = 1,
    kNoPrettyXML_Flag = 2,
    kRelativePathEncoding_Flag = 4,
}
#[test]
fn bindgen_test_layout_SkSVGCanvas() {
    assert_eq!(
        ::core::mem::size_of::<SkSVGCanvas>(),
        1usize,
        concat!("Size of: ", stringify!(SkSVGCanvas))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSVGCanvas>(),
        1usize,
        concat!("Alignment of ", stringify!(SkSVGCanvas))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkSVGCanvas4MakeERK6SkRectP9SkWStreamj"]
    pub fn SkSVGCanvas_Make(bounds: *const SkRect, arg1: *mut SkWStream, flags: u32) -> u64;
}
impl SkSVGCanvas {
    #[inline]
    pub unsafe fn Make(bounds: *const SkRect, arg1: *mut SkWStream, flags: u32) -> u64 {
        SkSVGCanvas_Make(bounds, arg1, flags)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPatch3D {
    pub fU: SkV3,
    pub fV: SkV3,
    pub fOrigin: SkV3,
}
#[test]
fn bindgen_test_layout_SkPatch3D() {
    const UNINIT: ::core::mem::MaybeUninit<SkPatch3D> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkPatch3D>(),
        36usize,
        concat!("Size of: ", stringify!(SkPatch3D))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPatch3D>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPatch3D))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fU) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPatch3D),
            "::",
            stringify!(fU)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fV) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPatch3D),
            "::",
            stringify!(fV)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOrigin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkPatch3D),
            "::",
            stringify!(fOrigin)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPatch3D5resetEv"]
    pub fn SkPatch3D_reset(this: *mut SkPatch3D);
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPatch3D9transformERK5SkM44PS_"]
    pub fn SkPatch3D_transform(this: *const SkPatch3D, arg1: *const SkM44, dst: *mut SkPatch3D);
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPatch3D7dotWithEfff"]
    pub fn SkPatch3D_dotWith(
        this: *const SkPatch3D,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPatch3DC1Ev"]
    pub fn SkPatch3D_SkPatch3D(this: *mut SkPatch3D);
}
impl SkPatch3D {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPatch3D_reset(self)
    }
    #[inline]
    pub unsafe fn transform(&self, arg1: *const SkM44, dst: *mut SkPatch3D) {
        SkPatch3D_transform(self, arg1, dst)
    }
    #[inline]
    pub unsafe fn dotWith(&self, dx: SkScalar, dy: SkScalar, dz: SkScalar) -> SkScalar {
        SkPatch3D_dotWith(self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPatch3D_SkPatch3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCamera3D {
    pub fLocation: SkV3,
    pub fAxis: SkV3,
    pub fZenith: SkV3,
    pub fObserver: SkV3,
    pub fOrientation: SkMatrix,
    pub fNeedToUpdate: bool,
}
#[test]
fn bindgen_test_layout_SkCamera3D() {
    const UNINIT: ::core::mem::MaybeUninit<SkCamera3D> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCamera3D>(),
        92usize,
        concat!("Size of: ", stringify!(SkCamera3D))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCamera3D>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCamera3D))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLocation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fLocation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAxis) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fAxis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fZenith) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fZenith)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fObserver) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fObserver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOrientation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fOrientation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fNeedToUpdate) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCamera3D),
            "::",
            stringify!(fNeedToUpdate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkCamera3D5resetEv"]
    pub fn SkCamera3D_reset(this: *mut SkCamera3D);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkCamera3D6updateEv"]
    pub fn SkCamera3D_update(this: *mut SkCamera3D);
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkCamera3D13patchToMatrixERK9SkPatch3DP8SkMatrix"]
    pub fn SkCamera3D_patchToMatrix(
        this: *const SkCamera3D,
        arg1: *const SkPatch3D,
        matrix: *mut SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkCamera3DC1Ev"]
    pub fn SkCamera3D_SkCamera3D(this: *mut SkCamera3D);
}
impl SkCamera3D {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkCamera3D_reset(self)
    }
    #[inline]
    pub unsafe fn update(&mut self) {
        SkCamera3D_update(self)
    }
    #[inline]
    pub unsafe fn patchToMatrix(&self, arg1: *const SkPatch3D, matrix: *mut SkMatrix) {
        SkCamera3D_patchToMatrix(self, arg1, matrix)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCamera3D_SkCamera3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Sk3DView {
    pub fRec: *mut Sk3DView_Rec,
    pub fInitialRec: Sk3DView_Rec,
    pub fCamera: SkCamera3D,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sk3DView_Rec {
    pub fNext: *mut Sk3DView_Rec,
    pub fMatrix: SkM44,
}
#[test]
fn bindgen_test_layout_Sk3DView_Rec() {
    const UNINIT: ::core::mem::MaybeUninit<Sk3DView_Rec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Sk3DView_Rec>(),
        72usize,
        concat!("Size of: ", stringify!(Sk3DView_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<Sk3DView_Rec>(),
        8usize,
        concat!("Alignment of ", stringify!(Sk3DView_Rec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fNext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView_Rec),
            "::",
            stringify!(fNext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMatrix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView_Rec),
            "::",
            stringify!(fMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_Sk3DView() {
    const UNINIT: ::core::mem::MaybeUninit<Sk3DView> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Sk3DView>(),
        176usize,
        concat!("Size of: ", stringify!(Sk3DView))
    );
    assert_eq!(
        ::core::mem::align_of::<Sk3DView>(),
        8usize,
        concat!("Alignment of ", stringify!(Sk3DView))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView),
            "::",
            stringify!(fRec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInitialRec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView),
            "::",
            stringify!(fInitialRec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCamera) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Sk3DView),
            "::",
            stringify!(fCamera)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView4saveEv"]
    pub fn Sk3DView_save(this: *mut Sk3DView);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView7restoreEv"]
    pub fn Sk3DView_restore(this: *mut Sk3DView);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView9translateEfff"]
    pub fn Sk3DView_translate(this: *mut Sk3DView, x: SkScalar, y: SkScalar, z: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView7rotateXEf"]
    pub fn Sk3DView_rotateX(this: *mut Sk3DView, deg: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView7rotateYEf"]
    pub fn Sk3DView_rotateY(this: *mut Sk3DView, deg: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView7rotateZEf"]
    pub fn Sk3DView_rotateZ(this: *mut Sk3DView, deg: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8Sk3DView9getMatrixEP8SkMatrix"]
    pub fn Sk3DView_getMatrix(this: *const Sk3DView, arg1: *mut SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8Sk3DView13applyToCanvasEP8SkCanvas"]
    pub fn Sk3DView_applyToCanvas(this: *const Sk3DView, arg1: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8Sk3DView13dotWithNormalEfff"]
    pub fn Sk3DView_dotWithNormal(
        this: *const Sk3DView,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DViewC1Ev"]
    pub fn Sk3DView_Sk3DView(this: *mut Sk3DView);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DViewD1Ev"]
    pub fn Sk3DView_Sk3DView_destructor(this: *mut Sk3DView);
}
impl Sk3DView {
    #[inline]
    pub unsafe fn save(&mut self) {
        Sk3DView_save(self)
    }
    #[inline]
    pub unsafe fn restore(&mut self) {
        Sk3DView_restore(self)
    }
    #[inline]
    pub unsafe fn translate(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) {
        Sk3DView_translate(self, x, y, z)
    }
    #[inline]
    pub unsafe fn rotateX(&mut self, deg: SkScalar) {
        Sk3DView_rotateX(self, deg)
    }
    #[inline]
    pub unsafe fn rotateY(&mut self, deg: SkScalar) {
        Sk3DView_rotateY(self, deg)
    }
    #[inline]
    pub unsafe fn rotateZ(&mut self, deg: SkScalar) {
        Sk3DView_rotateZ(self, deg)
    }
    #[inline]
    pub unsafe fn getMatrix(&self, arg1: *mut SkMatrix) {
        Sk3DView_getMatrix(self, arg1)
    }
    #[inline]
    pub unsafe fn applyToCanvas(&self, arg1: *mut SkCanvas) {
        Sk3DView_applyToCanvas(self, arg1)
    }
    #[inline]
    pub unsafe fn dotWithNormal(&self, dx: SkScalar, dy: SkScalar, dz: SkScalar) -> SkScalar {
        Sk3DView_dotWithNormal(self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Sk3DView_Sk3DView(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Sk3DView_Sk3DView_destructor(self)
    }
}
#[repr(C)]
pub struct SkCustomTypefaceBuilder {
    pub fGlyphRecs: [u64; 3usize],
    pub fMetrics: SkFontMetrics,
    pub fStyle: SkFontStyle,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkCustomTypefaceBuilder_GlyphRec {
    pub fPath: SkPath,
    pub fDrawable: sk_sp<SkDrawable>,
    pub fBounds: SkRect,
    pub fAdvance: f32,
}
#[test]
fn bindgen_test_layout_SkCustomTypefaceBuilder_GlyphRec() {
    const UNINIT: ::core::mem::MaybeUninit<SkCustomTypefaceBuilder_GlyphRec> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCustomTypefaceBuilder_GlyphRec>(),
        48usize,
        concat!("Size of: ", stringify!(SkCustomTypefaceBuilder_GlyphRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCustomTypefaceBuilder_GlyphRec>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkCustomTypefaceBuilder_GlyphRec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPath) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder_GlyphRec),
            "::",
            stringify!(fPath)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDrawable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder_GlyphRec),
            "::",
            stringify!(fDrawable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder_GlyphRec),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAdvance) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder_GlyphRec),
            "::",
            stringify!(fAdvance)
        )
    );
}
pub const SkCustomTypefaceBuilder_FactoryId: SkTypeface_FactoryId = 1970496882;
#[test]
fn bindgen_test_layout_SkCustomTypefaceBuilder() {
    const UNINIT: ::core::mem::MaybeUninit<SkCustomTypefaceBuilder> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkCustomTypefaceBuilder>(),
        96usize,
        concat!("Size of: ", stringify!(SkCustomTypefaceBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCustomTypefaceBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCustomTypefaceBuilder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGlyphRecs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder),
            "::",
            stringify!(fGlyphRecs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMetrics) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder),
            "::",
            stringify!(fMetrics)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStyle) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkCustomTypefaceBuilder),
            "::",
            stringify!(fStyle)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilder8setGlyphEtfRK6SkPath"]
    pub fn SkCustomTypefaceBuilder_setGlyph(
        this: *mut SkCustomTypefaceBuilder,
        arg1: SkGlyphID,
        advance: f32,
        arg2: *const SkPath,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilder10setMetricsERK13SkFontMetricsf"]
    pub fn SkCustomTypefaceBuilder_setMetrics(
        this: *mut SkCustomTypefaceBuilder,
        fm: *const SkFontMetrics,
        scale: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilder12setFontStyleE11SkFontStyle"]
    pub fn SkCustomTypefaceBuilder_setFontStyle(
        this: *mut SkCustomTypefaceBuilder,
        arg1: SkFontStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilder6detachEv"]
    pub fn SkCustomTypefaceBuilder_detach(this: *mut SkCustomTypefaceBuilder) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilder14MakeFromStreamENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEERK15SkFontArguments"]
    pub fn SkCustomTypefaceBuilder_MakeFromStream(
        arg1: u64,
        arg2: *const SkFontArguments,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilderC1Ev"]
    pub fn SkCustomTypefaceBuilder_SkCustomTypefaceBuilder(this: *mut SkCustomTypefaceBuilder);
}
impl SkCustomTypefaceBuilder {
    #[inline]
    pub unsafe fn setGlyph(&mut self, arg1: SkGlyphID, advance: f32, arg2: *const SkPath) {
        SkCustomTypefaceBuilder_setGlyph(self, arg1, advance, arg2)
    }
    #[inline]
    pub unsafe fn setMetrics(&mut self, fm: *const SkFontMetrics, scale: f32) {
        SkCustomTypefaceBuilder_setMetrics(self, fm, scale)
    }
    #[inline]
    pub unsafe fn setFontStyle(&mut self, arg1: SkFontStyle) {
        SkCustomTypefaceBuilder_setFontStyle(self, arg1)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> sk_sp<SkTypeface> {
        SkCustomTypefaceBuilder_detach(self)
    }
    #[inline]
    pub unsafe fn MakeFromStream(arg1: u64, arg2: *const SkFontArguments) -> sk_sp<SkTypeface> {
        SkCustomTypefaceBuilder_MakeFromStream(arg1, arg2)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCustomTypefaceBuilder_SkCustomTypefaceBuilder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct SkOrderedFontMgr {
    pub _base: SkFontMgr,
    pub fList: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_SkOrderedFontMgr() {
    const UNINIT: ::core::mem::MaybeUninit<SkOrderedFontMgr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkOrderedFontMgr>(),
        40usize,
        concat!("Size of: ", stringify!(SkOrderedFontMgr))
    );
    assert_eq!(
        ::core::mem::align_of::<SkOrderedFontMgr>(),
        8usize,
        concat!("Alignment of ", stringify!(SkOrderedFontMgr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fList) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkOrderedFontMgr),
            "::",
            stringify!(fList)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkOrderedFontMgr6appendE5sk_spI9SkFontMgrE"]
    pub fn SkOrderedFontMgr_append(this: *mut SkOrderedFontMgr, arg1: sk_sp<SkFontMgr>);
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkOrderedFontMgrC1Ev"]
    pub fn SkOrderedFontMgr_SkOrderedFontMgr(this: *mut SkOrderedFontMgr);
}
impl SkOrderedFontMgr {
    #[inline]
    pub unsafe fn append(&mut self, arg1: sk_sp<SkFontMgr>) {
        SkOrderedFontMgr_append(self, arg1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkOrderedFontMgr_SkOrderedFontMgr(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkOrderedFontMgrD1Ev"]
    pub fn SkOrderedFontMgr_SkOrderedFontMgr_destructor(this: *mut SkOrderedFontMgr);
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr15onCountFamiliesEv"]
    pub fn SkOrderedFontMgr_onCountFamilies(this: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr15onGetFamilyNameEiP8SkString"]
    pub fn SkOrderedFontMgr_onGetFamilyName(
        this: *mut ::core::ffi::c_void,
        index: ::core::ffi::c_int,
        familyName: *mut SkString,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr16onCreateStyleSetEi"]
    pub fn SkOrderedFontMgr_onCreateStyleSet(
        this: *mut ::core::ffi::c_void,
        index: ::core::ffi::c_int,
    ) -> sk_sp<SkFontStyleSet>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr13onMatchFamilyEPKc"]
    pub fn SkOrderedFontMgr_onMatchFamily(
        this: *mut ::core::ffi::c_void,
        familyName: *const ::core::ffi::c_char,
    ) -> sk_sp<SkFontStyleSet>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr18onMatchFamilyStyleEPKcRK11SkFontStyle"]
    pub fn SkOrderedFontMgr_onMatchFamilyStyle(
        this: *mut ::core::ffi::c_void,
        familyName: *const ::core::ffi::c_char,
        arg1: *const SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr27onMatchFamilyStyleCharacterEPKcRK11SkFontStylePS1_ii"]
    pub fn SkOrderedFontMgr_onMatchFamilyStyleCharacter(
        this: *mut ::core::ffi::c_void,
        familyName: *const ::core::ffi::c_char,
        arg1: *const SkFontStyle,
        bcp47: *mut *const ::core::ffi::c_char,
        bcp47Count: ::core::ffi::c_int,
        character: SkUnichar,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr14onMakeFromDataE5sk_spI6SkDataEi"]
    pub fn SkOrderedFontMgr_onMakeFromData(
        this: *mut ::core::ffi::c_void,
        arg1: sk_sp<SkData>,
        ttcIndex: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr21onMakeFromStreamIndexENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEEi"]
    pub fn SkOrderedFontMgr_onMakeFromStreamIndex(
        this: *mut ::core::ffi::c_void,
        arg1: u64,
        ttcIndex: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr20onMakeFromStreamArgsENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEERK15SkFontArguments"]
    pub fn SkOrderedFontMgr_onMakeFromStreamArgs(
        this: *mut ::core::ffi::c_void,
        arg1: u64,
        arg2: *const SkFontArguments,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr14onMakeFromFileEPKci"]
    pub fn SkOrderedFontMgr_onMakeFromFile(
        this: *mut ::core::ffi::c_void,
        path: *const ::core::ffi::c_char,
        ttcIndex: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr20onLegacyMakeTypefaceEPKc11SkFontStyle"]
    pub fn SkOrderedFontMgr_onLegacyMakeTypeface(
        this: *mut ::core::ffi::c_void,
        familyName: *const ::core::ffi::c_char,
        arg1: SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkParsePath {
    pub _address: u8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkParsePath_PathEncoding {
    Absolute = 0,
    Relative = 1,
}
#[test]
fn bindgen_test_layout_SkParsePath() {
    assert_eq!(
        ::core::mem::size_of::<SkParsePath>(),
        1usize,
        concat!("Size of: ", stringify!(SkParsePath))
    );
    assert_eq!(
        ::core::mem::align_of::<SkParsePath>(),
        1usize,
        concat!("Alignment of ", stringify!(SkParsePath))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkParsePath13FromSVGStringEPKcP6SkPath"]
    pub fn SkParsePath_FromSVGString(str_: *const ::core::ffi::c_char, arg1: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkParsePath11ToSVGStringERK6SkPathNS_12PathEncodingE"]
    pub fn SkParsePath_ToSVGString(arg1: *const SkPath, arg2: SkParsePath_PathEncoding)
        -> SkString;
}
impl SkParsePath {
    #[inline]
    pub unsafe fn FromSVGString(str_: *const ::core::ffi::c_char, arg1: *mut SkPath) -> bool {
        SkParsePath_FromSVGString(str_, arg1)
    }
    #[inline]
    pub unsafe fn ToSVGString(arg1: *const SkPath, arg2: SkParsePath_PathEncoding) -> SkString {
        SkParsePath_ToSVGString(arg1, arg2)
    }
}
pub const SkShadowFlags_kNone_ShadowFlag: SkShadowFlags = 0;
pub const SkShadowFlags_kTransparentOccluder_ShadowFlag: SkShadowFlags = 1;
pub const SkShadowFlags_kGeometricOnly_ShadowFlag: SkShadowFlags = 2;
pub const SkShadowFlags_kDirectionalLight_ShadowFlag: SkShadowFlags = 4;
pub const SkShadowFlags_kConcaveBlurOnly_ShadowFlag: SkShadowFlags = 8;
pub const SkShadowFlags_kAll_ShadowFlag: SkShadowFlags = 15;
pub type SkShadowFlags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShadowUtils {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkShadowUtils() {
    assert_eq!(
        ::core::mem::size_of::<SkShadowUtils>(),
        1usize,
        concat!("Size of: ", stringify!(SkShadowUtils))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShadowUtils>(),
        1usize,
        concat!("Alignment of ", stringify!(SkShadowUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkShadowUtils10DrawShadowEP8SkCanvasRK6SkPathRK8SkPoint3S7_fjjj"]
    pub fn SkShadowUtils_DrawShadow(
        canvas: *mut SkCanvas,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        ambientColor: SkColor,
        spotColor: SkColor,
        flags: u32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkShadowUtils14GetLocalBoundsERK8SkMatrixRK6SkPathRK8SkPoint3S8_fjP6SkRect"]
    pub fn SkShadowUtils_GetLocalBounds(
        ctm: *const SkMatrix,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        flags: u32,
        bounds: *mut SkRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkShadowUtils18ComputeTonalColorsEjjPjS0_"]
    pub fn SkShadowUtils_ComputeTonalColors(
        inAmbientColor: SkColor,
        inSpotColor: SkColor,
        outAmbientColor: *mut SkColor,
        outSpotColor: *mut SkColor,
    );
}
impl SkShadowUtils {
    #[inline]
    pub unsafe fn DrawShadow(
        canvas: *mut SkCanvas,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        ambientColor: SkColor,
        spotColor: SkColor,
        flags: u32,
    ) {
        SkShadowUtils_DrawShadow(
            canvas,
            path,
            zPlaneParams,
            lightPos,
            lightRadius,
            ambientColor,
            spotColor,
            flags,
        )
    }
    #[inline]
    pub unsafe fn GetLocalBounds(
        ctm: *const SkMatrix,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        flags: u32,
        bounds: *mut SkRect,
    ) -> bool {
        SkShadowUtils_GetLocalBounds(
            ctm,
            path,
            zPlaneParams,
            lightPos,
            lightRadius,
            flags,
            bounds,
        )
    }
    #[inline]
    pub unsafe fn ComputeTonalColors(
        inAmbientColor: SkColor,
        inSpotColor: SkColor,
        outAmbientColor: *mut SkColor,
        outSpotColor: *mut SkColor,
    ) {
        SkShadowUtils_ComputeTonalColors(inAmbientColor, inSpotColor, outAmbientColor, outSpotColor)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextUtils {
    pub _address: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextUtils_Align {
    Left = 0,
    Center = 1,
    Right = 2,
}
#[test]
fn bindgen_test_layout_SkTextUtils() {
    assert_eq!(
        ::core::mem::size_of::<SkTextUtils>(),
        1usize,
        concat!("Size of: ", stringify!(SkTextUtils))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextUtils>(),
        1usize,
        concat!("Alignment of ", stringify!(SkTextUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTextUtils4DrawEP8SkCanvasPKvm14SkTextEncodingffRK6SkFontRK7SkPaintNS_5AlignE"]
    pub fn SkTextUtils_Draw(
        arg1: *mut SkCanvas,
        text: *const ::core::ffi::c_void,
        size: usize,
        arg2: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg3: *const SkFont,
        arg4: *const SkPaint,
        arg5: SkTextUtils_Align,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTextUtils7GetPathEPKvm14SkTextEncodingffRK6SkFontP6SkPath"]
    pub fn SkTextUtils_GetPath(
        text: *const ::core::ffi::c_void,
        length: usize,
        arg1: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkFont,
        arg3: *mut SkPath,
    );
}
impl SkTextUtils {
    #[inline]
    pub unsafe fn Draw(
        arg1: *mut SkCanvas,
        text: *const ::core::ffi::c_void,
        size: usize,
        arg2: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg3: *const SkFont,
        arg4: *const SkPaint,
        arg5: SkTextUtils_Align,
    ) {
        SkTextUtils_Draw(arg1, text, size, arg2, x, y, arg3, arg4, arg5)
    }
    #[inline]
    pub unsafe fn GetPath(
        text: *const ::core::ffi::c_void,
        length: usize,
        arg1: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkFont,
        arg3: *mut SkPath,
    ) {
        SkTextUtils_GetPath(text, length, arg1, x, y, arg2, arg3)
    }
}
extern "C" {
    pub fn C_Bindings_Types(arg1: Sink<bool>);
}
extern "C" {
    pub fn C_SkCodec_MakeFromData(data: *mut SkData) -> *mut SkCodec;
}
extern "C" {
    pub fn C_SkCodec_delete(self_: *mut SkCodec);
}
extern "C" {
    pub fn C_SkCodec_getInfo(self_: *const SkCodec, info: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkCodec_dimensions(self_: *const SkCodec) -> SkISize;
}
extern "C" {
    pub fn C_SkCodec_bounds(self_: *const SkCodec, uninitialized: *mut SkIRect);
}
extern "C" {
    pub fn C_SkCodec_getOrigin(self_: *const SkCodec) -> SkEncodedOrigin;
}
extern "C" {
    pub fn C_SkCodec_getScaledDimensions(self_: *const SkCodec, desiredScale: f32) -> SkISize;
}
extern "C" {
    pub fn C_SkCodec_getValidSubset(self_: *const SkCodec, desiredSubset: *mut SkIRect) -> bool;
}
extern "C" {
    pub fn C_SkCodec_getEncodedFormat(self_: *const SkCodec) -> SkEncodedImageFormat;
}
extern "C" {
    pub fn C_SkCodec_getImage(
        self_: *mut SkCodec,
        info: *const SkImageInfo,
        opts: *const SkCodec_Options,
        result: *mut SkCodec_Result,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkCodec_incrementalDecode(
        self_: *mut SkCodec,
        rowsDecoded: *mut ::core::ffi::c_int,
    ) -> SkCodec_Result;
}
extern "C" {
    pub fn C_SkCodec_getScanlineOrder(self_: *const SkCodec) -> SkCodec_SkScanlineOrder;
}
extern "C" {
    pub fn C_SkCodec_nextScanline(self_: *const SkCodec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkCodec_getFrameCount(self_: *mut SkCodec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkFrameInfo_Construct(uninitialized: *mut SkCodec_FrameInfo);
}
extern "C" {
    pub fn C_SkCodec_getFrameInfo(
        self_: *mut SkCodec,
        index: ::core::ffi::c_int,
        info: *mut SkCodec_FrameInfo,
    ) -> bool;
}
extern "C" {
    pub fn C_SkCodec_getRepetitionCount(self_: *mut SkCodec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkEncodedOriginToMatrix(
        origin: SkEncodedOrigin,
        w: ::core::ffi::c_int,
        h: ::core::ffi::c_int,
        matrix: *mut SkMatrix,
    );
}
extern "C" {
    pub fn C_SkPixmapUtils_Orient(
        dst: *mut SkPixmap,
        src: *const SkPixmap,
        origin: SkEncodedOrigin,
    ) -> bool;
}
extern "C" {
    pub fn C_SkPixmapUtils_SwapWidthHeight(
        uninitialized: *mut SkImageInfo,
        info: *const SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkBmpDecoder_IsBmp(buf: *const ::core::ffi::c_char, size: usize) -> bool;
}
extern "C" {
    pub fn C_SkBmpDecoder_Decode(
        stream: *mut SkStream,
        result: *mut SkCodec_Result,
    ) -> *mut SkCodec;
}
extern "C" {
    pub fn C_SkGifDecoder_IsGif(buf: *const ::core::ffi::c_char, size: usize) -> bool;
}
extern "C" {
    pub fn C_SkGifDecoder_Decode(
        stream: *mut SkStream,
        result: *mut SkCodec_Result,
    ) -> *mut SkCodec;
}
extern "C" {
    pub fn C_SkIcoDecoder_IsIco(buf: *const ::core::ffi::c_char, size: usize) -> bool;
}
extern "C" {
    pub fn C_SkIcoDecoder_Decode(
        stream: *mut SkStream,
        result: *mut SkCodec_Result,
    ) -> *mut SkCodec;
}
extern "C" {
    pub fn C_SkJpegDecoder_IsJpeg(buf: *const ::core::ffi::c_char, size: usize) -> bool;
}
extern "C" {
    pub fn C_SkJpegDecoder_Decode(
        stream: *mut SkStream,
        result: *mut SkCodec_Result,
    ) -> *mut SkCodec;
}
extern "C" {
    pub fn C_SkPngDecoder_IsPng(buf: *const ::core::ffi::c_char, size: usize) -> bool;
}
extern "C" {
    pub fn C_SkPngDecoder_Decode(
        stream: *mut SkStream,
        result: *mut SkCodec_Result,
    ) -> *mut SkCodec;
}
extern "C" {
    pub fn C_SkWbmpDecoder_IsWbmp(buf: *const ::core::ffi::c_char, size: usize) -> bool;
}
extern "C" {
    pub fn C_SkWbmpDecoder_Decode(
        stream: *mut SkStream,
        result: *mut SkCodec_Result,
    ) -> *mut SkCodec;
}
extern "C" {
    pub fn C_SkWebpDecoder_IsWebp(buf: *const ::core::ffi::c_char, size: usize) -> bool;
}
extern "C" {
    pub fn C_SkWebpDecoder_Decode(
        stream: *mut SkStream,
        result: *mut SkCodec_Result,
    ) -> *mut SkCodec;
}
extern "C" {
    pub fn C_Core_Types(
        arg1: *mut SkGraphics,
        arg2: *mut SkCoverageMode,
        arg3: *mut SkColorChannelFlag,
        arg4: SkSurfaces_BackendSurfaceAccess,
    );
}
extern "C" {
    pub fn C_SkBlender_Mode(mode: SkBlendMode) -> *mut SkBlender;
}
extern "C" {
    pub fn C_SkBlender_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkBlender;
}
extern "C" {
    pub fn C_SkColor4f_toBytes_RGBA(color: *const SkColor4f) -> u32;
}
extern "C" {
    pub fn C_SkColor4f_FromBytes_RGBA(bytes: u32) -> SkColor4f;
}
extern "C" {
    pub fn C_SkCubicMap_computeFromT(self_: *const SkCubicMap, t: f32) -> SkPoint;
}
extern "C" {
    pub fn C_SkSurfaces_Null(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurfaces_Raster(
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurfaces_WrapPixels(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_width(self_: *const SkSurface) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkSurface_height(self_: *const SkSurface) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkSurface_imageInfo(self_: *mut SkSurface, info: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkSurface_makeImageSnapshot(
        self_: *mut SkSurface,
        bounds: *const SkIRect,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkSurface_makeSurface(
        self_: *mut SkSurface,
        imageInfo: *const SkImageInfo,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_makeSurface2(
        self_: *mut SkSurface,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_props(self_: *const SkSurface) -> *const SkSurfaceProps;
}
extern "C" {
    pub fn C_SkImages_RasterFromBitmap(bitmap: *const SkBitmap) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_RasterFromCompressedTextureData(
        data: *mut SkData,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        type_: SkTextureCompressionType,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_DeferredFromEncodedData(
        encoded: *mut SkData,
        alphaType: *const SkAlphaType,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_DeferredFromGenerator(imageGenerator: *mut SkImageGenerator) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_DeferredFromPicture(
        picture: *mut SkPicture,
        dimensions: *const SkISize,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
        bitDepth: SkImages_BitDepth,
        colorSpace: *mut SkColorSpace,
        props: *const SkSurfaceProps,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_RasterFromData(
        info: *const SkImageInfo,
        pixels: *mut SkData,
        rowBytes: usize,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeShader(
        self_: *const SkImage,
        tileMode1: SkTileMode,
        tileMode2: SkTileMode,
        samplingOptions: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkImage_makeRawShader(
        self_: *const SkImage,
        tileMode1: SkTileMode,
        tileMode2: SkTileMode,
        samplingOptions: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkImage_isTextureBacked(self_: *const SkImage) -> bool;
}
extern "C" {
    pub fn C_SkImage_textureSize(self_: *const SkImage) -> usize;
}
extern "C" {
    pub fn C_SkImage_isValid(self_: *const SkImage, context: *mut GrRecordingContext) -> bool;
}
extern "C" {
    pub fn C_SkImage_refEncodedData(self_: *const SkImage) -> *mut SkData;
}
extern "C" {
    pub fn C_SkImage_makeSubset(
        self_: *const SkImage,
        context: *mut GrDirectContext,
        subset: *const SkIRect,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_withDefaultMipmaps(self_: *const SkImage) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeNonTextureImage(
        self_: *const SkImage,
        context: *mut GrDirectContext,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeRasterImage(
        self_: *const SkImage,
        context: *mut GrDirectContext,
        cachingHint: SkImage_CachingHint,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeWithFilter(
        self_: *const SkImage,
        context: *mut GrRecordingContext,
        filter: *const SkImageFilter,
        subset: *const SkIRect,
        clipBounds: *const SkIRect,
        outSubset: *mut SkIRect,
        offset: *mut SkIPoint,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_isLazyGenerated(self_: *const SkImage) -> bool;
}
extern "C" {
    pub fn C_SkImage_makeColorSpace(
        self_: *const SkImage,
        direct: *mut GrDirectContext,
        target: *mut SkColorSpace,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_reinterpretColorSpace(
        self_: *const SkImage,
        newColorSpace: *mut SkColorSpace,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkData_ref(self_: *const SkData);
}
extern "C" {
    pub fn C_SkData_unref(self_: *const SkData);
}
extern "C" {
    pub fn C_SkData_unique(self_: *const SkData) -> bool;
}
extern "C" {
    pub fn C_SkData_MakeWithCopy(data: *const ::core::ffi::c_void, length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeSubset(src: *const SkData, offset: usize, length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeUninitialized(length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeZeroInitialized(length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeWithCString(cstr: *const ::core::ffi::c_char) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeWithoutCopy(data: *const ::core::ffi::c_void, length: usize)
        -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeEmpty() -> *mut SkData;
}
extern "C" {
    pub fn C_SkPaint_destruct(self_: *mut SkPaint);
}
extern "C" {
    pub fn C_SkPaint_copy(self_: *mut SkPaint, rhs: *const SkPaint);
}
extern "C" {
    pub fn C_SkPaint_Equals(lhs: *const SkPaint, rhs: *const SkPaint) -> bool;
}
extern "C" {
    pub fn C_SkPaint_getStyle(self_: *const SkPaint) -> SkPaint_Style;
}
extern "C" {
    pub fn C_SkPaint_getAlpha(self_: *const SkPaint) -> u8;
}
extern "C" {
    pub fn C_SkPaint_getStrokeCap(self_: *const SkPaint) -> SkPaint_Cap;
}
extern "C" {
    pub fn C_SkPaint_getStrokeJoin(self_: *const SkPaint) -> SkPaint_Join;
}
extern "C" {
    pub fn C_SkPaint_setShader(self_: *mut SkPaint, shader: *mut SkShader);
}
extern "C" {
    pub fn C_SkPaint_setColorFilter(self_: *mut SkPaint, colorFilter: *mut SkColorFilter);
}
extern "C" {
    pub fn C_SkPaint_asBlendMode(self_: *const SkPaint, mode: *mut SkBlendMode) -> bool;
}
extern "C" {
    pub fn C_SkPaint_setBlender(self_: *mut SkPaint, blender: *mut SkBlender);
}
extern "C" {
    pub fn C_SkPaint_setPathEffect(self_: *mut SkPaint, pathEffect: *mut SkPathEffect);
}
extern "C" {
    pub fn C_SkPaint_setMaskFilter(self_: *mut SkPaint, maskFilter: *mut SkMaskFilter);
}
extern "C" {
    pub fn C_SkPaint_setImageFilter(self_: *mut SkPaint, imageFilter: *mut SkImageFilter);
}
extern "C" {
    pub fn C_SkPath_Construct(uninitialized: *mut SkPath);
}
extern "C" {
    pub fn C_SkPath_Make(
        uninitialized: *mut SkPath,
        pts: *const SkPoint,
        pointCount: ::core::ffi::c_int,
        vbs: *const u8,
        verbCount: ::core::ffi::c_int,
        ws: *const SkScalar,
        wCount: ::core::ffi::c_int,
        ft: SkPathFillType,
        isVolatile: bool,
    );
}
extern "C" {
    pub fn C_SkPath_Rect(uninitialized: *mut SkPath, r: *const SkRect, dir: SkPathDirection);
}
extern "C" {
    pub fn C_SkPath_Oval(uninitialized: *mut SkPath, r: *const SkRect, dir: SkPathDirection);
}
extern "C" {
    pub fn C_SkPath_OvalWithStartIndex(
        uninitialized: *mut SkPath,
        r: *const SkRect,
        dir: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn C_SkPath_Circle(
        uninitialized: *mut SkPath,
        x: SkScalar,
        y: SkScalar,
        r: SkScalar,
        dir: SkPathDirection,
    );
}
extern "C" {
    pub fn C_SkPath_RRect(uninitialized: *mut SkPath, rr: *const SkRRect, dir: SkPathDirection);
}
extern "C" {
    pub fn C_SkPath_RRectWithStartIndex(
        uninitialized: *mut SkPath,
        r: *const SkRRect,
        dir: SkPathDirection,
        startIndex: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn C_SkPath_Polygon(
        uninitialized: *mut SkPath,
        pts: *const SkPoint,
        count: ::core::ffi::c_int,
        isClosed: bool,
        ft: SkPathFillType,
        isVolatile: bool,
    );
}
extern "C" {
    pub fn C_SkPath_destruct(self_: *const SkPath);
}
extern "C" {
    pub fn C_SkPath_Equals(lhs: *const SkPath, rhs: *const SkPath) -> bool;
}
extern "C" {
    pub fn C_SkPath_serialize(self_: *const SkPath) -> *mut SkData;
}
extern "C" {
    pub fn C_SkPath_Iter_destruct(self_: *mut SkPath_Iter);
}
extern "C" {
    pub fn C_SkPath_Iter_isCloseLine(self_: *const SkPath_Iter) -> bool;
}
extern "C" {
    pub fn C_SkPath_RawIter_Construct(uninitialized: *mut SkPath_RawIter);
}
extern "C" {
    pub fn C_SkPath_RawIter_destruct(self_: *mut SkPath_RawIter);
}
extern "C" {
    pub fn C_SkPath_RawIter_peek(self_: *const SkPath_RawIter) -> SkPath_Verb;
}
extern "C" {
    pub fn C_SkPath_getFillType(self_: *const SkPath) -> SkPathFillType;
}
extern "C" {
    pub fn C_SkPath_getPoint(self_: *const SkPath, index: ::core::ffi::c_int) -> SkPoint;
}
extern "C" {
    pub fn C_SkPath_getBounds(self_: *const SkPath) -> *const SkRect;
}
extern "C" {
    pub fn C_SkPath_computeTightBounds(self_: *const SkPath, uninitialized: *mut SkRect);
}
extern "C" {
    pub fn C_SkPathBuilder_Construct(uninitialized: *mut SkPathBuilder);
}
extern "C" {
    pub fn C_SkPathBuilder_Construct3(uninitialized: *mut SkPathBuilder, path: *const SkPath);
}
extern "C" {
    pub fn C_SkPathBuilder_computeBounds(self_: *const SkPathBuilder, uninitialized: *mut SkRect);
}
extern "C" {
    pub fn C_SkPathBuilder_CopyConstruct(
        uninitialized: *mut SkPathBuilder,
        pathBuilder: *const SkPathBuilder,
    );
}
extern "C" {
    pub fn C_SkPathBuilder_destruct(self_: *mut SkPathBuilder);
}
extern "C" {
    pub fn C_SkPathBuilder_snapshot(self_: *const SkPathBuilder, path: *mut SkPath);
}
extern "C" {
    pub fn C_SkPathBuilder_detach(self_: *mut SkPathBuilder, path: *mut SkPath);
}
extern "C" {
    pub fn C_SkPathMeasure_destruct(self_: *const SkPathMeasure);
}
extern "C" {
    pub fn C_SkPathTypes_Types(
        arg1: *mut SkPathFillType,
        arg2: *mut SkPathDirection,
        arg3: *mut SkPathSegmentMask,
        arg4: *mut SkPathVerb,
    );
}
extern "C" {
    pub fn C_PathUtils_FillPathWithPaint(
        src: *const SkPath,
        paint: *const SkPaint,
        dst: *mut SkPath,
        cullRect: *const SkRect,
        matrix: *const SkMatrix,
    ) -> bool;
}
extern "C" {
    pub fn C_SkCanvas_newEmpty() -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_newWidthHeightAndProps(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        props: *const SkSurfaceProps,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_newFromBitmap(bitmap: *const SkBitmap) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_newFromBitmapAndProps(
        bitmap: *const SkBitmap,
        props: *const SkSurfaceProps,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_delete(self_: *const SkCanvas);
}
extern "C" {
    pub fn C_SkCanvas_MakeRasterDirect(
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        row_bytes: usize,
        props: *const SkSurfaceProps,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_imageInfo(self_: *const SkCanvas, info: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkCanvas_getBaseLayerSize(self_: *const SkCanvas, size: *mut SkISize);
}
extern "C" {
    pub fn C_SkCanvas_makeSurface(
        self_: *mut SkCanvas,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkCanvas_clipShader(self_: *mut SkCanvas, shader: *mut SkShader, op: SkClipOp);
}
extern "C" {
    pub fn C_SkCanvas_getLocalClipBounds(self_: *const SkCanvas, uninitialized: *mut SkRect);
}
extern "C" {
    pub fn C_SkCanvas_getDeviceClipBounds(self_: *const SkCanvas, result: *mut SkIRect);
}
extern "C" {
    pub fn C_SkCanvas_isClipEmpty(self_: *const SkCanvas) -> bool;
}
extern "C" {
    pub fn C_SkCanvas_isClipRect(self_: *const SkCanvas) -> bool;
}
extern "C" {
    pub fn C_SkCanvas_getLocalToDevice(self_: *const SkCanvas, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkCanvas_getTotalMatrix(self_: *const SkCanvas, matrix: *mut SkMatrix);
}
extern "C" {
    pub fn C_SkCanvas_discard(self_: *mut SkCanvas);
}
extern "C" {
    pub fn C_SkAutoCanvasRestore_Construct(
        uninitialized: *mut SkAutoCanvasRestore,
        canvas: *mut SkCanvas,
        doSave: bool,
    );
}
extern "C" {
    pub fn C_SkAutoCanvasRestore_destruct(self_: *const SkAutoCanvasRestore);
}
extern "C" {
    pub fn C_SkAutoCanvasRestore_restore(self_: *mut SkAutoCanvasRestore);
}
extern "C" {
    pub fn C_SkColorInfo_Construct(uninitialized: *mut SkColorInfo);
}
extern "C" {
    pub fn C_SkColorInfo_Construct2(
        uninitialized: *mut SkColorInfo,
        ct: SkColorType,
        at: SkAlphaType,
        cs: *mut SkColorSpace,
    );
}
extern "C" {
    pub fn C_SkColorInfo_destruct(self_: *mut SkColorInfo);
}
extern "C" {
    pub fn C_SkColorInfo_Copy(from: *const SkColorInfo, to: *mut SkColorInfo);
}
extern "C" {
    pub fn C_SkColorInfo_Equals(lhs: *const SkColorInfo, rhs: *const SkColorInfo) -> bool;
}
extern "C" {
    pub fn C_SkColorInfo_makeAlphaType(
        self_: *const SkColorInfo,
        newAlphaType: SkAlphaType,
        uninitialized: *mut SkColorInfo,
    );
}
extern "C" {
    pub fn C_SkColorInfo_makeColorType(
        self_: *const SkColorInfo,
        newColorType: SkColorType,
        uninitialized: *mut SkColorInfo,
    );
}
extern "C" {
    pub fn C_SkColorInfo_makeColorSpace(
        self_: *const SkColorInfo,
        newColorSpace: *mut SkColorSpace,
        uninitialized: *mut SkColorInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_Construct(uninitialized: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkImageInfo_destruct(self_: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkImageInfo_Copy(from: *const SkImageInfo, to: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkImageInfo_Equals(lhs: *const SkImageInfo, rhs: *const SkImageInfo) -> bool;
}
extern "C" {
    pub fn C_SkImageInfo_Make(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        ct: SkColorType,
        at: SkAlphaType,
        cs: *mut SkColorSpace,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeN32(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        at: SkAlphaType,
        cs: *mut SkColorSpace,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeS32(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        at: SkAlphaType,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeN32Premul(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        cs: *mut SkColorSpace,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeA8(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeUnknown(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_makeColorSpace(
        self_: *const SkImageInfo,
        cs: *mut SkColorSpace,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_reset(self_: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkColorSpace_Types(arg1: *mut SkColorSpacePrimaries);
}
extern "C" {
    pub fn C_SkColorSpace_ref(self_: *const SkColorSpace);
}
extern "C" {
    pub fn C_SkColorSpace_unref(self_: *const SkColorSpace);
}
extern "C" {
    pub fn C_SkColorSpace_unique(self_: *const SkColorSpace) -> bool;
}
extern "C" {
    pub fn C_SkColorSpace_MakeSRGB() -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_MakeSRGBLinear() -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_makeLinearGamma(self_: *const SkColorSpace) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_makeSRGBGamma(self_: *const SkColorSpace) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_makeColorSpin(self_: *const SkColorSpace) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_serialize(self_: *const SkColorSpace) -> *mut SkData;
}
extern "C" {
    pub fn C_SkColorSpace_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkM44_Types(arg1: *mut SkV2);
}
extern "C" {
    pub fn C_SkM44_equals(self_: *const SkM44, other: *const SkM44) -> bool;
}
extern "C" {
    pub fn C_SkM44_RectToRect(src: *const SkRect, dst: *const SkRect, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkM44_LookAt(
        eye: *const SkV3,
        center: *const SkV3,
        up: *const SkV3,
        uninitialized: *mut SkM44,
    );
}
extern "C" {
    pub fn C_SkM44_Perspective(near: f32, far: f32, angle: f32, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkM44_transpose(self_: *const SkM44, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkM44_map(self_: *const SkM44, x: f32, y: f32, z: f32, w: f32) -> SkV4;
}
extern "C" {
    pub fn C_SkMatrix_Equals(self_: *const SkMatrix, rhs: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_SubscriptMut(self_: *mut SkMatrix, index: usize) -> *mut SkScalar;
}
extern "C" {
    pub fn C_SkMatrix_getType(self_: *const SkMatrix) -> SkMatrix_TypeMask;
}
extern "C" {
    pub fn C_SkMatrix_rectStaysRect(self_: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_hasPerspective(self_: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_invert(self_: *const SkMatrix, inverse: *mut SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_setScaleTranslate(
        self_: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        tx: SkScalar,
        ty: SkScalar,
    );
}
extern "C" {
    pub fn C_SkMatrix_isFinite(self_: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_InvalidMatrix() -> *const SkMatrix;
}
extern "C" {
    pub fn C_SkMatrix_normalizePerspective(self_: *mut SkMatrix);
}
extern "C" {
    pub fn C_SkSurfaceProps_Equals(
        self_: *const SkSurfaceProps,
        rhs: *const SkSurfaceProps,
    ) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_Construct(uninitialized: *mut SkBitmap);
}
extern "C" {
    pub fn C_SkBitmap_destruct(self_: *mut SkBitmap);
}
extern "C" {
    pub fn C_SkBitmap_Copy(from: *const SkBitmap, to: *mut SkBitmap);
}
extern "C" {
    pub fn C_SkBitmap_ComputeIsOpaque(self_: *const SkBitmap) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_tryAllocN32Pixels(
        self_: *mut SkBitmap,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        isOpaque: bool,
    ) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_tryAllocPixels(self_: *mut SkBitmap) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_pixelRefOrigin(self_: *const SkBitmap) -> SkIPoint;
}
extern "C" {
    pub fn C_SkBitmap_setPixelRef(
        self_: *mut SkBitmap,
        pixelRef: *mut SkPixelRef,
        dx: ::core::ffi::c_int,
        dy: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn C_SkBitmap_readyToDraw(self_: *const SkBitmap) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_eraseARGB(self_: *const SkBitmap, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU);
}
extern "C" {
    pub fn C_SkBitmap_getAlphaf(
        self_: *const SkBitmap,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> f32;
}
extern "C" {
    pub fn C_SkBitmap_extractAlpha(
        self_: *const SkBitmap,
        dst: *mut SkBitmap,
        paint: *const SkPaint,
        offset: *mut SkIPoint,
    ) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_makeShader(
        self_: *const SkBitmap,
        tmx: SkTileMode,
        tmy: SkTileMode,
        sampling: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkBitmap_asImage(self_: *const SkBitmap) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkPicture_MakeFromData(data: *const SkData) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPicture_MakeFromData2(
        data: *const ::core::ffi::c_void,
        size: usize,
    ) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPicture_serialize(self_: *const SkPicture) -> *mut SkData;
}
extern "C" {
    pub fn C_SkPicture_MakePlaceholder(cull: *const SkRect) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPicture_playback(self_: *const SkPicture, canvas: *mut SkCanvas);
}
extern "C" {
    pub fn C_SkPicture_cullRect(self_: *const SkPicture, uninitialized: *mut SkRect);
}
extern "C" {
    pub fn C_SkPicture_uniqueID(self_: *const SkPicture) -> u32;
}
extern "C" {
    pub fn C_SkPicture_approximateOpCount(
        self_: *const SkPicture,
        nested: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkPicture_approximateBytesUsed(self_: *const SkPicture, out: *mut usize);
}
extern "C" {
    pub fn C_SkPicture_makeShader(
        self_: *const SkPicture,
        tmx: SkTileMode,
        tmy: SkTileMode,
        mode: SkFilterMode,
        localMatrix: *const SkMatrix,
        tileRect: *const SkRect,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkRRect_Construct(uninitialized: *mut SkRRect);
}
extern "C" {
    pub fn C_SkRRect_getType(self_: *const SkRRect) -> SkRRect_Type;
}
extern "C" {
    pub fn C_SkRRect_setRect(self_: *mut SkRRect, rect: *const SkRect);
}
extern "C" {
    pub fn C_SkRRect_dumpToString(self_: *const SkRRect, asHex: bool, str_: *mut SkString);
}
extern "C" {
    pub fn C_SkRRect_Equals(lhs: *const SkRRect, rhs: *const SkRRect) -> bool;
}
extern "C" {
    pub fn C_SkRegion_destruct(region: *mut SkRegion);
}
extern "C" {
    pub fn C_SkRegion_Equals(lhs: *const SkRegion, rhs: *const SkRegion) -> bool;
}
extern "C" {
    pub fn C_SkRegion_set(self_: *mut SkRegion, region: *const SkRegion) -> bool;
}
extern "C" {
    pub fn C_SkRegion_quickContains(self_: *const SkRegion, r: *const SkIRect) -> bool;
}
extern "C" {
    pub fn C_SkRegion_Iterator_Construct(uninitialized: *mut SkRegion_Iterator);
}
extern "C" {
    pub fn C_SkRegion_Iterator_destruct(self_: *mut SkRegion_Iterator);
}
extern "C" {
    pub fn C_SkRegion_Iterator_rgn(self_: *const SkRegion_Iterator) -> *const SkRegion;
}
extern "C" {
    pub fn C_SkRegion_Cliperator_destruct(self_: *mut SkRegion_Cliperator);
}
extern "C" {
    pub fn C_SkRegion_Spanerator_destruct(self_: *mut SkRegion_Spanerator);
}
extern "C" {
    pub fn C_SkFontStyle_Construct(uninitialized: *mut SkFontStyle);
}
extern "C" {
    pub fn C_SkFontStyle_Construct2(
        uninitialized: *mut SkFontStyle,
        weight: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        slant: SkFontStyle_Slant,
    );
}
extern "C" {
    pub fn C_SkFontStyle_Equals(lhs: *const SkFontStyle, rhs: *const SkFontStyle) -> bool;
}
extern "C" {
    pub fn C_SkFontStyle_weight(self_: *const SkFontStyle) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkFontStyle_width(self_: *const SkFontStyle) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkFontStyle_slant(self_: *const SkFontStyle) -> SkFontStyle_Slant;
}
extern "C" {
    pub fn C_SkTextBlob_ref(self_: *const SkTextBlob);
}
extern "C" {
    pub fn C_SkTextBlob_unref(self_: *const SkTextBlob);
}
extern "C" {
    pub fn C_SkTextBlob_unique(self_: *const SkTextBlob) -> bool;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromPosTextH(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xPos: *const SkScalar,
        constY: SkScalar,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromPosText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        pos: *const SkPoint,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromRSXform(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xform: *const SkRSXform,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_Iter_destruct(self_: *mut SkTextBlob_Iter);
}
extern "C" {
    pub fn C_SkTextBlobBuilder_destruct(self_: *mut SkTextBlobBuilder);
}
extern "C" {
    pub fn C_SkTextBlobBuilder_make(self_: *mut SkTextBlobBuilder) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTypeface_isBold(self_: *const SkTypeface) -> bool;
}
extern "C" {
    pub fn C_SkTypeface_isItalic(self_: *const SkTypeface) -> bool;
}
extern "C" {
    pub fn C_SkTypeface_MakeDefault() -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_MakeFromName(
        familyName: *const ::core::ffi::c_char,
        fontStyle: SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_MakeFromData(
        data: *mut SkData,
        index: ::core::ffi::c_int,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_makeClone(
        self_: *const SkTypeface,
        arguments: *const SkFontArguments,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_serialize(
        self_: *const SkTypeface,
        behavior: SkTypeface_SerializeBehavior,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkTypeface_MakeDeserialize(stream: *mut SkStream) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_copyTableData(self_: *const SkTypeface, tag: SkFontTableTag)
        -> *mut SkData;
}
extern "C" {
    pub fn C_SkTypeface_openStream(
        self_: *const SkTypeface,
        ttcIndex: *mut ::core::ffi::c_int,
    ) -> *mut SkStreamAsset;
}
extern "C" {
    pub fn C_SkTypeface_getBounds(self_: *const SkTypeface, uninitialized: *mut SkRect);
}
extern "C" {
    pub fn C_SkTypeface_LocalizedStrings_unref(self_: *mut SkTypeface_LocalizedStrings);
}
extern "C" {
    pub fn C_SkTypeface_LocalizedStrings_next(
        self_: *mut SkTypeface_LocalizedStrings,
        string: *mut SkString,
        language: *mut SkString,
    ) -> bool;
}
extern "C" {
    pub fn C_SkFlattenable_getTypeName(self_: *const SkFlattenable) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn C_SkFlattenable_serialize(self_: *const SkFlattenable) -> *mut SkData;
}
extern "C" {
    pub fn C_SkFont_ConstructFromTypeface(uninitialized: *mut SkFont, typeface: *mut SkTypeface);
}
extern "C" {
    pub fn C_SkFont_ConstructFromTypefaceWithSize(
        uninitialized: *mut SkFont,
        typeface: *mut SkTypeface,
        size: SkScalar,
    );
}
extern "C" {
    pub fn C_SkFont_ConstructFromTypefaceWithSizeScaleAndSkew(
        uninitialized: *mut SkFont,
        typeface: *mut SkTypeface,
        size: SkScalar,
        scaleX: SkScalar,
        skewX: SkScalar,
    );
}
extern "C" {
    pub fn C_SkFont_CopyConstruct(uninitialized: *mut SkFont, font: *const SkFont);
}
extern "C" {
    pub fn C_SkFont_destruct(self_: *mut SkFont);
}
extern "C" {
    pub fn C_SkFont_Equals(self_: *const SkFont, other: *const SkFont) -> bool;
}
extern "C" {
    pub fn C_SkFont_getEdging(self_: *const SkFont) -> SkFont_Edging;
}
extern "C" {
    pub fn C_SkFont_getHinting(self_: *const SkFont) -> SkFontHinting;
}
extern "C" {
    pub fn C_SkFont_makeWithSize(self_: *const SkFont, size: SkScalar, result: *mut SkFont);
}
extern "C" {
    pub fn C_SkFont_getTypeface(self_: *mut SkFont) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFont_setTypeface(self_: *mut SkFont, tf: *mut SkTypeface);
}
extern "C" {
    pub fn C_SkFont_getIntercepts(
        self_: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::core::ffi::c_int,
        pos: *const SkPoint,
        top: SkScalar,
        bottom: SkScalar,
        paint: *const SkPaint,
        vs: *mut VecSink<SkScalar>,
    );
}
extern "C" {
    pub fn C_SkFontArguments_construct(uninitialized: *mut SkFontArguments);
}
extern "C" {
    pub fn C_SkFontArguments_destruct(self_: *mut SkFontArguments);
}
extern "C" {
    pub fn C_SkFontArguments_setCollectionIndex(
        self_: *mut SkFontArguments,
        collectionIndex: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn C_SkFontArguments_setVariationDesignPosition(
        self_: *mut SkFontArguments,
        position: SkFontArguments_VariationPosition,
    );
}
extern "C" {
    pub fn C_SkFontArguments_setPalette(
        self_: *mut SkFontArguments,
        palette: SkFontArguments_Palette,
    );
}
extern "C" {
    pub fn C_SkFontArguments_getVariationDesignPosition(
        self_: *const SkFontArguments,
    ) -> SkFontArguments_VariationPosition;
}
extern "C" {
    pub fn C_SkFontArguments_getPalette(self_: *const SkFontArguments) -> SkFontArguments_Palette;
}
extern "C" {
    pub fn C_SkFontStyleSet_count(self_: *mut SkFontStyleSet) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkFontStyleSet_getStyle(
        self_: *mut SkFontStyleSet,
        index: ::core::ffi::c_int,
        fontStyle: *mut SkFontStyle,
        style: *mut SkString,
    );
}
extern "C" {
    pub fn C_SkFontStyleSet_createTypeface(
        self_: *mut SkFontStyleSet,
        index: ::core::ffi::c_int,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontStyleSet_matchStyle(
        self_: *mut SkFontStyleSet,
        pattern: *const SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontStyleSet_CreateEmpty() -> *mut SkFontStyleSet;
}
extern "C" {
    pub fn C_SkFontMgr_createStyleSet(
        self_: *const SkFontMgr,
        index: ::core::ffi::c_int,
    ) -> *mut SkFontStyleSet;
}
extern "C" {
    pub fn C_SkFontMgr_matchFamily(
        self_: *const SkFontMgr,
        familyName: *const ::core::ffi::c_char,
    ) -> *mut SkFontStyleSet;
}
extern "C" {
    pub fn C_SkFontMgr_matchFamilyStyle(
        self_: *const SkFontMgr,
        familyName: *const ::core::ffi::c_char,
        style: *const SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontMgr_matchFamilyStyleCharacter(
        self_: *const SkFontMgr,
        familyName: *const ::core::ffi::c_char,
        style: *const SkFontStyle,
        bcp47: *mut *const ::core::ffi::c_char,
        bcp47Count: ::core::ffi::c_int,
        character: SkUnichar,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontMgr_makeFromStream(
        self_: *const SkFontMgr,
        stream: *mut SkStreamAsset,
        ttcIndex: ::core::ffi::c_int,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontMgr_RefDefault() -> *mut SkFontMgr;
}
extern "C" {
    pub fn C_SkFontMgr_RefEmpty() -> *mut SkFontMgr;
}
extern "C" {
    pub fn C_SkFontParameters_Variation_Axis_isHidden(
        self_: *const SkFontParameters_Variation_Axis,
    ) -> bool;
}
extern "C" {
    pub fn C_SkFontParameters_Variation_Axis_setHidden(
        self_: *mut SkFontParameters_Variation_Axis,
        hidden: bool,
    );
}
extern "C" {
    pub fn C_SkVertices_ref(self_: *const SkVertices);
}
extern "C" {
    pub fn C_SkVertices_unref(self_: *const SkVertices);
}
extern "C" {
    pub fn C_SkVertices_unique(self_: *const SkVertices) -> bool;
}
extern "C" {
    pub fn C_SkVertices_MakeCopy(
        mode: SkVertices_VertexMode,
        vertexCount: ::core::ffi::c_int,
        positions: *const SkPoint,
        texs: *const SkPoint,
        colors: *const SkColor,
        indexCount: ::core::ffi::c_int,
        indices: *const u16,
    ) -> *mut SkVertices;
}
extern "C" {
    pub fn C_SkVertices_Builder_destruct(builder: *mut SkVertices_Builder);
}
extern "C" {
    pub fn C_SkVertices_Builder_detach(builder: *mut SkVertices_Builder) -> *mut SkVertices;
}
extern "C" {
    pub fn C_SkPictureRecorder_Construct(uninitialized: *mut SkPictureRecorder);
}
extern "C" {
    pub fn C_SkPictureRecorder_destruct(self_: *mut SkPictureRecorder);
}
extern "C" {
    pub fn C_SkPictureRecorder_finishRecordingAsPicture(
        self_: *mut SkPictureRecorder,
        cullRect: *const SkRect,
    ) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPictureRecorder_finishRecordingAsDrawable(
        self_: *mut SkPictureRecorder,
    ) -> *mut SkDrawable;
}
extern "C" {
    pub fn C_SkPixelRef_width(self_: *const SkPixelRef) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkPixelRef_height(self_: *const SkPixelRef) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkPixelRef_pixels(self_: *const SkPixelRef) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn C_SkPixelRef_rowBytes(self_: *const SkPixelRef) -> usize;
}
extern "C" {
    pub fn C_SkPixelRef_isImmutable(self_: *const SkPixelRef) -> bool;
}
extern "C" {
    pub fn C_SkPixelRef_notifyAddedToCache(self_: *mut SkPixelRef);
}
extern "C" {
    pub fn C_SkPoint_isFinite(self_: *const SkPoint) -> bool;
}
extern "C" {
    pub fn C_SkIRect_isEmpty(self_: *const SkIRect) -> bool;
}
extern "C" {
    pub fn C_SkIRect_contains(self_: *const SkIRect, rect: *const SkRect) -> bool;
}
extern "C" {
    pub fn C_SkRect_round(self_: *const SkRect, dst: *mut SkIRect);
}
extern "C" {
    pub fn C_SkRect_roundIn(self_: *const SkRect, dst: *mut SkIRect);
}
extern "C" {
    pub fn C_SkRect_roundOut(self_: *const SkRect, dst: *mut SkIRect);
}
extern "C" {
    pub fn C_SkRefCntBase_ref(self_: *const SkRefCntBase);
}
extern "C" {
    pub fn C_SkRefCntBase_unref(self_: *const SkRefCntBase);
}
extern "C" {
    pub fn C_SkRefCntBase_unique(self_: *const SkRefCntBase) -> bool;
}
extern "C" {
    pub fn C_SkColorFilter_makeComposed(
        self_: *const SkColorFilter,
        inner: *mut SkColorFilter,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilter_filterColor4f(
        self_: *const SkColorFilter,
        srcColor: *const SkColor4f,
        srcCS: *mut SkColorSpace,
        dstCS: *mut SkColorSpace,
    ) -> SkColor4f;
}
extern "C" {
    pub fn C_SkColorFilters_Compose(
        outer: *mut SkColorFilter,
        inner: *mut SkColorFilter,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Blend2(
        c: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        blendMode: SkBlendMode,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Blend(c: SkColor, blendMode: SkBlendMode) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Matrix(colorMatrix: *const SkColorMatrix) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_MatrixRowMajor(array: *const SkScalar) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_HSLAMatrixOfColorMatrix(
        colorMatrix: *const SkColorMatrix,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_HSLAMatrix(rowMajor: *const f32) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_LinearToSRGBGamma() -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_SRGBToLinearGamma() -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Lerp(
        t: f32,
        dst: *mut SkColorFilter,
        src: *mut SkColorFilter,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Table(table: *const u8) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_TableARGB(
        tableA: *const u8,
        tableR: *const u8,
        tableG: *const u8,
        tableB: *const u8,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Table2(table: *mut SkColorTable) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Lighting(mul: SkColor, add: SkColor) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkContourMeasureIter_destruct(self_: *mut SkContourMeasureIter);
}
extern "C" {
    pub fn C_SkContourMeasureIter_next(self_: *mut SkContourMeasureIter) -> *mut SkContourMeasure;
}
extern "C" {
    pub fn C_SkContourMeasure_length(self_: *const SkContourMeasure) -> SkScalar;
}
extern "C" {
    pub fn C_SkContourMeasure_isClosed(self_: *const SkContourMeasure) -> bool;
}
extern "C" {
    pub fn C_SkDataTable_count(self_: *const SkDataTable) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkDataTable_MakeEmpty() -> *mut SkDataTable;
}
extern "C" {
    pub fn C_SkDataTable_MakeCopyArrays(
        ptrs: *const *const ::core::ffi::c_void,
        sizes: *const usize,
        count: ::core::ffi::c_int,
    ) -> *mut SkDataTable;
}
extern "C" {
    pub fn C_SkDataTable_MakeCopyArray(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::core::ffi::c_int,
    ) -> *mut SkDataTable;
}
extern "C" {
    pub fn C_SkColorTable_Make(
        tableA: *const u8,
        tableR: *const u8,
        tableG: *const u8,
        tableB: *const u8,
    ) -> *mut SkColorTable;
}
extern "C" {
    pub fn C_SkColorTable_getTable(self_: *const SkColorTable, index: usize) -> *const u8;
}
extern "C" {
    pub fn C_SkDrawable_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkDrawable;
}
extern "C" {
    pub fn C_SkDrawable_makePictureSnapshot(self_: *mut SkDrawable) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkDrawable_getBounds(self_: *mut SkDrawable, result: *mut SkRect);
}
extern "C" {
    pub fn C_SkImageFilter_computeFastBounds(
        self_: *const SkImageFilter,
        bounds: *const SkRect,
        uninitialized: *mut SkRect,
    );
}
extern "C" {
    pub fn C_SkImageFilter_makeWithLocalMatrix(
        self_: *const SkImageFilter,
        matrix: *const SkMatrix,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilter_filterBounds(
        self_: *const SkImageFilter,
        src: *const SkIRect,
        ctm: *const SkMatrix,
        mapDirection: SkImageFilter_MapDirection,
        inputRect: *const SkIRect,
        result: *mut SkIRect,
    );
}
extern "C" {
    pub fn C_SkImageFilter_isColorFilterNode(
        self_: *const SkImageFilter,
        filterPtr: *mut *mut SkColorFilter,
    ) -> bool;
}
extern "C" {
    pub fn C_SkImageFilter_countInputs(self_: *const SkImageFilter) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkImageFilter_getInput(
        self_: *const SkImageFilter,
        i: ::core::ffi::c_int,
    ) -> *const SkImageFilter;
}
extern "C" {
    pub fn C_SkImageGenerator_delete(self_: *mut SkImageGenerator);
}
extern "C" {
    pub fn C_SkImageGenerator_refEncodedData(self_: *mut SkImageGenerator) -> *mut SkData;
}
extern "C" {
    pub fn C_SkImageGenerator_isTextureGenerator(self_: *const SkImageGenerator) -> bool;
}
extern "C" {
    pub fn C_SkString_destruct(self_: *mut SkString);
}
extern "C" {
    pub fn C_SkString_c_str_size(
        self_: *const SkString,
        size: *mut usize,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn C_SkStrings_construct(
        uninitialized: *mut SkStrings,
        string: *mut SkString,
        count: usize,
    );
}
extern "C" {
    pub fn C_SkStrings_destruct(self_: *mut SkStrings);
}
extern "C" {
    pub fn C_SkStrings_ptr_count(self_: *const SkStrings, count: *mut usize) -> *const SkString;
}
extern "C" {
    pub fn C_string_view_ptr_size(
        self_: *const std_string_view,
        size: *mut usize,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn C_string_ptr_size(
        self_: *const std_string,
        size: *mut usize,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn C_SkStrokeRec_destruct(self_: *mut SkStrokeRec);
}
extern "C" {
    pub fn C_SkStrokeRec_copy(self_: *const SkStrokeRec, other: *mut SkStrokeRec);
}
extern "C" {
    pub fn C_SkStrokeRec_getCap(self_: *const SkStrokeRec) -> SkPaint_Cap;
}
extern "C" {
    pub fn C_SkStrokeRec_getJoin(self_: *const SkStrokeRec) -> SkPaint_Join;
}
extern "C" {
    pub fn C_SkStrokeRec_hasEqualEffect(
        self_: *const SkStrokeRec,
        other: *const SkStrokeRec,
    ) -> bool;
}
extern "C" {
    pub fn C_SkPathEffect_MakeSum(
        first: *mut SkPathEffect,
        second: *mut SkPathEffect,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPathEffect_MakeCompose(
        outer: *mut SkPathEffect,
        inner: *mut SkPathEffect,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPathEffect_DashInfo_Construct(uninitialized: *mut SkPathEffect_DashInfo);
}
extern "C" {
    pub fn C_SkPathEffect_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPixmap_destruct(self_: *mut SkPixmap);
}
extern "C" {
    pub fn C_SkPixmap_setColorSpace(self_: *mut SkPixmap, colorSpace: *mut SkColorSpace);
}
extern "C" {
    pub fn C_SkMaskFilter_MakeBlur(
        style: SkBlurStyle,
        sigma: SkScalar,
        respectCTM: bool,
    ) -> *mut SkMaskFilter;
}
extern "C" {
    pub fn C_SkMaskFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkMaskFilter;
}
extern "C" {
    pub fn C_SkSize_toRound(size: *const SkSize) -> SkISize;
}
extern "C" {
    pub fn C_SkSize_toCeil(size: *const SkSize) -> SkISize;
}
extern "C" {
    pub fn C_SkSize_toFloor(size: *const SkSize) -> SkISize;
}
extern "C" {
    pub fn C_SkShader_isOpaque(self_: *const SkShader) -> bool;
}
extern "C" {
    pub fn C_SkShader_isAImage(self_: *const SkShader) -> bool;
}
extern "C" {
    pub fn C_SkShader_makeWithLocalMatrix(
        self_: *const SkShader,
        matrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShader_makeWithColorFilter(
        self_: *const SkShader,
        colorFilter: *mut SkColorFilter,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Empty() -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Color(color: SkColor) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Color2(
        color: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Blend(
        blender: *mut SkBlender,
        dst: *mut SkShader,
        src: *mut SkShader,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_CoordClamp(shader: *mut SkShader, subset: *const SkRect) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShader_Deserialize(data: *const ::core::ffi::c_void, length: usize)
        -> *mut SkShader;
}
extern "C" {
    pub fn C_SkStream_delete(stream: *mut SkStream);
}
extern "C" {
    pub fn C_SkStream_read(
        stream: *mut SkStream,
        buffer: *mut ::core::ffi::c_void,
        len: usize,
    ) -> usize;
}
extern "C" {
    pub fn C_SkStreamAsset_getLength(self_: *const SkStreamAsset) -> usize;
}
extern "C" {
    pub fn C_SkWStream_destruct(self_: *mut SkWStream);
}
extern "C" {
    pub fn C_SkWStream_write(
        self_: *mut SkWStream,
        buffer: *const ::core::ffi::c_void,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn C_SkMemoryStream_MakeDirect(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkMemoryStream;
}
extern "C" {
    pub fn C_SkDynamicMemoryWStream_Construct(uninitialized: *mut SkDynamicMemoryWStream);
}
extern "C" {
    pub fn C_SkDynamicMemoryWStream_detachAsData(self_: *mut SkDynamicMemoryWStream)
        -> *mut SkData;
}
extern "C" {
    pub fn C_SkDynamicMemoryWStream_detachAsStream(
        self_: *mut SkDynamicMemoryWStream,
    ) -> *mut SkStreamAsset;
}
extern "C" {
    pub fn C_SkTiledImageUtils_DrawImageRect(
        canvas: *mut SkCanvas,
        image: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        sampling: *const SkSamplingOptions,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    pub fn C_SkTiledImageUtils_GetImageKeyValues(image: *const SkImage, keyValues: *mut u32);
}
extern "C" {
    pub fn C_SkYUVAInfo_Construct(uninitialized: *mut SkYUVAInfo);
}
extern "C" {
    pub fn C_SkYUVAInfo_destruct(self_: *mut SkYUVAInfo);
}
extern "C" {
    pub fn C_SkYUVAInfo_SubsamplingFactors(
        subsampling: SkYUVAInfo_Subsampling,
        factors: *mut ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn C_SkYUVAInfo_PlaneSubsamplingFactors(
        planeConfig: SkYUVAInfo_PlaneConfig,
        subsampling: SkYUVAInfo_Subsampling,
        planeIdx: ::core::ffi::c_int,
        factors: *mut ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn C_SkYUVAInfo_NumPlanes(planeConfig: SkYUVAInfo_PlaneConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkYUVAInfo_NumChannelsInPlane(
        planarConfig: SkYUVAInfo_PlaneConfig,
        i: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkYUVAInfo_equals(a: *const SkYUVAInfo, b: *const SkYUVAInfo) -> bool;
}
extern "C" {
    pub fn C_SkYUVAInfo_makeSubsampling(
        self_: *const SkYUVAInfo,
        subsampling: SkYUVAInfo_Subsampling,
        uninitialized: *mut SkYUVAInfo,
    );
}
extern "C" {
    pub fn C_SkYUVAInfo_makeDimensions(
        self_: *const SkYUVAInfo,
        dimensions: *const SkISize,
        uninitialized: *mut SkYUVAInfo,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_Construct(uninitialized: *mut SkYUVAPixmapInfo);
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_destruct(self_: *mut SkYUVAPixmapInfo);
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_equals(
        a: *const SkYUVAPixmapInfo,
        b: *const SkYUVAPixmapInfo,
    ) -> bool;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_rowBytes(
        self_: *const SkYUVAPixmapInfo,
        i: ::core::ffi::c_int,
    ) -> usize;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_planeInfo(
        self_: *const SkYUVAPixmapInfo,
        i: ::core::ffi::c_int,
    ) -> *const SkImageInfo;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_isValid(self_: *const SkYUVAPixmapInfo) -> bool;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_Construct(
        uninitialized: *mut SkYUVAPixmapInfo_SupportedDataTypes,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_destruct(
        self_: *mut SkYUVAPixmapInfo_SupportedDataTypes,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_All(
        uninitialized: *mut SkYUVAPixmapInfo_SupportedDataTypes,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_supported(
        self_: *const SkYUVAPixmapInfo_SupportedDataTypes,
        pc: SkYUVAPixmapInfo_PlaneConfig,
        dt: SkYUVAPixmapInfo_DataType,
    ) -> bool;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_DefaultColorTypeForDataType(
        dt: SkYUVAPixmapInfo_DataType,
        numChannels: ::core::ffi::c_int,
    ) -> SkColorType;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_NumChannelsAndDataType(
        colorType: SkColorType,
        dataType: *mut SkYUVAPixmapInfo_DataType,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_SkYUVAPixmaps_Construct(uninitialized: *mut SkYUVAPixmaps);
}
extern "C" {
    pub fn C_SkYUVAPixmaps_destruct(self_: *mut SkYUVAPixmaps);
}
extern "C" {
    pub fn C_SkYUVAPixmaps_MakeCopy(self_: *const SkYUVAPixmaps, uninitialized: *mut SkYUVAPixmaps);
}
extern "C" {
    pub fn C_SkYUVAPixmaps_Allocate(
        uninitialized: *mut SkYUVAPixmaps,
        yuvaPixmapInfo: *const SkYUVAPixmapInfo,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_FromData(
        uninitialized: *mut SkYUVAPixmaps,
        yuvaPixmapInfo: *const SkYUVAPixmapInfo,
        data: *mut SkData,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_FromExternalMemory(
        uninitialized: *mut SkYUVAPixmaps,
        yuvaPixmapInfo: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_FromExternalPixmaps(
        uninitialized: *mut SkYUVAPixmaps,
        yuvaInfo: *const SkYUVAInfo,
        pixmaps: *const SkPixmap,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_pixmapsInfo(
        self_: *const SkYUVAPixmaps,
        uninitialized: *mut SkYUVAPixmapInfo,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_planes(self_: *const SkYUVAPixmaps) -> *const SkPixmap;
}
extern "C" {
    pub fn C_SkYUVAPixmaps_isValid(self_: *const SkYUVAPixmaps) -> bool;
}
extern "C" {
    pub fn C_Effects_Types(arg1: *mut SkTableMaskFilter);
}
extern "C" {
    pub fn C_SkBlenders_Arithmetic(
        k1: f32,
        k2: f32,
        k3: f32,
        k4: f32,
        enforcePremul: bool,
    ) -> *mut SkBlender;
}
extern "C" {
    pub fn C_SkGradientShader_Types(arg1: *mut SkGradientShader);
}
extern "C" {
    pub fn C_SkGradientShader_MakeLinear(
        pts: *const SkPoint,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeLinearWithInterpolation(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeRadial(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeRadialWithInterpolation(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeTwoPointConical(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeTwoPointConicalWithInterpolation(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeSweep(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeSweepWithInterpolation(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::core::ffi::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        interpolation: *const SkGradientShader_Interpolation,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_MakeFractalNoise(
        baseFrequencyX: SkScalar,
        baseFrequencyY: SkScalar,
        numOctaves: ::core::ffi::c_int,
        seed: SkScalar,
        tileSize: *const SkISize,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_MakeTurbulence(
        baseFrequencyX: SkScalar,
        baseFrequencyY: SkScalar,
        numOctaves: ::core::ffi::c_int,
        seed: SkScalar,
        tileSize: *const SkISize,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkPath1DPathEffect_Make(
        path: *const SkPath,
        advance: SkScalar,
        phase: SkScalar,
        style: SkPath1DPathEffect_Style,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkLine2DPathEffect_Make(width: SkScalar, matrix: *const SkMatrix)
        -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPath2DPathEffect_Make(
        matrix: *const SkMatrix,
        path: *const SkPath,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkColorMatrix_Construct(uninitialized: *mut SkColorMatrix);
}
extern "C" {
    pub fn C_SkColorMatrix_Construct2(
        uninitialized: *mut SkColorMatrix,
        m00: f32,
        m01: f32,
        m02: f32,
        m03: f32,
        m04: f32,
        m10: f32,
        m11: f32,
        m12: f32,
        m13: f32,
        m14: f32,
        m20: f32,
        m21: f32,
        m22: f32,
        m23: f32,
        m24: f32,
        m30: f32,
        m31: f32,
        m32: f32,
        m33: f32,
        m34: f32,
    );
}
extern "C" {
    pub fn C_SkColorMatrix_setRowMajor(self_: *mut SkColorMatrix, src: *const f32);
}
extern "C" {
    pub fn C_SkColorMatrix_getRowMajor(self_: *const SkColorMatrix, dst: *mut f32);
}
extern "C" {
    pub fn C_SkCornerPathEffect_Make(radius: SkScalar) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkDashPathEffect_Make(
        intervals: *const SkScalar,
        count: ::core::ffi::c_int,
        phase: SkScalar,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkDiscretePathEffect_Make(
        segLength: SkScalar,
        dev: SkScalar,
        seedAssist: u32,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkHighContrastFilter_Make(config: *const SkHighContrastConfig) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkLumaColorFilter_Make() -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkMergePathEffect_Make(
        one: *mut SkPathEffect,
        two: *mut SkPathEffect,
        op: SkPathOp,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkMatrixPathEffect_MakeTranslate(dx: SkScalar, dy: SkScalar) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkMatrixPathEffect_Make(m: *const SkMatrix) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkStrokePathEffect_Make(
        width: SkScalar,
        join: SkPaint_Join,
        cap: SkPaint_Cap,
        miter: SkScalar,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkOverdrawColorFilter_MakeWithSkColors(colors: *const SkColor) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkRuntimeEffect_MakeForColorFilter(
        sksl: *const SkString,
        options: *const SkRuntimeEffect_Options,
        error: *mut SkString,
    ) -> *mut SkRuntimeEffect;
}
extern "C" {
    pub fn C_SkRuntimeEffect_MakeForShader(
        sksl: *const SkString,
        options: *const SkRuntimeEffect_Options,
        error: *mut SkString,
    ) -> *mut SkRuntimeEffect;
}
extern "C" {
    pub fn C_SkRuntimeEffect_MakeForBlender(
        sksl: *const SkString,
        options: *const SkRuntimeEffect_Options,
        error: *mut SkString,
    ) -> *mut SkRuntimeEffect;
}
extern "C" {
    pub fn C_SkRuntimeEffect_makeShader(
        self_: *const SkRuntimeEffect,
        uniforms: *const SkData,
        children: *mut SkRuntimeEffect_ChildPtr,
        childCount: usize,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkRuntimeEffect_makeColorFilter(
        self_: *const SkRuntimeEffect,
        inputs: *const SkData,
        children: *mut SkRuntimeEffect_ChildPtr,
        childCount: usize,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkRuntimeEffect_makeBlender(
        self_: *const SkRuntimeEffect,
        uniforms: *const SkData,
        children: *mut SkRuntimeEffect_ChildPtr,
        childCount: usize,
    ) -> *mut SkBlender;
}
extern "C" {
    pub fn C_SkRuntimeEffect_source(
        self_: *const SkRuntimeEffect,
        len: *mut usize,
    ) -> *const ::core::ffi::c_uchar;
}
extern "C" {
    pub fn C_SkRuntimeEffect_uniforms(
        self_: *const SkRuntimeEffect,
        count: *mut usize,
    ) -> *const SkRuntimeEffect_Uniform;
}
extern "C" {
    pub fn C_SkRuntimeEffect_children(
        self_: *const SkRuntimeEffect,
        count: *mut usize,
    ) -> *const SkRuntimeEffect_Child;
}
extern "C" {
    pub fn C_SkRuntimeEffect_findUniform(
        self_: *const SkRuntimeEffect,
        name: *const ::core::ffi::c_char,
        count: usize,
    ) -> *const SkRuntimeEffect_Uniform;
}
extern "C" {
    pub fn C_SkRuntimeEffect_findChild(
        self_: *const SkRuntimeEffect,
        name: *const ::core::ffi::c_char,
        count: usize,
    ) -> *const SkRuntimeEffect_Child;
}
extern "C" {
    pub fn C_SkRuntimeEffect_allowShader(self_: *const SkRuntimeEffect) -> bool;
}
extern "C" {
    pub fn C_SkRuntimeEffect_allowColorFilter(self_: *const SkRuntimeEffect) -> bool;
}
extern "C" {
    pub fn C_SkRuntimeEffect_allowBlender(self_: *const SkRuntimeEffect) -> bool;
}
extern "C" {
    pub fn C_SkShaderMaskFilter_Make(shader: *mut SkShader) -> *mut SkMaskFilter;
}
extern "C" {
    pub fn C_SkStrokeAndFillePathEffect_Make() -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkTrimPathEffect_Make(
        startT: SkScalar,
        stopT: SkScalar,
        mode: SkTrimPathEffect_Mode,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkImageFilters_Arithmetic(
        k1: f32,
        k2: f32,
        k3: f32,
        k4: f32,
        enforcePMColor: bool,
        background: *mut SkImageFilter,
        foreground: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Blend(
        blender: *mut SkBlender,
        background: *mut SkImageFilter,
        foreground: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Blur(
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        tileMode: SkTileMode,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_ColorFilter(
        cf: *mut SkColorFilter,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Compose(
        outer: *mut SkImageFilter,
        inner: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DisplacementMap(
        xChannelSelector: SkColorChannel,
        yChannelSelector: SkColorChannel,
        scale: SkScalar,
        displacement: *mut SkImageFilter,
        color: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DropShadow(
        dx: SkScalar,
        dy: SkScalar,
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        color: SkColor,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DropShadowOnly(
        dx: SkScalar,
        dy: SkScalar,
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        color: SkColor,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Image(
        image: *mut SkImage,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        sampling: *const SkSamplingOptions,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Magnifier(
        lensBounds: *const SkRect,
        zoomAmount: SkScalar,
        inset: SkScalar,
        sampling: *const SkSamplingOptions,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_MatrixConvolution(
        kernelSize: *const SkISize,
        kernel: *const SkScalar,
        gain: SkScalar,
        bias: SkScalar,
        kernelOffset: *const SkIPoint,
        tileMode: SkTileMode,
        convolveAlpha: bool,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_MatrixTransform(
        matrix: *const SkMatrix,
        sampling: *const SkSamplingOptions,
        input: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Merge(
        filters: *const *mut SkImageFilter,
        count: ::core::ffi::c_int,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Offset(
        dx: SkScalar,
        dy: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Picture(
        pic: *mut SkPicture,
        targetRect: *const SkRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Shader(
        shader: *mut SkShader,
        dither: SkImageFilters_Dither,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Tile(
        src: *const SkRect,
        dst: *const SkRect,
        input: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Dilate(
        radiusX: SkScalar,
        radiusY: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Erode(
        radiusX: SkScalar,
        radiusY: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DistantLitDiffuse(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_PointLitDiffuse(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_SpotLitDiffuse(
        location: *const SkPoint3,
        target: *const SkPoint3,
        specularExponent: SkScalar,
        cutoffAngle: SkScalar,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_ImageFilters_DistantLitSpecular(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_PointLitSpecular(
        location: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_SpotLitSpecular(
        location: *const SkPoint3,
        target: *const SkPoint3,
        specularExponent: SkScalar,
        cutoffAngle: SkScalar,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkPngEncoder_Encode(
        stream: *mut SkWStream,
        pixmap: *const SkPixmap,
        comments: *mut SkDataTable,
        filterFlags: SkPngEncoder_FilterFlag,
        zLibLevel: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    pub fn C_SkPngEncoder_EncodeImage(
        ctx: *mut GrDirectContext,
        img: *const SkImage,
        comments: *mut SkDataTable,
        filterFlags: SkPngEncoder_FilterFlag,
        zLibLevel: ::core::ffi::c_int,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkJpegEncoder_Encode(
        stream: *mut SkWStream,
        pixmap: *const SkPixmap,
        quality: ::core::ffi::c_int,
        downsample: SkJpegEncoder_Downsample,
        alphaOption: SkJpegEncoder_AlphaOption,
        xmpMetadata: *const SkData,
    ) -> bool;
}
extern "C" {
    pub fn C_SkJpegEncoder_EncodeImage(
        ctx: *mut GrDirectContext,
        img: *const SkImage,
        quality: ::core::ffi::c_int,
        downsample: SkJpegEncoder_Downsample,
        alphaOption: SkJpegEncoder_AlphaOption,
        xmpMetadata: *const SkData,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkPDF_AttributeList_destruct(self_: *mut SkPDF_AttributeList);
}
extern "C" {
    pub fn C_SkPDF_AttributeList_appendFloatArray(
        self_: *mut SkPDF_AttributeList,
        owner: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        value: *const f32,
        len: usize,
    );
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_new() -> *mut SkPDF_StructureElementNode;
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_delete(self_: *mut SkPDF_StructureElementNode);
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_setChildVector(
        self_: *mut SkPDF_StructureElementNode,
        nodes: *mut *mut SkPDF_StructureElementNode,
        len: usize,
    );
}
extern "C" {
    pub fn C_SkPDF_StructElementNode_appendChild(
        self_: *mut SkPDF_StructureElementNode,
        node: *mut SkPDF_StructureElementNode,
    );
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_getChildVector(
        self_: *const SkPDF_StructureElementNode,
        nodes: *mut *mut SkPDF_StructureElementNode,
    ) -> usize;
}
extern "C" {
    pub fn C_SkPDF_Metadata_Construct(uninitialized: *mut SkPDF_Metadata);
}
extern "C" {
    pub fn C_SkPDF_Metadata_destruct(self_: *mut SkPDF_Metadata);
}
extern "C" {
    pub fn C_SkPDF_MakeDocument(
        stream: *mut SkWStream,
        metadata: *const SkPDF_Metadata,
    ) -> *mut SkDocument;
}
extern "C" {
    pub fn C_SkOpBuilder_Construct(uninitialized: *mut SkOpBuilder);
}
extern "C" {
    pub fn C_SkOpBuilder_destruct(self_: *mut SkOpBuilder);
}
extern "C" {
    pub fn C_SVG_Types(arg1: *mut SkSVGCanvas);
}
extern "C" {
    pub fn C_SkSVGCanvas_Make(
        bounds: *const SkRect,
        writer: *mut SkWStream,
        flags: u32,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_Utils_Types(
        arg1: *mut SkShadowFlags,
        arg2: *mut SkShadowUtils,
        arg3: *mut SkTextUtils,
        arg4: *mut SkParsePath,
        arg5: *mut SkCustomTypefaceBuilder,
    );
}
extern "C" {
    pub fn C_Sk3DView_new() -> *mut Sk3DView;
}
extern "C" {
    pub fn C_Sk3DView_delete(self_: *mut Sk3DView);
}
extern "C" {
    pub fn C_SkCustomTypefaceBuilder_destruct(self_: *mut SkCustomTypefaceBuilder);
}
extern "C" {
    pub fn C_SkCustomTypefaceBuilder_detach(self_: *mut SkCustomTypefaceBuilder)
        -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkCustomTypefaceBuilder_setGlyph(
        self_: *mut SkCustomTypefaceBuilder,
        glyph: SkGlyphID,
        advance: f32,
        drawable: *mut SkDrawable,
        bounds: *const SkRect,
    );
}
extern "C" {
    pub fn C_SkCustomTypefaceBuilder_FromData(
        data: *mut SkData,
        fontArguments: *const SkFontArguments,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkMakeNullCanvas() -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkOrderedFontMgr_new() -> *mut SkOrderedFontMgr;
}
extern "C" {
    pub fn C_SkOrderedFontMgr_append(self_: *mut SkOrderedFontMgr, fontMgr: *mut SkFontMgr);
}
extern "C" {
    pub fn C_SkParsePath_ToSVGString(
        self_: *const SkPath,
        uninitialized: *mut SkString,
        encoding: SkParsePath_PathEncoding,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct RustStream {
    pub _base: SkStream,
    pub m_data: *mut ::core::ffi::c_void,
    pub m_length: usize,
    pub m_isEof: bool,
    pub m_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *mut ::core::ffi::c_void,
            arg3: usize,
        ) -> usize,
    >,
    pub m_seekAbsolute: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: usize) -> bool,
    >,
    pub m_seekRelative: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_long) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_RustStream() {
    const UNINIT: ::core::mem::MaybeUninit<RustStream> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RustStream>(),
        56usize,
        concat!("Size of: ", stringify!(RustStream))
    );
    assert_eq!(
        ::core::mem::align_of::<RustStream>(),
        8usize,
        concat!("Alignment of ", stringify!(RustStream))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RustStream),
            "::",
            stringify!(m_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RustStream),
            "::",
            stringify!(m_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_isEof) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RustStream),
            "::",
            stringify!(m_isEof)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RustStream),
            "::",
            stringify!(m_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_seekAbsolute) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RustStream),
            "::",
            stringify!(m_seekAbsolute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_seekRelative) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RustStream),
            "::",
            stringify!(m_seekRelative)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStreamC1EPvmPFmS0_S0_mEPFbS0_mEPFbS0_lE"]
    pub fn RustStream_RustStream(
        this: *mut RustStream,
        data: *mut ::core::ffi::c_void,
        length: usize,
        read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_void,
                arg3: usize,
            ) -> usize,
        >,
        seekAbsolute: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        seekRelative: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_long) -> bool,
        >,
    );
}
impl RustStream {
    #[inline]
    pub unsafe fn new(
        data: *mut ::core::ffi::c_void,
        length: usize,
        read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_void,
                arg3: usize,
            ) -> usize,
        >,
        seekAbsolute: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        seekRelative: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_long) -> bool,
        >,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        RustStream_RustStream(
            __bindgen_tmp.as_mut_ptr(),
            data,
            length,
            read,
            seekAbsolute,
            seekRelative,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStream4readEPvm"]
    pub fn RustStream_read(
        this: *mut ::core::ffi::c_void,
        buffer: *mut ::core::ffi::c_void,
        count: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStream6rewindEv"]
    pub fn RustStream_rewind(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStream4seekEm"]
    pub fn RustStream_seek(this: *mut ::core::ffi::c_void, pos: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStream4moveEl"]
    pub fn RustStream_move(this: *mut ::core::ffi::c_void, offset: ::core::ffi::c_long) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10RustStream7isAtEndEv"]
    pub fn RustStream_isAtEnd(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10RustStream9hasLengthEv"]
    pub fn RustStream_hasLength(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10RustStream9getLengthEv"]
    pub fn RustStream_getLength(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn C_RustStream_new(
        data: *mut ::core::ffi::c_void,
        length: usize,
        read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_void,
                arg3: usize,
            ) -> usize,
        >,
        seekAbsolute: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        seekRelative: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_long) -> bool,
        >,
    ) -> *mut RustStream;
}
extern "C" {
    pub fn C_RustStream_delete(stream: *mut RustStream);
}
#[repr(C)]
#[derive(Debug)]
pub struct RustWStream {
    pub _base: SkWStream,
    pub m_data: *mut ::core::ffi::c_void,
    pub m_length: usize,
    pub m_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *const ::core::ffi::c_void,
            arg3: usize,
        ) -> bool,
    >,
    pub m_flush: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
}
#[test]
fn bindgen_test_layout_RustWStream() {
    const UNINIT: ::core::mem::MaybeUninit<RustWStream> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RustWStream>(),
        40usize,
        concat!("Size of: ", stringify!(RustWStream))
    );
    assert_eq!(
        ::core::mem::align_of::<RustWStream>(),
        8usize,
        concat!("Alignment of ", stringify!(RustWStream))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RustWStream),
            "::",
            stringify!(m_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RustWStream),
            "::",
            stringify!(m_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RustWStream),
            "::",
            stringify!(m_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_flush) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RustWStream),
            "::",
            stringify!(m_flush)
        )
    );
}
extern "C" {
    pub fn C_RustWStream_construct(
        out: *mut RustWStream,
        data: *mut ::core::ffi::c_void,
        write: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: usize,
            ) -> bool,
        >,
        flush: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    );
}
extern "C" {
    pub fn C_RustWStream_destruct(stream: *mut RustWStream);
}
impl GrBackendApi {
    pub const OpenGL_GrBackend: GrBackendApi = GrBackendApi::OpenGL;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrBackendApi {
    OpenGL = 0,
    Vulkan = 1,
    Metal = 2,
    Direct3D = 3,
    Dawn = 4,
    Mock = 5,
}
pub use self::skgpu_Mipmapped as GrMipmapped;
pub use self::skgpu_Mipmapped as GrMipMapped;
pub use self::skgpu_Protected as GrProtected;
pub use self::skgpu_Renderable as GrRenderable;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrSurfaceOrigin {
    TopLeft = 0,
    BottomLeft = 1,
}
pub const GrGLBackendState_kRenderTarget_GrGLBackendState: GrGLBackendState = 1;
pub const GrGLBackendState_kTextureBinding_GrGLBackendState: GrGLBackendState = 2;
pub const GrGLBackendState_kView_GrGLBackendState: GrGLBackendState = 4;
pub const GrGLBackendState_kBlend_GrGLBackendState: GrGLBackendState = 8;
pub const GrGLBackendState_kMSAAEnable_GrGLBackendState: GrGLBackendState = 16;
pub const GrGLBackendState_kVertex_GrGLBackendState: GrGLBackendState = 32;
pub const GrGLBackendState_kStencil_GrGLBackendState: GrGLBackendState = 64;
pub const GrGLBackendState_kPixelStore_GrGLBackendState: GrGLBackendState = 128;
pub const GrGLBackendState_kProgram_GrGLBackendState: GrGLBackendState = 256;
pub const GrGLBackendState_kFixedFunction_GrGLBackendState: GrGLBackendState = 512;
pub const GrGLBackendState_kMisc_GrGLBackendState: GrGLBackendState = 1024;
pub const GrGLBackendState_kALL_GrGLBackendState: GrGLBackendState = 65535;
pub type GrGLBackendState = ::core::ffi::c_uint;
pub const kAll_GrBackendState: u32 = 4294967295;
pub type GrGpuFinishedContext = *mut ::core::ffi::c_void;
pub type GrGpuFinishedProc =
    ::core::option::Option<unsafe extern "C" fn(finishedContext: GrGpuFinishedContext)>;
pub type GrGpuSubmittedContext = *mut ::core::ffi::c_void;
pub type GrGpuSubmittedProc = ::core::option::Option<
    unsafe extern "C" fn(submittedContext: GrGpuSubmittedContext, success: bool),
>;
pub type GrDirectContextDestroyedContext = *mut ::core::ffi::c_void;
pub type GrDirectContextDestroyedProc =
    ::core::option::Option<unsafe extern "C" fn(destroyedContext: GrDirectContextDestroyedContext)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrFlushInfo {
    pub fNumSemaphores: usize,
    pub fSignalSemaphores: *mut GrBackendSemaphore,
    pub fFinishedProc: GrGpuFinishedProc,
    pub fFinishedContext: GrGpuFinishedContext,
    pub fSubmittedProc: GrGpuSubmittedProc,
    pub fSubmittedContext: GrGpuSubmittedContext,
}
#[test]
fn bindgen_test_layout_GrFlushInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GrFlushInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrFlushInfo>(),
        48usize,
        concat!("Size of: ", stringify!(GrFlushInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrFlushInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GrFlushInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fNumSemaphores) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fNumSemaphores)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSignalSemaphores) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fSignalSemaphores)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFinishedProc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fFinishedProc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFinishedContext) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fFinishedContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSubmittedProc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fSubmittedProc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSubmittedContext) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GrFlushInfo),
            "::",
            stringify!(fSubmittedContext)
        )
    );
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrSemaphoresSubmitted {
    No = 0,
    Yes = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrTextureType {
    kNone = 0,
    k2D = 1,
    kRectangle = 2,
    kExternal = 3,
}
impl GrColorType {
    pub const kLast: GrColorType = GrColorType::kARGB_4444;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrColorType {
    kUnknown = 0,
    kAlpha_8 = 1,
    kBGR_565 = 2,
    kABGR_4444 = 3,
    kRGBA_8888 = 4,
    kRGBA_8888_SRGB = 5,
    kRGB_888x = 6,
    kRG_88 = 7,
    kBGRA_8888 = 8,
    kRGBA_1010102 = 9,
    kBGRA_1010102 = 10,
    kGray_8 = 11,
    kGrayAlpha_88 = 12,
    kAlpha_F16 = 13,
    kRGBA_F16 = 14,
    kRGBA_F16_Clamped = 15,
    kRGBA_F32 = 16,
    kAlpha_16 = 17,
    kRG_1616 = 18,
    kRG_F16 = 19,
    kRGBA_16161616 = 20,
    kAlpha_8xxx = 21,
    kAlpha_F32xxx = 22,
    kGray_8xxx = 23,
    kR_8xxx = 24,
    kRGB_888 = 25,
    kR_8 = 26,
    kR_16 = 27,
    kR_F16 = 28,
    kGray_F16 = 29,
    kBGRA_4444 = 30,
    kARGB_4444 = 31,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrColorTypeEncoding {
    kUnorm = 0,
    kSRGBUnorm = 1,
    kFloat = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrColorFormatDesc {
    pub fRBits: ::core::ffi::c_int,
    pub fGBits: ::core::ffi::c_int,
    pub fBBits: ::core::ffi::c_int,
    pub fABits: ::core::ffi::c_int,
    pub fGrayBits: ::core::ffi::c_int,
    pub fEncoding: GrColorTypeEncoding,
}
#[test]
fn bindgen_test_layout_GrColorFormatDesc() {
    const UNINIT: ::core::mem::MaybeUninit<GrColorFormatDesc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrColorFormatDesc>(),
        24usize,
        concat!("Size of: ", stringify!(GrColorFormatDesc))
    );
    assert_eq!(
        ::core::mem::align_of::<GrColorFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(GrColorFormatDesc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRBits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrColorFormatDesc),
            "::",
            stringify!(fRBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGBits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrColorFormatDesc),
            "::",
            stringify!(fGBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBBits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrColorFormatDesc),
            "::",
            stringify!(fBBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fABits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GrColorFormatDesc),
            "::",
            stringify!(fABits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGrayBits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrColorFormatDesc),
            "::",
            stringify!(fGrayBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEncoding) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GrColorFormatDesc),
            "::",
            stringify!(fEncoding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrMockTextureInfo {
    pub fColorType: GrColorType,
    pub fCompressionType: SkTextureCompressionType,
    pub fID: ::core::ffi::c_int,
    pub fProtected: skgpu_Protected,
}
#[test]
fn bindgen_test_layout_GrMockTextureInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GrMockTextureInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrMockTextureInfo>(),
        16usize,
        concat!("Size of: ", stringify!(GrMockTextureInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrMockTextureInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(GrMockTextureInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockTextureInfo),
            "::",
            stringify!(fColorType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCompressionType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockTextureInfo),
            "::",
            stringify!(fCompressionType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockTextureInfo),
            "::",
            stringify!(fID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProtected) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockTextureInfo),
            "::",
            stringify!(fProtected)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK17GrMockTextureInfo16getBackendFormatEv"]
    pub fn GrMockTextureInfo_getBackendFormat(this: *const GrMockTextureInfo) -> GrBackendFormat;
}
impl GrMockTextureInfo {
    #[inline]
    pub unsafe fn getBackendFormat(&self) -> GrBackendFormat {
        GrMockTextureInfo_getBackendFormat(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrMockRenderTargetInfo {
    pub fColorType: GrColorType,
    pub fID: ::core::ffi::c_int,
    pub fProtected: skgpu_Protected,
}
#[test]
fn bindgen_test_layout_GrMockRenderTargetInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GrMockRenderTargetInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrMockRenderTargetInfo>(),
        12usize,
        concat!("Size of: ", stringify!(GrMockRenderTargetInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrMockRenderTargetInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(GrMockRenderTargetInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockRenderTargetInfo),
            "::",
            stringify!(fColorType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockRenderTargetInfo),
            "::",
            stringify!(fID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProtected) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockRenderTargetInfo),
            "::",
            stringify!(fProtected)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK22GrMockRenderTargetInfo16getBackendFormatEv"]
    pub fn GrMockRenderTargetInfo_getBackendFormat(
        this: *const GrMockRenderTargetInfo,
    ) -> GrBackendFormat;
}
impl GrMockRenderTargetInfo {
    #[inline]
    pub unsafe fn getBackendFormat(&self) -> GrBackendFormat {
        GrMockRenderTargetInfo_getBackendFormat(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrMockOptions {
    pub fMipmapSupport: bool,
    pub fDrawInstancedSupport: bool,
    pub fHalfFloatVertexAttributeSupport: bool,
    pub fMapBufferFlags: u32,
    pub fMaxTextureSize: ::core::ffi::c_int,
    pub fMaxRenderTargetSize: ::core::ffi::c_int,
    pub fMaxWindowRectangles: ::core::ffi::c_int,
    pub fMaxVertexAttributes: ::core::ffi::c_int,
    pub fConfigOptions: [GrMockOptions_ConfigOptions; 32usize],
    pub fCompressedOptions: [GrMockOptions_ConfigOptions; 4usize],
    pub fIntegerSupport: bool,
    pub fFlatInterpolationSupport: bool,
    pub fMaxVertexSamplers: ::core::ffi::c_int,
    pub fMaxFragmentSamplers: ::core::ffi::c_int,
    pub fShaderDerivativeSupport: bool,
    pub fDualSourceBlendingSupport: bool,
    pub fFailTextureAllocations: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrMockOptions_ConfigOptions {
    pub fRenderability: GrMockOptions_ConfigOptions_Renderability,
    pub fTexturable: bool,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrMockOptions_ConfigOptions_Renderability {
    kNo = 0,
    kNonMSAA = 1,
    kMSAA = 2,
}
#[test]
fn bindgen_test_layout_GrMockOptions_ConfigOptions() {
    const UNINIT: ::core::mem::MaybeUninit<GrMockOptions_ConfigOptions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrMockOptions_ConfigOptions>(),
        8usize,
        concat!("Size of: ", stringify!(GrMockOptions_ConfigOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<GrMockOptions_ConfigOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(GrMockOptions_ConfigOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRenderability) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions_ConfigOptions),
            "::",
            stringify!(fRenderability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTexturable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions_ConfigOptions),
            "::",
            stringify!(fTexturable)
        )
    );
}
#[test]
fn bindgen_test_layout_GrMockOptions() {
    const UNINIT: ::core::mem::MaybeUninit<GrMockOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrMockOptions>(),
        328usize,
        concat!("Size of: ", stringify!(GrMockOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<GrMockOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(GrMockOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMipmapSupport) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fMipmapSupport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDrawInstancedSupport) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fDrawInstancedSupport)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fHalfFloatVertexAttributeSupport) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fHalfFloatVertexAttributeSupport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMapBufferFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fMapBufferFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxTextureSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fMaxTextureSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxRenderTargetSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fMaxRenderTargetSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxWindowRectangles) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fMaxWindowRectangles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxVertexAttributes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fMaxVertexAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fConfigOptions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fConfigOptions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCompressedOptions) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fCompressedOptions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIntegerSupport) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fIntegerSupport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFlatInterpolationSupport) as usize - ptr as usize },
        313usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fFlatInterpolationSupport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxVertexSamplers) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fMaxVertexSamplers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxFragmentSamplers) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fMaxFragmentSamplers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fShaderDerivativeSupport) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fShaderDerivativeSupport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDualSourceBlendingSupport) as usize - ptr as usize },
        325usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fDualSourceBlendingSupport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFailTextureAllocations) as usize - ptr as usize },
        326usize,
        concat!(
            "Offset of field: ",
            stringify!(GrMockOptions),
            "::",
            stringify!(fFailTextureAllocations)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrGLStandard {
    None = 0,
    GL = 1,
    GLES = 2,
    WebGL = 3,
}
impl GrGLFormat {
    pub const LastColorFormat: GrGLFormat = GrGLFormat::LUMINANCE16F;
}
impl GrGLFormat {
    pub const Last: GrGLFormat = GrGLFormat::DEPTH24_STENCIL8;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrGLFormat {
    Unknown = 0,
    RGBA8 = 1,
    R8 = 2,
    ALPHA8 = 3,
    LUMINANCE8 = 4,
    LUMINANCE8_ALPHA8 = 5,
    BGRA8 = 6,
    RGB565 = 7,
    RGBA16F = 8,
    R16F = 9,
    RGB8 = 10,
    RGBX8 = 11,
    RG8 = 12,
    RGB10_A2 = 13,
    RGBA4 = 14,
    SRGB8_ALPHA8 = 15,
    COMPRESSED_ETC1_RGB8 = 16,
    COMPRESSED_RGB8_ETC2 = 17,
    COMPRESSED_RGB8_BC1 = 18,
    COMPRESSED_RGBA8_BC1 = 19,
    R16 = 20,
    RG16 = 21,
    RGBA16 = 22,
    RG16F = 23,
    LUMINANCE16F = 24,
    STENCIL_INDEX8 = 25,
    STENCIL_INDEX16 = 26,
    DEPTH24_STENCIL8 = 27,
}
pub type GrGLenum = ::core::ffi::c_uint;
pub type GrGLint = ::core::ffi::c_int;
pub type GrGLubyte = ::core::ffi::c_uchar;
pub type GrGLuint = ::core::ffi::c_uint;
pub type GrGLvoid = ::core::ffi::c_void;
pub type GrEGLDisplay = *mut ::core::ffi::c_void;
pub type GrEGLint = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrGLTextureInfo {
    pub fTarget: GrGLenum,
    pub fID: GrGLuint,
    pub fFormat: GrGLenum,
    pub fProtected: skgpu_Protected,
}
#[test]
fn bindgen_test_layout_GrGLTextureInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GrGLTextureInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrGLTextureInfo>(),
        16usize,
        concat!("Size of: ", stringify!(GrGLTextureInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrGLTextureInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(GrGLTextureInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTarget) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLTextureInfo),
            "::",
            stringify!(fTarget)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLTextureInfo),
            "::",
            stringify!(fID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFormat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLTextureInfo),
            "::",
            stringify!(fFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProtected) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLTextureInfo),
            "::",
            stringify!(fProtected)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrGLFramebufferInfo {
    pub fFBOID: GrGLuint,
    pub fFormat: GrGLenum,
    pub fProtected: skgpu_Protected,
}
#[test]
fn bindgen_test_layout_GrGLFramebufferInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GrGLFramebufferInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrGLFramebufferInfo>(),
        12usize,
        concat!("Size of: ", stringify!(GrGLFramebufferInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrGLFramebufferInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(GrGLFramebufferInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFBOID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLFramebufferInfo),
            "::",
            stringify!(fFBOID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLFramebufferInfo),
            "::",
            stringify!(fFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProtected) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLFramebufferInfo),
            "::",
            stringify!(fProtected)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrGLSurfaceInfo {
    pub fSampleCount: u32,
    pub fLevelCount: u32,
    pub fProtected: skgpu_Protected,
    pub fTarget: GrGLenum,
    pub fFormat: GrGLenum,
}
#[test]
fn bindgen_test_layout_GrGLSurfaceInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GrGLSurfaceInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrGLSurfaceInfo>(),
        20usize,
        concat!("Size of: ", stringify!(GrGLSurfaceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrGLSurfaceInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(GrGLSurfaceInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSampleCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLSurfaceInfo),
            "::",
            stringify!(fSampleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLevelCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLSurfaceInfo),
            "::",
            stringify!(fLevelCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProtected) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLSurfaceInfo),
            "::",
            stringify!(fProtected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTarget) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLSurfaceInfo),
            "::",
            stringify!(fTarget)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFormat) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLSurfaceInfo),
            "::",
            stringify!(fFormat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendFormatData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendTextureData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendRenderTargetData {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct GrBackendFormat {
    pub fBackend: GrBackendApi,
    pub fValid: bool,
    pub fFormatData: u64,
    pub __bindgen_anon_1: GrBackendFormat__bindgen_ty_1,
    pub fTextureType: GrTextureType,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GrBackendFormat__bindgen_ty_1 {
    pub fMock: GrBackendFormat__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendFormat__bindgen_ty_1__bindgen_ty_1 {
    pub fColorType: GrColorType,
    pub fCompressionType: SkTextureCompressionType,
    pub fIsStencilFormat: bool,
}
#[test]
fn bindgen_test_layout_GrBackendFormat__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<GrBackendFormat__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrBackendFormat__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(GrBackendFormat__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendFormat__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(GrBackendFormat__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendFormat__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fColorType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCompressionType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendFormat__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fCompressionType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsStencilFormat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendFormat__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fIsStencilFormat)
        )
    );
}
#[test]
fn bindgen_test_layout_GrBackendFormat__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<GrBackendFormat__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrBackendFormat__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(GrBackendFormat__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendFormat__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GrBackendFormat__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendFormat__bindgen_ty_1),
            "::",
            stringify!(fMock)
        )
    );
}
#[test]
fn bindgen_test_layout_GrBackendFormat() {
    const UNINIT: ::core::mem::MaybeUninit<GrBackendFormat> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrBackendFormat>(),
        32usize,
        concat!("Size of: ", stringify!(GrBackendFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(GrBackendFormat))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBackend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendFormat),
            "::",
            stringify!(fBackend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fValid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendFormat),
            "::",
            stringify!(fValid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFormatData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendFormat),
            "::",
            stringify!(fFormatData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextureType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendFormat),
            "::",
            stringify!(fTextureType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrBackendFormat8MakeMockE11GrColorType24SkTextureCompressionTypeb"]
    pub fn GrBackendFormat_MakeMock(
        colorType: GrColorType,
        compression: SkTextureCompressionType,
        isStencilFormat: bool,
    ) -> GrBackendFormat;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrBackendFormat11channelMaskEv"]
    pub fn GrBackendFormat_channelMask(this: *const GrBackendFormat) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrBackendFormat4descEv"]
    pub fn GrBackendFormat_desc(this: *const GrBackendFormat) -> GrColorFormatDesc;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrBackendFormat15asMockColorTypeEv"]
    pub fn GrBackendFormat_asMockColorType(this: *const GrBackendFormat) -> GrColorType;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrBackendFormat21asMockCompressionTypeEv"]
    pub fn GrBackendFormat_asMockCompressionType(
        this: *const GrBackendFormat,
    ) -> SkTextureCompressionType;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrBackendFormat19isMockStencilFormatEv"]
    pub fn GrBackendFormat_isMockStencilFormat(this: *const GrBackendFormat) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrBackendFormat13makeTexture2DEv"]
    pub fn GrBackendFormat_makeTexture2D(this: *const GrBackendFormat) -> GrBackendFormat;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrBackendFormat6MakeGLEjj"]
    pub fn GrBackendFormat_MakeGL(format: GrGLenum, target: GrGLenum) -> GrBackendFormat;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrBackendFormat10asGLFormatEv"]
    pub fn GrBackendFormat_asGLFormat(this: *const GrBackendFormat) -> GrGLFormat;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrBackendFormat14asGLFormatEnumEv"]
    pub fn GrBackendFormat_asGLFormatEnum(this: *const GrBackendFormat) -> GrGLenum;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrBackendFormatC1Ev"]
    pub fn GrBackendFormat_GrBackendFormat(this: *mut GrBackendFormat);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrBackendFormatC1ERKS_"]
    pub fn GrBackendFormat_GrBackendFormat1(
        this: *mut GrBackendFormat,
        arg1: *const GrBackendFormat,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrBackendFormatD1Ev"]
    pub fn GrBackendFormat_GrBackendFormat_destructor(this: *mut GrBackendFormat);
}
impl GrBackendFormat {
    #[inline]
    pub unsafe fn MakeMock(
        colorType: GrColorType,
        compression: SkTextureCompressionType,
        isStencilFormat: bool,
    ) -> GrBackendFormat {
        GrBackendFormat_MakeMock(colorType, compression, isStencilFormat)
    }
    #[inline]
    pub unsafe fn channelMask(&self) -> u32 {
        GrBackendFormat_channelMask(self)
    }
    #[inline]
    pub unsafe fn desc(&self) -> GrColorFormatDesc {
        GrBackendFormat_desc(self)
    }
    #[inline]
    pub unsafe fn asMockColorType(&self) -> GrColorType {
        GrBackendFormat_asMockColorType(self)
    }
    #[inline]
    pub unsafe fn asMockCompressionType(&self) -> SkTextureCompressionType {
        GrBackendFormat_asMockCompressionType(self)
    }
    #[inline]
    pub unsafe fn isMockStencilFormat(&self) -> bool {
        GrBackendFormat_isMockStencilFormat(self)
    }
    #[inline]
    pub unsafe fn makeTexture2D(&self) -> GrBackendFormat {
        GrBackendFormat_makeTexture2D(self)
    }
    #[inline]
    pub unsafe fn MakeGL(format: GrGLenum, target: GrGLenum) -> GrBackendFormat {
        GrBackendFormat_MakeGL(format, target)
    }
    #[inline]
    pub unsafe fn asGLFormat(&self) -> GrGLFormat {
        GrBackendFormat_asGLFormat(self)
    }
    #[inline]
    pub unsafe fn asGLFormatEnum(&self) -> GrGLenum {
        GrBackendFormat_asGLFormatEnum(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendFormat_GrBackendFormat(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const GrBackendFormat) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendFormat_GrBackendFormat1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        GrBackendFormat_GrBackendFormat_destructor(self)
    }
}
#[repr(C)]
pub struct GrBackendTexture {
    pub fIsValid: bool,
    pub fWidth: ::core::ffi::c_int,
    pub fHeight: ::core::ffi::c_int,
    pub fLabel: std_string,
    pub fMipmapped: GrMipmapped,
    pub fBackend: GrBackendApi,
    pub fTextureType: GrTextureType,
    pub fTextureData: u64,
    pub __bindgen_anon_1: GrBackendTexture__bindgen_ty_1,
    pub fMutableState: sk_sp<skgpu_MutableTextureStateRef>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GrBackendTexture__bindgen_ty_1 {
    pub fMockInfo: GrMockTextureInfo,
}
#[test]
fn bindgen_test_layout_GrBackendTexture__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<GrBackendTexture__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrBackendTexture__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(GrBackendTexture__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendTexture__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GrBackendTexture__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMockInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture__bindgen_ty_1),
            "::",
            stringify!(fMockInfo)
        )
    );
}
#[test]
fn bindgen_test_layout_GrBackendTexture() {
    const UNINIT: ::core::mem::MaybeUninit<GrBackendTexture> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrBackendTexture>(),
        88usize,
        concat!("Size of: ", stringify!(GrBackendTexture))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendTexture>(),
        8usize,
        concat!("Alignment of ", stringify!(GrBackendTexture))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsValid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture),
            "::",
            stringify!(fIsValid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLabel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture),
            "::",
            stringify!(fLabel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMipmapped) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture),
            "::",
            stringify!(fMipmapped)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBackend) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture),
            "::",
            stringify!(fBackend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextureType) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture),
            "::",
            stringify!(fTextureType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextureData) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture),
            "::",
            stringify!(fTextureData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMutableState) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendTexture),
            "::",
            stringify!(fMutableState)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK16GrBackendTexture16getBackendFormatEv"]
    pub fn GrBackendTexture_getBackendFormat(this: *const GrBackendTexture) -> GrBackendFormat;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16GrBackendTexture18getMockTextureInfoEP17GrMockTextureInfo"]
    pub fn GrBackendTexture_getMockTextureInfo(
        this: *const GrBackendTexture,
        arg1: *mut GrMockTextureInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN16GrBackendTexture15setMutableStateERKN5skgpu19MutableTextureStateE"]
    pub fn GrBackendTexture_setMutableState(
        this: *mut GrBackendTexture,
        arg1: *const skgpu_MutableTextureState,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK16GrBackendTexture11isProtectedEv"]
    pub fn GrBackendTexture_isProtected(this: *const GrBackendTexture) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN16GrBackendTexture13isSameTextureERKS_"]
    pub fn GrBackendTexture_isSameTexture(
        this: *mut GrBackendTexture,
        arg1: *const GrBackendTexture,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16GrBackendTexture16getGLTextureInfoEP15GrGLTextureInfo"]
    pub fn GrBackendTexture_getGLTextureInfo(
        this: *const GrBackendTexture,
        arg1: *mut GrGLTextureInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN16GrBackendTexture27glTextureParametersModifiedEv"]
    pub fn GrBackendTexture_glTextureParametersModified(this: *mut GrBackendTexture);
}
extern "C" {
    #[link_name = "\u{1}__ZN16GrBackendTextureC1Ev"]
    pub fn GrBackendTexture_GrBackendTexture(this: *mut GrBackendTexture);
}
extern "C" {
    #[link_name = "\u{1}__ZN16GrBackendTextureC1EiiN5skgpu9MipmappedERK17GrMockTextureInfoNSt3__117basic_string_viewIcNS5_11char_traitsIcEEEE"]
    pub fn GrBackendTexture_GrBackendTexture1(
        this: *mut GrBackendTexture,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: GrMipmapped,
        mockInfo: *const GrMockTextureInfo,
        label: std_string_view,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16GrBackendTextureC1ERKS_"]
    pub fn GrBackendTexture_GrBackendTexture2(
        this: *mut GrBackendTexture,
        that: *const GrBackendTexture,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16GrBackendTextureC1EiiN5skgpu9MipmappedERK15GrGLTextureInfoNSt3__117basic_string_viewIcNS5_11char_traitsIcEEEE"]
    pub fn GrBackendTexture_GrBackendTexture3(
        this: *mut GrBackendTexture,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: GrMipmapped,
        glInfo: *const GrGLTextureInfo,
        label: std_string_view,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16GrBackendTextureD1Ev"]
    pub fn GrBackendTexture_GrBackendTexture_destructor(this: *mut GrBackendTexture);
}
impl GrBackendTexture {
    #[inline]
    pub unsafe fn getBackendFormat(&self) -> GrBackendFormat {
        GrBackendTexture_getBackendFormat(self)
    }
    #[inline]
    pub unsafe fn getMockTextureInfo(&self, arg1: *mut GrMockTextureInfo) -> bool {
        GrBackendTexture_getMockTextureInfo(self, arg1)
    }
    #[inline]
    pub unsafe fn setMutableState(&mut self, arg1: *const skgpu_MutableTextureState) {
        GrBackendTexture_setMutableState(self, arg1)
    }
    #[inline]
    pub unsafe fn isProtected(&self) -> bool {
        GrBackendTexture_isProtected(self)
    }
    #[inline]
    pub unsafe fn isSameTexture(&mut self, arg1: *const GrBackendTexture) -> bool {
        GrBackendTexture_isSameTexture(self, arg1)
    }
    #[inline]
    pub unsafe fn getGLTextureInfo(&self, arg1: *mut GrGLTextureInfo) -> bool {
        GrBackendTexture_getGLTextureInfo(self, arg1)
    }
    #[inline]
    pub unsafe fn glTextureParametersModified(&mut self) {
        GrBackendTexture_glTextureParametersModified(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendTexture_GrBackendTexture(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: GrMipmapped,
        mockInfo: *const GrMockTextureInfo,
        label: std_string_view,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendTexture_GrBackendTexture1(
            __bindgen_tmp.as_mut_ptr(),
            width,
            height,
            arg1,
            mockInfo,
            label,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(that: *const GrBackendTexture) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendTexture_GrBackendTexture2(__bindgen_tmp.as_mut_ptr(), that);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: GrMipmapped,
        glInfo: *const GrGLTextureInfo,
        label: std_string_view,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendTexture_GrBackendTexture3(
            __bindgen_tmp.as_mut_ptr(),
            width,
            height,
            arg1,
            glInfo,
            label,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        GrBackendTexture_GrBackendTexture_destructor(self)
    }
}
#[repr(C)]
pub struct GrBackendRenderTarget {
    pub fIsValid: bool,
    pub fFramebufferOnly: bool,
    pub fWidth: ::core::ffi::c_int,
    pub fHeight: ::core::ffi::c_int,
    pub fSampleCnt: ::core::ffi::c_int,
    pub fStencilBits: ::core::ffi::c_int,
    pub fBackend: GrBackendApi,
    pub fRTData: u64,
    pub __bindgen_anon_1: GrBackendRenderTarget__bindgen_ty_1,
    pub fMutableState: sk_sp<skgpu_MutableTextureStateRef>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GrBackendRenderTarget__bindgen_ty_1 {
    pub fMockInfo: GrMockRenderTargetInfo,
}
#[test]
fn bindgen_test_layout_GrBackendRenderTarget__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<GrBackendRenderTarget__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrBackendRenderTarget__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(GrBackendRenderTarget__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendRenderTarget__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(GrBackendRenderTarget__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMockInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget__bindgen_ty_1),
            "::",
            stringify!(fMockInfo)
        )
    );
}
#[test]
fn bindgen_test_layout_GrBackendRenderTarget() {
    const UNINIT: ::core::mem::MaybeUninit<GrBackendRenderTarget> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrBackendRenderTarget>(),
        56usize,
        concat!("Size of: ", stringify!(GrBackendRenderTarget))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendRenderTarget>(),
        8usize,
        concat!("Alignment of ", stringify!(GrBackendRenderTarget))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsValid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget),
            "::",
            stringify!(fIsValid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFramebufferOnly) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget),
            "::",
            stringify!(fFramebufferOnly)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSampleCnt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget),
            "::",
            stringify!(fSampleCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStencilBits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget),
            "::",
            stringify!(fStencilBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBackend) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget),
            "::",
            stringify!(fBackend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRTData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget),
            "::",
            stringify!(fRTData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMutableState) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendRenderTarget),
            "::",
            stringify!(fMutableState)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK21GrBackendRenderTarget16getBackendFormatEv"]
    pub fn GrBackendRenderTarget_getBackendFormat(
        this: *const GrBackendRenderTarget,
    ) -> GrBackendFormat;
}
extern "C" {
    #[link_name = "\u{1}__ZNK21GrBackendRenderTarget23getMockRenderTargetInfoEP22GrMockRenderTargetInfo"]
    pub fn GrBackendRenderTarget_getMockRenderTargetInfo(
        this: *const GrBackendRenderTarget,
        arg1: *mut GrMockRenderTargetInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN21GrBackendRenderTarget15setMutableStateERKN5skgpu19MutableTextureStateE"]
    pub fn GrBackendRenderTarget_setMutableState(
        this: *mut GrBackendRenderTarget,
        arg1: *const skgpu_MutableTextureState,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK21GrBackendRenderTarget11isProtectedEv"]
    pub fn GrBackendRenderTarget_isProtected(this: *const GrBackendRenderTarget) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK21GrBackendRenderTarget20getGLFramebufferInfoEP19GrGLFramebufferInfo"]
    pub fn GrBackendRenderTarget_getGLFramebufferInfo(
        this: *const GrBackendRenderTarget,
        arg1: *mut GrGLFramebufferInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN21GrBackendRenderTargetC1Ev"]
    pub fn GrBackendRenderTarget_GrBackendRenderTarget(this: *mut GrBackendRenderTarget);
}
extern "C" {
    #[link_name = "\u{1}__ZN21GrBackendRenderTargetC1EiiiiRK22GrMockRenderTargetInfo"]
    pub fn GrBackendRenderTarget_GrBackendRenderTarget1(
        this: *mut GrBackendRenderTarget,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        sampleCnt: ::core::ffi::c_int,
        stencilBits: ::core::ffi::c_int,
        mockInfo: *const GrMockRenderTargetInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN21GrBackendRenderTargetC1ERKS_"]
    pub fn GrBackendRenderTarget_GrBackendRenderTarget2(
        this: *mut GrBackendRenderTarget,
        that: *const GrBackendRenderTarget,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN21GrBackendRenderTargetC1EiiiiRK19GrGLFramebufferInfo"]
    pub fn GrBackendRenderTarget_GrBackendRenderTarget3(
        this: *mut GrBackendRenderTarget,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        sampleCnt: ::core::ffi::c_int,
        stencilBits: ::core::ffi::c_int,
        glInfo: *const GrGLFramebufferInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN21GrBackendRenderTargetD1Ev"]
    pub fn GrBackendRenderTarget_GrBackendRenderTarget_destructor(this: *mut GrBackendRenderTarget);
}
impl GrBackendRenderTarget {
    #[inline]
    pub unsafe fn getBackendFormat(&self) -> GrBackendFormat {
        GrBackendRenderTarget_getBackendFormat(self)
    }
    #[inline]
    pub unsafe fn getMockRenderTargetInfo(&self, arg1: *mut GrMockRenderTargetInfo) -> bool {
        GrBackendRenderTarget_getMockRenderTargetInfo(self, arg1)
    }
    #[inline]
    pub unsafe fn setMutableState(&mut self, arg1: *const skgpu_MutableTextureState) {
        GrBackendRenderTarget_setMutableState(self, arg1)
    }
    #[inline]
    pub unsafe fn isProtected(&self) -> bool {
        GrBackendRenderTarget_isProtected(self)
    }
    #[inline]
    pub unsafe fn getGLFramebufferInfo(&self, arg1: *mut GrGLFramebufferInfo) -> bool {
        GrBackendRenderTarget_getGLFramebufferInfo(self, arg1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendRenderTarget_GrBackendRenderTarget(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        sampleCnt: ::core::ffi::c_int,
        stencilBits: ::core::ffi::c_int,
        mockInfo: *const GrMockRenderTargetInfo,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendRenderTarget_GrBackendRenderTarget1(
            __bindgen_tmp.as_mut_ptr(),
            width,
            height,
            sampleCnt,
            stencilBits,
            mockInfo,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(that: *const GrBackendRenderTarget) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendRenderTarget_GrBackendRenderTarget2(__bindgen_tmp.as_mut_ptr(), that);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        sampleCnt: ::core::ffi::c_int,
        stencilBits: ::core::ffi::c_int,
        glInfo: *const GrGLFramebufferInfo,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrBackendRenderTarget_GrBackendRenderTarget3(
            __bindgen_tmp.as_mut_ptr(),
            width,
            height,
            sampleCnt,
            stencilBits,
            glInfo,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        GrBackendRenderTarget_GrBackendRenderTarget_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct GrDriverBugWorkarounds {
    pub add_and_true_to_loop_condition: bool,
    pub disable_blend_equation_advanced: bool,
    pub disable_discard_framebuffer: bool,
    pub disable_dual_source_blending_support: bool,
    pub disable_texture_storage: bool,
    pub disallow_large_instanced_draw: bool,
    pub emulate_abs_int_function: bool,
    pub flush_on_framebuffer_change: bool,
    pub force_update_scissor_state_when_binding_fbo0: bool,
    pub gl_clear_broken: bool,
    pub max_fragment_uniform_vectors_32: bool,
    pub max_msaa_sample_count_4: bool,
    pub pack_parameters_workaround_with_pack_buffer: bool,
    pub remove_pow_with_constant_exponent: bool,
    pub rewrite_do_while_loops: bool,
    pub unbind_attachments_on_bound_render_fbo_delete: bool,
    pub unfold_short_circuit_as_ternary_operation: bool,
}
#[test]
fn bindgen_test_layout_GrDriverBugWorkarounds() {
    const UNINIT: ::core::mem::MaybeUninit<GrDriverBugWorkarounds> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrDriverBugWorkarounds>(),
        17usize,
        concat!("Size of: ", stringify!(GrDriverBugWorkarounds))
    );
    assert_eq!(
        ::core::mem::align_of::<GrDriverBugWorkarounds>(),
        1usize,
        concat!("Alignment of ", stringify!(GrDriverBugWorkarounds))
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).add_and_true_to_loop_condition) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(add_and_true_to_loop_condition)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).disable_blend_equation_advanced) as usize - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(disable_blend_equation_advanced)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).disable_discard_framebuffer) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(disable_discard_framebuffer)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).disable_dual_source_blending_support) as usize
                - ptr as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(disable_dual_source_blending_support)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disable_texture_storage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(disable_texture_storage)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).disallow_large_instanced_draw) as usize - ptr as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(disallow_large_instanced_draw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).emulate_abs_int_function) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(emulate_abs_int_function)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).flush_on_framebuffer_change) as usize - ptr as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(flush_on_framebuffer_change)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).force_update_scissor_state_when_binding_fbo0) as usize
                - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(force_update_scissor_state_when_binding_fbo0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gl_clear_broken) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(gl_clear_broken)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).max_fragment_uniform_vectors_32) as usize - ptr as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(max_fragment_uniform_vectors_32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_msaa_sample_count_4) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(max_msaa_sample_count_4)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).pack_parameters_workaround_with_pack_buffer) as usize
                - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(pack_parameters_workaround_with_pack_buffer)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).remove_pow_with_constant_exponent) as usize - ptr as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(remove_pow_with_constant_exponent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rewrite_do_while_loops) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(rewrite_do_while_loops)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).unbind_attachments_on_bound_render_fbo_delete) as usize
                - ptr as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(unbind_attachments_on_bound_render_fbo_delete)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).unfold_short_circuit_as_ternary_operation) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDriverBugWorkarounds),
            "::",
            stringify!(unfold_short_circuit_as_ternary_operation)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22GrDriverBugWorkarounds14applyOverridesERKS_"]
    pub fn GrDriverBugWorkarounds_applyOverrides(
        this: *mut GrDriverBugWorkarounds,
        workarounds: *const GrDriverBugWorkarounds,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22GrDriverBugWorkaroundsC1Ev"]
    pub fn GrDriverBugWorkarounds_GrDriverBugWorkarounds(this: *mut GrDriverBugWorkarounds);
}
extern "C" {
    #[link_name = "\u{1}__ZN22GrDriverBugWorkaroundsC1ERKNSt3__16vectorIiNS0_9allocatorIiEEEE"]
    pub fn GrDriverBugWorkarounds_GrDriverBugWorkarounds1(
        this: *mut GrDriverBugWorkarounds,
        workarounds: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22GrDriverBugWorkaroundsD1Ev"]
    pub fn GrDriverBugWorkarounds_GrDriverBugWorkarounds_destructor(
        this: *mut GrDriverBugWorkarounds,
    );
}
impl GrDriverBugWorkarounds {
    #[inline]
    pub unsafe fn applyOverrides(&mut self, workarounds: *const GrDriverBugWorkarounds) {
        GrDriverBugWorkarounds_applyOverrides(self, workarounds)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrDriverBugWorkarounds_GrDriverBugWorkarounds(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(workarounds: *const [u64; 3usize]) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrDriverBugWorkarounds_GrDriverBugWorkarounds1(__bindgen_tmp.as_mut_ptr(), workarounds);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        GrDriverBugWorkarounds_GrDriverBugWorkarounds_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct GrContextOptions {
    pub fSuppressPrints: bool,
    pub fSkipGLErrorChecks: GrContextOptions_Enable,
    pub fMaxTextureSizeOverride: ::core::ffi::c_int,
    pub fBufferMapThreshold: ::core::ffi::c_int,
    pub fExecutor: *mut SkExecutor,
    pub fDoManualMipmapping: bool,
    pub fDisableCoverageCountingPaths: bool,
    pub fDisableDistanceFieldPaths: bool,
    pub fAllowPathMaskCaching: bool,
    pub fDisableGpuYUVConversion: bool,
    pub fGlyphCacheTextureMaximumBytes: usize,
    pub fMinDistanceFieldFontSize: f32,
    pub fGlyphsAsPathsFontSize: f32,
    pub fAllowMultipleGlyphCacheTextures: GrContextOptions_Enable,
    pub fAvoidStencilBuffers: bool,
    pub fUseDrawInsteadOfClear: GrContextOptions_Enable,
    pub fReduceOpsTaskSplitting: GrContextOptions_Enable,
    pub fPreferExternalImagesOverES3: bool,
    pub fDisableDriverCorrectnessWorkarounds: bool,
    pub fRuntimeProgramCacheSize: ::core::ffi::c_int,
    pub fPersistentCache: *mut GrContextOptions_PersistentCache,
    pub fShaderCacheStrategy: GrContextOptions_ShaderCacheStrategy,
    pub fShaderErrorHandler: *mut GrContextOptions_ShaderErrorHandler,
    pub fInternalMultisampleCount: ::core::ffi::c_int,
    pub fMaxCachedVulkanSecondaryCommandBuffers: ::core::ffi::c_int,
    pub fSuppressMipmapSupport: bool,
    pub fDisableTessellationPathRenderer: bool,
    pub fEnableExperimentalHardwareTessellation: bool,
    pub fSupportBilerpFromGlyphAtlas: bool,
    pub fReducedShaderVariations: bool,
    pub fAllowMSAAOnNewIntel: bool,
    pub fAlwaysUseTexStorageWhenAvailable: bool,
    pub fContextDeleteContext: GrDirectContextDestroyedContext,
    pub fContextDeleteProc: GrDirectContextDestroyedProc,
    pub fDriverBugWorkarounds: GrDriverBugWorkarounds,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrContextOptions_Enable {
    No = 0,
    Yes = 1,
    Default = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrContextOptions_ShaderCacheStrategy {
    SkSL = 0,
    BackendSource = 1,
    BackendBinary = 2,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct GrContextOptions_PersistentCache {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_GrContextOptions_PersistentCache() {
    assert_eq!(
        ::core::mem::size_of::<GrContextOptions_PersistentCache>(),
        8usize,
        concat!("Size of: ", stringify!(GrContextOptions_PersistentCache))
    );
    assert_eq!(
        ::core::mem::align_of::<GrContextOptions_PersistentCache>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(GrContextOptions_PersistentCache)
        )
    );
}
pub type GrContextOptions_ShaderErrorHandler = u64;
#[test]
fn bindgen_test_layout_GrContextOptions() {
    const UNINIT: ::core::mem::MaybeUninit<GrContextOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrContextOptions>(),
        152usize,
        concat!("Size of: ", stringify!(GrContextOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<GrContextOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(GrContextOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSuppressPrints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fSuppressPrints)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSkipGLErrorChecks) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fSkipGLErrorChecks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxTextureSizeOverride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fMaxTextureSizeOverride)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBufferMapThreshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fBufferMapThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fExecutor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fExecutor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDoManualMipmapping) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fDoManualMipmapping)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fDisableCoverageCountingPaths) as usize - ptr as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fDisableCoverageCountingPaths)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDisableDistanceFieldPaths) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fDisableDistanceFieldPaths)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAllowPathMaskCaching) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fAllowPathMaskCaching)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDisableGpuYUVConversion) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fDisableGpuYUVConversion)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fGlyphCacheTextureMaximumBytes) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fGlyphCacheTextureMaximumBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMinDistanceFieldFontSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fMinDistanceFieldFontSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGlyphsAsPathsFontSize) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fGlyphsAsPathsFontSize)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fAllowMultipleGlyphCacheTextures) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fAllowMultipleGlyphCacheTextures)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAvoidStencilBuffers) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fAvoidStencilBuffers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUseDrawInsteadOfClear) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fUseDrawInsteadOfClear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fReduceOpsTaskSplitting) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fReduceOpsTaskSplitting)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fPreferExternalImagesOverES3) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fPreferExternalImagesOverES3)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fDisableDriverCorrectnessWorkarounds) as usize
                - ptr as usize
        },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fDisableDriverCorrectnessWorkarounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRuntimeProgramCacheSize) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fRuntimeProgramCacheSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPersistentCache) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fPersistentCache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fShaderCacheStrategy) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fShaderCacheStrategy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fShaderErrorHandler) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fShaderErrorHandler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInternalMultisampleCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fInternalMultisampleCount)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fMaxCachedVulkanSecondaryCommandBuffers) as usize
                - ptr as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fMaxCachedVulkanSecondaryCommandBuffers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSuppressMipmapSupport) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fSuppressMipmapSupport)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fDisableTessellationPathRenderer) as usize - ptr as usize
        },
        105usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fDisableTessellationPathRenderer)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fEnableExperimentalHardwareTessellation) as usize
                - ptr as usize
        },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fEnableExperimentalHardwareTessellation)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fSupportBilerpFromGlyphAtlas) as usize - ptr as usize
        },
        107usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fSupportBilerpFromGlyphAtlas)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fReducedShaderVariations) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fReducedShaderVariations)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAllowMSAAOnNewIntel) as usize - ptr as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fAllowMSAAOnNewIntel)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).fAlwaysUseTexStorageWhenAvailable) as usize - ptr as usize
        },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fAlwaysUseTexStorageWhenAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fContextDeleteContext) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fContextDeleteContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fContextDeleteProc) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fContextDeleteProc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDriverBugWorkarounds) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GrContextOptions),
            "::",
            stringify!(fDriverBugWorkarounds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrDrawingManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrOnFlushCallbackObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrProgramDesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrProgramInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrThreadSafeCache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkArenaAlloc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkJSONWriter {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct GrRecordingContext {
    pub _bindgen_opaque_blob: [u64; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrRecordingContext_Arenas {
    pub fRecordTimeAllocator: *mut SkArenaAlloc,
    pub fRecordTimeSubRunAllocator: *mut sktext_gpu_SubRunAllocator,
}
#[test]
fn bindgen_test_layout_GrRecordingContext_Arenas() {
    const UNINIT: ::core::mem::MaybeUninit<GrRecordingContext_Arenas> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrRecordingContext_Arenas>(),
        16usize,
        concat!("Size of: ", stringify!(GrRecordingContext_Arenas))
    );
    assert_eq!(
        ::core::mem::align_of::<GrRecordingContext_Arenas>(),
        8usize,
        concat!("Alignment of ", stringify!(GrRecordingContext_Arenas))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRecordTimeAllocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrRecordingContext_Arenas),
            "::",
            stringify!(fRecordTimeAllocator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRecordTimeSubRunAllocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrRecordingContext_Arenas),
            "::",
            stringify!(fRecordTimeSubRunAllocator)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext6ArenasC1EP12SkArenaAllocPN6sktext3gpu15SubRunAllocatorE"]
    pub fn GrRecordingContext_Arenas_Arenas(
        this: *mut GrRecordingContext_Arenas,
        arg1: *mut SkArenaAlloc,
        arg2: *mut sktext_gpu_SubRunAllocator,
    );
}
impl GrRecordingContext_Arenas {
    #[inline]
    pub unsafe fn new(arg1: *mut SkArenaAlloc, arg2: *mut sktext_gpu_SubRunAllocator) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrRecordingContext_Arenas_Arenas(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct GrRecordingContext_OwnedArenas {
    pub fDDLRecording: bool,
    pub fRecordTimeAllocator: u64,
    pub fRecordTimeSubRunAllocator: u64,
}
#[test]
fn bindgen_test_layout_GrRecordingContext_OwnedArenas() {
    const UNINIT: ::core::mem::MaybeUninit<GrRecordingContext_OwnedArenas> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrRecordingContext_OwnedArenas>(),
        24usize,
        concat!("Size of: ", stringify!(GrRecordingContext_OwnedArenas))
    );
    assert_eq!(
        ::core::mem::align_of::<GrRecordingContext_OwnedArenas>(),
        8usize,
        concat!("Alignment of ", stringify!(GrRecordingContext_OwnedArenas))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDDLRecording) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrRecordingContext_OwnedArenas),
            "::",
            stringify!(fDDLRecording)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRecordTimeAllocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrRecordingContext_OwnedArenas),
            "::",
            stringify!(fRecordTimeAllocator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRecordTimeSubRunAllocator) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrRecordingContext_OwnedArenas),
            "::",
            stringify!(fRecordTimeSubRunAllocator)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext11OwnedArenas3getEv"]
    pub fn GrRecordingContext_OwnedArenas_get(
        this: *mut GrRecordingContext_OwnedArenas,
    ) -> GrRecordingContext_Arenas;
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext11OwnedArenasC1Eb"]
    pub fn GrRecordingContext_OwnedArenas_OwnedArenas(
        this: *mut GrRecordingContext_OwnedArenas,
        ddlRecording: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext11OwnedArenasD1Ev"]
    pub fn GrRecordingContext_OwnedArenas_OwnedArenas_destructor(
        this: *mut GrRecordingContext_OwnedArenas,
    );
}
impl GrRecordingContext_OwnedArenas {
    #[inline]
    pub unsafe fn get(&mut self) -> GrRecordingContext_Arenas {
        GrRecordingContext_OwnedArenas_get(self)
    }
    #[inline]
    pub unsafe fn new(ddlRecording: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrRecordingContext_OwnedArenas_OwnedArenas(__bindgen_tmp.as_mut_ptr(), ddlRecording);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        GrRecordingContext_OwnedArenas_OwnedArenas_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct GrRecordingContext_ProgramData {
    pub fDesc: u64,
    pub fInfo: *const GrProgramInfo,
}
#[test]
fn bindgen_test_layout_GrRecordingContext_ProgramData() {
    const UNINIT: ::core::mem::MaybeUninit<GrRecordingContext_ProgramData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrRecordingContext_ProgramData>(),
        16usize,
        concat!("Size of: ", stringify!(GrRecordingContext_ProgramData))
    );
    assert_eq!(
        ::core::mem::align_of::<GrRecordingContext_ProgramData>(),
        8usize,
        concat!("Alignment of ", stringify!(GrRecordingContext_ProgramData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDesc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrRecordingContext_ProgramData),
            "::",
            stringify!(fDesc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrRecordingContext_ProgramData),
            "::",
            stringify!(fInfo)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext11ProgramDataC1ENSt3__110unique_ptrIK13GrProgramDescNS1_14default_deleteIS4_EEEEPK13GrProgramInfo"]
    pub fn GrRecordingContext_ProgramData_ProgramData(
        this: *mut GrRecordingContext_ProgramData,
        arg1: u64,
        arg2: *const GrProgramInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext11ProgramDataC1EOS0_"]
    pub fn GrRecordingContext_ProgramData_ProgramData1(
        this: *mut GrRecordingContext_ProgramData,
        arg1: *mut GrRecordingContext_ProgramData,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext11ProgramDataD1Ev"]
    pub fn GrRecordingContext_ProgramData_ProgramData_destructor(
        this: *mut GrRecordingContext_ProgramData,
    );
}
impl GrRecordingContext_ProgramData {
    #[inline]
    pub unsafe fn new(arg1: u64, arg2: *const GrProgramInfo) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrRecordingContext_ProgramData_ProgramData(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *mut GrRecordingContext_ProgramData) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrRecordingContext_ProgramData_ProgramData1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        GrRecordingContext_ProgramData_ProgramData_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrRecordingContext_Stats {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GrRecordingContext_Stats() {
    assert_eq!(
        ::core::mem::size_of::<GrRecordingContext_Stats>(),
        1usize,
        concat!("Size of: ", stringify!(GrRecordingContext_Stats))
    );
    assert_eq!(
        ::core::mem::align_of::<GrRecordingContext_Stats>(),
        1usize,
        concat!("Alignment of ", stringify!(GrRecordingContext_Stats))
    );
}
#[test]
fn bindgen_test_layout_GrRecordingContext() {
    assert_eq!(
        ::core::mem::size_of::<GrRecordingContext>(),
        80usize,
        concat!("Size of: ", stringify!(GrRecordingContext))
    );
    assert_eq!(
        ::core::mem::align_of::<GrRecordingContext>(),
        8usize,
        concat!("Alignment of ", stringify!(GrRecordingContext))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK18GrRecordingContext14maxTextureSizeEv"]
    pub fn GrRecordingContext_maxTextureSize(this: *const GrRecordingContext)
        -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK18GrRecordingContext19maxRenderTargetSizeEv"]
    pub fn GrRecordingContext_maxRenderTargetSize(
        this: *const GrRecordingContext,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK18GrRecordingContext25colorTypeSupportedAsImageE11SkColorType"]
    pub fn GrRecordingContext_colorTypeSupportedAsImage(
        this: *const GrRecordingContext,
        arg1: SkColorType,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK18GrRecordingContext14skCapabilitiesEv"]
    pub fn GrRecordingContext_skCapabilities(
        this: *const GrRecordingContext,
    ) -> sk_sp<SkCapabilities>;
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext14drawingManagerEv"]
    pub fn GrRecordingContext_drawingManager(
        this: *mut GrRecordingContext,
    ) -> *mut GrDrawingManager;
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext21destroyDrawingManagerEv"]
    pub fn GrRecordingContext_destroyDrawingManager(this: *mut GrRecordingContext);
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext12detachArenasEv"]
    pub fn GrRecordingContext_detachArenas(
        this: *mut GrRecordingContext,
    ) -> *mut GrRecordingContext_OwnedArenas;
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext28getTextBlobRedrawCoordinatorEv"]
    pub fn GrRecordingContext_getTextBlobRedrawCoordinator(
        this: *mut GrRecordingContext,
    ) -> *mut sktext_gpu_TextBlobRedrawCoordinator;
}
extern "C" {
    #[link_name = "\u{1}__ZNK18GrRecordingContext28getTextBlobRedrawCoordinatorEv"]
    pub fn GrRecordingContext_getTextBlobRedrawCoordinator1(
        this: *const GrRecordingContext,
    ) -> *const sktext_gpu_TextBlobRedrawCoordinator;
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext15threadSafeCacheEv"]
    pub fn GrRecordingContext_threadSafeCache(
        this: *mut GrRecordingContext,
    ) -> *mut GrThreadSafeCache;
}
extern "C" {
    #[link_name = "\u{1}__ZNK18GrRecordingContext15threadSafeCacheEv"]
    pub fn GrRecordingContext_threadSafeCache1(
        this: *const GrRecordingContext,
    ) -> *const GrThreadSafeCache;
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext24addOnFlushCallbackObjectEP23GrOnFlushCallbackObject"]
    pub fn GrRecordingContext_addOnFlushCallbackObject(
        this: *mut GrRecordingContext,
        arg1: *mut GrOnFlushCallbackObject,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK18GrRecordingContext8dumpJSONEP12SkJSONWriter"]
    pub fn GrRecordingContext_dumpJSON(this: *const GrRecordingContext, arg1: *mut SkJSONWriter);
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContextC1E5sk_spI24GrContextThreadSafeProxyEb"]
    pub fn GrRecordingContext_GrRecordingContext(
        this: *mut GrRecordingContext,
        arg1: sk_sp<GrContextThreadSafeProxy>,
        ddlRecording: bool,
    );
}
impl GrRecordingContext {
    #[inline]
    pub unsafe fn maxTextureSize(&self) -> ::core::ffi::c_int {
        GrRecordingContext_maxTextureSize(self)
    }
    #[inline]
    pub unsafe fn maxRenderTargetSize(&self) -> ::core::ffi::c_int {
        GrRecordingContext_maxRenderTargetSize(self)
    }
    #[inline]
    pub unsafe fn colorTypeSupportedAsImage(&self, arg1: SkColorType) -> bool {
        GrRecordingContext_colorTypeSupportedAsImage(self, arg1)
    }
    #[inline]
    pub unsafe fn skCapabilities(&self) -> sk_sp<SkCapabilities> {
        GrRecordingContext_skCapabilities(self)
    }
    #[inline]
    pub unsafe fn drawingManager(&mut self) -> *mut GrDrawingManager {
        GrRecordingContext_drawingManager(self)
    }
    #[inline]
    pub unsafe fn destroyDrawingManager(&mut self) {
        GrRecordingContext_destroyDrawingManager(self)
    }
    #[inline]
    pub unsafe fn detachArenas(&mut self) -> *mut GrRecordingContext_OwnedArenas {
        GrRecordingContext_detachArenas(self)
    }
    #[inline]
    pub unsafe fn getTextBlobRedrawCoordinator(
        &mut self,
    ) -> *mut sktext_gpu_TextBlobRedrawCoordinator {
        GrRecordingContext_getTextBlobRedrawCoordinator(self)
    }
    #[inline]
    pub unsafe fn getTextBlobRedrawCoordinator1(
        &self,
    ) -> *const sktext_gpu_TextBlobRedrawCoordinator {
        GrRecordingContext_getTextBlobRedrawCoordinator1(self)
    }
    #[inline]
    pub unsafe fn threadSafeCache(&mut self) -> *mut GrThreadSafeCache {
        GrRecordingContext_threadSafeCache(self)
    }
    #[inline]
    pub unsafe fn threadSafeCache1(&self) -> *const GrThreadSafeCache {
        GrRecordingContext_threadSafeCache1(self)
    }
    #[inline]
    pub unsafe fn addOnFlushCallbackObject(&mut self, arg1: *mut GrOnFlushCallbackObject) {
        GrRecordingContext_addOnFlushCallbackObject(self, arg1)
    }
    #[inline]
    pub unsafe fn dumpJSON(&self, arg1: *mut SkJSONWriter) {
        GrRecordingContext_dumpJSON(self, arg1)
    }
    #[inline]
    pub unsafe fn new(arg1: sk_sp<GrContextThreadSafeProxy>, ddlRecording: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrRecordingContext_GrRecordingContext(__bindgen_tmp.as_mut_ptr(), arg1, ddlRecording);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContextD1Ev"]
    pub fn GrRecordingContext_GrRecordingContext_destructor(this: *mut GrRecordingContext);
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext4initEv"]
    pub fn GrRecordingContext_init(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN18GrRecordingContext14abandonContextEv"]
    pub fn GrRecordingContext_abandonContext(this: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrDirectContextPriv {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct GrDirectContext {
    pub _bindgen_opaque_blob: [u64; 22usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrDirectContext_DirectContextID {
    pub fID: u32,
}
#[test]
fn bindgen_test_layout_GrDirectContext_DirectContextID() {
    const UNINIT: ::core::mem::MaybeUninit<GrDirectContext_DirectContextID> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrDirectContext_DirectContextID>(),
        4usize,
        concat!("Size of: ", stringify!(GrDirectContext_DirectContextID))
    );
    assert_eq!(
        ::core::mem::align_of::<GrDirectContext_DirectContextID>(),
        4usize,
        concat!("Alignment of ", stringify!(GrDirectContext_DirectContextID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDirectContext_DirectContextID),
            "::",
            stringify!(fID)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext15DirectContextID4NextEv"]
    pub fn GrDirectContext_DirectContextID_Next() -> GrDirectContext_DirectContextID;
}
impl GrDirectContext_DirectContextID {
    #[inline]
    pub unsafe fn Next() -> GrDirectContext_DirectContextID {
        GrDirectContext_DirectContextID_Next()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct GrDirectContext_DeleteCallbackHelper {
    pub fContext: GrDirectContextDestroyedContext,
    pub fProc: GrDirectContextDestroyedProc,
}
#[test]
fn bindgen_test_layout_GrDirectContext_DeleteCallbackHelper() {
    const UNINIT: ::core::mem::MaybeUninit<GrDirectContext_DeleteCallbackHelper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrDirectContext_DeleteCallbackHelper>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(GrDirectContext_DeleteCallbackHelper)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<GrDirectContext_DeleteCallbackHelper>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(GrDirectContext_DeleteCallbackHelper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDirectContext_DeleteCallbackHelper),
            "::",
            stringify!(fContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fProc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrDirectContext_DeleteCallbackHelper),
            "::",
            stringify!(fProc)
        )
    );
}
#[test]
fn bindgen_test_layout_GrDirectContext() {
    assert_eq!(
        ::core::mem::size_of::<GrDirectContext>(),
        176usize,
        concat!("Size of: ", stringify!(GrDirectContext))
    );
    assert_eq!(
        ::core::mem::align_of::<GrDirectContext>(),
        8usize,
        concat!("Alignment of ", stringify!(GrDirectContext))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext6MakeGLE5sk_spIK13GrGLInterfaceERK16GrContextOptions"]
    pub fn GrDirectContext_MakeGL(
        arg1: sk_sp<GrGLInterface>,
        arg2: *const GrContextOptions,
    ) -> sk_sp<GrDirectContext>;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext6MakeGLE5sk_spIK13GrGLInterfaceE"]
    pub fn GrDirectContext_MakeGL1(arg1: sk_sp<GrGLInterface>) -> sk_sp<GrDirectContext>;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext6MakeGLERK16GrContextOptions"]
    pub fn GrDirectContext_MakeGL2(arg1: *const GrContextOptions) -> sk_sp<GrDirectContext>;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext6MakeGLEv"]
    pub fn GrDirectContext_MakeGL3() -> sk_sp<GrDirectContext>;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext8MakeMockEPK13GrMockOptionsRK16GrContextOptions"]
    pub fn GrDirectContext_MakeMock(
        arg1: *const GrMockOptions,
        arg2: *const GrContextOptions,
    ) -> sk_sp<GrDirectContext>;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext8MakeMockEPK13GrMockOptions"]
    pub fn GrDirectContext_MakeMock1(arg1: *const GrMockOptions) -> sk_sp<GrDirectContext>;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext12resetContextEj"]
    pub fn GrDirectContext_resetContext(this: *mut GrDirectContext, state: u32);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext22resetGLTextureBindingsEv"]
    pub fn GrDirectContext_resetGLTextureBindings(this: *mut GrDirectContext);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext15threadSafeProxyEv"]
    pub fn GrDirectContext_threadSafeProxy(
        this: *mut GrDirectContext,
    ) -> sk_sp<GrContextThreadSafeProxy>;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5oomedEv"]
    pub fn GrDirectContext_oomed(this: *mut GrDirectContext) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext33releaseResourcesAndAbandonContextEv"]
    pub fn GrDirectContext_releaseResourcesAndAbandonContext(this: *mut GrDirectContext);
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrDirectContext22getResourceCacheLimitsEPiPm"]
    pub fn GrDirectContext_getResourceCacheLimits(
        this: *const GrDirectContext,
        maxResources: *mut ::core::ffi::c_int,
        maxResourceBytes: *mut usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrDirectContext21getResourceCacheLimitEv"]
    pub fn GrDirectContext_getResourceCacheLimit(this: *const GrDirectContext) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrDirectContext21getResourceCacheUsageEPiPm"]
    pub fn GrDirectContext_getResourceCacheUsage(
        this: *const GrDirectContext,
        resourceCount: *mut ::core::ffi::c_int,
        resourceBytes: *mut usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrDirectContext30getResourceCachePurgeableBytesEv"]
    pub fn GrDirectContext_getResourceCachePurgeableBytes(this: *const GrDirectContext) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext22setResourceCacheLimitsEim"]
    pub fn GrDirectContext_setResourceCacheLimits(
        this: *mut GrDirectContext,
        maxResources: ::core::ffi::c_int,
        maxResourceBytes: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext21setResourceCacheLimitEm"]
    pub fn GrDirectContext_setResourceCacheLimit(
        this: *mut GrDirectContext,
        maxResourceBytes: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext16freeGpuResourcesEv"]
    pub fn GrDirectContext_freeGpuResources(this: *mut GrDirectContext);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext22performDeferredCleanupENSt3__16chrono8durationIxNS0_5ratioILl1ELl1000EEEEEb"]
    pub fn GrDirectContext_performDeferredCleanup(
        this: *mut GrDirectContext,
        msNotUsed: std_chrono_milliseconds,
        scratchResourcesOnly: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext22purgeUnlockedResourcesEmb"]
    pub fn GrDirectContext_purgeUnlockedResources(
        this: *mut GrDirectContext,
        bytesToPurge: usize,
        preferScratchResources: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext22purgeUnlockedResourcesEb"]
    pub fn GrDirectContext_purgeUnlockedResources1(
        this: *mut GrDirectContext,
        scratchResourcesOnly: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext4waitEiPK18GrBackendSemaphoreb"]
    pub fn GrDirectContext_wait(
        this: *mut GrDirectContext,
        numSemaphores: ::core::ffi::c_int,
        waitSemaphores: *const GrBackendSemaphore,
        deleteSemaphoresAfterWait: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5flushERK11GrFlushInfo"]
    pub fn GrDirectContext_flush(
        this: *mut GrDirectContext,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5flushE5sk_spIK7SkImageERK11GrFlushInfo"]
    pub fn GrDirectContext_flush1(
        this: *mut GrDirectContext,
        image: sk_sp<SkImage>,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5flushE5sk_spIK7SkImageE"]
    pub fn GrDirectContext_flush2(this: *mut GrDirectContext, image: sk_sp<SkImage>);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext14flushAndSubmitE5sk_spIK7SkImageE"]
    pub fn GrDirectContext_flushAndSubmit(this: *mut GrDirectContext, image: sk_sp<SkImage>);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5flushEP9SkSurfaceN10SkSurfaces20BackendSurfaceAccessERK11GrFlushInfo"]
    pub fn GrDirectContext_flush3(
        this: *mut GrDirectContext,
        surface: *mut SkSurface,
        access: SkSurfaces_BackendSurfaceAccess,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5flushE5sk_spI9SkSurfaceEN10SkSurfaces20BackendSurfaceAccessERK11GrFlushInfo"]
    pub fn GrDirectContext_flush4(
        this: *mut GrDirectContext,
        surface: sk_sp<SkSurface>,
        access: SkSurfaces_BackendSurfaceAccess,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5flushEP9SkSurfaceRK11GrFlushInfoPKN5skgpu19MutableTextureStateE"]
    pub fn GrDirectContext_flush5(
        this: *mut GrDirectContext,
        surface: *mut SkSurface,
        info: *const GrFlushInfo,
        newState: *const skgpu_MutableTextureState,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5flushE5sk_spI9SkSurfaceERK11GrFlushInfoPKN5skgpu19MutableTextureStateE"]
    pub fn GrDirectContext_flush6(
        this: *mut GrDirectContext,
        surface: sk_sp<SkSurface>,
        info: *const GrFlushInfo,
        newState: *const skgpu_MutableTextureState,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext14flushAndSubmitEP9SkSurfaceb"]
    pub fn GrDirectContext_flushAndSubmit1(
        this: *mut GrDirectContext,
        surface: *mut SkSurface,
        syncCpu: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext14flushAndSubmitE5sk_spI9SkSurfaceEb"]
    pub fn GrDirectContext_flushAndSubmit2(
        this: *mut GrDirectContext,
        surface: sk_sp<SkSurface>,
        syncCpu: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5flushEP9SkSurface"]
    pub fn GrDirectContext_flush7(this: *mut GrDirectContext, surface: *mut SkSurface);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext5flushE5sk_spI9SkSurfaceE"]
    pub fn GrDirectContext_flush8(this: *mut GrDirectContext, surface: sk_sp<SkSurface>);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext6submitEb"]
    pub fn GrDirectContext_submit(this: *mut GrDirectContext, syncCpu: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext24checkAsyncWorkCompletionEv"]
    pub fn GrDirectContext_checkAsyncWorkCompletion(this: *mut GrDirectContext);
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrDirectContext20dumpMemoryStatisticsEP17SkTraceMemoryDump"]
    pub fn GrDirectContext_dumpMemoryStatistics(
        this: *const GrDirectContext,
        traceMemoryDump: *mut SkTraceMemoryDump,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK15GrDirectContext25supportsDistanceFieldTextEv"]
    pub fn GrDirectContext_supportsDistanceFieldText(this: *const GrDirectContext) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext24storeVkPipelineCacheDataEv"]
    pub fn GrDirectContext_storeVkPipelineCacheData(this: *mut GrDirectContext);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20createBackendTextureEiiRK15GrBackendFormatN5skgpu9MipmappedENS3_10RenderableENS3_9ProtectedENSt3__117basic_string_viewIcNS7_11char_traitsIcEEEE"]
    pub fn GrDirectContext_createBackendTexture(
        this: *mut GrDirectContext,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: *const GrBackendFormat,
        arg2: GrMipmapped,
        arg3: GrRenderable,
        arg4: GrProtected,
        label: std_string_view,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20createBackendTextureEii11SkColorTypeN5skgpu9MipmappedENS1_10RenderableENS1_9ProtectedENSt3__117basic_string_viewIcNS5_11char_traitsIcEEEE"]
    pub fn GrDirectContext_createBackendTexture1(
        this: *mut GrDirectContext,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: SkColorType,
        arg2: GrMipmapped,
        arg3: GrRenderable,
        arg4: GrProtected,
        label: std_string_view,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20createBackendTextureEiiRK15GrBackendFormatRK8SkRGBA4fIL11SkAlphaType3EEN5skgpu9MipmappedENS8_10RenderableENS8_9ProtectedEPFvPvESC_NSt3__117basic_string_viewIcNSF_11char_traitsIcEEEE"]
    pub fn GrDirectContext_createBackendTexture2(
        this: *mut GrDirectContext,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: *const GrBackendFormat,
        color: *const SkColor4f,
        arg2: GrMipmapped,
        arg3: GrRenderable,
        arg4: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20createBackendTextureEii11SkColorTypeRK8SkRGBA4fIL11SkAlphaType3EEN5skgpu9MipmappedENS6_10RenderableENS6_9ProtectedEPFvPvESA_NSt3__117basic_string_viewIcNSD_11char_traitsIcEEEE"]
    pub fn GrDirectContext_createBackendTexture3(
        this: *mut GrDirectContext,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: SkColorType,
        color: *const SkColor4f,
        arg2: GrMipmapped,
        arg3: GrRenderable,
        arg4: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20createBackendTextureEPK8SkPixmapi15GrSurfaceOriginN5skgpu10RenderableENS4_9ProtectedEPFvPvES7_NSt3__117basic_string_viewIcNSA_11char_traitsIcEEEE"]
    pub fn GrDirectContext_createBackendTexture4(
        this: *mut GrDirectContext,
        srcData: *const SkPixmap,
        numLevels: ::core::ffi::c_int,
        arg1: GrSurfaceOrigin,
        arg2: GrRenderable,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20createBackendTextureERK8SkPixmap15GrSurfaceOriginN5skgpu10RenderableENS4_9ProtectedEPFvPvES7_NSt3__117basic_string_viewIcNSA_11char_traitsIcEEEE"]
    pub fn GrDirectContext_createBackendTexture5(
        this: *mut GrDirectContext,
        srcData: *const SkPixmap,
        textureOrigin: GrSurfaceOrigin,
        renderable: GrRenderable,
        isProtected: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20createBackendTextureEPK8SkPixmapiN5skgpu10RenderableENS3_9ProtectedEPFvPvES6_NSt3__117basic_string_viewIcNS9_11char_traitsIcEEEE"]
    pub fn GrDirectContext_createBackendTexture6(
        this: *mut GrDirectContext,
        srcData: *const SkPixmap,
        numLevels: ::core::ffi::c_int,
        renderable: GrRenderable,
        isProtected: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20createBackendTextureERK8SkPixmapN5skgpu10RenderableENS3_9ProtectedEPFvPvES6_NSt3__117basic_string_viewIcNS9_11char_traitsIcEEEE"]
    pub fn GrDirectContext_createBackendTexture7(
        this: *mut GrDirectContext,
        srcData: *const SkPixmap,
        renderable: GrRenderable,
        isProtected: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20updateBackendTextureERK16GrBackendTextureRK8SkRGBA4fIL11SkAlphaType3EEPFvPvES8_"]
    pub fn GrDirectContext_updateBackendTexture(
        this: *mut GrDirectContext,
        arg1: *const GrBackendTexture,
        color: *const SkColor4f,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20updateBackendTextureERK16GrBackendTexture11SkColorTypeRK8SkRGBA4fIL11SkAlphaType3EEPFvPvES9_"]
    pub fn GrDirectContext_updateBackendTexture1(
        this: *mut GrDirectContext,
        arg1: *const GrBackendTexture,
        skColorType: SkColorType,
        color: *const SkColor4f,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20updateBackendTextureERK16GrBackendTexturePK8SkPixmapi15GrSurfaceOriginPFvPvES7_"]
    pub fn GrDirectContext_updateBackendTexture2(
        this: *mut GrDirectContext,
        arg1: *const GrBackendTexture,
        srcData: *const SkPixmap,
        numLevels: ::core::ffi::c_int,
        arg2: GrSurfaceOrigin,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20updateBackendTextureERK16GrBackendTexturePK8SkPixmapiPFvPvES6_"]
    pub fn GrDirectContext_updateBackendTexture3(
        this: *mut GrDirectContext,
        texture: *const GrBackendTexture,
        srcData: *const SkPixmap,
        numLevels: ::core::ffi::c_int,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext30createCompressedBackendTextureEiiRK15GrBackendFormatRK8SkRGBA4fIL11SkAlphaType3EEN5skgpu9MipmappedENS8_9ProtectedEPFvPvESB_"]
    pub fn GrDirectContext_createCompressedBackendTexture(
        this: *mut GrDirectContext,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: *const GrBackendFormat,
        color: *const SkColor4f,
        arg2: GrMipmapped,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext30createCompressedBackendTextureEii24SkTextureCompressionTypeRK8SkRGBA4fIL11SkAlphaType3EEN5skgpu9MipmappedENS6_9ProtectedEPFvPvES9_"]
    pub fn GrDirectContext_createCompressedBackendTexture1(
        this: *mut GrDirectContext,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: SkTextureCompressionType,
        color: *const SkColor4f,
        arg2: GrMipmapped,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext30createCompressedBackendTextureEiiRK15GrBackendFormatPKvmN5skgpu9MipmappedENS5_9ProtectedEPFvPvES8_"]
    pub fn GrDirectContext_createCompressedBackendTexture2(
        this: *mut GrDirectContext,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: *const GrBackendFormat,
        data: *const ::core::ffi::c_void,
        dataSize: usize,
        arg2: GrMipmapped,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext30createCompressedBackendTextureEii24SkTextureCompressionTypePKvmN5skgpu9MipmappedENS3_9ProtectedEPFvPvES6_"]
    pub fn GrDirectContext_createCompressedBackendTexture3(
        this: *mut GrDirectContext,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: SkTextureCompressionType,
        data: *const ::core::ffi::c_void,
        dataSize: usize,
        arg2: GrMipmapped,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> GrBackendTexture;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext30updateCompressedBackendTextureERK16GrBackendTextureRK8SkRGBA4fIL11SkAlphaType3EEPFvPvES8_"]
    pub fn GrDirectContext_updateCompressedBackendTexture(
        this: *mut GrDirectContext,
        arg1: *const GrBackendTexture,
        color: *const SkColor4f,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext30updateCompressedBackendTextureERK16GrBackendTexturePKvmPFvPvES5_"]
    pub fn GrDirectContext_updateCompressedBackendTexture1(
        this: *mut GrDirectContext,
        arg1: *const GrBackendTexture,
        data: *const ::core::ffi::c_void,
        dataSize: usize,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext22setBackendTextureStateERK16GrBackendTextureRKN5skgpu19MutableTextureStateEPS4_PFvPvES8_"]
    pub fn GrDirectContext_setBackendTextureState(
        this: *mut GrDirectContext,
        arg1: *const GrBackendTexture,
        arg2: *const skgpu_MutableTextureState,
        previousState: *mut skgpu_MutableTextureState,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext27setBackendRenderTargetStateERK21GrBackendRenderTargetRKN5skgpu19MutableTextureStateEPS4_PFvPvES8_"]
    pub fn GrDirectContext_setBackendRenderTargetState(
        this: *mut GrDirectContext,
        arg1: *const GrBackendRenderTarget,
        arg2: *const skgpu_MutableTextureState,
        previousState: *mut skgpu_MutableTextureState,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext20deleteBackendTextureERK16GrBackendTexture"]
    pub fn GrDirectContext_deleteBackendTexture(
        this: *mut GrDirectContext,
        arg1: *const GrBackendTexture,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext16precompileShaderERK6SkDataS2_"]
    pub fn GrDirectContext_precompileShader(
        this: *mut GrDirectContext,
        key: *const SkData,
        data: *const SkData,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext22onGetSmallPathAtlasMgrEv"]
    pub fn GrDirectContext_onGetSmallPathAtlasMgr(
        this: *mut GrDirectContext,
    ) -> *mut skgpu_ganesh_SmallPathAtlasMgr;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContextC1E12GrBackendApiRK16GrContextOptions"]
    pub fn GrDirectContext_GrDirectContext(
        this: *mut GrDirectContext,
        backend: GrBackendApi,
        options: *const GrContextOptions,
    );
}
impl GrDirectContext {
    #[inline]
    pub unsafe fn MakeGL(
        arg1: sk_sp<GrGLInterface>,
        arg2: *const GrContextOptions,
    ) -> sk_sp<GrDirectContext> {
        GrDirectContext_MakeGL(arg1, arg2)
    }
    #[inline]
    pub unsafe fn MakeGL1(arg1: sk_sp<GrGLInterface>) -> sk_sp<GrDirectContext> {
        GrDirectContext_MakeGL1(arg1)
    }
    #[inline]
    pub unsafe fn MakeGL2(arg1: *const GrContextOptions) -> sk_sp<GrDirectContext> {
        GrDirectContext_MakeGL2(arg1)
    }
    #[inline]
    pub unsafe fn MakeGL3() -> sk_sp<GrDirectContext> {
        GrDirectContext_MakeGL3()
    }
    #[inline]
    pub unsafe fn MakeMock(
        arg1: *const GrMockOptions,
        arg2: *const GrContextOptions,
    ) -> sk_sp<GrDirectContext> {
        GrDirectContext_MakeMock(arg1, arg2)
    }
    #[inline]
    pub unsafe fn MakeMock1(arg1: *const GrMockOptions) -> sk_sp<GrDirectContext> {
        GrDirectContext_MakeMock1(arg1)
    }
    #[inline]
    pub unsafe fn resetContext(&mut self, state: u32) {
        GrDirectContext_resetContext(self, state)
    }
    #[inline]
    pub unsafe fn resetGLTextureBindings(&mut self) {
        GrDirectContext_resetGLTextureBindings(self)
    }
    #[inline]
    pub unsafe fn threadSafeProxy(&mut self) -> sk_sp<GrContextThreadSafeProxy> {
        GrDirectContext_threadSafeProxy(self)
    }
    #[inline]
    pub unsafe fn oomed(&mut self) -> bool {
        GrDirectContext_oomed(self)
    }
    #[inline]
    pub unsafe fn releaseResourcesAndAbandonContext(&mut self) {
        GrDirectContext_releaseResourcesAndAbandonContext(self)
    }
    #[inline]
    pub unsafe fn getResourceCacheLimits(
        &self,
        maxResources: *mut ::core::ffi::c_int,
        maxResourceBytes: *mut usize,
    ) {
        GrDirectContext_getResourceCacheLimits(self, maxResources, maxResourceBytes)
    }
    #[inline]
    pub unsafe fn getResourceCacheLimit(&self) -> usize {
        GrDirectContext_getResourceCacheLimit(self)
    }
    #[inline]
    pub unsafe fn getResourceCacheUsage(
        &self,
        resourceCount: *mut ::core::ffi::c_int,
        resourceBytes: *mut usize,
    ) {
        GrDirectContext_getResourceCacheUsage(self, resourceCount, resourceBytes)
    }
    #[inline]
    pub unsafe fn getResourceCachePurgeableBytes(&self) -> usize {
        GrDirectContext_getResourceCachePurgeableBytes(self)
    }
    #[inline]
    pub unsafe fn setResourceCacheLimits(
        &mut self,
        maxResources: ::core::ffi::c_int,
        maxResourceBytes: usize,
    ) {
        GrDirectContext_setResourceCacheLimits(self, maxResources, maxResourceBytes)
    }
    #[inline]
    pub unsafe fn setResourceCacheLimit(&mut self, maxResourceBytes: usize) {
        GrDirectContext_setResourceCacheLimit(self, maxResourceBytes)
    }
    #[inline]
    pub unsafe fn freeGpuResources(&mut self) {
        GrDirectContext_freeGpuResources(self)
    }
    #[inline]
    pub unsafe fn performDeferredCleanup(
        &mut self,
        msNotUsed: std_chrono_milliseconds,
        scratchResourcesOnly: bool,
    ) {
        GrDirectContext_performDeferredCleanup(self, msNotUsed, scratchResourcesOnly)
    }
    #[inline]
    pub unsafe fn purgeUnlockedResources(
        &mut self,
        bytesToPurge: usize,
        preferScratchResources: bool,
    ) {
        GrDirectContext_purgeUnlockedResources(self, bytesToPurge, preferScratchResources)
    }
    #[inline]
    pub unsafe fn purgeUnlockedResources1(&mut self, scratchResourcesOnly: bool) {
        GrDirectContext_purgeUnlockedResources1(self, scratchResourcesOnly)
    }
    #[inline]
    pub unsafe fn wait(
        &mut self,
        numSemaphores: ::core::ffi::c_int,
        waitSemaphores: *const GrBackendSemaphore,
        deleteSemaphoresAfterWait: bool,
    ) -> bool {
        GrDirectContext_wait(
            self,
            numSemaphores,
            waitSemaphores,
            deleteSemaphoresAfterWait,
        )
    }
    #[inline]
    pub unsafe fn flush(&mut self, info: *const GrFlushInfo) -> GrSemaphoresSubmitted {
        GrDirectContext_flush(self, info)
    }
    #[inline]
    pub unsafe fn flush1(
        &mut self,
        image: sk_sp<SkImage>,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted {
        GrDirectContext_flush1(self, image, info)
    }
    #[inline]
    pub unsafe fn flush2(&mut self, image: sk_sp<SkImage>) {
        GrDirectContext_flush2(self, image)
    }
    #[inline]
    pub unsafe fn flushAndSubmit(&mut self, image: sk_sp<SkImage>) {
        GrDirectContext_flushAndSubmit(self, image)
    }
    #[inline]
    pub unsafe fn flush3(
        &mut self,
        surface: *mut SkSurface,
        access: SkSurfaces_BackendSurfaceAccess,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted {
        GrDirectContext_flush3(self, surface, access, info)
    }
    #[inline]
    pub unsafe fn flush4(
        &mut self,
        surface: sk_sp<SkSurface>,
        access: SkSurfaces_BackendSurfaceAccess,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted {
        GrDirectContext_flush4(self, surface, access, info)
    }
    #[inline]
    pub unsafe fn flush5(
        &mut self,
        surface: *mut SkSurface,
        info: *const GrFlushInfo,
        newState: *const skgpu_MutableTextureState,
    ) -> GrSemaphoresSubmitted {
        GrDirectContext_flush5(self, surface, info, newState)
    }
    #[inline]
    pub unsafe fn flush6(
        &mut self,
        surface: sk_sp<SkSurface>,
        info: *const GrFlushInfo,
        newState: *const skgpu_MutableTextureState,
    ) -> GrSemaphoresSubmitted {
        GrDirectContext_flush6(self, surface, info, newState)
    }
    #[inline]
    pub unsafe fn flushAndSubmit1(&mut self, surface: *mut SkSurface, syncCpu: bool) {
        GrDirectContext_flushAndSubmit1(self, surface, syncCpu)
    }
    #[inline]
    pub unsafe fn flushAndSubmit2(&mut self, surface: sk_sp<SkSurface>, syncCpu: bool) {
        GrDirectContext_flushAndSubmit2(self, surface, syncCpu)
    }
    #[inline]
    pub unsafe fn flush7(&mut self, surface: *mut SkSurface) {
        GrDirectContext_flush7(self, surface)
    }
    #[inline]
    pub unsafe fn flush8(&mut self, surface: sk_sp<SkSurface>) {
        GrDirectContext_flush8(self, surface)
    }
    #[inline]
    pub unsafe fn submit(&mut self, syncCpu: bool) -> bool {
        GrDirectContext_submit(self, syncCpu)
    }
    #[inline]
    pub unsafe fn checkAsyncWorkCompletion(&mut self) {
        GrDirectContext_checkAsyncWorkCompletion(self)
    }
    #[inline]
    pub unsafe fn dumpMemoryStatistics(&self, traceMemoryDump: *mut SkTraceMemoryDump) {
        GrDirectContext_dumpMemoryStatistics(self, traceMemoryDump)
    }
    #[inline]
    pub unsafe fn supportsDistanceFieldText(&self) -> bool {
        GrDirectContext_supportsDistanceFieldText(self)
    }
    #[inline]
    pub unsafe fn storeVkPipelineCacheData(&mut self) {
        GrDirectContext_storeVkPipelineCacheData(self)
    }
    #[inline]
    pub unsafe fn createBackendTexture(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: *const GrBackendFormat,
        arg2: GrMipmapped,
        arg3: GrRenderable,
        arg4: GrProtected,
        label: std_string_view,
    ) -> GrBackendTexture {
        GrDirectContext_createBackendTexture(self, width, height, arg1, arg2, arg3, arg4, label)
    }
    #[inline]
    pub unsafe fn createBackendTexture1(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: SkColorType,
        arg2: GrMipmapped,
        arg3: GrRenderable,
        arg4: GrProtected,
        label: std_string_view,
    ) -> GrBackendTexture {
        GrDirectContext_createBackendTexture1(self, width, height, arg1, arg2, arg3, arg4, label)
    }
    #[inline]
    pub unsafe fn createBackendTexture2(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: *const GrBackendFormat,
        color: *const SkColor4f,
        arg2: GrMipmapped,
        arg3: GrRenderable,
        arg4: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture {
        GrDirectContext_createBackendTexture2(
            self,
            width,
            height,
            arg1,
            color,
            arg2,
            arg3,
            arg4,
            finishedProc,
            finishedContext,
            label,
        )
    }
    #[inline]
    pub unsafe fn createBackendTexture3(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: SkColorType,
        color: *const SkColor4f,
        arg2: GrMipmapped,
        arg3: GrRenderable,
        arg4: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture {
        GrDirectContext_createBackendTexture3(
            self,
            width,
            height,
            arg1,
            color,
            arg2,
            arg3,
            arg4,
            finishedProc,
            finishedContext,
            label,
        )
    }
    #[inline]
    pub unsafe fn createBackendTexture4(
        &mut self,
        srcData: *const SkPixmap,
        numLevels: ::core::ffi::c_int,
        arg1: GrSurfaceOrigin,
        arg2: GrRenderable,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture {
        GrDirectContext_createBackendTexture4(
            self,
            srcData,
            numLevels,
            arg1,
            arg2,
            arg3,
            finishedProc,
            finishedContext,
            label,
        )
    }
    #[inline]
    pub unsafe fn createBackendTexture5(
        &mut self,
        srcData: *const SkPixmap,
        textureOrigin: GrSurfaceOrigin,
        renderable: GrRenderable,
        isProtected: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture {
        GrDirectContext_createBackendTexture5(
            self,
            srcData,
            textureOrigin,
            renderable,
            isProtected,
            finishedProc,
            finishedContext,
            label,
        )
    }
    #[inline]
    pub unsafe fn createBackendTexture6(
        &mut self,
        srcData: *const SkPixmap,
        numLevels: ::core::ffi::c_int,
        renderable: GrRenderable,
        isProtected: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture {
        GrDirectContext_createBackendTexture6(
            self,
            srcData,
            numLevels,
            renderable,
            isProtected,
            finishedProc,
            finishedContext,
            label,
        )
    }
    #[inline]
    pub unsafe fn createBackendTexture7(
        &mut self,
        srcData: *const SkPixmap,
        renderable: GrRenderable,
        isProtected: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
        label: std_string_view,
    ) -> GrBackendTexture {
        GrDirectContext_createBackendTexture7(
            self,
            srcData,
            renderable,
            isProtected,
            finishedProc,
            finishedContext,
            label,
        )
    }
    #[inline]
    pub unsafe fn updateBackendTexture(
        &mut self,
        arg1: *const GrBackendTexture,
        color: *const SkColor4f,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool {
        GrDirectContext_updateBackendTexture(self, arg1, color, finishedProc, finishedContext)
    }
    #[inline]
    pub unsafe fn updateBackendTexture1(
        &mut self,
        arg1: *const GrBackendTexture,
        skColorType: SkColorType,
        color: *const SkColor4f,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool {
        GrDirectContext_updateBackendTexture1(
            self,
            arg1,
            skColorType,
            color,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn updateBackendTexture2(
        &mut self,
        arg1: *const GrBackendTexture,
        srcData: *const SkPixmap,
        numLevels: ::core::ffi::c_int,
        arg2: GrSurfaceOrigin,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool {
        GrDirectContext_updateBackendTexture2(
            self,
            arg1,
            srcData,
            numLevels,
            arg2,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn updateBackendTexture3(
        &mut self,
        texture: *const GrBackendTexture,
        srcData: *const SkPixmap,
        numLevels: ::core::ffi::c_int,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool {
        GrDirectContext_updateBackendTexture3(
            self,
            texture,
            srcData,
            numLevels,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn createCompressedBackendTexture(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: *const GrBackendFormat,
        color: *const SkColor4f,
        arg2: GrMipmapped,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> GrBackendTexture {
        GrDirectContext_createCompressedBackendTexture(
            self,
            width,
            height,
            arg1,
            color,
            arg2,
            arg3,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn createCompressedBackendTexture1(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: SkTextureCompressionType,
        color: *const SkColor4f,
        arg2: GrMipmapped,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> GrBackendTexture {
        GrDirectContext_createCompressedBackendTexture1(
            self,
            width,
            height,
            arg1,
            color,
            arg2,
            arg3,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn createCompressedBackendTexture2(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: *const GrBackendFormat,
        data: *const ::core::ffi::c_void,
        dataSize: usize,
        arg2: GrMipmapped,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> GrBackendTexture {
        GrDirectContext_createCompressedBackendTexture2(
            self,
            width,
            height,
            arg1,
            data,
            dataSize,
            arg2,
            arg3,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn createCompressedBackendTexture3(
        &mut self,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        arg1: SkTextureCompressionType,
        data: *const ::core::ffi::c_void,
        dataSize: usize,
        arg2: GrMipmapped,
        arg3: GrProtected,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> GrBackendTexture {
        GrDirectContext_createCompressedBackendTexture3(
            self,
            width,
            height,
            arg1,
            data,
            dataSize,
            arg2,
            arg3,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn updateCompressedBackendTexture(
        &mut self,
        arg1: *const GrBackendTexture,
        color: *const SkColor4f,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool {
        GrDirectContext_updateCompressedBackendTexture(
            self,
            arg1,
            color,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn updateCompressedBackendTexture1(
        &mut self,
        arg1: *const GrBackendTexture,
        data: *const ::core::ffi::c_void,
        dataSize: usize,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool {
        GrDirectContext_updateCompressedBackendTexture1(
            self,
            arg1,
            data,
            dataSize,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn setBackendTextureState(
        &mut self,
        arg1: *const GrBackendTexture,
        arg2: *const skgpu_MutableTextureState,
        previousState: *mut skgpu_MutableTextureState,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool {
        GrDirectContext_setBackendTextureState(
            self,
            arg1,
            arg2,
            previousState,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn setBackendRenderTargetState(
        &mut self,
        arg1: *const GrBackendRenderTarget,
        arg2: *const skgpu_MutableTextureState,
        previousState: *mut skgpu_MutableTextureState,
        finishedProc: GrGpuFinishedProc,
        finishedContext: GrGpuFinishedContext,
    ) -> bool {
        GrDirectContext_setBackendRenderTargetState(
            self,
            arg1,
            arg2,
            previousState,
            finishedProc,
            finishedContext,
        )
    }
    #[inline]
    pub unsafe fn deleteBackendTexture(&mut self, arg1: *const GrBackendTexture) {
        GrDirectContext_deleteBackendTexture(self, arg1)
    }
    #[inline]
    pub unsafe fn precompileShader(&mut self, key: *const SkData, data: *const SkData) -> bool {
        GrDirectContext_precompileShader(self, key, data)
    }
    #[inline]
    pub unsafe fn onGetSmallPathAtlasMgr(&mut self) -> *mut skgpu_ganesh_SmallPathAtlasMgr {
        GrDirectContext_onGetSmallPathAtlasMgr(self)
    }
    #[inline]
    pub unsafe fn new(backend: GrBackendApi, options: *const GrContextOptions) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrDirectContext_GrDirectContext(__bindgen_tmp.as_mut_ptr(), backend, options);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContextD1Ev"]
    pub fn GrDirectContext_GrDirectContext_destructor(this: *mut GrDirectContext);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext14abandonContextEv"]
    pub fn GrDirectContext_abandonContext(this: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext9abandonedEv"]
    pub fn GrDirectContext_abandoned(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN15GrDirectContext4initEv"]
    pub fn GrDirectContext_init(this: *mut ::core::ffi::c_void) -> bool;
}
pub type GrGLGetIntegervFn =
    ::core::option::Option<unsafe extern "C" fn(pname: GrGLenum, params: *mut GrGLint)>;
pub type GrGLGetStringFn =
    ::core::option::Option<unsafe extern "C" fn(name: GrGLenum) -> *const GrGLubyte>;
pub type GrGLGetStringiFn = ::core::option::Option<
    unsafe extern "C" fn(name: GrGLenum, index: GrGLuint) -> *const GrGLubyte,
>;
pub type GrEGLQueryStringFn = ::core::option::Option<
    unsafe extern "C" fn(dpy: GrEGLDisplay, name: GrEGLint) -> *const ::core::ffi::c_char,
>;
#[repr(C)]
#[derive(Debug)]
pub struct GrGLExtensions {
    pub fInitialized: bool,
    pub fStrings: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_GrGLExtensions() {
    const UNINIT: ::core::mem::MaybeUninit<GrGLExtensions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrGLExtensions>(),
        24usize,
        concat!("Size of: ", stringify!(GrGLExtensions))
    );
    assert_eq!(
        ::core::mem::align_of::<GrGLExtensions>(),
        8usize,
        concat!("Alignment of ", stringify!(GrGLExtensions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fInitialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLExtensions),
            "::",
            stringify!(fInitialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStrings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLExtensions),
            "::",
            stringify!(fStrings)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14GrGLExtensions4initE12GrGLStandard12GrGLFunctionIFPKhjEES1_IFS3_jjEES1_IFvjPiEES1_IFPKcPviEESD_"]
    pub fn GrGLExtensions_init(
        this: *mut GrGLExtensions,
        standard: GrGLStandard,
        getString: [u64; 5usize],
        getStringi: [u64; 5usize],
        getIntegerv: [u64; 5usize],
        queryString: [u64; 5usize],
        eglDisplay: GrEGLDisplay,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK14GrGLExtensions3hasEPKc"]
    pub fn GrGLExtensions_has(
        this: *const GrGLExtensions,
        arg1: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN14GrGLExtensions6removeEPKc"]
    pub fn GrGLExtensions_remove(
        this: *mut GrGLExtensions,
        arg1: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN14GrGLExtensions3addEPKc"]
    pub fn GrGLExtensions_add(this: *mut GrGLExtensions, arg1: *const ::core::ffi::c_char);
}
extern "C" {
    #[link_name = "\u{1}__ZNK14GrGLExtensions8dumpJSONEP12SkJSONWriter"]
    pub fn GrGLExtensions_dumpJSON(this: *const GrGLExtensions, arg1: *mut SkJSONWriter);
}
extern "C" {
    #[link_name = "\u{1}__ZN14GrGLExtensionsC1ERKS_"]
    pub fn GrGLExtensions_GrGLExtensions(this: *mut GrGLExtensions, arg1: *const GrGLExtensions);
}
impl GrGLExtensions {
    #[inline]
    pub unsafe fn init(
        &mut self,
        standard: GrGLStandard,
        getString: [u64; 5usize],
        getStringi: [u64; 5usize],
        getIntegerv: [u64; 5usize],
        queryString: [u64; 5usize],
        eglDisplay: GrEGLDisplay,
    ) -> bool {
        GrGLExtensions_init(
            self,
            standard,
            getString,
            getStringi,
            getIntegerv,
            queryString,
            eglDisplay,
        )
    }
    #[inline]
    pub unsafe fn has(&self, arg1: *const ::core::ffi::c_char) -> bool {
        GrGLExtensions_has(self, arg1)
    }
    #[inline]
    pub unsafe fn remove(&mut self, arg1: *const ::core::ffi::c_char) -> bool {
        GrGLExtensions_remove(self, arg1)
    }
    #[inline]
    pub unsafe fn add(&mut self, arg1: *const ::core::ffi::c_char) {
        GrGLExtensions_add(self, arg1)
    }
    #[inline]
    pub unsafe fn dumpJSON(&self, arg1: *mut SkJSONWriter) {
        GrGLExtensions_dumpJSON(self, arg1)
    }
    #[inline]
    pub unsafe fn new(arg1: *const GrGLExtensions) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrGLExtensions_GrGLExtensions(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
pub struct GrGLInterface {
    pub _bindgen_opaque_blob: [u64; 1035usize],
}
pub type GrGLInterface_INHERITED = SkRefCnt;
#[repr(C)]
#[derive(Copy, Clone)]
pub union GrGLInterface__bindgen_ty_1 {
    pub fStandard: GrGLStandard,
    pub fBindingsExported: GrGLStandard,
}
#[test]
fn bindgen_test_layout_GrGLInterface__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<GrGLInterface__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrGLInterface__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(GrGLInterface__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GrGLInterface__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GrGLInterface__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStandard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLInterface__bindgen_ty_1),
            "::",
            stringify!(fStandard)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBindingsExported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrGLInterface__bindgen_ty_1),
            "::",
            stringify!(fBindingsExported)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
pub struct GrGLInterface_Functions {
    pub _bindgen_opaque_blob: [u64; 1030usize],
}
#[test]
fn bindgen_test_layout_GrGLInterface_Functions() {
    assert_eq!(
        ::core::mem::size_of::<GrGLInterface_Functions>(),
        8240usize,
        concat!("Size of: ", stringify!(GrGLInterface_Functions))
    );
    assert_eq!(
        ::core::mem::align_of::<GrGLInterface_Functions>(),
        8usize,
        concat!("Alignment of ", stringify!(GrGLInterface_Functions))
    );
}
#[test]
fn bindgen_test_layout_GrGLInterface() {
    assert_eq!(
        ::core::mem::size_of::<GrGLInterface>(),
        8280usize,
        concat!("Size of: ", stringify!(GrGLInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<GrGLInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(GrGLInterface))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK13GrGLInterface8validateEv"]
    pub fn GrGLInterface_validate(this: *const GrGLInterface) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13GrGLInterfaceC1Ev"]
    pub fn GrGLInterface_GrGLInterface(this: *mut GrGLInterface);
}
impl GrGLInterface {
    #[inline]
    pub unsafe fn validate(&self) -> bool {
        GrGLInterface_validate(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrGLInterface_GrGLInterface(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    pub fn C_GrGLTypes(arg1: *mut GrGLSurfaceInfo);
}
extern "C" {
    pub fn C_GrGLTextureInfo_Equals(
        lhs: *const GrGLTextureInfo,
        rhs: *const GrGLTextureInfo,
    ) -> bool;
}
extern "C" {
    pub fn C_GrGLFramebufferInfo_Equals(
        lhs: *const GrGLFramebufferInfo,
        rhs: *const GrGLFramebufferInfo,
    ) -> bool;
}
extern "C" {
    pub fn C_GPU_GL_Types(arg1: *mut GrGLBackendState);
}
extern "C" {
    pub fn C_GrGLFormatFromGLEnum(glFormat: GrGLenum) -> GrGLFormat;
}
extern "C" {
    pub fn C_GrGLFormatToEnum(format: GrGLFormat) -> GrGLenum;
}
extern "C" {
    pub fn C_GrGLExtensions_destruct(self_: *mut GrGLExtensions);
}
extern "C" {
    pub fn C_GrGLExtensions_reset(self_: *mut GrGLExtensions);
}
extern "C" {
    pub fn C_GrGLInterface_MakeNativeInterface() -> *const GrGLInterface;
}
extern "C" {
    pub fn C_GrGLInterface_extensions(self_: *mut GrGLInterface) -> *mut GrGLExtensions;
}
pub type GLGetProcFnVoidPtr = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        name: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_void,
>;
extern "C" {
    pub fn C_GrGLInterface_MakeAssembledInterface(
        ctx: *mut ::core::ffi::c_void,
        get: GLGetProcFnVoidPtr,
    ) -> *const GrGLInterface;
}
extern "C" {
    pub fn C_GrDirectContext_MakeGL(
        interface: *mut GrGLInterface,
        options: *const GrContextOptions,
    ) -> *mut GrDirectContext;
}
extern "C" {
    pub fn C_GrBackendFormat_ConstructGL(
        uninitialized: *mut GrBackendFormat,
        format: GrGLenum,
        target: GrGLenum,
    );
}
extern "C" {
    pub fn C_GrBackendTexture_newGL(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        mipMapped: GrMipMapped,
        glInfo: *const GrGLTextureInfo,
        label: *const ::core::ffi::c_char,
        labelCount: usize,
    ) -> *mut GrBackendTexture;
}
extern "C" {
    pub fn C_GrBackendRenderTarget_ConstructGL(
        uninitialized: *mut GrBackendRenderTarget,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        sampleCnt: ::core::ffi::c_int,
        stencilBits: ::core::ffi::c_int,
        glInfo: *const GrGLFramebufferInfo,
    );
}
extern "C" {
    pub fn C_GrBackendFormats_ConstructGL(
        uninitialized: *mut GrBackendFormat,
        format: GrGLenum,
        target: GrGLenum,
    );
}
extern "C" {
    pub fn C_GrBackendFormats_AsGLFormat(format: *const GrBackendFormat) -> GrGLFormat;
}
extern "C" {
    pub fn C_GrBackendFormats_AsGLFormatEnum(format: *const GrBackendFormat) -> GrGLenum;
}
extern "C" {
    pub fn C_GrBackendTextures_newGL(
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        mipMapped: GrMipMapped,
        glInfo: *const GrGLTextureInfo,
        label: *const ::core::ffi::c_char,
        labelCount: usize,
    ) -> *mut GrBackendTexture;
}
extern "C" {
    pub fn C_GrBackendTextures_GetGLTextureInfo(
        texture: *const GrBackendTexture,
        info: *mut GrGLTextureInfo,
    ) -> bool;
}
extern "C" {
    pub fn C_GrBackendTextures_GLTextureParametersModified(texture: *mut GrBackendTexture);
}
extern "C" {
    pub fn C_GrBackendRenderTargets_ConstructGL(
        uninitialized: *mut GrBackendRenderTarget,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        sampleCnt: ::core::ffi::c_int,
        stencilBits: ::core::ffi::c_int,
        glInfo: *const GrGLFramebufferInfo,
    );
}
extern "C" {
    pub fn C_GrBackendRenderTargets_GetGLFramebufferInfo(
        self_: *const GrBackendRenderTarget,
        info: *mut GrGLFramebufferInfo,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBuffer_T {
    _unused: [u8; 0],
}
pub type VkCommandBuffer = *mut VkCommandBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPass_T {
    _unused: [u8; 0],
}
pub type VkRenderPass = *mut VkRenderPass_T;
impl VkFormat {
    pub const G8B8G8R8_422_UNORM_KHR: VkFormat = VkFormat::G8B8G8R8_422_UNORM;
}
impl VkFormat {
    pub const B8G8R8G8_422_UNORM_KHR: VkFormat = VkFormat::B8G8R8G8_422_UNORM;
}
impl VkFormat {
    pub const G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat = VkFormat::G8_B8_R8_3PLANE_420_UNORM;
}
impl VkFormat {
    pub const G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat = VkFormat::G8_B8R8_2PLANE_420_UNORM;
}
impl VkFormat {
    pub const G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat = VkFormat::G8_B8_R8_3PLANE_422_UNORM;
}
impl VkFormat {
    pub const G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat = VkFormat::G8_B8R8_2PLANE_422_UNORM;
}
impl VkFormat {
    pub const G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat = VkFormat::G8_B8_R8_3PLANE_444_UNORM;
}
impl VkFormat {
    pub const R10X6_UNORM_PACK16_KHR: VkFormat = VkFormat::R10X6_UNORM_PACK16;
}
impl VkFormat {
    pub const R10X6G10X6_UNORM_2PACK16_KHR: VkFormat = VkFormat::R10X6G10X6_UNORM_2PACK16;
}
impl VkFormat {
    pub const R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat =
        VkFormat::R10X6G10X6B10X6A10X6_UNORM_4PACK16;
}
impl VkFormat {
    pub const G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat =
        VkFormat::G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
}
impl VkFormat {
    pub const B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat =
        VkFormat::B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
}
impl VkFormat {
    pub const G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
}
impl VkFormat {
    pub const G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
}
impl VkFormat {
    pub const G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
}
impl VkFormat {
    pub const G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
}
impl VkFormat {
    pub const G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
}
impl VkFormat {
    pub const R12X4_UNORM_PACK16_KHR: VkFormat = VkFormat::R12X4_UNORM_PACK16;
}
impl VkFormat {
    pub const R12X4G12X4_UNORM_2PACK16_KHR: VkFormat = VkFormat::R12X4G12X4_UNORM_2PACK16;
}
impl VkFormat {
    pub const R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat =
        VkFormat::R12X4G12X4B12X4A12X4_UNORM_4PACK16;
}
impl VkFormat {
    pub const G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat =
        VkFormat::G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
}
impl VkFormat {
    pub const B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat =
        VkFormat::B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
}
impl VkFormat {
    pub const G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
}
impl VkFormat {
    pub const G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
}
impl VkFormat {
    pub const G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
}
impl VkFormat {
    pub const G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
}
impl VkFormat {
    pub const G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat =
        VkFormat::G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
}
impl VkFormat {
    pub const G16B16G16R16_422_UNORM_KHR: VkFormat = VkFormat::G16B16G16R16_422_UNORM;
}
impl VkFormat {
    pub const B16G16R16G16_422_UNORM_KHR: VkFormat = VkFormat::B16G16R16G16_422_UNORM;
}
impl VkFormat {
    pub const G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat = VkFormat::G16_B16_R16_3PLANE_420_UNORM;
}
impl VkFormat {
    pub const G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat = VkFormat::G16_B16R16_2PLANE_420_UNORM;
}
impl VkFormat {
    pub const G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat = VkFormat::G16_B16_R16_3PLANE_422_UNORM;
}
impl VkFormat {
    pub const G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat = VkFormat::G16_B16R16_2PLANE_422_UNORM;
}
impl VkFormat {
    pub const G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat = VkFormat::G16_B16_R16_3PLANE_444_UNORM;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VkFormat {
    UNDEFINED = 0,
    R4G4_UNORM_PACK8 = 1,
    R4G4B4A4_UNORM_PACK16 = 2,
    B4G4R4A4_UNORM_PACK16 = 3,
    R5G6B5_UNORM_PACK16 = 4,
    B5G6R5_UNORM_PACK16 = 5,
    R5G5B5A1_UNORM_PACK16 = 6,
    B5G5R5A1_UNORM_PACK16 = 7,
    A1R5G5B5_UNORM_PACK16 = 8,
    R8_UNORM = 9,
    R8_SNORM = 10,
    R8_USCALED = 11,
    R8_SSCALED = 12,
    R8_UINT = 13,
    R8_SINT = 14,
    R8_SRGB = 15,
    R8G8_UNORM = 16,
    R8G8_SNORM = 17,
    R8G8_USCALED = 18,
    R8G8_SSCALED = 19,
    R8G8_UINT = 20,
    R8G8_SINT = 21,
    R8G8_SRGB = 22,
    R8G8B8_UNORM = 23,
    R8G8B8_SNORM = 24,
    R8G8B8_USCALED = 25,
    R8G8B8_SSCALED = 26,
    R8G8B8_UINT = 27,
    R8G8B8_SINT = 28,
    R8G8B8_SRGB = 29,
    B8G8R8_UNORM = 30,
    B8G8R8_SNORM = 31,
    B8G8R8_USCALED = 32,
    B8G8R8_SSCALED = 33,
    B8G8R8_UINT = 34,
    B8G8R8_SINT = 35,
    B8G8R8_SRGB = 36,
    R8G8B8A8_UNORM = 37,
    R8G8B8A8_SNORM = 38,
    R8G8B8A8_USCALED = 39,
    R8G8B8A8_SSCALED = 40,
    R8G8B8A8_UINT = 41,
    R8G8B8A8_SINT = 42,
    R8G8B8A8_SRGB = 43,
    B8G8R8A8_UNORM = 44,
    B8G8R8A8_SNORM = 45,
    B8G8R8A8_USCALED = 46,
    B8G8R8A8_SSCALED = 47,
    B8G8R8A8_UINT = 48,
    B8G8R8A8_SINT = 49,
    B8G8R8A8_SRGB = 50,
    A8B8G8R8_UNORM_PACK32 = 51,
    A8B8G8R8_SNORM_PACK32 = 52,
    A8B8G8R8_USCALED_PACK32 = 53,
    A8B8G8R8_SSCALED_PACK32 = 54,
    A8B8G8R8_UINT_PACK32 = 55,
    A8B8G8R8_SINT_PACK32 = 56,
    A8B8G8R8_SRGB_PACK32 = 57,
    A2R10G10B10_UNORM_PACK32 = 58,
    A2R10G10B10_SNORM_PACK32 = 59,
    A2R10G10B10_USCALED_PACK32 = 60,
    A2R10G10B10_SSCALED_PACK32 = 61,
    A2R10G10B10_UINT_PACK32 = 62,
    A2R10G10B10_SINT_PACK32 = 63,
    A2B10G10R10_UNORM_PACK32 = 64,
    A2B10G10R10_SNORM_PACK32 = 65,
    A2B10G10R10_USCALED_PACK32 = 66,
    A2B10G10R10_SSCALED_PACK32 = 67,
    A2B10G10R10_UINT_PACK32 = 68,
    A2B10G10R10_SINT_PACK32 = 69,
    R16_UNORM = 70,
    R16_SNORM = 71,
    R16_USCALED = 72,
    R16_SSCALED = 73,
    R16_UINT = 74,
    R16_SINT = 75,
    R16_SFLOAT = 76,
    R16G16_UNORM = 77,
    R16G16_SNORM = 78,
    R16G16_USCALED = 79,
    R16G16_SSCALED = 80,
    R16G16_UINT = 81,
    R16G16_SINT = 82,
    R16G16_SFLOAT = 83,
    R16G16B16_UNORM = 84,
    R16G16B16_SNORM = 85,
    R16G16B16_USCALED = 86,
    R16G16B16_SSCALED = 87,
    R16G16B16_UINT = 88,
    R16G16B16_SINT = 89,
    R16G16B16_SFLOAT = 90,
    R16G16B16A16_UNORM = 91,
    R16G16B16A16_SNORM = 92,
    R16G16B16A16_USCALED = 93,
    R16G16B16A16_SSCALED = 94,
    R16G16B16A16_UINT = 95,
    R16G16B16A16_SINT = 96,
    R16G16B16A16_SFLOAT = 97,
    R32_UINT = 98,
    R32_SINT = 99,
    R32_SFLOAT = 100,
    R32G32_UINT = 101,
    R32G32_SINT = 102,
    R32G32_SFLOAT = 103,
    R32G32B32_UINT = 104,
    R32G32B32_SINT = 105,
    R32G32B32_SFLOAT = 106,
    R32G32B32A32_UINT = 107,
    R32G32B32A32_SINT = 108,
    R32G32B32A32_SFLOAT = 109,
    R64_UINT = 110,
    R64_SINT = 111,
    R64_SFLOAT = 112,
    R64G64_UINT = 113,
    R64G64_SINT = 114,
    R64G64_SFLOAT = 115,
    R64G64B64_UINT = 116,
    R64G64B64_SINT = 117,
    R64G64B64_SFLOAT = 118,
    R64G64B64A64_UINT = 119,
    R64G64B64A64_SINT = 120,
    R64G64B64A64_SFLOAT = 121,
    B10G11R11_UFLOAT_PACK32 = 122,
    E5B9G9R9_UFLOAT_PACK32 = 123,
    D16_UNORM = 124,
    X8_D24_UNORM_PACK32 = 125,
    D32_SFLOAT = 126,
    S8_UINT = 127,
    D16_UNORM_S8_UINT = 128,
    D24_UNORM_S8_UINT = 129,
    D32_SFLOAT_S8_UINT = 130,
    BC1_RGB_UNORM_BLOCK = 131,
    BC1_RGB_SRGB_BLOCK = 132,
    BC1_RGBA_UNORM_BLOCK = 133,
    BC1_RGBA_SRGB_BLOCK = 134,
    BC2_UNORM_BLOCK = 135,
    BC2_SRGB_BLOCK = 136,
    BC3_UNORM_BLOCK = 137,
    BC3_SRGB_BLOCK = 138,
    BC4_UNORM_BLOCK = 139,
    BC4_SNORM_BLOCK = 140,
    BC5_UNORM_BLOCK = 141,
    BC5_SNORM_BLOCK = 142,
    BC6H_UFLOAT_BLOCK = 143,
    BC6H_SFLOAT_BLOCK = 144,
    BC7_UNORM_BLOCK = 145,
    BC7_SRGB_BLOCK = 146,
    ETC2_R8G8B8_UNORM_BLOCK = 147,
    ETC2_R8G8B8_SRGB_BLOCK = 148,
    ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    EAC_R11_UNORM_BLOCK = 153,
    EAC_R11_SNORM_BLOCK = 154,
    EAC_R11G11_UNORM_BLOCK = 155,
    EAC_R11G11_SNORM_BLOCK = 156,
    ASTC_4x4_UNORM_BLOCK = 157,
    ASTC_4x4_SRGB_BLOCK = 158,
    ASTC_5x4_UNORM_BLOCK = 159,
    ASTC_5x4_SRGB_BLOCK = 160,
    ASTC_5x5_UNORM_BLOCK = 161,
    ASTC_5x5_SRGB_BLOCK = 162,
    ASTC_6x5_UNORM_BLOCK = 163,
    ASTC_6x5_SRGB_BLOCK = 164,
    ASTC_6x6_UNORM_BLOCK = 165,
    ASTC_6x6_SRGB_BLOCK = 166,
    ASTC_8x5_UNORM_BLOCK = 167,
    ASTC_8x5_SRGB_BLOCK = 168,
    ASTC_8x6_UNORM_BLOCK = 169,
    ASTC_8x6_SRGB_BLOCK = 170,
    ASTC_8x8_UNORM_BLOCK = 171,
    ASTC_8x8_SRGB_BLOCK = 172,
    ASTC_10x5_UNORM_BLOCK = 173,
    ASTC_10x5_SRGB_BLOCK = 174,
    ASTC_10x6_UNORM_BLOCK = 175,
    ASTC_10x6_SRGB_BLOCK = 176,
    ASTC_10x8_UNORM_BLOCK = 177,
    ASTC_10x8_SRGB_BLOCK = 178,
    ASTC_10x10_UNORM_BLOCK = 179,
    ASTC_10x10_SRGB_BLOCK = 180,
    ASTC_12x10_UNORM_BLOCK = 181,
    ASTC_12x10_SRGB_BLOCK = 182,
    ASTC_12x12_UNORM_BLOCK = 183,
    ASTC_12x12_SRGB_BLOCK = 184,
    G8B8G8R8_422_UNORM = 1000156000,
    B8G8R8G8_422_UNORM = 1000156001,
    G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    G8_B8R8_2PLANE_420_UNORM = 1000156003,
    G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    G8_B8R8_2PLANE_422_UNORM = 1000156005,
    G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    R10X6_UNORM_PACK16 = 1000156007,
    R10X6G10X6_UNORM_2PACK16 = 1000156008,
    R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    R12X4_UNORM_PACK16 = 1000156017,
    R12X4G12X4_UNORM_2PACK16 = 1000156018,
    R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    G16B16G16R16_422_UNORM = 1000156027,
    B16G16R16G16_422_UNORM = 1000156028,
    G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    G16_B16R16_2PLANE_420_UNORM = 1000156030,
    G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    G16_B16R16_2PLANE_422_UNORM = 1000156032,
    G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
    ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
    ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
    ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
    ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
    ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
    ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
    ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
    ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
    ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
    ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
    ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
    ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
    ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,
    G8_B8R8_2PLANE_444_UNORM_EXT = 1000330000,
    G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 1000330001,
    G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 1000330002,
    G16_B16R16_2PLANE_444_UNORM_EXT = 1000330003,
    A4R4G4B4_UNORM_PACK16_EXT = 1000340000,
    A4B4G4R4_UNORM_PACK16_EXT = 1000340001,
    MAX_ENUM = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExtent2D {
    pub width: u32,
    pub height: u32,
}
#[test]
fn bindgen_test_layout_VkExtent2D() {
    const UNINIT: ::core::mem::MaybeUninit<VkExtent2D> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VkExtent2D>(),
        8usize,
        concat!("Size of: ", stringify!(VkExtent2D))
    );
    assert_eq!(
        ::core::mem::align_of::<VkExtent2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExtent2D))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent2D),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent2D),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOffset2D {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_VkOffset2D() {
    const UNINIT: ::core::mem::MaybeUninit<VkOffset2D> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VkOffset2D>(),
        8usize,
        concat!("Size of: ", stringify!(VkOffset2D))
    );
    assert_eq!(
        ::core::mem::align_of::<VkOffset2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkOffset2D))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkOffset2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkOffset2D),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRect2D {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkRect2D() {
    const UNINIT: ::core::mem::MaybeUninit<VkRect2D> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VkRect2D>(),
        16usize,
        concat!("Size of: ", stringify!(VkRect2D))
    );
    assert_eq!(
        ::core::mem::align_of::<VkRect2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkRect2D))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRect2D),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRect2D),
            "::",
            stringify!(extent)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
pub struct VkPhysicalDeviceFeatures {
    pub _bindgen_opaque_blob: [u32; 55usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures() {
    assert_eq!(
        ::core::mem::size_of::<VkPhysicalDeviceFeatures>(),
        220usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceFeatures))
    );
    assert_eq!(
        ::core::mem::align_of::<VkPhysicalDeviceFeatures>(),
        4usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceFeatures))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFeatures2 {
    pub _bindgen_opaque_blob: [u64; 30usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures2() {
    assert_eq!(
        ::core::mem::size_of::<VkPhysicalDeviceFeatures2>(),
        240usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceFeatures2))
    );
    assert_eq!(
        ::core::mem::align_of::<VkPhysicalDeviceFeatures2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceFeatures2))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrVkDrawableInfo {
    pub fSecondaryCommandBuffer: VkCommandBuffer,
    pub fColorAttachmentIndex: u32,
    pub fCompatibleRenderPass: VkRenderPass,
    pub fFormat: VkFormat,
    pub fDrawBounds: *mut VkRect2D,
}
#[test]
fn bindgen_test_layout_GrVkDrawableInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GrVkDrawableInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrVkDrawableInfo>(),
        40usize,
        concat!("Size of: ", stringify!(GrVkDrawableInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrVkDrawableInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GrVkDrawableInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSecondaryCommandBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrVkDrawableInfo),
            "::",
            stringify!(fSecondaryCommandBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColorAttachmentIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrVkDrawableInfo),
            "::",
            stringify!(fColorAttachmentIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCompatibleRenderPass) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrVkDrawableInfo),
            "::",
            stringify!(fCompatibleRenderPass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFormat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GrVkDrawableInfo),
            "::",
            stringify!(fFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDrawBounds) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GrVkDrawableInfo),
            "::",
            stringify!(fDrawBounds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendDrawableInfo {
    pub fIsValid: bool,
    pub fBackend: GrBackendApi,
    pub fVkInfo: GrVkDrawableInfo,
}
#[test]
fn bindgen_test_layout_GrBackendDrawableInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GrBackendDrawableInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrBackendDrawableInfo>(),
        48usize,
        concat!("Size of: ", stringify!(GrBackendDrawableInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendDrawableInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GrBackendDrawableInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsValid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendDrawableInfo),
            "::",
            stringify!(fIsValid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBackend) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendDrawableInfo),
            "::",
            stringify!(fBackend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVkInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrBackendDrawableInfo),
            "::",
            stringify!(fVkInfo)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GrBackendSurfaceMutableState {
    pub _base: skgpu_MutableTextureState,
}
#[test]
fn bindgen_test_layout_GrBackendSurfaceMutableState() {
    assert_eq!(
        ::core::mem::size_of::<GrBackendSurfaceMutableState>(),
        12usize,
        concat!("Size of: ", stringify!(GrBackendSurfaceMutableState))
    );
    assert_eq!(
        ::core::mem::align_of::<GrBackendSurfaceMutableState>(),
        4usize,
        concat!("Alignment of ", stringify!(GrBackendSurfaceMutableState))
    );
}
#[repr(C)]
pub struct GrYUVABackendTextureInfo {
    pub fYUVAInfo: SkYUVAInfo,
    pub fPlaneFormats: [GrBackendFormat; 4usize],
    pub fMipmapped: GrMipmapped,
    pub fTextureOrigin: GrSurfaceOrigin,
}
pub const GrYUVABackendTextureInfo_kMaxPlanes: ::core::ffi::c_int = 4;
#[test]
fn bindgen_test_layout_GrYUVABackendTextureInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GrYUVABackendTextureInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrYUVABackendTextureInfo>(),
        168usize,
        concat!("Size of: ", stringify!(GrYUVABackendTextureInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GrYUVABackendTextureInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GrYUVABackendTextureInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fYUVAInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrYUVABackendTextureInfo),
            "::",
            stringify!(fYUVAInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPlaneFormats) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GrYUVABackendTextureInfo),
            "::",
            stringify!(fPlaneFormats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMipmapped) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(GrYUVABackendTextureInfo),
            "::",
            stringify!(fMipmapped)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextureOrigin) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(GrYUVABackendTextureInfo),
            "::",
            stringify!(fTextureOrigin)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK24GrYUVABackendTextureInfo15toYUVALocationsEv"]
    pub fn GrYUVABackendTextureInfo_toYUVALocations(
        this: *const GrYUVABackendTextureInfo,
    ) -> SkYUVAInfo_YUVALocations;
}
extern "C" {
    #[link_name = "\u{1}__ZN24GrYUVABackendTextureInfoC1ERK10SkYUVAInfoPK15GrBackendFormatN5skgpu9MipmappedE15GrSurfaceOrigin"]
    pub fn GrYUVABackendTextureInfo_GrYUVABackendTextureInfo(
        this: *mut GrYUVABackendTextureInfo,
        arg1: *const SkYUVAInfo,
        arg2: *const GrBackendFormat,
        arg3: GrMipmapped,
        arg4: GrSurfaceOrigin,
    );
}
impl GrYUVABackendTextureInfo {
    #[inline]
    pub unsafe fn toYUVALocations(&self) -> SkYUVAInfo_YUVALocations {
        GrYUVABackendTextureInfo_toYUVALocations(self)
    }
    #[inline]
    pub unsafe fn new(
        arg1: *const SkYUVAInfo,
        arg2: *const GrBackendFormat,
        arg3: GrMipmapped,
        arg4: GrSurfaceOrigin,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrYUVABackendTextureInfo_GrYUVABackendTextureInfo(
            __bindgen_tmp.as_mut_ptr(),
            arg1,
            arg2,
            arg3,
            arg4,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct GrYUVABackendTextures {
    pub fYUVAInfo: SkYUVAInfo,
    pub fTextures: [u64; 44usize],
    pub fTextureOrigin: GrSurfaceOrigin,
}
#[test]
fn bindgen_test_layout_GrYUVABackendTextures() {
    const UNINIT: ::core::mem::MaybeUninit<GrYUVABackendTextures> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GrYUVABackendTextures>(),
        392usize,
        concat!("Size of: ", stringify!(GrYUVABackendTextures))
    );
    assert_eq!(
        ::core::mem::align_of::<GrYUVABackendTextures>(),
        8usize,
        concat!("Alignment of ", stringify!(GrYUVABackendTextures))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fYUVAInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrYUVABackendTextures),
            "::",
            stringify!(fYUVAInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextures) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GrYUVABackendTextures),
            "::",
            stringify!(fTextures)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextureOrigin) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(GrYUVABackendTextures),
            "::",
            stringify!(fTextureOrigin)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK21GrYUVABackendTextures15toYUVALocationsEv"]
    pub fn GrYUVABackendTextures_toYUVALocations(
        this: *const GrYUVABackendTextures,
    ) -> SkYUVAInfo_YUVALocations;
}
extern "C" {
    #[link_name = "\u{1}__ZN21GrYUVABackendTexturesC1ERK10SkYUVAInfoPK16GrBackendTexture15GrSurfaceOrigin"]
    pub fn GrYUVABackendTextures_GrYUVABackendTextures(
        this: *mut GrYUVABackendTextures,
        arg1: *const SkYUVAInfo,
        arg2: *const GrBackendTexture,
        textureOrigin: GrSurfaceOrigin,
    );
}
impl GrYUVABackendTextures {
    #[inline]
    pub unsafe fn toYUVALocations(&self) -> SkYUVAInfo_YUVALocations {
        GrYUVABackendTextures_toYUVALocations(self)
    }
    #[inline]
    pub unsafe fn new(
        arg1: *const SkYUVAInfo,
        arg2: *const GrBackendTexture,
        textureOrigin: GrSurfaceOrigin,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        GrYUVABackendTextures_GrYUVABackendTextures(
            __bindgen_tmp.as_mut_ptr(),
            arg1,
            arg2,
            textureOrigin,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    pub fn C_SkSurface_replaceBackendTexture(
        self_: *mut SkSurface,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        contentChangeMode: SkSurface_ContentChangeMode,
    ) -> bool;
}
extern "C" {
    pub fn C_SkImageGenerator_isValid(
        self_: *const SkImageGenerator,
        context: *mut GrRecordingContext,
    ) -> bool;
}
extern "C" {
    pub fn C_GrBackendRenderTarget_Construct(uninitialized: *mut GrBackendRenderTarget);
}
extern "C" {
    pub fn C_GrBackendRenderTarget_CopyConstruct(
        uninitialized: *mut GrBackendRenderTarget,
        renderTarget: *const GrBackendRenderTarget,
    );
}
extern "C" {
    pub fn C_GrBackendRenderTarget_destruct(self_: *mut GrBackendRenderTarget);
}
extern "C" {
    pub fn C_GrBackendRenderTarget_getBackendFormat(
        self_: *const GrBackendRenderTarget,
        uninitialized: *mut GrBackendFormat,
    );
}
extern "C" {
    pub fn C_GrBackendTexture_new() -> *mut GrBackendTexture;
}
extern "C" {
    pub fn C_GrBackendTexture_Clone(texture: *const GrBackendTexture) -> *mut GrBackendTexture;
}
extern "C" {
    pub fn C_GrBackendTexture_delete(self_: *const GrBackendTexture);
}
extern "C" {
    pub fn C_GrBackendTexture_getBackendFormat(
        self_: *const GrBackendTexture,
        format: *mut GrBackendFormat,
    );
}
extern "C" {
    pub fn C_GrBackendFormat_Construct(uninitialized: *mut GrBackendFormat);
}
extern "C" {
    pub fn C_GrBackendFormat_destruct(self_: *mut GrBackendFormat);
}
extern "C" {
    pub fn C_GrBackendFormat_Equals(
        lhs: *const GrBackendFormat,
        rhs: *const GrBackendFormat,
    ) -> bool;
}
extern "C" {
    pub fn C_GrBackendFormat_makeTexture2D(
        self_: *const GrBackendFormat,
        format: *mut GrBackendFormat,
    );
}
extern "C" {
    pub fn C_GrBackendSurfaceMutableState_Construct(
        uninitialized: *mut GrBackendSurfaceMutableState,
    );
}
extern "C" {
    pub fn C_GrBackendSurfaceMutableState_destruct(self_: *mut GrBackendSurfaceMutableState);
}
extern "C" {
    pub fn C_MutableTextureState_Construct(uninitialized: *mut skgpu_MutableTextureState);
}
extern "C" {
    pub fn C_MutableTextureState_CopyConstruct(
        uninitialized: *mut skgpu_MutableTextureState,
        state: *const skgpu_MutableTextureState,
    );
}
extern "C" {
    pub fn C_MutableTextureState_destruct(self_: *mut skgpu_MutableTextureState);
}
extern "C" {
    pub fn C_MutableTextureState_backend(
        self_: *const skgpu_MutableTextureState,
    ) -> skgpu_BackendApi;
}
extern "C" {
    pub fn C_GrRecordingContext_asDirectContext(
        self_: *mut GrRecordingContext,
    ) -> *mut GrDirectContext;
}
extern "C" {
    pub fn C_GrRecordingContext_backend(self_: *const GrRecordingContext) -> GrBackendApi;
}
extern "C" {
    pub fn C_GrRecordingContext_defaultBackendFormat(
        self_: *const GrRecordingContext,
        ct: SkColorType,
        renderable: GrRenderable,
        result: *mut GrBackendFormat,
    );
}
extern "C" {
    pub fn C_GrRecordingContext_compressedBackendFormat(
        self_: *const GrRecordingContext,
        compressionType: SkTextureCompressionType,
        backendFormat: *mut GrBackendFormat,
    );
}
extern "C" {
    pub fn C_GrRecordingContext_abandoned(self_: *mut GrRecordingContext) -> bool;
}
extern "C" {
    pub fn C_GrRecordingContext_maxSurfaceSampleCountForColorType(
        self_: *const GrRecordingContext,
        colorType: SkColorType,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_GrDirectContext_flushAndSubmit(self_: *mut GrDirectContext);
}
extern "C" {
    pub fn C_GrDirectContext_flushImageWithInfo(
        self_: *mut GrDirectContext,
        image: *mut SkImage,
        info: *const GrFlushInfo,
    ) -> GrSemaphoresSubmitted;
}
extern "C" {
    pub fn C_GrDirectContext_flushImage(self_: *mut GrDirectContext, image: *mut SkImage);
}
extern "C" {
    pub fn C_GrDirectContext_flushAndSubmitImage(self_: *mut GrDirectContext, image: *mut SkImage);
}
extern "C" {
    pub fn C_GrDirectContext_compressedBackendFormat(
        self_: *const GrDirectContext,
        compression: SkTextureCompressionType,
        result: *mut GrBackendFormat,
    );
}
extern "C" {
    pub fn C_GrDirectContext_directContextId(
        self_: *const GrDirectContext,
        r: *mut GrDirectContext_DirectContextID,
    );
}
extern "C" {
    pub fn C_GrDirectContext_performDeferredCleanup(
        self_: *mut GrDirectContext,
        msNotUsed: ::core::ffi::c_long,
        scratchResourcesOnly: bool,
    );
}
extern "C" {
    pub fn C_GrContextOptions_Construct(uninitialized: *mut GrContextOptions);
}
extern "C" {
    pub fn C_GrRecordingContext_colorTypeSupportedAsSurface(
        self_: *const GrRecordingContext,
        colorType: SkColorType,
    ) -> bool;
}
extern "C" {
    pub fn C_GrBackendDrawableInfo_Construct(uninitialized: *mut GrBackendDrawableInfo);
}
extern "C" {
    pub fn C_GrBackendDrawableInfo_Construct2(
        uninitialized: *mut GrBackendDrawableInfo,
        info: *const GrVkDrawableInfo,
    );
}
extern "C" {
    pub fn C_GrBackendDrawableInfo_destruct(self_: *mut GrBackendDrawableInfo);
}
extern "C" {
    pub fn C_GrBackendDrawableInfo_isValid(self_: *const GrBackendDrawableInfo) -> bool;
}
extern "C" {
    pub fn C_GrBackendDrawableInfo_backend(self_: *const GrBackendDrawableInfo) -> GrBackendApi;
}
extern "C" {
    pub fn C_GrYUVABackendTextures_construct(
        uninitialized: *mut GrYUVABackendTextures,
        yuvaInfo: *const SkYUVAInfo,
        backend_textures: *const *const GrBackendTexture,
        textureOrigin: GrSurfaceOrigin,
    );
}
extern "C" {
    pub fn C_GrYUVABackendTextureInfo_destruct(self_: *mut GrYUVABackendTextureInfo);
}
extern "C" {
    pub fn C_GrYUVABackendTextureInfo_CopyConstruct(
        uninitialized: *mut GrYUVABackendTextureInfo,
        src: *const GrYUVABackendTextureInfo,
    );
}
extern "C" {
    pub fn C_GrYUVABackendTextureInfo_equals(
        a: *const GrYUVABackendTextureInfo,
        b: *const GrYUVABackendTextureInfo,
    ) -> bool;
}
extern "C" {
    pub fn C_GrYUVABackendTextures_destruct(self_: *mut GrYUVABackendTextures);
}
extern "C" {
    pub fn C_GrYUVABackendTextures_textures(
        self_: *const GrYUVABackendTextures,
    ) -> *const GrBackendTexture;
}
extern "C" {
    pub fn C_SkCanvas_recordingContext(self_: *const SkCanvas) -> *mut GrRecordingContext;
}
extern "C" {
    pub fn C_SkDrawable_snapGpuDrawHandler(
        self_: *mut SkDrawable,
        backendApi: GrBackendApi,
        matrix: *const SkMatrix,
        clipBounds: *const SkIRect,
        bufferInfo: *const SkImageInfo,
    ) -> *mut SkDrawable_GpuDrawHandler;
}
extern "C" {
    pub fn C_SkDrawable_GpuDrawHandler_delete(self_: *mut SkDrawable_GpuDrawHandler);
}
extern "C" {
    pub fn C_SkDrawable_GpuDrawHandler_draw(
        self_: *mut SkDrawable_GpuDrawHandler,
        info: *const GrBackendDrawableInfo,
    );
}
extern "C" {
    pub fn C_SkImages_AdoptTextureFrom(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        colorType: SkColorType,
        alphaType: SkAlphaType,
        colorSpace: *mut SkColorSpace,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_BorrowTextureFrom(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        colorType: SkColorType,
        alphaType: SkAlphaType,
        colorSpace: *mut SkColorSpace,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_CrossContextTextureFromPixmap(
        context: *mut GrDirectContext,
        pixmap: *const SkPixmap,
        buildMips: bool,
        limitToMaxTextureSize: bool,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_TextureFromCompressedTextureData(
        context: *mut GrDirectContext,
        data: *mut SkData,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        type_: SkTextureCompressionType,
        mipMapped: GrMipMapped,
        prot: GrProtected,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_TextureFromImage(
        context: *mut GrDirectContext,
        self_: *const SkImage,
        mipMapped: GrMipMapped,
        budgeted: skgpu_Budgeted,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_TextureFromYUVAPixmaps(
        context: *mut GrRecordingContext,
        pixmaps: *const SkYUVAPixmaps,
        buildMips: GrMipmapped,
        limitToMaxTextureSize: bool,
        imageColorSpace: *mut SkColorSpace,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_TextureFromYUVATextures(
        context: *mut GrRecordingContext,
        yuvaTextures: *const GrYUVABackendTextures,
        imageColorSpace: *mut SkColorSpace,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImages_GetBackendTextureFromImage(
        self_: *const SkImage,
        flushPendingGrContextIO: bool,
        origin: *mut GrSurfaceOrigin,
    ) -> *mut GrBackendTexture;
}
extern "C" {
    pub fn C_SkImages_SubsetTextureFrom(
        context: *mut GrDirectContext,
        image: *const SkImage,
        subset: *const SkIRect,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkSurfaces_RenderTarget(
        context: *mut GrRecordingContext,
        budgeted: skgpu_Budgeted,
        imageInfo: *const SkImageInfo,
        sampleCount: ::core::ffi::c_int,
        surfaceOrigin: GrSurfaceOrigin,
        surfaceProps: *const SkSurfaceProps,
        shouldCreateWithMips: bool,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurfaces_WrapBackendTexture(
        context: *mut GrRecordingContext,
        backendTexture: *const GrBackendTexture,
        origin: GrSurfaceOrigin,
        sampleCnt: ::core::ffi::c_int,
        colorType: SkColorType,
        colorSpace: *mut SkColorSpace,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurfaces_WrapBackendRenderTarget(
        context: *mut GrRecordingContext,
        backendRenderTarget: *const GrBackendRenderTarget,
        origin: GrSurfaceOrigin,
        colorType: SkColorType,
        colorSpace: *mut SkColorSpace,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurfaces_GetBackendTexture(
        surface: *mut SkSurface,
        handleAccess: SkSurface_BackendHandleAccess,
    ) -> *mut GrBackendTexture;
}
extern "C" {
    pub fn C_SkSurfaces_GetBackendRenderTarget(
        surface: *mut SkSurface,
        handleAccess: SkSurface_BackendHandleAccess,
        backendRenderTarget: *mut GrBackendRenderTarget,
    );
}
extern "C" {
    pub fn C_SkSurfaces_ResolveMSAA(surface: *mut SkSurface);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_RunIterator {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkShaper_RunIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_RunIterator>(),
        8usize,
        concat!("Size of: ", stringify!(SkShaper_RunIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_RunIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_RunIterator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_FontRunIterator {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkShaper_FontRunIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_FontRunIterator>(),
        8usize,
        concat!("Size of: ", stringify!(SkShaper_FontRunIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_FontRunIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_FontRunIterator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_BiDiRunIterator {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkShaper_BiDiRunIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_BiDiRunIterator>(),
        8usize,
        concat!("Size of: ", stringify!(SkShaper_BiDiRunIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_BiDiRunIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_BiDiRunIterator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_ScriptRunIterator {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkShaper_ScriptRunIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_ScriptRunIterator>(),
        8usize,
        concat!("Size of: ", stringify!(SkShaper_ScriptRunIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_ScriptRunIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_ScriptRunIterator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_LanguageRunIterator {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkShaper_LanguageRunIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_LanguageRunIterator>(),
        8usize,
        concat!("Size of: ", stringify!(SkShaper_LanguageRunIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_LanguageRunIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_LanguageRunIterator))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_Feature {
    pub tag: SkFourByteTag,
    pub value: u32,
    pub start: usize,
    pub end: usize,
}
#[test]
fn bindgen_test_layout_SkShaper_Feature() {
    const UNINIT: ::core::mem::MaybeUninit<SkShaper_Feature> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkShaper_Feature>(),
        24usize,
        concat!("Size of: ", stringify!(SkShaper_Feature))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_Feature>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_Feature))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_Feature),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_Feature),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_Feature),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_Feature),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_TrivialRunIterator<RunIteratorSubclass> {
    pub _base: RunIteratorSubclass,
    pub fEnd: usize,
    pub fAtEnd: bool,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<RunIteratorSubclass>>,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_TrivialFontRunIterator {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_SkShaper_TrivialFontRunIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_TrivialFontRunIterator>(),
        48usize,
        concat!("Size of: ", stringify!(SkShaper_TrivialFontRunIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_TrivialFontRunIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_TrivialFontRunIterator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_TrivialBiDiRunIterator {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_SkShaper_TrivialBiDiRunIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_TrivialBiDiRunIterator>(),
        24usize,
        concat!("Size of: ", stringify!(SkShaper_TrivialBiDiRunIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_TrivialBiDiRunIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_TrivialBiDiRunIterator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_TrivialScriptRunIterator {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_SkShaper_TrivialScriptRunIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_TrivialScriptRunIterator>(),
        24usize,
        concat!("Size of: ", stringify!(SkShaper_TrivialScriptRunIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_TrivialScriptRunIterator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkShaper_TrivialScriptRunIterator)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_TrivialLanguageRunIterator {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_SkShaper_TrivialLanguageRunIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_TrivialLanguageRunIterator>(),
        32usize,
        concat!("Size of: ", stringify!(SkShaper_TrivialLanguageRunIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_TrivialLanguageRunIterator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkShaper_TrivialLanguageRunIterator)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_RunHandler {
    pub _bindgen_opaque_blob: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_RunHandler_Range {
    pub fBegin: usize,
    pub fSize: usize,
}
#[test]
fn bindgen_test_layout_SkShaper_RunHandler_Range() {
    const UNINIT: ::core::mem::MaybeUninit<SkShaper_RunHandler_Range> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkShaper_RunHandler_Range>(),
        16usize,
        concat!("Size of: ", stringify!(SkShaper_RunHandler_Range))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_RunHandler_Range>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_RunHandler_Range))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBegin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_Range),
            "::",
            stringify!(fBegin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_Range),
            "::",
            stringify!(fSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_RunHandler_RunInfo {
    pub fFont: *const SkFont,
    pub fBidiLevel: u8,
    pub fAdvance: SkVector,
    pub glyphCount: usize,
    pub utf8Range: SkShaper_RunHandler_Range,
}
#[test]
fn bindgen_test_layout_SkShaper_RunHandler_RunInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SkShaper_RunHandler_RunInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkShaper_RunHandler_RunInfo>(),
        48usize,
        concat!("Size of: ", stringify!(SkShaper_RunHandler_RunInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_RunHandler_RunInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_RunHandler_RunInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFont) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_RunInfo),
            "::",
            stringify!(fFont)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBidiLevel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_RunInfo),
            "::",
            stringify!(fBidiLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAdvance) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_RunInfo),
            "::",
            stringify!(fAdvance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).glyphCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_RunInfo),
            "::",
            stringify!(glyphCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).utf8Range) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_RunInfo),
            "::",
            stringify!(utf8Range)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShaper_RunHandler_Buffer {
    pub glyphs: *mut SkGlyphID,
    pub positions: *mut SkPoint,
    pub offsets: *mut SkPoint,
    pub clusters: *mut u32,
    pub point: SkPoint,
}
#[test]
fn bindgen_test_layout_SkShaper_RunHandler_Buffer() {
    const UNINIT: ::core::mem::MaybeUninit<SkShaper_RunHandler_Buffer> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkShaper_RunHandler_Buffer>(),
        40usize,
        concat!("Size of: ", stringify!(SkShaper_RunHandler_Buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_RunHandler_Buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_RunHandler_Buffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).glyphs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_Buffer),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).positions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_Buffer),
            "::",
            stringify!(positions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offsets) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_Buffer),
            "::",
            stringify!(offsets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clusters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_Buffer),
            "::",
            stringify!(clusters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).point) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkShaper_RunHandler_Buffer),
            "::",
            stringify!(point)
        )
    );
}
#[test]
fn bindgen_test_layout_SkShaper_RunHandler() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper_RunHandler>(),
        8usize,
        concat!("Size of: ", stringify!(SkShaper_RunHandler))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper_RunHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper_RunHandler))
    );
}
#[test]
fn bindgen_test_layout_SkShaper() {
    assert_eq!(
        ::core::mem::size_of::<SkShaper>(),
        8usize,
        concat!("Size of: ", stringify!(SkShaper))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShaper>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShaper))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper13MakePrimitiveEv"]
    pub fn SkShaper_MakePrimitive() -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper23MakeShaperDrivenWrapperE5sk_spI9SkFontMgrE"]
    pub fn SkShaper_MakeShaperDrivenWrapper(arg1: sk_sp<SkFontMgr>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper17MakeShapeThenWrapE5sk_spI9SkFontMgrE"]
    pub fn SkShaper_MakeShapeThenWrap(arg1: sk_sp<SkFontMgr>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper26MakeShapeDontWrapOrReorderENSt3__110unique_ptrI9SkUnicodeNS0_14default_deleteIS2_EEEE5sk_spI9SkFontMgrE"]
    pub fn SkShaper_MakeShapeDontWrapOrReorder(unicode: u64, arg1: sk_sp<SkFontMgr>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper18PurgeHarfBuzzCacheEv"]
    pub fn SkShaper_PurgeHarfBuzzCache();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper12MakeCoreTextEv"]
    pub fn SkShaper_MakeCoreText() -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper4MakeE5sk_spI9SkFontMgrE"]
    pub fn SkShaper_Make(arg1: sk_sp<SkFontMgr>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper11PurgeCachesEv"]
    pub fn SkShaper_PurgeCaches();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper22MakeFontMgrRunIteratorEPKcmRK6SkFont5sk_spI9SkFontMgrE"]
    pub fn SkShaper_MakeFontMgrRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        font: *const SkFont,
        fallback: sk_sp<SkFontMgr>,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper22MakeFontMgrRunIteratorEPKcmRK6SkFont5sk_spI9SkFontMgrES1_11SkFontStylePKNS_19LanguageRunIteratorE"]
    pub fn SkShaper_MakeFontMgrRunIterator1(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        font: *const SkFont,
        fallback: sk_sp<SkFontMgr>,
        requestName: *const ::core::ffi::c_char,
        requestStyle: SkFontStyle,
        arg1: *const SkShaper_LanguageRunIterator,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper19MakeBiDiRunIteratorEPKcmh"]
    pub fn SkShaper_MakeBiDiRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        bidiLevel: u8,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper28MakeSkUnicodeBidiRunIteratorEP9SkUnicodePKcmh"]
    pub fn SkShaper_MakeSkUnicodeBidiRunIterator(
        unicode: *mut SkUnicode,
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        bidiLevel: u8,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper22MakeIcuBiDiRunIteratorEPKcmh"]
    pub fn SkShaper_MakeIcuBiDiRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        bidiLevel: u8,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper21MakeScriptRunIteratorEPKcmj"]
    pub fn SkShaper_MakeScriptRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        script: SkFourByteTag,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper32MakeSkUnicodeHbScriptRunIteratorEPKcm"]
    pub fn SkShaper_MakeSkUnicodeHbScriptRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper32MakeSkUnicodeHbScriptRunIteratorEPKcmj"]
    pub fn SkShaper_MakeSkUnicodeHbScriptRunIterator1(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        script: SkFourByteTag,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper26MakeHbIcuScriptRunIteratorEPKcm"]
    pub fn SkShaper_MakeHbIcuScriptRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaper26MakeStdLanguageRunIteratorEPKcm"]
    pub fn SkShaper_MakeStdLanguageRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaperC2Ev"]
    pub fn SkShaper_SkShaper(this: *mut SkShaper);
}
impl SkShaper {
    #[inline]
    pub unsafe fn MakePrimitive() -> u64 {
        SkShaper_MakePrimitive()
    }
    #[inline]
    pub unsafe fn MakeShaperDrivenWrapper(arg1: sk_sp<SkFontMgr>) -> u64 {
        SkShaper_MakeShaperDrivenWrapper(arg1)
    }
    #[inline]
    pub unsafe fn MakeShapeThenWrap(arg1: sk_sp<SkFontMgr>) -> u64 {
        SkShaper_MakeShapeThenWrap(arg1)
    }
    #[inline]
    pub unsafe fn MakeShapeDontWrapOrReorder(unicode: u64, arg1: sk_sp<SkFontMgr>) -> u64 {
        SkShaper_MakeShapeDontWrapOrReorder(unicode, arg1)
    }
    #[inline]
    pub unsafe fn PurgeHarfBuzzCache() {
        SkShaper_PurgeHarfBuzzCache()
    }
    #[inline]
    pub unsafe fn MakeCoreText() -> u64 {
        SkShaper_MakeCoreText()
    }
    #[inline]
    pub unsafe fn Make(arg1: sk_sp<SkFontMgr>) -> u64 {
        SkShaper_Make(arg1)
    }
    #[inline]
    pub unsafe fn PurgeCaches() {
        SkShaper_PurgeCaches()
    }
    #[inline]
    pub unsafe fn MakeFontMgrRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        font: *const SkFont,
        fallback: sk_sp<SkFontMgr>,
    ) -> u64 {
        SkShaper_MakeFontMgrRunIterator(utf8, utf8Bytes, font, fallback)
    }
    #[inline]
    pub unsafe fn MakeFontMgrRunIterator1(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        font: *const SkFont,
        fallback: sk_sp<SkFontMgr>,
        requestName: *const ::core::ffi::c_char,
        requestStyle: SkFontStyle,
        arg1: *const SkShaper_LanguageRunIterator,
    ) -> u64 {
        SkShaper_MakeFontMgrRunIterator1(
            utf8,
            utf8Bytes,
            font,
            fallback,
            requestName,
            requestStyle,
            arg1,
        )
    }
    #[inline]
    pub unsafe fn MakeBiDiRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        bidiLevel: u8,
    ) -> u64 {
        SkShaper_MakeBiDiRunIterator(utf8, utf8Bytes, bidiLevel)
    }
    #[inline]
    pub unsafe fn MakeSkUnicodeBidiRunIterator(
        unicode: *mut SkUnicode,
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        bidiLevel: u8,
    ) -> u64 {
        SkShaper_MakeSkUnicodeBidiRunIterator(unicode, utf8, utf8Bytes, bidiLevel)
    }
    #[inline]
    pub unsafe fn MakeIcuBiDiRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        bidiLevel: u8,
    ) -> u64 {
        SkShaper_MakeIcuBiDiRunIterator(utf8, utf8Bytes, bidiLevel)
    }
    #[inline]
    pub unsafe fn MakeScriptRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        script: SkFourByteTag,
    ) -> u64 {
        SkShaper_MakeScriptRunIterator(utf8, utf8Bytes, script)
    }
    #[inline]
    pub unsafe fn MakeSkUnicodeHbScriptRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
    ) -> u64 {
        SkShaper_MakeSkUnicodeHbScriptRunIterator(utf8, utf8Bytes)
    }
    #[inline]
    pub unsafe fn MakeSkUnicodeHbScriptRunIterator1(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        script: SkFourByteTag,
    ) -> u64 {
        SkShaper_MakeSkUnicodeHbScriptRunIterator1(utf8, utf8Bytes, script)
    }
    #[inline]
    pub unsafe fn MakeHbIcuScriptRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
    ) -> u64 {
        SkShaper_MakeHbIcuScriptRunIterator(utf8, utf8Bytes)
    }
    #[inline]
    pub unsafe fn MakeStdLanguageRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
    ) -> u64 {
        SkShaper_MakeStdLanguageRunIterator(utf8, utf8Bytes)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkShaper_SkShaper(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkShaperD1Ev"]
    pub fn SkShaper_SkShaper_destructor(this: *mut SkShaper);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlobBuilderRunHandler {
    pub _base: SkShaper_RunHandler,
    pub fBuilder: SkTextBlobBuilder,
    pub fUtf8Text: *const ::core::ffi::c_char,
    pub fClusters: *mut u32,
    pub fClusterOffset: ::core::ffi::c_int,
    pub fGlyphCount: ::core::ffi::c_int,
    pub fMaxRunAscent: SkScalar,
    pub fMaxRunDescent: SkScalar,
    pub fMaxRunLeading: SkScalar,
    pub fCurrentPosition: SkPoint,
    pub fOffset: SkPoint,
}
#[test]
fn bindgen_test_layout_SkTextBlobBuilderRunHandler() {
    const UNINIT: ::core::mem::MaybeUninit<SkTextBlobBuilderRunHandler> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkTextBlobBuilderRunHandler>(),
        152usize,
        concat!("Size of: ", stringify!(SkTextBlobBuilderRunHandler))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlobBuilderRunHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlobBuilderRunHandler))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBuilder) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fBuilder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUtf8Text) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fUtf8Text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fClusters) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fClusters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fClusterOffset) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fClusterOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGlyphCount) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fGlyphCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxRunAscent) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fMaxRunAscent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxRunDescent) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fMaxRunDescent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxRunLeading) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fMaxRunLeading)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCurrentPosition) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fCurrentPosition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOffset) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(SkTextBlobBuilderRunHandler),
            "::",
            stringify!(fOffset)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN27SkTextBlobBuilderRunHandler8makeBlobEv"]
    pub fn SkTextBlobBuilderRunHandler_makeBlob(
        this: *mut SkTextBlobBuilderRunHandler,
    ) -> sk_sp<SkTextBlob>;
}
impl SkTextBlobBuilderRunHandler {
    #[inline]
    pub unsafe fn makeBlob(&mut self) -> sk_sp<SkTextBlob> {
        SkTextBlobBuilderRunHandler_makeBlob(self)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN27SkTextBlobBuilderRunHandler9beginLineEv"]
    pub fn SkTextBlobBuilderRunHandler_beginLine(this: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN27SkTextBlobBuilderRunHandler7runInfoERKN8SkShaper10RunHandler7RunInfoE"]
    pub fn SkTextBlobBuilderRunHandler_runInfo(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkShaper_RunHandler_RunInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN27SkTextBlobBuilderRunHandler13commitRunInfoEv"]
    pub fn SkTextBlobBuilderRunHandler_commitRunInfo(this: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN27SkTextBlobBuilderRunHandler9runBufferERKN8SkShaper10RunHandler7RunInfoE"]
    pub fn SkTextBlobBuilderRunHandler_runBuffer(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkShaper_RunHandler_RunInfo,
    ) -> SkShaper_RunHandler_Buffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN27SkTextBlobBuilderRunHandler15commitRunBufferERKN8SkShaper10RunHandler7RunInfoE"]
    pub fn SkTextBlobBuilderRunHandler_commitRunBuffer(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkShaper_RunHandler_RunInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN27SkTextBlobBuilderRunHandler10commitLineEv"]
    pub fn SkTextBlobBuilderRunHandler_commitLine(this: *mut ::core::ffi::c_void);
}
#[repr(C)]
pub struct SkBidiIterator__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkBidiIterator {
    pub vtable_: *const SkBidiIterator__bindgen_vtable,
}
pub type SkBidiIterator_Position = i32;
pub type SkBidiIterator_Level = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBidiIterator_Region {
    pub start: SkBidiIterator_Position,
    pub end: SkBidiIterator_Position,
    pub level: SkBidiIterator_Level,
}
#[test]
fn bindgen_test_layout_SkBidiIterator_Region() {
    const UNINIT: ::core::mem::MaybeUninit<SkBidiIterator_Region> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkBidiIterator_Region>(),
        12usize,
        concat!("Size of: ", stringify!(SkBidiIterator_Region))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBidiIterator_Region>(),
        4usize,
        concat!("Alignment of ", stringify!(SkBidiIterator_Region))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBidiIterator_Region),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBidiIterator_Region),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkBidiIterator_Region),
            "::",
            stringify!(level)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBidiIterator_Direction {
    kLTR = 0,
    kRTL = 1,
}
#[test]
fn bindgen_test_layout_SkBidiIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkBidiIterator>(),
        8usize,
        concat!("Size of: ", stringify!(SkBidiIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBidiIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBidiIterator))
    );
}
#[repr(C)]
pub struct SkBreakIterator__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkBreakIterator {
    pub vtable_: *const SkBreakIterator__bindgen_vtable,
}
pub type SkBreakIterator_Position = i32;
pub type SkBreakIterator_Status = i32;
#[test]
fn bindgen_test_layout_SkBreakIterator() {
    assert_eq!(
        ::core::mem::size_of::<SkBreakIterator>(),
        8usize,
        concat!("Size of: ", stringify!(SkBreakIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBreakIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBreakIterator))
    );
}
pub const SkUnicode_CodeUnitFlags_kNoCodeUnitFlag: SkUnicode_CodeUnitFlags = 0;
pub const SkUnicode_CodeUnitFlags_kPartOfWhiteSpaceBreak: SkUnicode_CodeUnitFlags = 1;
pub const SkUnicode_CodeUnitFlags_kGraphemeStart: SkUnicode_CodeUnitFlags = 2;
pub const SkUnicode_CodeUnitFlags_kSoftLineBreakBefore: SkUnicode_CodeUnitFlags = 4;
pub const SkUnicode_CodeUnitFlags_kHardLineBreakBefore: SkUnicode_CodeUnitFlags = 8;
pub const SkUnicode_CodeUnitFlags_kPartOfIntraWordBreak: SkUnicode_CodeUnitFlags = 16;
pub const SkUnicode_CodeUnitFlags_kControl: SkUnicode_CodeUnitFlags = 32;
pub const SkUnicode_CodeUnitFlags_kTabulation: SkUnicode_CodeUnitFlags = 64;
pub const SkUnicode_CodeUnitFlags_kGlyphClusterStart: SkUnicode_CodeUnitFlags = 128;
pub const SkUnicode_CodeUnitFlags_kIdeographic: SkUnicode_CodeUnitFlags = 256;
pub const SkUnicode_CodeUnitFlags_kEmoji: SkUnicode_CodeUnitFlags = 512;
pub const SkUnicode_CodeUnitFlags_kWordBreak: SkUnicode_CodeUnitFlags = 1024;
pub type SkUnicode_CodeUnitFlags = ::core::ffi::c_uint;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkUnicode_TextDirection {
    LTR = 0,
    RTL = 1,
}
pub type SkUnicode_Position = usize;
pub type SkUnicode_BidiLevel = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkUnicode_BidiRegion {
    pub start: SkUnicode_Position,
    pub end: SkUnicode_Position,
    pub level: SkUnicode_BidiLevel,
}
#[test]
fn bindgen_test_layout_SkUnicode_BidiRegion() {
    const UNINIT: ::core::mem::MaybeUninit<SkUnicode_BidiRegion> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkUnicode_BidiRegion>(),
        24usize,
        concat!("Size of: ", stringify!(SkUnicode_BidiRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<SkUnicode_BidiRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(SkUnicode_BidiRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkUnicode_BidiRegion),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkUnicode_BidiRegion),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkUnicode_BidiRegion),
            "::",
            stringify!(level)
        )
    );
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkUnicode_LineBreakType {
    kSoftLineBreak = 0,
    kHardLineBreak = 100,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkUnicode_BreakType {
    kWords = 0,
    kGraphemes = 1,
    kLines = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkUnicode_LineBreakBefore {
    pub pos: SkUnicode_Position,
    pub breakType: SkUnicode_LineBreakType,
}
#[test]
fn bindgen_test_layout_SkUnicode_LineBreakBefore() {
    const UNINIT: ::core::mem::MaybeUninit<SkUnicode_LineBreakBefore> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkUnicode_LineBreakBefore>(),
        16usize,
        concat!("Size of: ", stringify!(SkUnicode_LineBreakBefore))
    );
    assert_eq!(
        ::core::mem::align_of::<SkUnicode_LineBreakBefore>(),
        8usize,
        concat!("Alignment of ", stringify!(SkUnicode_LineBreakBefore))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkUnicode_LineBreakBefore),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).breakType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkUnicode_LineBreakBefore),
            "::",
            stringify!(breakType)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode17hasTabulationFlagENS_13CodeUnitFlagsE"]
    pub fn SkUnicode_hasTabulationFlag(flags: SkUnicode_CodeUnitFlags) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode20hasHardLineBreakFlagENS_13CodeUnitFlagsE"]
    pub fn SkUnicode_hasHardLineBreakFlag(flags: SkUnicode_CodeUnitFlags) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode20hasSoftLineBreakFlagENS_13CodeUnitFlagsE"]
    pub fn SkUnicode_hasSoftLineBreakFlag(flags: SkUnicode_CodeUnitFlags) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode20hasGraphemeStartFlagENS_13CodeUnitFlagsE"]
    pub fn SkUnicode_hasGraphemeStartFlag(flags: SkUnicode_CodeUnitFlags) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode14hasControlFlagENS_13CodeUnitFlagsE"]
    pub fn SkUnicode_hasControlFlag(flags: SkUnicode_CodeUnitFlags) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode28hasPartOfWhiteSpaceBreakFlagENS_13CodeUnitFlagsE"]
    pub fn SkUnicode_hasPartOfWhiteSpaceBreakFlag(flags: SkUnicode_CodeUnitFlags) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode11extractBidiEPKciNS_13TextDirectionEPNSt3__16vectorINS_10BidiRegionENS3_9allocatorIS5_EEEE"]
    pub fn SkUnicode_extractBidi(
        utf8: *const ::core::ffi::c_char,
        utf8Units: ::core::ffi::c_int,
        dir: SkUnicode_TextDirection,
        bidiRegions: *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode18convertUtf16ToUtf8EPKDsi"]
    pub fn SkUnicode_convertUtf16ToUtf8(
        utf16: *const u16,
        utf16Units: ::core::ffi::c_int,
    ) -> SkString;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode18convertUtf16ToUtf8ERKNSt3__112basic_stringIDsNS0_11char_traitsIDsEENS0_9allocatorIDsEEEE"]
    pub fn SkUnicode_convertUtf16ToUtf81(utf16: *const std_u16string) -> SkString;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode18convertUtf8ToUtf16EPKci"]
    pub fn SkUnicode_convertUtf8ToUtf16(
        utf8: *const ::core::ffi::c_char,
        utf8Units: ::core::ffi::c_int,
    ) -> std_u16string;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode18convertUtf8ToUtf16ERK8SkString"]
    pub fn SkUnicode_convertUtf8ToUtf161(utf8: *const SkString) -> std_u16string;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode4MakeEv"]
    pub fn SkUnicode_Make() -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode19MakeIcuBasedUnicodeEv"]
    pub fn SkUnicode_MakeIcuBasedUnicode() -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode22MakeClientBasedUnicodeE6SkSpanIcENSt3__16vectorImNS2_9allocatorImEEEES6_NS3_INS_15LineBreakBeforeENS4_IS7_EEEE"]
    pub fn SkUnicode_MakeClientBasedUnicode(
        text: SkSpan<::core::ffi::c_char>,
        words: u8,
        graphemeBreaks: u8,
        lineBreaks: u8,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkUnicode27MakeLibgraphemeBasedUnicodeEv"]
    pub fn SkUnicode_MakeLibgraphemeBasedUnicode() -> u64;
}
extern "C" {
    pub fn C_SkShaper_MakePrimitive() -> *mut SkShaper;
}
extern "C" {
    pub fn C_SkShaper_MakeShaperDrivenWrapper(fontMgr: *mut SkFontMgr) -> *mut SkShaper;
}
extern "C" {
    pub fn C_SkShaper_MakeShapeThenWrap(fontMgr: *mut SkFontMgr) -> *mut SkShaper;
}
extern "C" {
    pub fn C_SkShaper_MakeShapeDontWrapOrReorder(fontMgr: *mut SkFontMgr) -> *mut SkShaper;
}
extern "C" {
    pub fn C_SkShaper_MakeCoreText() -> *mut SkShaper;
}
extern "C" {
    pub fn C_SkShaper_Make(fontMgr: *mut SkFontMgr) -> *mut SkShaper;
}
extern "C" {
    pub fn C_SkShaper_delete(self_: *mut SkShaper);
}
extern "C" {
    pub fn C_SkShaper_RunIterator_delete(self_: *mut SkShaper_RunIterator);
}
extern "C" {
    pub fn C_SkShaper_RunIterator_consume(self_: *mut SkShaper_RunIterator);
}
extern "C" {
    pub fn C_SkShaper_RunIterator_endOfCurrentRun(self_: *const SkShaper_RunIterator) -> usize;
}
extern "C" {
    pub fn C_SkShaper_RunIterator_atEnd(self_: *const SkShaper_RunIterator) -> bool;
}
extern "C" {
    pub fn C_SkShaper_FontRunIterator_currentFont(
        self_: *const SkShaper_FontRunIterator,
    ) -> *const SkFont;
}
extern "C" {
    pub fn C_SkShaper_MakeFontMgrRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        font: *const SkFont,
        fallback: *mut SkFontMgr,
    ) -> *mut SkShaper_FontRunIterator;
}
extern "C" {
    pub fn C_SkShaper_TrivialFontRunIterator_new(
        font: *const SkFont,
        utf8Bytes: usize,
    ) -> *mut SkShaper_FontRunIterator;
}
extern "C" {
    pub fn C_SkShaper_BiDiRunIterator_currentLevel(self_: *const SkShaper_BiDiRunIterator) -> u8;
}
extern "C" {
    pub fn C_SkShaper_MakeBidiRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        bidiLevel: u8,
    ) -> *mut SkShaper_BiDiRunIterator;
}
extern "C" {
    pub fn C_SkShaper_MakeIcuBidiRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        bidiLevel: u8,
    ) -> *mut SkShaper_BiDiRunIterator;
}
extern "C" {
    pub fn C_SkShaper_TrivialBidiRunIterator_new(
        bidiLevel: u8,
        utf8Bytes: usize,
    ) -> *mut SkShaper_BiDiRunIterator;
}
extern "C" {
    pub fn C_SkShaper_ScriptRunIterator_currentScript(
        self_: *const SkShaper_ScriptRunIterator,
    ) -> SkFourByteTag;
}
extern "C" {
    pub fn C_SkShaper_MakeScriptRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        script: SkFourByteTag,
    ) -> *mut SkShaper_ScriptRunIterator;
}
extern "C" {
    pub fn C_SkShaper_MakeHbIcuScriptRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
    ) -> *mut SkShaper_ScriptRunIterator;
}
extern "C" {
    pub fn C_SkShaper_TrivialScriptRunIterator_new(
        bidiLevel: u8,
        utf8Bytes: usize,
    ) -> *mut SkShaper_ScriptRunIterator;
}
extern "C" {
    pub fn C_SkShaper_LanguageRunIterator_currentLanguage(
        self_: *const SkShaper_LanguageRunIterator,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn C_SkShaper_MakeStdLanguageRunIterator(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
    ) -> *mut SkShaper_LanguageRunIterator;
}
extern "C" {
    pub fn C_SkShaper_TrivialLanguageRunIterator_new(
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
    ) -> *mut SkShaper_LanguageRunIterator;
}
extern "C" {
    pub fn C_SkShaper_RunHandler_delete(self_: *mut SkShaper_RunHandler);
}
pub type RunHandler_BeginLine = ::core::option::Option<unsafe extern "C" fn(arg1: TraitObject)>;
pub type RunHandler_RunInfo = ::core::option::Option<
    unsafe extern "C" fn(arg1: TraitObject, arg2: *const SkShaper_RunHandler_RunInfo),
>;
pub type RunHandler_CommitRunInfo = ::core::option::Option<unsafe extern "C" fn(arg1: TraitObject)>;
pub type RunHandler_RunBuffer = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: TraitObject,
        arg2: *const SkShaper_RunHandler_RunInfo,
    ) -> SkShaper_RunHandler_Buffer,
>;
pub type RunHandler_CommitRunBuffer = ::core::option::Option<
    unsafe extern "C" fn(arg1: TraitObject, arg2: *const SkShaper_RunHandler_RunInfo),
>;
pub type RunHandler_CommitLine = ::core::option::Option<unsafe extern "C" fn(arg1: TraitObject)>;
#[repr(C)]
#[derive(Debug)]
pub struct RustRunHandler {
    pub _base: SkShaper_RunHandler,
    pub _param: RustRunHandler_Param,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RustRunHandler_Param {
    pub trait_: TraitObject,
    pub beginLine: RunHandler_BeginLine,
    pub runInfo: RunHandler_RunInfo,
    pub commitRunInfo: RunHandler_CommitRunInfo,
    pub runBuffer: RunHandler_RunBuffer,
    pub commitRunBuffer: RunHandler_CommitRunBuffer,
    pub commitLine: RunHandler_CommitLine,
}
#[test]
fn bindgen_test_layout_RustRunHandler_Param() {
    const UNINIT: ::core::mem::MaybeUninit<RustRunHandler_Param> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RustRunHandler_Param>(),
        64usize,
        concat!("Size of: ", stringify!(RustRunHandler_Param))
    );
    assert_eq!(
        ::core::mem::align_of::<RustRunHandler_Param>(),
        8usize,
        concat!("Alignment of ", stringify!(RustRunHandler_Param))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trait_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RustRunHandler_Param),
            "::",
            stringify!(trait_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beginLine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RustRunHandler_Param),
            "::",
            stringify!(beginLine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).runInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RustRunHandler_Param),
            "::",
            stringify!(runInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).commitRunInfo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RustRunHandler_Param),
            "::",
            stringify!(commitRunInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).runBuffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RustRunHandler_Param),
            "::",
            stringify!(runBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).commitRunBuffer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RustRunHandler_Param),
            "::",
            stringify!(commitRunBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).commitLine) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RustRunHandler_Param),
            "::",
            stringify!(commitLine)
        )
    );
}
#[test]
fn bindgen_test_layout_RustRunHandler() {
    const UNINIT: ::core::mem::MaybeUninit<RustRunHandler> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RustRunHandler>(),
        72usize,
        concat!("Size of: ", stringify!(RustRunHandler))
    );
    assert_eq!(
        ::core::mem::align_of::<RustRunHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(RustRunHandler))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._param) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RustRunHandler),
            "::",
            stringify!(_param)
        )
    );
}
extern "C" {
    pub fn C_RustRunHandler_construct(
        uninitialized: *mut RustRunHandler,
        param: *const RustRunHandler_Param,
    );
}
extern "C" {
    pub fn C_SkShaper_shape(
        self_: *const SkShaper,
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        srcFont: *const SkFont,
        leftToRight: bool,
        width: SkScalar,
        runHandler: *mut SkShaper_RunHandler,
    );
}
extern "C" {
    pub fn C_SkShaper_shape2(
        self_: *const SkShaper,
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        fontRunIterator: *mut SkShaper_FontRunIterator,
        bidiRunIterator: *mut SkShaper_BiDiRunIterator,
        scriptRunIterator: *mut SkShaper_ScriptRunIterator,
        languageRunIterator: *mut SkShaper_LanguageRunIterator,
        width: SkScalar,
        runHandler: *mut SkShaper_RunHandler,
    );
}
extern "C" {
    pub fn C_SkShaper_shape3(
        self_: *const SkShaper,
        utf8: *const ::core::ffi::c_char,
        utf8Bytes: usize,
        fontRunIterator: *mut SkShaper_FontRunIterator,
        bidiRunIterator: *mut SkShaper_BiDiRunIterator,
        scriptRunIterator: *mut SkShaper_ScriptRunIterator,
        languageRunIterator: *mut SkShaper_LanguageRunIterator,
        features: *const SkShaper_Feature,
        featuresSize: usize,
        width: SkScalar,
        runHandler: *mut SkShaper_RunHandler,
    );
}
extern "C" {
    pub fn C_SkTextBlobBuilderRunHandler_construct(
        uninitialized: *mut SkTextBlobBuilderRunHandler,
        utf8Text: *const ::core::ffi::c_char,
        offset: *const SkPoint,
    );
}
extern "C" {
    pub fn C_SkTextBlobBuilderRunHandler_makeBlob(
        self_: *mut SkTextBlobBuilderRunHandler,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlobBuilderRunHandler_endPoint(
        self_: *mut SkTextBlobBuilderRunHandler,
    ) -> SkPoint;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_Affinity {
    Upstream = 0,
    Downstream = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_RectHeightStyle {
    kTight = 0,
    kMax = 1,
    kIncludeLineSpacingMiddle = 2,
    kIncludeLineSpacingTop = 3,
    kIncludeLineSpacingBottom = 4,
    kStrut = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_RectWidthStyle {
    kTight = 0,
    kMax = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_TextAlign {
    Left = 0,
    Right = 1,
    Center = 2,
    Justify = 3,
    Start = 4,
    End = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_TextDirection {
    RTL = 0,
    LTR = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_PositionWithAffinity {
    pub position: i32,
    pub affinity: skia_textlayout_Affinity,
}
#[test]
fn bindgen_test_layout_skia_textlayout_PositionWithAffinity() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_PositionWithAffinity> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_PositionWithAffinity>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_PositionWithAffinity)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_PositionWithAffinity>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_PositionWithAffinity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_PositionWithAffinity),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).affinity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_PositionWithAffinity),
            "::",
            stringify!(affinity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_TextBox {
    pub rect: SkRect,
    pub direction: skia_textlayout_TextDirection,
}
#[test]
fn bindgen_test_layout_skia_textlayout_TextBox() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_TextBox> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_TextBox>(),
        20usize,
        concat!("Size of: ", stringify!(skia_textlayout_TextBox))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_TextBox>(),
        4usize,
        concat!("Alignment of ", stringify!(skia_textlayout_TextBox))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextBox),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextBox),
            "::",
            stringify!(direction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_SkRange<T> {
    pub start: T,
    pub end: T,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
pub type skia_textlayout_SkRange_SignedT = std_make_signed_t;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_TextBaseline {
    Alphabetic = 0,
    Ideographic = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_TextHeightBehavior {
    All = 0,
    DisableFirstAscent = 1,
    DisableLastDescent = 2,
    DisableAll = 3,
}
#[repr(C)]
pub struct skia_textlayout_FontArguments {
    pub fCollectionIndex: ::core::ffi::c_int,
    pub fCoordinates: [u64; 3usize],
    pub fPaletteIndex: ::core::ffi::c_int,
    pub fPaletteOverrides: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_skia_textlayout_FontArguments() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_FontArguments> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_FontArguments>(),
        64usize,
        concat!("Size of: ", stringify!(skia_textlayout_FontArguments))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_FontArguments>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_FontArguments))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCollectionIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_FontArguments),
            "::",
            stringify!(fCollectionIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCoordinates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_FontArguments),
            "::",
            stringify!(fCoordinates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPaletteIndex) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_FontArguments),
            "::",
            stringify!(fPaletteIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPaletteOverrides) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_FontArguments),
            "::",
            stringify!(fPaletteOverrides)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout13FontArguments13CloneTypefaceE5sk_spI10SkTypefaceE"]
    pub fn skia_textlayout_FontArguments_CloneTypeface(
        this: *const skia_textlayout_FontArguments,
        typeface: sk_sp<SkTypeface>,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout13FontArgumentsC1ERK15SkFontArguments"]
    pub fn skia_textlayout_FontArguments_FontArguments(
        this: *mut skia_textlayout_FontArguments,
        arg1: *const SkFontArguments,
    );
}
impl skia_textlayout_FontArguments {
    #[inline]
    pub unsafe fn CloneTypeface(&self, typeface: sk_sp<SkTypeface>) -> sk_sp<SkTypeface> {
        skia_textlayout_FontArguments_CloneTypeface(self, typeface)
    }
    #[inline]
    pub unsafe fn new(arg1: *const SkFontArguments) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_FontArguments_FontArguments(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_ParagraphImpl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_ParagraphCacheKey {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_ParagraphCacheValue {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct skia_textlayout_ParagraphCache {
    pub fParagraphMutex: SkMutex,
    pub fChecker: [u64; 4usize],
    pub fLRUCacheMap: [u64; 5usize],
    pub fCacheIsOn: bool,
    pub fLastCachedValue: *mut skia_textlayout_ParagraphCacheValue,
    pub fTotalRequests: ::core::ffi::c_int,
    pub fCacheMisses: ::core::ffi::c_int,
    pub fHashMisses: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_ParagraphCache_Entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_ParagraphCache_KeyHash {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_skia_textlayout_ParagraphCache_KeyHash() {
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_ParagraphCache_KeyHash>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_ParagraphCache_KeyHash)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_ParagraphCache_KeyHash>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_ParagraphCache_KeyHash)
        )
    );
}
pub const skia_textlayout_ParagraphCache_kMaxEntries: ::core::ffi::c_int = 128;
#[test]
fn bindgen_test_layout_skia_textlayout_ParagraphCache() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_ParagraphCache> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_ParagraphCache>(),
        120usize,
        concat!("Size of: ", stringify!(skia_textlayout_ParagraphCache))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_ParagraphCache>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_ParagraphCache))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fParagraphMutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphCache),
            "::",
            stringify!(fParagraphMutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fChecker) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphCache),
            "::",
            stringify!(fChecker)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLRUCacheMap) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphCache),
            "::",
            stringify!(fLRUCacheMap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCacheIsOn) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphCache),
            "::",
            stringify!(fCacheIsOn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLastCachedValue) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphCache),
            "::",
            stringify!(fLastCachedValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTotalRequests) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphCache),
            "::",
            stringify!(fTotalRequests)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCacheMisses) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphCache),
            "::",
            stringify!(fCacheMisses)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHashMisses) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphCache),
            "::",
            stringify!(fHashMisses)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14ParagraphCache7abandonEv"]
    pub fn skia_textlayout_ParagraphCache_abandon(this: *mut skia_textlayout_ParagraphCache);
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14ParagraphCache5resetEv"]
    pub fn skia_textlayout_ParagraphCache_reset(this: *mut skia_textlayout_ParagraphCache);
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14ParagraphCache15updateParagraphEPNS0_13ParagraphImplE"]
    pub fn skia_textlayout_ParagraphCache_updateParagraph(
        this: *mut skia_textlayout_ParagraphCache,
        paragraph: *mut skia_textlayout_ParagraphImpl,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14ParagraphCache13findParagraphEPNS0_13ParagraphImplE"]
    pub fn skia_textlayout_ParagraphCache_findParagraph(
        this: *mut skia_textlayout_ParagraphCache,
        paragraph: *mut skia_textlayout_ParagraphImpl,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14ParagraphCache15printStatisticsEv"]
    pub fn skia_textlayout_ParagraphCache_printStatistics(
        this: *mut skia_textlayout_ParagraphCache,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14ParagraphCache21isPossiblyTextEditingEPNS0_13ParagraphImplE"]
    pub fn skia_textlayout_ParagraphCache_isPossiblyTextEditing(
        this: *mut skia_textlayout_ParagraphCache,
        paragraph: *mut skia_textlayout_ParagraphImpl,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14ParagraphCacheC1Ev"]
    pub fn skia_textlayout_ParagraphCache_ParagraphCache(this: *mut skia_textlayout_ParagraphCache);
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14ParagraphCacheD1Ev"]
    pub fn skia_textlayout_ParagraphCache_ParagraphCache_destructor(
        this: *mut skia_textlayout_ParagraphCache,
    );
}
impl skia_textlayout_ParagraphCache {
    #[inline]
    pub unsafe fn abandon(&mut self) {
        skia_textlayout_ParagraphCache_abandon(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        skia_textlayout_ParagraphCache_reset(self)
    }
    #[inline]
    pub unsafe fn updateParagraph(
        &mut self,
        paragraph: *mut skia_textlayout_ParagraphImpl,
    ) -> bool {
        skia_textlayout_ParagraphCache_updateParagraph(self, paragraph)
    }
    #[inline]
    pub unsafe fn findParagraph(&mut self, paragraph: *mut skia_textlayout_ParagraphImpl) -> bool {
        skia_textlayout_ParagraphCache_findParagraph(self, paragraph)
    }
    #[inline]
    pub unsafe fn printStatistics(&mut self) {
        skia_textlayout_ParagraphCache_printStatistics(self)
    }
    #[inline]
    pub unsafe fn isPossiblyTextEditing(
        &mut self,
        paragraph: *mut skia_textlayout_ParagraphImpl,
    ) -> bool {
        skia_textlayout_ParagraphCache_isPossiblyTextEditing(self, paragraph)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_ParagraphCache_ParagraphCache(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        skia_textlayout_ParagraphCache_ParagraphCache_destructor(self)
    }
}
#[repr(C)]
pub struct skia_textlayout_ParagraphPainter__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct skia_textlayout_ParagraphPainter {
    pub vtable_: *const skia_textlayout_ParagraphPainter__bindgen_vtable,
}
pub type skia_textlayout_ParagraphPainter_PaintID = ::core::ffi::c_int;
pub type skia_textlayout_ParagraphPainter_SkPaintOrID = [u64; 11usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_ParagraphPainter_DashPathEffect {
    pub fOnLength: SkScalar,
    pub fOffLength: SkScalar,
}
#[test]
fn bindgen_test_layout_skia_textlayout_ParagraphPainter_DashPathEffect() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_ParagraphPainter_DashPathEffect> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_ParagraphPainter_DashPathEffect>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_ParagraphPainter_DashPathEffect)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_ParagraphPainter_DashPathEffect>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_ParagraphPainter_DashPathEffect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOnLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphPainter_DashPathEffect),
            "::",
            stringify!(fOnLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOffLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphPainter_DashPathEffect),
            "::",
            stringify!(fOffLength)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout16ParagraphPainter14DashPathEffectC1Eff"]
    pub fn skia_textlayout_ParagraphPainter_DashPathEffect_DashPathEffect(
        this: *mut skia_textlayout_ParagraphPainter_DashPathEffect,
        onLength: SkScalar,
        offLength: SkScalar,
    );
}
impl skia_textlayout_ParagraphPainter_DashPathEffect {
    #[inline]
    pub unsafe fn new(onLength: SkScalar, offLength: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_ParagraphPainter_DashPathEffect_DashPathEffect(
            __bindgen_tmp.as_mut_ptr(),
            onLength,
            offLength,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct skia_textlayout_ParagraphPainter_DecorationStyle {
    pub fColor: SkColor,
    pub fStrokeWidth: SkScalar,
    pub fDashPathEffect: [u32; 3usize],
    pub fPaint: SkPaint,
}
#[test]
fn bindgen_test_layout_skia_textlayout_ParagraphPainter_DecorationStyle() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_ParagraphPainter_DecorationStyle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_ParagraphPainter_DecorationStyle>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_ParagraphPainter_DecorationStyle)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_ParagraphPainter_DecorationStyle>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_ParagraphPainter_DecorationStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphPainter_DecorationStyle),
            "::",
            stringify!(fColor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStrokeWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphPainter_DecorationStyle),
            "::",
            stringify!(fStrokeWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDashPathEffect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphPainter_DecorationStyle),
            "::",
            stringify!(fDashPathEffect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPaint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphPainter_DecorationStyle),
            "::",
            stringify!(fPaint)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout16ParagraphPainter15DecorationStyleC1Ev"]
    pub fn skia_textlayout_ParagraphPainter_DecorationStyle_DecorationStyle(
        this: *mut skia_textlayout_ParagraphPainter_DecorationStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout16ParagraphPainter15DecorationStyleC1EjfNSt3__18optionalINS1_14DashPathEffectEEE"]
    pub fn skia_textlayout_ParagraphPainter_DecorationStyle_DecorationStyle1(
        this: *mut skia_textlayout_ParagraphPainter_DecorationStyle,
        color: SkColor,
        strokeWidth: SkScalar,
        dashPathEffect: [u32; 3usize],
    );
}
impl skia_textlayout_ParagraphPainter_DecorationStyle {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_ParagraphPainter_DecorationStyle_DecorationStyle(
            __bindgen_tmp.as_mut_ptr(),
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        color: SkColor,
        strokeWidth: SkScalar,
        dashPathEffect: [u32; 3usize],
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_ParagraphPainter_DecorationStyle_DecorationStyle1(
            __bindgen_tmp.as_mut_ptr(),
            color,
            strokeWidth,
            dashPathEffect,
        );
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn bindgen_test_layout_skia_textlayout_ParagraphPainter() {
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_ParagraphPainter>(),
        8usize,
        concat!("Size of: ", stringify!(skia_textlayout_ParagraphPainter))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_ParagraphPainter>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_ParagraphPainter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_TextShadow {
    pub fColor: SkColor,
    pub fOffset: SkPoint,
    pub fBlurSigma: f64,
}
#[test]
fn bindgen_test_layout_skia_textlayout_TextShadow() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_TextShadow> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_TextShadow>(),
        24usize,
        concat!("Size of: ", stringify!(skia_textlayout_TextShadow))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_TextShadow>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_TextShadow))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextShadow),
            "::",
            stringify!(fColor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fOffset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextShadow),
            "::",
            stringify!(fOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBlurSigma) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextShadow),
            "::",
            stringify!(fBlurSigma)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout10TextShadow9hasShadowEv"]
    pub fn skia_textlayout_TextShadow_hasShadow(this: *const skia_textlayout_TextShadow) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout10TextShadowC1Ev"]
    pub fn skia_textlayout_TextShadow_TextShadow(this: *mut skia_textlayout_TextShadow);
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout10TextShadowC1Ej7SkPointd"]
    pub fn skia_textlayout_TextShadow_TextShadow1(
        this: *mut skia_textlayout_TextShadow,
        color: SkColor,
        offset: SkPoint,
        blurSigma: f64,
    );
}
impl skia_textlayout_TextShadow {
    #[inline]
    pub unsafe fn hasShadow(&self) -> bool {
        skia_textlayout_TextShadow_hasShadow(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_TextShadow_TextShadow(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(color: SkColor, offset: SkPoint, blurSigma: f64) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_TextShadow_TextShadow1(
            __bindgen_tmp.as_mut_ptr(),
            color,
            offset,
            blurSigma,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_TextDecoration {
    kNoDecoration = 0,
    kUnderline = 1,
    kOverline = 2,
    kLineThrough = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_TextDecorationStyle {
    Solid = 0,
    Double = 1,
    Dotted = 2,
    Dashed = 3,
    Wavy = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_TextDecorationMode {
    Gaps = 0,
    Through = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_StyleType {
    None = 0,
    AllAttributes = 1,
    Font = 2,
    Foreground = 3,
    Background = 4,
    Shadow = 5,
    Decorations = 6,
    LetterSpacing = 7,
    WordSpacing = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_Decoration {
    pub fType: skia_textlayout_TextDecoration,
    pub fMode: skia_textlayout_TextDecorationMode,
    pub fColor: SkColor,
    pub fStyle: skia_textlayout_TextDecorationStyle,
    pub fThicknessMultiplier: SkScalar,
}
#[test]
fn bindgen_test_layout_skia_textlayout_Decoration() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_Decoration> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_Decoration>(),
        20usize,
        concat!("Size of: ", stringify!(skia_textlayout_Decoration))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_Decoration>(),
        4usize,
        concat!("Alignment of ", stringify!(skia_textlayout_Decoration))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Decoration),
            "::",
            stringify!(fType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Decoration),
            "::",
            stringify!(fMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Decoration),
            "::",
            stringify!(fColor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStyle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Decoration),
            "::",
            stringify!(fStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fThicknessMultiplier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Decoration),
            "::",
            stringify!(fThicknessMultiplier)
        )
    );
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skia_textlayout_PlaceholderAlignment {
    kBaseline = 0,
    kAboveBaseline = 1,
    kBelowBaseline = 2,
    kTop = 3,
    kBottom = 4,
    kMiddle = 5,
}
#[repr(C)]
#[derive(Debug)]
pub struct skia_textlayout_FontFeature {
    pub fName: SkString,
    pub fValue: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_skia_textlayout_FontFeature() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_FontFeature> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_FontFeature>(),
        16usize,
        concat!("Size of: ", stringify!(skia_textlayout_FontFeature))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_FontFeature>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_FontFeature))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_FontFeature),
            "::",
            stringify!(fName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_FontFeature),
            "::",
            stringify!(fValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_PlaceholderStyle {
    pub fWidth: SkScalar,
    pub fHeight: SkScalar,
    pub fAlignment: skia_textlayout_PlaceholderAlignment,
    pub fBaseline: skia_textlayout_TextBaseline,
    pub fBaselineOffset: SkScalar,
}
#[test]
fn bindgen_test_layout_skia_textlayout_PlaceholderStyle() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_PlaceholderStyle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_PlaceholderStyle>(),
        20usize,
        concat!("Size of: ", stringify!(skia_textlayout_PlaceholderStyle))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_PlaceholderStyle>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_PlaceholderStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_PlaceholderStyle),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_PlaceholderStyle),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAlignment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_PlaceholderStyle),
            "::",
            stringify!(fAlignment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBaseline) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_PlaceholderStyle),
            "::",
            stringify!(fBaseline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBaselineOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_PlaceholderStyle),
            "::",
            stringify!(fBaselineOffset)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout16PlaceholderStyle6equalsERKS1_"]
    pub fn skia_textlayout_PlaceholderStyle_equals(
        this: *const skia_textlayout_PlaceholderStyle,
        arg1: *const skia_textlayout_PlaceholderStyle,
    ) -> bool;
}
impl skia_textlayout_PlaceholderStyle {
    #[inline]
    pub unsafe fn equals(&self, arg1: *const skia_textlayout_PlaceholderStyle) -> bool {
        skia_textlayout_PlaceholderStyle_equals(self, arg1)
    }
}
#[repr(C)]
pub struct skia_textlayout_TextStyle {
    pub fDecoration: skia_textlayout_Decoration,
    pub fFontStyle: SkFontStyle,
    pub fFontFamilies: [u64; 3usize],
    pub fFontSize: SkScalar,
    pub fHeight: SkScalar,
    pub fHeightOverride: bool,
    pub fBaselineShift: SkScalar,
    pub fHalfLeading: bool,
    pub fLocale: SkString,
    pub fLetterSpacing: SkScalar,
    pub fWordSpacing: SkScalar,
    pub fTextBaseline: skia_textlayout_TextBaseline,
    pub fColor: SkColor,
    pub fHasBackground: bool,
    pub fBackground: skia_textlayout_ParagraphPainter_SkPaintOrID,
    pub fHasForeground: bool,
    pub fForeground: skia_textlayout_ParagraphPainter_SkPaintOrID,
    pub fTextShadows: [u64; 3usize],
    pub fTypeface: sk_sp<SkTypeface>,
    pub fIsPlaceholder: bool,
    pub fFontFeatures: [u64; 3usize],
    pub fFontArguments: [u64; 9usize],
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout9TextStyle20kDefaultFontFamiliesE"]
    pub static mut skia_textlayout_TextStyle_kDefaultFontFamilies: *const [u64; 3usize];
}
#[test]
fn bindgen_test_layout_skia_textlayout_TextStyle() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_TextStyle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_TextStyle>(),
        424usize,
        concat!("Size of: ", stringify!(skia_textlayout_TextStyle))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_TextStyle>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_TextStyle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDecoration) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fDecoration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontStyle) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fFontStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontFamilies) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fFontFamilies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fFontSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeightOverride) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fHeightOverride)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBaselineShift) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fBaselineShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHalfLeading) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fHalfLeading)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLocale) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fLocale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLetterSpacing) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fLetterSpacing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWordSpacing) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fWordSpacing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextBaseline) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fTextBaseline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fColor) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fColor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHasBackground) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fHasBackground)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBackground) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fBackground)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHasForeground) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fHasForeground)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fForeground) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fForeground)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextShadows) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fTextShadows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTypeface) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fTypeface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIsPlaceholder) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fIsPlaceholder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontFeatures) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fFontFeatures)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontArguments) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TextStyle),
            "::",
            stringify!(fFontArguments)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout9TextStyle19cloneForPlaceholderEv"]
    pub fn skia_textlayout_TextStyle_cloneForPlaceholder(
        this: *mut skia_textlayout_TextStyle,
    ) -> skia_textlayout_TextStyle;
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout9TextStyle6equalsERKS1_"]
    pub fn skia_textlayout_TextStyle_equals(
        this: *const skia_textlayout_TextStyle,
        other: *const skia_textlayout_TextStyle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout9TextStyle13equalsByFontsERKS1_"]
    pub fn skia_textlayout_TextStyle_equalsByFonts(
        this: *const skia_textlayout_TextStyle,
        that: *const skia_textlayout_TextStyle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout9TextStyle17matchOneAttributeENS0_9StyleTypeERKS1_"]
    pub fn skia_textlayout_TextStyle_matchOneAttribute(
        this: *const skia_textlayout_TextStyle,
        styleType: skia_textlayout_StyleType,
        other: *const skia_textlayout_TextStyle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout9TextStyle16setFontArgumentsERKNSt3__18optionalI15SkFontArgumentsEE"]
    pub fn skia_textlayout_TextStyle_setFontArguments(
        this: *mut skia_textlayout_TextStyle,
        args: *const [u64; 7usize],
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout9TextStyle14getFontMetricsEP13SkFontMetrics"]
    pub fn skia_textlayout_TextStyle_getFontMetrics(
        this: *const skia_textlayout_TextStyle,
        metrics: *mut SkFontMetrics,
    );
}
impl skia_textlayout_TextStyle {
    #[inline]
    pub unsafe fn cloneForPlaceholder(&mut self) -> skia_textlayout_TextStyle {
        skia_textlayout_TextStyle_cloneForPlaceholder(self)
    }
    #[inline]
    pub unsafe fn equals(&self, other: *const skia_textlayout_TextStyle) -> bool {
        skia_textlayout_TextStyle_equals(self, other)
    }
    #[inline]
    pub unsafe fn equalsByFonts(&self, that: *const skia_textlayout_TextStyle) -> bool {
        skia_textlayout_TextStyle_equalsByFonts(self, that)
    }
    #[inline]
    pub unsafe fn matchOneAttribute(
        &self,
        styleType: skia_textlayout_StyleType,
        other: *const skia_textlayout_TextStyle,
    ) -> bool {
        skia_textlayout_TextStyle_matchOneAttribute(self, styleType, other)
    }
    #[inline]
    pub unsafe fn setFontArguments(&mut self, args: *const [u64; 7usize]) {
        skia_textlayout_TextStyle_setFontArguments(self, args)
    }
    #[inline]
    pub unsafe fn getFontMetrics(&self, metrics: *mut SkFontMetrics) {
        skia_textlayout_TextStyle_getFontMetrics(self, metrics)
    }
}
pub type skia_textlayout_TextIndex = usize;
pub type skia_textlayout_TextRange = skia_textlayout_SkRange<usize>;
#[repr(C)]
pub struct skia_textlayout_Block {
    pub fRange: skia_textlayout_TextRange,
    pub fStyle: skia_textlayout_TextStyle,
}
#[test]
fn bindgen_test_layout_skia_textlayout_Block() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_Block> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_Block>(),
        440usize,
        concat!("Size of: ", stringify!(skia_textlayout_Block))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_Block>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_Block))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRange) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Block),
            "::",
            stringify!(fRange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStyle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Block),
            "::",
            stringify!(fStyle)
        )
    );
}
pub type skia_textlayout_BlockRange = skia_textlayout_SkRange<usize>;
#[repr(C)]
pub struct skia_textlayout_Placeholder {
    pub fRange: skia_textlayout_TextRange,
    pub fStyle: skia_textlayout_PlaceholderStyle,
    pub fTextStyle: skia_textlayout_TextStyle,
    pub fBlocksBefore: skia_textlayout_BlockRange,
    pub fTextBefore: skia_textlayout_TextRange,
}
#[test]
fn bindgen_test_layout_skia_textlayout_Placeholder() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_Placeholder> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_Placeholder>(),
        496usize,
        concat!("Size of: ", stringify!(skia_textlayout_Placeholder))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_Placeholder>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_Placeholder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRange) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Placeholder),
            "::",
            stringify!(fRange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStyle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Placeholder),
            "::",
            stringify!(fStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextStyle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Placeholder),
            "::",
            stringify!(fTextStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBlocksBefore) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Placeholder),
            "::",
            stringify!(fBlocksBefore)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextBefore) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Placeholder),
            "::",
            stringify!(fTextBefore)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_FontCollection {
    pub _bindgen_opaque_blob: [u64; 26usize],
}
#[repr(C)]
pub struct skia_textlayout_FontCollection_FamilyKey {
    pub fFamilyNames: [u64; 3usize],
    pub fFontStyle: SkFontStyle,
    pub fFontArguments: [u64; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_FontCollection_FamilyKey_Hasher {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_skia_textlayout_FontCollection_FamilyKey_Hasher() {
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_FontCollection_FamilyKey_Hasher>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_FontCollection_FamilyKey_Hasher)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_FontCollection_FamilyKey_Hasher>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_FontCollection_FamilyKey_Hasher)
        )
    );
}
#[test]
fn bindgen_test_layout_skia_textlayout_FontCollection_FamilyKey() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_FontCollection_FamilyKey> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_FontCollection_FamilyKey>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_FontCollection_FamilyKey)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_FontCollection_FamilyKey>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_FontCollection_FamilyKey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFamilyNames) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_FontCollection_FamilyKey),
            "::",
            stringify!(fFamilyNames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontStyle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_FontCollection_FamilyKey),
            "::",
            stringify!(fFontStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontArguments) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_FontCollection_FamilyKey),
            "::",
            stringify!(fFontArguments)
        )
    );
}
#[test]
fn bindgen_test_layout_skia_textlayout_FontCollection() {
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_FontCollection>(),
        208usize,
        concat!("Size of: ", stringify!(skia_textlayout_FontCollection))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_FontCollection>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_FontCollection))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout14FontCollection20getFontManagersCountEv"]
    pub fn skia_textlayout_FontCollection_getFontManagersCount(
        this: *const skia_textlayout_FontCollection,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection19setAssetFontManagerE5sk_spI9SkFontMgrE"]
    pub fn skia_textlayout_FontCollection_setAssetFontManager(
        this: *mut skia_textlayout_FontCollection,
        fontManager: sk_sp<SkFontMgr>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection21setDynamicFontManagerE5sk_spI9SkFontMgrE"]
    pub fn skia_textlayout_FontCollection_setDynamicFontManager(
        this: *mut skia_textlayout_FontCollection,
        fontManager: sk_sp<SkFontMgr>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection18setTestFontManagerE5sk_spI9SkFontMgrE"]
    pub fn skia_textlayout_FontCollection_setTestFontManager(
        this: *mut skia_textlayout_FontCollection,
        fontManager: sk_sp<SkFontMgr>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection21setDefaultFontManagerE5sk_spI9SkFontMgrE"]
    pub fn skia_textlayout_FontCollection_setDefaultFontManager(
        this: *mut skia_textlayout_FontCollection,
        fontManager: sk_sp<SkFontMgr>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection21setDefaultFontManagerE5sk_spI9SkFontMgrEPKc"]
    pub fn skia_textlayout_FontCollection_setDefaultFontManager1(
        this: *mut skia_textlayout_FontCollection,
        fontManager: sk_sp<SkFontMgr>,
        defaultFamilyName: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection21setDefaultFontManagerE5sk_spI9SkFontMgrERKNSt3__16vectorI8SkStringNS5_9allocatorIS7_EEEE"]
    pub fn skia_textlayout_FontCollection_setDefaultFontManager2(
        this: *mut skia_textlayout_FontCollection,
        fontManager: sk_sp<SkFontMgr>,
        defaultFamilyNames: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection13findTypefacesERKNSt3__16vectorI8SkStringNS2_9allocatorIS4_EEEE11SkFontStyle"]
    pub fn skia_textlayout_FontCollection_findTypefaces(
        this: *mut skia_textlayout_FontCollection,
        familyNames: *const [u64; 3usize],
        fontStyle: SkFontStyle,
    ) -> [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection13findTypefacesERKNSt3__16vectorI8SkStringNS2_9allocatorIS4_EEEE11SkFontStyleRKNS2_8optionalINS0_13FontArgumentsEEE"]
    pub fn skia_textlayout_FontCollection_findTypefaces1(
        this: *mut skia_textlayout_FontCollection,
        familyNames: *const [u64; 3usize],
        fontStyle: SkFontStyle,
        fontArgs: *const [u64; 9usize],
    ) -> [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection15defaultFallbackEi11SkFontStyleRK8SkString"]
    pub fn skia_textlayout_FontCollection_defaultFallback(
        this: *mut skia_textlayout_FontCollection,
        unicode: SkUnichar,
        fontStyle: SkFontStyle,
        locale: *const SkString,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection15defaultFallbackEv"]
    pub fn skia_textlayout_FontCollection_defaultFallback1(
        this: *mut skia_textlayout_FontCollection,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection19disableFontFallbackEv"]
    pub fn skia_textlayout_FontCollection_disableFontFallback(
        this: *mut skia_textlayout_FontCollection,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection18enableFontFallbackEv"]
    pub fn skia_textlayout_FontCollection_enableFontFallback(
        this: *mut skia_textlayout_FontCollection,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollection11clearCachesEv"]
    pub fn skia_textlayout_FontCollection_clearCaches(this: *mut skia_textlayout_FontCollection);
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14FontCollectionC1Ev"]
    pub fn skia_textlayout_FontCollection_FontCollection(this: *mut skia_textlayout_FontCollection);
}
impl skia_textlayout_FontCollection {
    #[inline]
    pub unsafe fn getFontManagersCount(&self) -> usize {
        skia_textlayout_FontCollection_getFontManagersCount(self)
    }
    #[inline]
    pub unsafe fn setAssetFontManager(&mut self, fontManager: sk_sp<SkFontMgr>) {
        skia_textlayout_FontCollection_setAssetFontManager(self, fontManager)
    }
    #[inline]
    pub unsafe fn setDynamicFontManager(&mut self, fontManager: sk_sp<SkFontMgr>) {
        skia_textlayout_FontCollection_setDynamicFontManager(self, fontManager)
    }
    #[inline]
    pub unsafe fn setTestFontManager(&mut self, fontManager: sk_sp<SkFontMgr>) {
        skia_textlayout_FontCollection_setTestFontManager(self, fontManager)
    }
    #[inline]
    pub unsafe fn setDefaultFontManager(&mut self, fontManager: sk_sp<SkFontMgr>) {
        skia_textlayout_FontCollection_setDefaultFontManager(self, fontManager)
    }
    #[inline]
    pub unsafe fn setDefaultFontManager1(
        &mut self,
        fontManager: sk_sp<SkFontMgr>,
        defaultFamilyName: *const ::core::ffi::c_char,
    ) {
        skia_textlayout_FontCollection_setDefaultFontManager1(self, fontManager, defaultFamilyName)
    }
    #[inline]
    pub unsafe fn setDefaultFontManager2(
        &mut self,
        fontManager: sk_sp<SkFontMgr>,
        defaultFamilyNames: *const [u64; 3usize],
    ) {
        skia_textlayout_FontCollection_setDefaultFontManager2(self, fontManager, defaultFamilyNames)
    }
    #[inline]
    pub unsafe fn findTypefaces(
        &mut self,
        familyNames: *const [u64; 3usize],
        fontStyle: SkFontStyle,
    ) -> [u64; 3usize] {
        skia_textlayout_FontCollection_findTypefaces(self, familyNames, fontStyle)
    }
    #[inline]
    pub unsafe fn findTypefaces1(
        &mut self,
        familyNames: *const [u64; 3usize],
        fontStyle: SkFontStyle,
        fontArgs: *const [u64; 9usize],
    ) -> [u64; 3usize] {
        skia_textlayout_FontCollection_findTypefaces1(self, familyNames, fontStyle, fontArgs)
    }
    #[inline]
    pub unsafe fn defaultFallback(
        &mut self,
        unicode: SkUnichar,
        fontStyle: SkFontStyle,
        locale: *const SkString,
    ) -> sk_sp<SkTypeface> {
        skia_textlayout_FontCollection_defaultFallback(self, unicode, fontStyle, locale)
    }
    #[inline]
    pub unsafe fn defaultFallback1(&mut self) -> sk_sp<SkTypeface> {
        skia_textlayout_FontCollection_defaultFallback1(self)
    }
    #[inline]
    pub unsafe fn disableFontFallback(&mut self) {
        skia_textlayout_FontCollection_disableFontFallback(self)
    }
    #[inline]
    pub unsafe fn enableFontFallback(&mut self) {
        skia_textlayout_FontCollection_enableFontFallback(self)
    }
    #[inline]
    pub unsafe fn clearCaches(&mut self) {
        skia_textlayout_FontCollection_clearCaches(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_FontCollection_FontCollection(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_StyleMetrics {
    pub text_style: *const skia_textlayout_TextStyle,
    pub font_metrics: SkFontMetrics,
}
#[test]
fn bindgen_test_layout_skia_textlayout_StyleMetrics() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_StyleMetrics> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_StyleMetrics>(),
        72usize,
        concat!("Size of: ", stringify!(skia_textlayout_StyleMetrics))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_StyleMetrics>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_StyleMetrics))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_style) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StyleMetrics),
            "::",
            stringify!(text_style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_metrics) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StyleMetrics),
            "::",
            stringify!(font_metrics)
        )
    );
}
#[repr(C)]
pub struct skia_textlayout_LineMetrics {
    pub fStartIndex: usize,
    pub fEndIndex: usize,
    pub fEndExcludingWhitespaces: usize,
    pub fEndIncludingNewline: usize,
    pub fHardBreak: bool,
    pub fAscent: f64,
    pub fDescent: f64,
    pub fUnscaledAscent: f64,
    pub fHeight: f64,
    pub fWidth: f64,
    pub fLeft: f64,
    pub fBaseline: f64,
    pub fLineNumber: usize,
    pub fLineMetrics: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_skia_textlayout_LineMetrics() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_LineMetrics> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_LineMetrics>(),
        128usize,
        concat!("Size of: ", stringify!(skia_textlayout_LineMetrics))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_LineMetrics>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_LineMetrics))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStartIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fStartIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEndIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fEndIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEndExcludingWhitespaces) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fEndExcludingWhitespaces)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEndIncludingNewline) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fEndIncludingNewline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHardBreak) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fHardBreak)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAscent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fAscent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDescent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fDescent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fUnscaledAscent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fUnscaledAscent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLeft) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fLeft)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBaseline) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fBaseline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLineNumber) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fLineNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLineMetrics) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_LineMetrics),
            "::",
            stringify!(fLineMetrics)
        )
    );
}
#[repr(C)]
pub struct skia_textlayout_StrutStyle {
    pub fFontFamilies: [u64; 3usize],
    pub fFontStyle: SkFontStyle,
    pub fFontSize: SkScalar,
    pub fHeight: SkScalar,
    pub fLeading: SkScalar,
    pub fForceHeight: bool,
    pub fEnabled: bool,
    pub fHeightOverride: bool,
    pub fHalfLeading: bool,
}
#[test]
fn bindgen_test_layout_skia_textlayout_StrutStyle() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_StrutStyle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_StrutStyle>(),
        48usize,
        concat!("Size of: ", stringify!(skia_textlayout_StrutStyle))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_StrutStyle>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_StrutStyle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontFamilies) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StrutStyle),
            "::",
            stringify!(fFontFamilies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontStyle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StrutStyle),
            "::",
            stringify!(fFontStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontSize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StrutStyle),
            "::",
            stringify!(fFontSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StrutStyle),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLeading) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StrutStyle),
            "::",
            stringify!(fLeading)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fForceHeight) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StrutStyle),
            "::",
            stringify!(fForceHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEnabled) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StrutStyle),
            "::",
            stringify!(fEnabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeightOverride) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StrutStyle),
            "::",
            stringify!(fHeightOverride)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHalfLeading) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_StrutStyle),
            "::",
            stringify!(fHalfLeading)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout10StrutStyleC1Ev"]
    pub fn skia_textlayout_StrutStyle_StrutStyle(this: *mut skia_textlayout_StrutStyle);
}
impl skia_textlayout_StrutStyle {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_StrutStyle_StrutStyle(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct skia_textlayout_ParagraphStyle {
    pub fStrutStyle: skia_textlayout_StrutStyle,
    pub fDefaultTextStyle: skia_textlayout_TextStyle,
    pub fTextAlign: skia_textlayout_TextAlign,
    pub fTextDirection: skia_textlayout_TextDirection,
    pub fLinesLimit: usize,
    pub fEllipsisUtf16: std_u16string,
    pub fEllipsis: SkString,
    pub fHeight: SkScalar,
    pub fTextHeightBehavior: skia_textlayout_TextHeightBehavior,
    pub fHintingIsOn: bool,
    pub fReplaceTabCharacters: bool,
    pub fApplyRoundingHack: bool,
}
#[test]
fn bindgen_test_layout_skia_textlayout_ParagraphStyle() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_ParagraphStyle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_ParagraphStyle>(),
        536usize,
        concat!("Size of: ", stringify!(skia_textlayout_ParagraphStyle))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_ParagraphStyle>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_ParagraphStyle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStrutStyle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fStrutStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fDefaultTextStyle) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fDefaultTextStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextAlign) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fTextAlign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextDirection) as usize - ptr as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fTextDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLinesLimit) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fLinesLimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEllipsisUtf16) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fEllipsisUtf16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fEllipsis) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fEllipsis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextHeightBehavior) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fTextHeightBehavior)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHintingIsOn) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fHintingIsOn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fReplaceTabCharacters) as usize - ptr as usize },
        529usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fReplaceTabCharacters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fApplyRoundingHack) as usize - ptr as usize },
        530usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_ParagraphStyle),
            "::",
            stringify!(fApplyRoundingHack)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout14ParagraphStyle15effective_alignEv"]
    pub fn skia_textlayout_ParagraphStyle_effective_align(
        this: *const skia_textlayout_ParagraphStyle,
    ) -> skia_textlayout_TextAlign;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout14ParagraphStyleC1Ev"]
    pub fn skia_textlayout_ParagraphStyle_ParagraphStyle(this: *mut skia_textlayout_ParagraphStyle);
}
impl skia_textlayout_ParagraphStyle {
    #[inline]
    pub unsafe fn effective_align(&self) -> skia_textlayout_TextAlign {
        skia_textlayout_ParagraphStyle_effective_align(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_ParagraphStyle_ParagraphStyle(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct skia_textlayout_Paragraph__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
pub struct skia_textlayout_Paragraph {
    pub vtable_: *const skia_textlayout_Paragraph__bindgen_vtable,
    pub fFontCollection: sk_sp<skia_textlayout_FontCollection>,
    pub fParagraphStyle: skia_textlayout_ParagraphStyle,
    pub fAlphabeticBaseline: SkScalar,
    pub fIdeographicBaseline: SkScalar,
    pub fHeight: SkScalar,
    pub fWidth: SkScalar,
    pub fMaxIntrinsicWidth: SkScalar,
    pub fMinIntrinsicWidth: SkScalar,
    pub fLongestLine: SkScalar,
    pub fExceededMaxLines: bool,
}
pub const skia_textlayout_Paragraph_VisitorFlags_kWhiteSpace_VisitorFlag:
    skia_textlayout_Paragraph_VisitorFlags = 1;
pub type skia_textlayout_Paragraph_VisitorFlags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_Paragraph_VisitorInfo {
    pub font: *const SkFont,
    pub origin: SkPoint,
    pub advanceX: SkScalar,
    pub count: ::core::ffi::c_int,
    pub glyphs: *const u16,
    pub positions: *const SkPoint,
    pub utf8Starts: *const u32,
    pub flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_skia_textlayout_Paragraph_VisitorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_Paragraph_VisitorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_Paragraph_VisitorInfo>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_Paragraph_VisitorInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).origin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).advanceX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo),
            "::",
            stringify!(advanceX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).glyphs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).positions) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo),
            "::",
            stringify!(positions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).utf8Starts) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo),
            "::",
            stringify!(utf8Starts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_VisitorInfo),
            "::",
            stringify!(flags)
        )
    );
}
pub type skia_textlayout_Paragraph_Visitor = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_Paragraph_ExtendedVisitorInfo {
    pub font: *const SkFont,
    pub origin: SkPoint,
    pub advance: SkSize,
    pub count: ::core::ffi::c_int,
    pub glyphs: *const u16,
    pub positions: *mut SkPoint,
    pub bounds: *const SkRect,
    pub utf8Starts: *const u32,
    pub flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_skia_textlayout_Paragraph_ExtendedVisitorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_Paragraph_ExtendedVisitorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_Paragraph_ExtendedVisitorInfo>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_Paragraph_ExtendedVisitorInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).origin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).advance) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo),
            "::",
            stringify!(advance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).glyphs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).positions) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo),
            "::",
            stringify!(positions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bounds) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo),
            "::",
            stringify!(bounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).utf8Starts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo),
            "::",
            stringify!(utf8Starts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_ExtendedVisitorInfo),
            "::",
            stringify!(flags)
        )
    );
}
pub type skia_textlayout_Paragraph_ExtendedVisitor = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skia_textlayout_Paragraph_GlyphClusterInfo {
    pub fBounds: SkRect,
    pub fClusterTextRange: skia_textlayout_TextRange,
    pub fGlyphClusterPosition: skia_textlayout_TextDirection,
}
#[test]
fn bindgen_test_layout_skia_textlayout_Paragraph_GlyphClusterInfo() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_Paragraph_GlyphClusterInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_Paragraph_GlyphClusterInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_Paragraph_GlyphClusterInfo)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_Paragraph_GlyphClusterInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_Paragraph_GlyphClusterInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_GlyphClusterInfo),
            "::",
            stringify!(fBounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fClusterTextRange) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_GlyphClusterInfo),
            "::",
            stringify!(fClusterTextRange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fGlyphClusterPosition) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_GlyphClusterInfo),
            "::",
            stringify!(fGlyphClusterPosition)
        )
    );
}
#[repr(C)]
pub struct skia_textlayout_Paragraph_FontInfo__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct skia_textlayout_Paragraph_FontInfo {
    pub vtable_: *const skia_textlayout_Paragraph_FontInfo__bindgen_vtable,
    pub fFont: SkFont,
    pub fTextRange: skia_textlayout_TextRange,
}
#[test]
fn bindgen_test_layout_skia_textlayout_Paragraph_FontInfo() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_Paragraph_FontInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_Paragraph_FontInfo>(),
        48usize,
        concat!("Size of: ", stringify!(skia_textlayout_Paragraph_FontInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_Paragraph_FontInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_Paragraph_FontInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFont) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_FontInfo),
            "::",
            stringify!(fFont)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fTextRange) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph_FontInfo),
            "::",
            stringify!(fTextRange)
        )
    );
}
#[test]
fn bindgen_test_layout_skia_textlayout_Paragraph() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_Paragraph> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_Paragraph>(),
        584usize,
        concat!("Size of: ", stringify!(skia_textlayout_Paragraph))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_Paragraph>(),
        8usize,
        concat!("Alignment of ", stringify!(skia_textlayout_Paragraph))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFontCollection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fFontCollection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fParagraphStyle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fParagraphStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAlphabeticBaseline) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fAlphabeticBaseline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fIdeographicBaseline) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fIdeographicBaseline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMaxIntrinsicWidth) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fMaxIntrinsicWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fMinIntrinsicWidth) as usize - ptr as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fMinIntrinsicWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fLongestLine) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fLongestLine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fExceededMaxLines) as usize - ptr as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_Paragraph),
            "::",
            stringify!(fExceededMaxLines)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout9Paragraph7GetPathEP10SkTextBlob"]
    pub fn skia_textlayout_Paragraph_GetPath(textBlob: *mut SkTextBlob) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout9ParagraphC2ENS0_14ParagraphStyleE5sk_spINS0_14FontCollectionEE"]
    pub fn skia_textlayout_Paragraph_Paragraph(
        this: *mut skia_textlayout_Paragraph,
        style: skia_textlayout_ParagraphStyle,
        fonts: sk_sp<skia_textlayout_FontCollection>,
    );
}
impl skia_textlayout_Paragraph {
    #[inline]
    pub unsafe fn GetPath(textBlob: *mut SkTextBlob) -> SkPath {
        skia_textlayout_Paragraph_GetPath(textBlob)
    }
    #[inline]
    pub unsafe fn new(
        style: skia_textlayout_ParagraphStyle,
        fonts: sk_sp<skia_textlayout_FontCollection>,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_Paragraph_Paragraph(__bindgen_tmp.as_mut_ptr(), style, fonts);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct skia_textlayout_ParagraphBuilder__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct skia_textlayout_ParagraphBuilder {
    pub vtable_: *const skia_textlayout_ParagraphBuilder__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_skia_textlayout_ParagraphBuilder() {
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_ParagraphBuilder>(),
        8usize,
        concat!("Size of: ", stringify!(skia_textlayout_ParagraphBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_ParagraphBuilder>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_ParagraphBuilder)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout16ParagraphBuilder4makeERKNS0_14ParagraphStyleE5sk_spINS0_14FontCollectionEE"]
    pub fn skia_textlayout_ParagraphBuilder_make(
        style: *const skia_textlayout_ParagraphStyle,
        fontCollection: sk_sp<skia_textlayout_FontCollection>,
    ) -> u64;
}
impl skia_textlayout_ParagraphBuilder {
    #[inline]
    pub unsafe fn make(
        style: *const skia_textlayout_ParagraphStyle,
        fontCollection: sk_sp<skia_textlayout_FontCollection>,
    ) -> u64 {
        skia_textlayout_ParagraphBuilder_make(style, fontCollection)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct skia_textlayout_TypefaceFontStyleSet {
    pub _base: SkFontStyleSet,
    pub fStyles: [u64; 2usize],
    pub fFamilyName: SkString,
    pub fAlias: SkString,
}
#[test]
fn bindgen_test_layout_skia_textlayout_TypefaceFontStyleSet() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_TypefaceFontStyleSet> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_TypefaceFontStyleSet>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_TypefaceFontStyleSet)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_TypefaceFontStyleSet>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_TypefaceFontStyleSet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStyles) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TypefaceFontStyleSet),
            "::",
            stringify!(fStyles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFamilyName) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TypefaceFontStyleSet),
            "::",
            stringify!(fFamilyName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fAlias) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TypefaceFontStyleSet),
            "::",
            stringify!(fAlias)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout20TypefaceFontStyleSet14appendTypefaceE5sk_spI10SkTypefaceE"]
    pub fn skia_textlayout_TypefaceFontStyleSet_appendTypeface(
        this: *mut skia_textlayout_TypefaceFontStyleSet,
        typeface: sk_sp<SkTypeface>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout20TypefaceFontStyleSetC1ERK8SkString"]
    pub fn skia_textlayout_TypefaceFontStyleSet_TypefaceFontStyleSet(
        this: *mut skia_textlayout_TypefaceFontStyleSet,
        familyName: *const SkString,
    );
}
impl skia_textlayout_TypefaceFontStyleSet {
    #[inline]
    pub unsafe fn appendTypeface(&mut self, typeface: sk_sp<SkTypeface>) {
        skia_textlayout_TypefaceFontStyleSet_appendTypeface(self, typeface)
    }
    #[inline]
    pub unsafe fn new(familyName: *const SkString) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        skia_textlayout_TypefaceFontStyleSet_TypefaceFontStyleSet(
            __bindgen_tmp.as_mut_ptr(),
            familyName,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout20TypefaceFontStyleSet5countEv"]
    pub fn skia_textlayout_TypefaceFontStyleSet_count(
        this: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout20TypefaceFontStyleSet8getStyleEiP11SkFontStyleP8SkString"]
    pub fn skia_textlayout_TypefaceFontStyleSet_getStyle(
        this: *mut ::core::ffi::c_void,
        index: ::core::ffi::c_int,
        arg1: *mut SkFontStyle,
        name: *mut SkString,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout20TypefaceFontStyleSet14createTypefaceEi"]
    pub fn skia_textlayout_TypefaceFontStyleSet_createTypeface(
        this: *mut ::core::ffi::c_void,
        index: ::core::ffi::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout20TypefaceFontStyleSet10matchStyleERK11SkFontStyle"]
    pub fn skia_textlayout_TypefaceFontStyleSet_matchStyle(
        this: *mut ::core::ffi::c_void,
        pattern: *const SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
#[repr(C)]
#[derive(Debug)]
pub struct skia_textlayout_TypefaceFontProvider {
    pub _base: SkFontMgr,
    pub fRegisteredFamilies: [u64; 2usize],
    pub fFamilyNames: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_skia_textlayout_TypefaceFontProvider() {
    const UNINIT: ::core::mem::MaybeUninit<skia_textlayout_TypefaceFontProvider> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_TypefaceFontProvider>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(skia_textlayout_TypefaceFontProvider)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_TypefaceFontProvider>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(skia_textlayout_TypefaceFontProvider)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fRegisteredFamilies) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TypefaceFontProvider),
            "::",
            stringify!(fRegisteredFamilies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFamilyNames) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(skia_textlayout_TypefaceFontProvider),
            "::",
            stringify!(fFamilyNames)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout20TypefaceFontProvider16registerTypefaceE5sk_spI10SkTypefaceE"]
    pub fn skia_textlayout_TypefaceFontProvider_registerTypeface(
        this: *mut skia_textlayout_TypefaceFontProvider,
        typeface: sk_sp<SkTypeface>,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN4skia10textlayout20TypefaceFontProvider16registerTypefaceE5sk_spI10SkTypefaceERK8SkString"]
    pub fn skia_textlayout_TypefaceFontProvider_registerTypeface1(
        this: *mut skia_textlayout_TypefaceFontProvider,
        typeface: sk_sp<SkTypeface>,
        alias: *const SkString,
    ) -> usize;
}
impl skia_textlayout_TypefaceFontProvider {
    #[inline]
    pub unsafe fn registerTypeface(&mut self, typeface: sk_sp<SkTypeface>) -> usize {
        skia_textlayout_TypefaceFontProvider_registerTypeface(self, typeface)
    }
    #[inline]
    pub unsafe fn registerTypeface1(
        &mut self,
        typeface: sk_sp<SkTypeface>,
        alias: *const SkString,
    ) -> usize {
        skia_textlayout_TypefaceFontProvider_registerTypeface1(self, typeface, alias)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout20TypefaceFontProvider15onCountFamiliesEv"]
    pub fn skia_textlayout_TypefaceFontProvider_onCountFamilies(
        this: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout20TypefaceFontProvider15onGetFamilyNameEiP8SkString"]
    pub fn skia_textlayout_TypefaceFontProvider_onGetFamilyName(
        this: *mut ::core::ffi::c_void,
        index: ::core::ffi::c_int,
        familyName: *mut SkString,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK4skia10textlayout20TypefaceFontProvider13onMatchFamilyEPKc"]
    pub fn skia_textlayout_TypefaceFontProvider_onMatchFamily(
        this: *mut ::core::ffi::c_void,
        familyName: *const ::core::ffi::c_char,
    ) -> sk_sp<SkFontStyleSet>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTInternalLList<T> {
    pub fHead: *mut T,
    pub fTail: *mut T,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTInternalLList_Iter<T> {
    pub fCurr: *mut T,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
impl SkTInternalLList_Iter_IterStart {
    pub const kTail_IterStart: SkTInternalLList_Iter_IterStart =
        SkTInternalLList_Iter_IterStart::kHead_IterStart;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTInternalLList_Iter_IterStart {
    kHead_IterStart = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkGoodHash {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkGoodHash() {
    assert_eq!(
        ::core::mem::size_of::<SkGoodHash>(),
        1usize,
        concat!("Size of: ", stringify!(SkGoodHash))
    );
    assert_eq!(
        ::core::mem::align_of::<SkGoodHash>(),
        1usize,
        concat!("Alignment of ", stringify!(SkGoodHash))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkLRUCache_Traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkFontDescriptor {
    pub fFamilyName: SkString,
    pub fFullName: SkString,
    pub fPostscriptName: SkString,
    pub fStyle: SkFontStyle,
    pub fStream: u64,
    pub fCollectionIndex: ::core::ffi::c_int,
    pub fCoordinateCount: ::core::ffi::c_int,
    pub fVariation: SkFontDescriptor_Coordinates,
    pub fPaletteIndex: ::core::ffi::c_int,
    pub fPaletteEntryOverrideCount: ::core::ffi::c_int,
    pub fPaletteEntryOverrides: u64,
    pub fFactoryId: SkTypeface_FactoryId,
}
pub type SkFontDescriptor_Coordinates = [u64; 5usize];
#[test]
fn bindgen_test_layout_SkFontDescriptor() {
    const UNINIT: ::core::mem::MaybeUninit<SkFontDescriptor> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SkFontDescriptor>(),
        112usize,
        concat!("Size of: ", stringify!(SkFontDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontDescriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFamilyName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fFamilyName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFullName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fFullName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPostscriptName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fPostscriptName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStyle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fStyle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fStream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fStream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCollectionIndex) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fCollectionIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fCoordinateCount) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fCoordinateCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fVariation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fVariation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPaletteIndex) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fPaletteIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPaletteEntryOverrideCount) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fPaletteEntryOverrideCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fPaletteEntryOverrides) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fPaletteEntryOverrides)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fFactoryId) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SkFontDescriptor),
            "::",
            stringify!(fFactoryId)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkFontDescriptor11DeserializeEP8SkStreamPS_"]
    pub fn SkFontDescriptor_Deserialize(arg1: *mut SkStream, result: *mut SkFontDescriptor)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkFontDescriptor9serializeEP9SkWStream"]
    pub fn SkFontDescriptor_serialize(this: *const SkFontDescriptor, arg1: *mut SkWStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkFontDescriptor33SkFontStyleWidthForWidthAxisValueEf"]
    pub fn SkFontDescriptor_SkFontStyleWidthForWidthAxisValue(width: SkScalar)
        -> SkFontStyle_Width;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkFontDescriptorC1Ev"]
    pub fn SkFontDescriptor_SkFontDescriptor(this: *mut SkFontDescriptor);
}
impl SkFontDescriptor {
    #[inline]
    pub unsafe fn Deserialize(arg1: *mut SkStream, result: *mut SkFontDescriptor) -> bool {
        SkFontDescriptor_Deserialize(arg1, result)
    }
    #[inline]
    pub unsafe fn serialize(&self, arg1: *mut SkWStream) {
        SkFontDescriptor_serialize(self, arg1)
    }
    #[inline]
    pub unsafe fn SkFontStyleWidthForWidthAxisValue(width: SkScalar) -> SkFontStyle_Width {
        SkFontDescriptor_SkFontStyleWidthForWidthAxisValue(width)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFontDescriptor_SkFontDescriptor(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    pub fn C_FontArguments_Construct(
        fontArguments: *const SkFontArguments,
        uninitialized: *mut skia_textlayout_FontArguments,
    );
}
extern "C" {
    pub fn C_FontArguments_CopyConstruct(
        uninitialized: *mut skia_textlayout_FontArguments,
        self_: *const skia_textlayout_FontArguments,
    );
}
extern "C" {
    pub fn C_FontArguments_destruct(self_: *mut skia_textlayout_FontArguments);
}
extern "C" {
    pub fn C_FontArguments_Equals(
        lhs: *const skia_textlayout_FontArguments,
        rhs: *const skia_textlayout_FontArguments,
    ) -> bool;
}
extern "C" {
    pub fn C_FontArguments_hash(self_: *const skia_textlayout_FontArguments) -> usize;
}
extern "C" {
    pub fn C_FontArguments_cloneTypeface(
        self_: *const skia_textlayout_FontArguments,
        tf: *mut SkTypeface,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_FontCollection_new() -> *mut skia_textlayout_FontCollection;
}
extern "C" {
    pub fn C_FontCollection_setAssetFontManager(
        self_: *mut skia_textlayout_FontCollection,
        fontManager: *const SkFontMgr,
    );
}
extern "C" {
    pub fn C_FontCollection_setDynamicFontManager(
        self_: *mut skia_textlayout_FontCollection,
        fontManager: *const SkFontMgr,
    );
}
extern "C" {
    pub fn C_FontCollection_setTestFontManager(
        self_: *mut skia_textlayout_FontCollection,
        fontManager: *const SkFontMgr,
    );
}
extern "C" {
    pub fn C_FontCollection_setDefaultFontManager(
        self_: *mut skia_textlayout_FontCollection,
        fontManager: *const SkFontMgr,
    );
}
extern "C" {
    pub fn C_FontCollection_setDefaultFontManager2(
        self_: *mut skia_textlayout_FontCollection,
        fontManager: *const SkFontMgr,
        defaultFamilyName: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn C_FontCollection_setDefaultFontManager3(
        self_: *mut skia_textlayout_FontCollection,
        fontManager: *const SkFontMgr,
        familyNames: *const SkStrings,
    );
}
extern "C" {
    pub fn C_FontCollection_getFallbackManager(
        self_: *const skia_textlayout_FontCollection,
    ) -> *mut SkFontMgr;
}
extern "C" {
    pub fn C_FontCollection_findTypefaces(
        self_: *mut skia_textlayout_FontCollection,
        familyNames: *const SkStrings,
        fontStyle: SkFontStyle,
        fontArguments: *const skia_textlayout_FontArguments,
        typefaces: *mut VecSink<sk_sp<SkTypeface>>,
    );
}
extern "C" {
    pub fn C_FontCollection_defaultFallback(
        self_: *mut skia_textlayout_FontCollection,
        unicode: SkUnichar,
        fontStyle: SkFontStyle,
        locale: *const SkString,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_FontCollection_defaultFallback2(
        self_: *mut skia_textlayout_FontCollection,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_FontCollection_fontFallbackEnabled(
        self_: *const skia_textlayout_FontCollection,
    ) -> bool;
}
extern "C" {
    pub fn C_FontCollection_paragraphCache(
        self_: *mut skia_textlayout_FontCollection,
    ) -> *mut skia_textlayout_ParagraphCache;
}
extern "C" {
    pub fn C_ParagraphCache_destruct(self_: *mut skia_textlayout_ParagraphCache);
}
extern "C" {
    pub fn C_ParagraphCache_count(self_: *mut skia_textlayout_ParagraphCache)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_StrutStyle_Construct(uninitialized: *mut skia_textlayout_StrutStyle);
}
extern "C" {
    pub fn C_StrutStyle_CopyConstruct(
        uninitialized: *mut skia_textlayout_StrutStyle,
        other: *const skia_textlayout_StrutStyle,
    );
}
extern "C" {
    pub fn C_StrutStyle_destruct(self_: *mut skia_textlayout_StrutStyle);
}
extern "C" {
    pub fn C_StrutStyle_getFontFamilies(
        self_: *const skia_textlayout_StrutStyle,
        count: *mut usize,
    ) -> *const SkString;
}
extern "C" {
    pub fn C_StrutStyle_setFontFamilies(
        self_: *mut skia_textlayout_StrutStyle,
        data: *const SkString,
        count: usize,
    );
}
extern "C" {
    pub fn C_StrutStyle_equals(
        self_: *const skia_textlayout_StrutStyle,
        rhs: *const skia_textlayout_StrutStyle,
    ) -> bool;
}
extern "C" {
    pub fn C_ParagraphStyle_new() -> *mut skia_textlayout_ParagraphStyle;
}
extern "C" {
    pub fn C_ParagraphStyle_newCopy(
        other: *const skia_textlayout_ParagraphStyle,
    ) -> *mut skia_textlayout_ParagraphStyle;
}
extern "C" {
    pub fn C_ParagraphStyle_delete(self_: *mut skia_textlayout_ParagraphStyle);
}
extern "C" {
    pub fn C_ParagraphStyle_Equals(
        left: *const skia_textlayout_ParagraphStyle,
        right: *const skia_textlayout_ParagraphStyle,
    ) -> bool;
}
extern "C" {
    pub fn C_ParagraphStyle_ellipsized(self_: *const skia_textlayout_ParagraphStyle) -> bool;
}
extern "C" {
    pub fn C_TextShadow_Equals(
        self_: *const skia_textlayout_TextShadow,
        other: *const skia_textlayout_TextShadow,
    ) -> bool;
}
extern "C" {
    pub fn C_LineMetrics_styleMetricsCount(self_: *const skia_textlayout_LineMetrics) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexedStyleMetrics {
    pub index: usize,
    pub metrics: skia_textlayout_StyleMetrics,
}
#[test]
fn bindgen_test_layout_IndexedStyleMetrics() {
    const UNINIT: ::core::mem::MaybeUninit<IndexedStyleMetrics> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IndexedStyleMetrics>(),
        80usize,
        concat!("Size of: ", stringify!(IndexedStyleMetrics))
    );
    assert_eq!(
        ::core::mem::align_of::<IndexedStyleMetrics>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexedStyleMetrics))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexedStyleMetrics),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).metrics) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexedStyleMetrics),
            "::",
            stringify!(metrics)
        )
    );
}
extern "C" {
    pub fn C_LineMetrics_getAllStyleMetrics(
        self_: *const skia_textlayout_LineMetrics,
        result: *mut IndexedStyleMetrics,
    );
}
extern "C" {
    pub fn C_Paragraph_delete(self_: *mut skia_textlayout_Paragraph);
}
extern "C" {
    pub fn C_Paragraph_layout(self_: *mut skia_textlayout_Paragraph, width: SkScalar);
}
extern "C" {
    pub fn C_Paragraph_paint(
        self_: *mut skia_textlayout_Paragraph,
        canvas: *mut SkCanvas,
        x: SkScalar,
        y: SkScalar,
    );
}
extern "C" {
    pub fn C_Paragraph_getRectsForRange(
        self_: *mut skia_textlayout_Paragraph,
        start: ::core::ffi::c_uint,
        end: ::core::ffi::c_uint,
        rectHeightStyle: skia_textlayout_RectHeightStyle,
        rectWidthStyle: skia_textlayout_RectWidthStyle,
        textBoxes: *mut VecSink<skia_textlayout_TextBox>,
    );
}
extern "C" {
    pub fn C_Paragraph_getRectsForPlaceholders(
        self_: *mut skia_textlayout_Paragraph,
        result: *mut VecSink<skia_textlayout_TextBox>,
    );
}
extern "C" {
    pub fn C_Paragraph_getGlyphPositionAtCoordinate(
        self_: *mut skia_textlayout_Paragraph,
        x: SkScalar,
        y: SkScalar,
        position: *mut skia_textlayout_PositionWithAffinity,
    );
}
extern "C" {
    pub fn C_Paragraph_getWordBoundary(
        self_: *mut skia_textlayout_Paragraph,
        offset: ::core::ffi::c_uint,
        range: *mut usize,
    );
}
extern "C" {
    pub fn C_Paragraph_getLineMetrics(
        self_: *mut skia_textlayout_Paragraph,
        result: *mut VecSink<skia_textlayout_LineMetrics>,
    );
}
extern "C" {
    pub fn C_Paragraph_lineNumber(self_: *mut skia_textlayout_Paragraph) -> usize;
}
extern "C" {
    pub fn C_Paragraph_markDirty(self_: *mut skia_textlayout_Paragraph);
}
extern "C" {
    pub fn C_Paragraph_unresolvedGlyphs(self_: *mut skia_textlayout_Paragraph) -> i32;
}
extern "C" {
    pub fn C_Paragraph_unresolvedCodepoints(
        self_: *mut skia_textlayout_Paragraph,
        result: *mut VecSink<SkUnichar>,
    );
}
extern "C" {
    pub fn C_Paragraph_visit(
        self_: *mut skia_textlayout_Paragraph,
        ctx: *mut ::core::ffi::c_void,
        visit: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: usize,
                arg3: *const skia_textlayout_Paragraph_VisitorInfo,
            ),
        >,
    );
}
extern "C" {
    pub fn C_Paragraph_extendedVisit(
        self_: *mut skia_textlayout_Paragraph,
        ctx: *mut ::core::ffi::c_void,
        visit: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: usize,
                arg3: *const skia_textlayout_Paragraph_ExtendedVisitorInfo,
            ),
        >,
    );
}
extern "C" {
    pub fn C_Paragraph_getPath(
        self_: *mut skia_textlayout_Paragraph,
        lineNumber: ::core::ffi::c_int,
        path: *mut SkPath,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_Paragraph_GetPath(textBlob: *mut SkTextBlob, uninitialized: *mut SkPath);
}
extern "C" {
    pub fn C_Paragraph_containsEmoji(
        self_: *mut skia_textlayout_Paragraph,
        textBlob: *mut SkTextBlob,
    ) -> bool;
}
extern "C" {
    pub fn C_Paragraph_containsColorFontOrBitmap(
        self_: *mut skia_textlayout_Paragraph,
        textBlob: *mut SkTextBlob,
    ) -> bool;
}
extern "C" {
    pub fn C_Paragraph_getLineNumberAt(
        self_: *const skia_textlayout_Paragraph,
        codeUnitIndex: skia_textlayout_TextIndex,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn C_Paragraph_getLineMetricsAt(
        self_: *const skia_textlayout_Paragraph,
        lineNumber: usize,
        lineMetrics: *mut Sink<skia_textlayout_LineMetrics>,
    );
}
extern "C" {
    pub fn C_Paragraph_getActualTextRange(
        self_: *const skia_textlayout_Paragraph,
        lineNumber: usize,
        includeSpaces: bool,
        r: *mut usize,
    );
}
extern "C" {
    pub fn C_Paragraph_getGlyphClusterAt(
        self_: *const skia_textlayout_Paragraph,
        codeUnitIndex: skia_textlayout_TextIndex,
        r: *mut Sink<skia_textlayout_Paragraph_GlyphClusterInfo>,
    );
}
extern "C" {
    pub fn C_Paragraph_getClosestGlyphClusterAt(
        self_: *const skia_textlayout_Paragraph,
        dx: SkScalar,
        dy: SkScalar,
        r: *mut Sink<skia_textlayout_Paragraph_GlyphClusterInfo>,
    );
}
extern "C" {
    pub fn C_Paragraph_getFontAt(
        self_: *const skia_textlayout_Paragraph,
        codeUnitIndex: skia_textlayout_TextIndex,
        uninitialized: *mut SkFont,
    );
}
extern "C" {
    pub fn C_Paragraph_getFonts(
        self_: *const skia_textlayout_Paragraph,
        r: *mut VecSink<skia_textlayout_Paragraph_FontInfo>,
    );
}
extern "C" {
    pub fn C_ParagraphBuilder_delete(self_: *mut skia_textlayout_ParagraphBuilder);
}
extern "C" {
    pub fn C_ParagraphBuilder_pushStyle(
        self_: *mut skia_textlayout_ParagraphBuilder,
        style: *const skia_textlayout_TextStyle,
    );
}
extern "C" {
    pub fn C_ParagraphBuilder_pop(self_: *mut skia_textlayout_ParagraphBuilder);
}
extern "C" {
    pub fn C_ParagraphBuilder_peekStyle(
        self_: *mut skia_textlayout_ParagraphBuilder,
        style: *mut skia_textlayout_TextStyle,
    );
}
extern "C" {
    pub fn C_ParagraphBuilder_addText(
        self_: *mut skia_textlayout_ParagraphBuilder,
        text: *const ::core::ffi::c_char,
        len: usize,
    );
}
extern "C" {
    pub fn C_ParagraphBuilder_addPlaceholder(
        self_: *mut skia_textlayout_ParagraphBuilder,
        placeholderStyle: *const skia_textlayout_PlaceholderStyle,
    );
}
extern "C" {
    pub fn C_ParagraphBuilder_Build(
        self_: *mut skia_textlayout_ParagraphBuilder,
    ) -> *mut skia_textlayout_Paragraph;
}
extern "C" {
    pub fn C_ParagraphBuilder_getText(
        self_: *mut skia_textlayout_ParagraphBuilder,
        text: *mut *mut ::core::ffi::c_char,
        len: *mut usize,
    );
}
extern "C" {
    pub fn C_ParagraphBuilder_getParagraphStyle(
        self_: *const skia_textlayout_ParagraphBuilder,
    ) -> *mut skia_textlayout_ParagraphStyle;
}
extern "C" {
    pub fn C_ParagraphBuilder_Reset(self_: *mut skia_textlayout_ParagraphBuilder);
}
extern "C" {
    pub fn C_ParagraphBuilder_make(
        style: *const skia_textlayout_ParagraphStyle,
        fontCollection: *const skia_textlayout_FontCollection,
    ) -> *mut skia_textlayout_ParagraphBuilder;
}
extern "C" {
    pub fn C_TextStyle_Types(
        arg1: *const skia_textlayout_Block,
        arg2: *const skia_textlayout_Placeholder,
    );
}
extern "C" {
    pub fn C_FontFeature_CopyConstruct(
        uninitialized: *mut skia_textlayout_FontFeature,
        other: *const skia_textlayout_FontFeature,
    );
}
extern "C" {
    pub fn C_FontFeature_destruct(self_: *mut skia_textlayout_FontFeature);
}
extern "C" {
    pub fn C_TextStyle_Construct(uninitialized: *mut skia_textlayout_TextStyle);
}
extern "C" {
    pub fn C_TextStyle_CopyConstruct(
        uninitialized: *mut skia_textlayout_TextStyle,
        other: *const skia_textlayout_TextStyle,
    );
}
extern "C" {
    pub fn C_TextStyle_cloneForPlaceholder(
        self_: *const skia_textlayout_TextStyle,
        uninitialized: *mut skia_textlayout_TextStyle,
    );
}
extern "C" {
    pub fn C_TextStyle_destruct(self_: *mut skia_textlayout_TextStyle);
}
extern "C" {
    pub fn C_TextStyle_getForeground(
        self_: *const skia_textlayout_TextStyle,
        uninitialized: *mut SkPaint,
    );
}
extern "C" {
    pub fn C_TextStyle_setForegroundPaint(
        self_: *mut skia_textlayout_TextStyle,
        paint: *const SkPaint,
    );
}
extern "C" {
    pub fn C_TextStyle_getBackground(
        self_: *const skia_textlayout_TextStyle,
        uninitialized: *mut SkPaint,
    );
}
extern "C" {
    pub fn C_TextStyle_setBackgroundPaint(
        self_: *mut skia_textlayout_TextStyle,
        paint: *const SkPaint,
    );
}
extern "C" {
    pub fn C_TextStyle_getShadows(
        self_: *const [u64; 3usize],
        len_ref: *mut usize,
    ) -> *const skia_textlayout_TextShadow;
}
extern "C" {
    pub fn C_TextStyle_addShadow(
        self_: *mut skia_textlayout_TextStyle,
        shadow: *const skia_textlayout_TextShadow,
    );
}
extern "C" {
    pub fn C_TextStyle_resetShadows(self_: *mut skia_textlayout_TextStyle);
}
extern "C" {
    pub fn C_TextStyle_getFontFeatures(
        self_: *const [u64; 3usize],
        len_ref: *mut usize,
    ) -> *const skia_textlayout_FontFeature;
}
extern "C" {
    pub fn C_TextStyle_addFontFeature(
        self_: *mut skia_textlayout_TextStyle,
        fontFeature: *const SkString,
        value: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn C_TextStyle_resetFontFeatures(self_: *mut skia_textlayout_TextStyle);
}
extern "C" {
    pub fn C_TextStyle_getFontArguments(
        self_: *const skia_textlayout_TextStyle,
    ) -> *const skia_textlayout_FontArguments;
}
extern "C" {
    pub fn C_TextStyle_setFontArguments(
        self_: *mut skia_textlayout_TextStyle,
        arguments: *const SkFontArguments,
    );
}
extern "C" {
    pub fn C_TextStyle_getFontFamilies(
        self_: *const skia_textlayout_TextStyle,
        count: *mut usize,
    ) -> *const SkString;
}
extern "C" {
    pub fn C_TextStyle_setFontFamilies(
        self_: *mut skia_textlayout_TextStyle,
        data: *const SkString,
        count: usize,
    );
}
extern "C" {
    pub fn C_TextStyle_setTypeface(
        self_: *mut skia_textlayout_TextStyle,
        typeface: *mut SkTypeface,
    );
}
extern "C" {
    pub fn C_TypefaceFontStyleSet_new(
        family_name: *const SkString,
    ) -> *mut skia_textlayout_TypefaceFontStyleSet;
}
extern "C" {
    pub fn C_TypefaceFontStyleSet_appendTypeface(
        self_: *mut skia_textlayout_TypefaceFontStyleSet,
        typeface: *mut SkTypeface,
    );
}
extern "C" {
    pub fn C_TypefaceFontProvider_new() -> *mut skia_textlayout_TypefaceFontProvider;
}
extern "C" {
    pub fn C_TypefaceFontProvider_registerTypeface(
        self_: *mut skia_textlayout_TypefaceFontProvider,
        typeface: *mut SkTypeface,
        alias: *const SkString,
    ) -> usize;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkWebpEncoder_Compression {
    Lossy = 0,
    Lossless = 1,
}
extern "C" {
    pub fn C_SkWebpEncoder_Encode(
        stream: *mut SkWStream,
        pixmap: *const SkPixmap,
        compression: SkWebpEncoder_Compression,
        quality: f32,
    ) -> bool;
}
extern "C" {
    pub fn C_SkWebpEncoder_EncodeImage(
        ctx: *mut GrDirectContext,
        img: *const SkImage,
        compression: SkWebpEncoder_Compression,
        quality: f32,
    ) -> *mut SkData;
}
pub type __builtin_va_list = *mut ::core::ffi::c_char;
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_milli_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_chrono_duration<::core::ffi::c_longlong>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_chrono_duration<::core::ffi::c_longlong>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_chrono_duration<::core::ffi::c_longlong>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_chrono_duration<::core::ffi::c_longlong>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_basic_string_view<::core::ffi::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<::core::ffi::c_char>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_basic_string_view<::core::ffi::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<::core::ffi::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkData_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkColorSpace_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation_1()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation_2()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMipmap_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMipmap>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMipmap>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMipmap>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMipmap>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSpecialImage_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSpecialImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSpecialImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSpecialImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSpecialImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSpecialImage_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSpecialImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSpecialImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSpecialImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSpecialImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_Layer_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_BackImage_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_sktext_GlyphRunBuilder_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorTable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorTable_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkContourMeasure_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkContourMeasureIter_Impl_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_float_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontStyleSet_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontStyleSet_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontStyleSet_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontStyleSet_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontStyleSet_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_29() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_30() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_29() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkIDChangeListener_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkIDChangeListener>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkIDChangeListener>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkIDChangeListener>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkIDChangeListener>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkIDChangeListener_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkIDChangeListener>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkIDChangeListener>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkIDChangeListener>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkIDChangeListener>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkIDChangeListener_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkIDChangeListener>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkIDChangeListener>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkIDChangeListener>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkIDChangeListener>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkContourMeasure_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBBoxHierarchy_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBBoxHierarchy_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkRecorder_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkRecord_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkRecord>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkRecord>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkRecord>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkRecord>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkIDChangeListener_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkIDChangeListener>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkIDChangeListener>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkIDChangeListener>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkIDChangeListener>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_29() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_30() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_31() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_32() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_33() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_30() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_31() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkTextBlob_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_34() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkVertices_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_float_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkPDFArray_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkPDF_StructureElementNode_close0_instantiation()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_unique_ptr_open1_SkPDF_StructureElementNode_std_default_delete_open2_SkPDF_StructureElementNode_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkPDF_StructureElementNode_close0_instantiation_1(
) {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_32() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_33() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_34() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_35() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_SkPathOp_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(SkTDArray))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkRuntimeEffect_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkRuntimeEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkRuntimeEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkRuntimeEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkRuntimeEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_35() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_29() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_36() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_30() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_37() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_38() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_39() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_40() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_31() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSL_DebugTrace_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSL_DebugTrace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSL_DebugTrace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSL_DebugTrace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSL_DebugTrace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_32() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_31() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_32() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkCustomTypefaceBuilder_GlyphRec_close0_instantiation()
{
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontStyleSet_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontStyleSet_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_33() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_34() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_41() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_35() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_36() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_37() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_38() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_39() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_sk_sp_open1_SkFontMgr_close1_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Sink_open0_bool__close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<Sink<bool>>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(Sink<bool>))
    );
    assert_eq!(
        ::core::mem::align_of::<Sink<bool>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Sink<bool>)
        )
    );
}
#[test]
fn __bindgen_test_layout_VecSink_open0_SkScalar_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<VecSink<SkScalar>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(VecSink<SkScalar>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<VecSink<SkScalar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(VecSink<SkScalar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_GrBackendFormatData_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_GrBackendTextureData_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_skgpu_MutableTextureStateRef_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<skgpu_MutableTextureStateRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<skgpu_MutableTextureStateRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<skgpu_MutableTextureStateRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<skgpu_MutableTextureStateRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_GrBackendRenderTargetData_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_skgpu_MutableTextureStateRef_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<skgpu_MutableTextureStateRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<skgpu_MutableTextureStateRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<skgpu_MutableTextureStateRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<skgpu_MutableTextureStateRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_42() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkArenaAlloc_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_sktext_gpu_SubRunAllocator_close0_instantiation()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrContextThreadSafeProxy>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrContextThreadSafeProxy>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrContextThreadSafeProxy>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrContextThreadSafeProxy>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_GrProgramDesc_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_GrProgramDesc_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrGLInterface_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrGLInterface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrGLInterface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrGLInterface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrGLInterface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrGLInterface_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrGLInterface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrGLInterface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrGLInterface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrGLInterface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrDirectContext>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrDirectContext>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<GrContextThreadSafeProxy>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<GrContextThreadSafeProxy>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<GrContextThreadSafeProxy>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<GrContextThreadSafeProxy>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkUnicode_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_FontRunIterator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_FontRunIterator_close0_instantiation_1()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_BiDiRunIterator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_BiDiRunIterator_close0_instantiation_1()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_BiDiRunIterator_close0_instantiation_2()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_ScriptRunIterator_close0_instantiation()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_ScriptRunIterator_close0_instantiation_1(
) {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_ScriptRunIterator_close0_instantiation_2(
) {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_ScriptRunIterator_close0_instantiation_3(
) {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkShaper_LanguageRunIterator_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkBidiIterator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkBidiIterator_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkBreakIterator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkBreakIterator_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkUnicode_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkUnicode_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkUnicode_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkSpan_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkSpan<::core::ffi::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkSpan<::core::ffi::c_char>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkSpan<::core::ffi::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkSpan<::core::ffi::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkUnicode_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkUnicode_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_40() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_41() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkFontArguments_VariationPosition_Coordinate_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkFontArguments_Palette_Override_close0_instantiation()
{
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_TextShadow_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_42() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_FontFeature_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_skia_textlayout_SkRange_open0_size_t_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_SkRange<usize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(skia_textlayout_SkRange<usize>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_SkRange<usize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(skia_textlayout_SkRange<usize>)
        )
    );
}
#[test]
fn __bindgen_test_layout_skia_textlayout_SkRange_open0_size_t_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_SkRange<usize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(skia_textlayout_SkRange<usize>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_SkRange<usize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(skia_textlayout_SkRange<usize>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_43() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_sk_sp_open1_SkTypeface_close1_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_44() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_45() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_sk_sp_open1_SkTypeface_close1_close0_instantiation_1()
{
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_46() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_47() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_48() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_less_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_less>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_less))
    );
    assert_eq!(
        ::core::mem::align_of::<std_less>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_less)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_pair_open1_const_unsigned_long_skia_textlayout_StyleMetrics_close1_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_const_unsigned_long_skia_textlayout_StyleMetrics_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_pair<::core::ffi::c_ulong, skia_textlayout_StyleMetrics>>(),
        80usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (std_pair < :: core :: ffi :: c_ulong , skia_textlayout_StyleMetrics >)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_pair<::core::ffi::c_ulong, skia_textlayout_StyleMetrics>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (std_pair < :: core :: ffi :: c_ulong , skia_textlayout_StyleMetrics >)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_skia_textlayout_FontCollection_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<skia_textlayout_FontCollection>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<skia_textlayout_FontCollection>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<skia_textlayout_FontCollection>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<skia_textlayout_FontCollection>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_TextBox_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_TextBox_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_skia_textlayout_SkRange_open0_size_t_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<skia_textlayout_SkRange<usize>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(skia_textlayout_SkRange<usize>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<skia_textlayout_SkRange<usize>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(skia_textlayout_SkRange<usize>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_LineMetrics_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_hash_open0_int_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_hash>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std_hash))
    );
    assert_eq!(
        ::core::mem::align_of::<std_hash>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_hash)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_equal_to_open0_int_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_equal_to>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_equal_to)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_equal_to>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_equal_to)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_Paragraph_FontInfo_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_skia_textlayout_FontCollection_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<skia_textlayout_FontCollection>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<skia_textlayout_FontCollection>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<skia_textlayout_FontCollection>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<skia_textlayout_FontCollection>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_skia_textlayout_Paragraph_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkSpan_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<SkSpan<::core::ffi::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkSpan<::core::ffi::c_char>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkSpan<::core::ffi::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkSpan<::core::ffi::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkUnicode_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_skia_textlayout_FontCollection_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<skia_textlayout_FontCollection>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<skia_textlayout_FontCollection>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<skia_textlayout_FontCollection>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<skia_textlayout_FontCollection>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_skia_textlayout_ParagraphBuilder_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_49() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_50() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_51() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_52() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_53() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_54() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontStyleSet_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontStyleSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontStyleSet>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_skia_textlayout_TypefaceFontStyleSet_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<skia_textlayout_TypefaceFontStyleSet>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<skia_textlayout_TypefaceFontStyleSet>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<skia_textlayout_TypefaceFontStyleSet>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<skia_textlayout_TypefaceFontStyleSet>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_VecSink_open0_sk_sp_open1_SkTypeface_close1_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<VecSink<sk_sp<SkTypeface>>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(VecSink<sk_sp<SkTypeface>>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<VecSink<sk_sp<SkTypeface>>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(VecSink<sk_sp<SkTypeface>>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_55() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_VecSink_open0_skia_textlayout_TextBox_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<VecSink<skia_textlayout_TextBox>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(VecSink<skia_textlayout_TextBox>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<VecSink<skia_textlayout_TextBox>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(VecSink<skia_textlayout_TextBox>)
        )
    );
}
#[test]
fn __bindgen_test_layout_VecSink_open0_skia_textlayout_TextBox_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<VecSink<skia_textlayout_TextBox>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(VecSink<skia_textlayout_TextBox>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<VecSink<skia_textlayout_TextBox>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(VecSink<skia_textlayout_TextBox>)
        )
    );
}
#[test]
fn __bindgen_test_layout_VecSink_open0_skia_textlayout_LineMetrics_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<VecSink<skia_textlayout_LineMetrics>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(VecSink<skia_textlayout_LineMetrics>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<VecSink<skia_textlayout_LineMetrics>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(VecSink<skia_textlayout_LineMetrics>)
        )
    );
}
#[test]
fn __bindgen_test_layout_VecSink_open0_SkUnichar_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<VecSink<SkUnichar>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(VecSink<SkUnichar>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<VecSink<SkUnichar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(VecSink<SkUnichar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Sink_open0_skia_textlayout_LineMetrics_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<Sink<skia_textlayout_LineMetrics>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Sink<skia_textlayout_LineMetrics>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<Sink<skia_textlayout_LineMetrics>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Sink<skia_textlayout_LineMetrics>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Sink_open0_skia_textlayout_Paragraph_GlyphClusterInfo_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<Sink<skia_textlayout_Paragraph_GlyphClusterInfo>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Sink<skia_textlayout_Paragraph_GlyphClusterInfo>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<Sink<skia_textlayout_Paragraph_GlyphClusterInfo>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Sink<skia_textlayout_Paragraph_GlyphClusterInfo>)
        )
    );
}
#[test]
fn __bindgen_test_layout_Sink_open0_skia_textlayout_Paragraph_GlyphClusterInfo_close0_instantiation_1(
) {
    assert_eq!(
        ::core::mem::size_of::<Sink<skia_textlayout_Paragraph_GlyphClusterInfo>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(Sink<skia_textlayout_Paragraph_GlyphClusterInfo>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<Sink<skia_textlayout_Paragraph_GlyphClusterInfo>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(Sink<skia_textlayout_Paragraph_GlyphClusterInfo>)
        )
    );
}
#[test]
fn __bindgen_test_layout_VecSink_open0_skia_textlayout_Paragraph_FontInfo_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<VecSink<skia_textlayout_Paragraph_FontInfo>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(VecSink<skia_textlayout_Paragraph_FontInfo>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<VecSink<skia_textlayout_Paragraph_FontInfo>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(VecSink<skia_textlayout_Paragraph_FontInfo>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_TextShadow_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_FontFeature_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
