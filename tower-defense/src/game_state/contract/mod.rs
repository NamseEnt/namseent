use crate::game_state::GameState;
use crate::game_state::effect::{Effect, run_effect};
use crate::rarity::Rarity;
use rand::{Rng, thread_rng};
use std::fmt::Display;
use std::sync::atomic::AtomicUsize;

#[allow(dead_code)]
pub fn generate_contract(rarity: Rarity) -> Contract {
    let mut rng = thread_rng();
    let duration_stages = rng.gen_range(1..=5);
    let risk = ContractEffect::OnSign {
        effect: Effect::Dummy,
    };
    let reward = ContractEffect::OnSign {
        effect: Effect::Dummy,
    };
    Contract::new(rarity, duration_stages, risk, reward)
}

#[derive(Clone, Debug)]
pub enum ContractEffect {
    OnSign { effect: Effect },
    WhileActive { effect: Effect },
    OnStageStart { effect: Effect },
    OnExpire { effect: Effect },
}

#[derive(Clone, Debug, PartialEq, Copy)]
pub enum ContractStatus {
    Pending { duration_stages: usize },
    Active { remaining_stages: usize },
    Expired,
}
impl Display for ContractStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let n = match self {
            ContractStatus::Pending { duration_stages: n }
            | ContractStatus::Active {
                remaining_stages: n,
            } => *n,
            ContractStatus::Expired => 0,
        };
        write!(f, "S-{n}")
    }
}

pub type ContractId = usize;

#[derive(Clone, Debug)]
pub struct Contract {
    pub id: usize,
    pub rarity: Rarity,
    pub status: ContractStatus,
    pub risk: ContractEffect,
    pub reward: ContractEffect,
    /// Events generated by this contract that are pending to be processed
    pending_events: Vec<ContractEvent>,
}
impl Contract {
    pub fn new(
        rarity: Rarity,
        duration_stages: usize,
        risk: ContractEffect,
        reward: ContractEffect,
    ) -> Self {
        static ID: AtomicUsize = AtomicUsize::new(1);
        Contract {
            id: ID.fetch_add(1, std::sync::atomic::Ordering::Relaxed),
            rarity,
            status: ContractStatus::Pending { duration_stages },
            risk,
            reward,
            pending_events: Vec::new(),
        }
    }

    pub fn on_sign_effects(&self) -> Vec<&Effect> {
        [&self.reward, &self.risk]
            .iter()
            .filter_map(|contract_effect| {
                if let ContractEffect::OnSign { effect } = contract_effect {
                    Some(effect)
                } else {
                    None
                }
            })
            .collect()
    }

    pub fn while_active_effects(&self) -> Vec<&Effect> {
        [&self.reward, &self.risk]
            .iter()
            .filter_map(|contract_effect| {
                if let ContractEffect::WhileActive { effect } = contract_effect {
                    Some(effect)
                } else {
                    None
                }
            })
            .collect()
    }

    pub fn on_stage_start_effects(&self) -> Vec<&Effect> {
        [&self.reward, &self.risk]
            .iter()
            .filter_map(|contract_effect| {
                if let ContractEffect::OnStageStart { effect } = contract_effect {
                    Some(effect)
                } else {
                    None
                }
            })
            .collect()
    }

    pub fn on_expire_effects(&self) -> Vec<&Effect> {
        [&self.reward, &self.risk]
            .iter()
            .filter_map(|contract_effect| {
                if let ContractEffect::OnExpire { effect } = contract_effect {
                    Some(effect)
                } else {
                    None
                }
            })
            .collect()
    }

    /// Advances the contract to the next stage and stores events internally.
    /// This follows Command pattern - only modifies state, doesn't return events.
    /// Use `drain_events()` to retrieve generated events after stepping.
    pub fn step_stage(&mut self) {
        let previous_status = self.status;

        match &mut self.status {
            ContractStatus::Pending { duration_stages } => {
                self.status = ContractStatus::Active {
                    remaining_stages: *duration_stages,
                };
            }
            ContractStatus::Active { remaining_stages } => {
                if *remaining_stages > 0 {
                    *remaining_stages -= 1;
                }
                if *remaining_stages == 0 {
                    self.status = ContractStatus::Expired;
                }
            }
            ContractStatus::Expired => {
                eprintln!(
                    "Warning: Attempting to step expired contract (id: {})",
                    self.id
                );
                return; // No events generated for expired contracts
            }
        }

        // Generate and store events based on transition
        let events = self.generate_transition_events(previous_status, self.status);
        self.pending_events.extend(events);
    }

    /// Drains all pending events from this contract.
    /// This follows Query pattern - only returns data, doesn't modify state.
    pub fn drain_events(&mut self) -> Vec<ContractEvent> {
        std::mem::take(&mut self.pending_events)
    }

    /// Generates events based on status transition.
    fn generate_transition_events(
        &self,
        from_status: ContractStatus,
        to_status: ContractStatus,
    ) -> Vec<ContractEvent> {
        match (from_status, to_status) {
            // Pending -> Active: Generate stage start events
            (ContractStatus::Pending { .. }, ContractStatus::Active { .. }) => {
                self.create_events_from_effects(&self.on_stage_start_effects(), false)
            }
            // Active -> Expired: Generate expire events
            (ContractStatus::Active { .. }, ContractStatus::Expired) => {
                self.create_events_from_effects(&self.on_expire_effects(), true)
            }
            // Active -> Active: Generate ongoing stage events if any
            (ContractStatus::Active { .. }, ContractStatus::Active { .. }) => {
                self.create_events_from_effects(&self.on_stage_start_effects(), false)
            }
            // No events for other transitions
            _ => vec![],
        }
    }

    /// Creates ContractEvents from a list of effects with consistent structure.
    fn create_events_from_effects(
        &self,
        effects: &[&Effect],
        should_remove: bool,
    ) -> Vec<ContractEvent> {
        effects
            .iter()
            .map(|effect| ContractEvent {
                contract_id: self.id,
                effect: (*effect).clone(),
                should_remove,
            })
            .collect()
    }

    pub fn is_expired(&self) -> bool {
        matches!(self.status, ContractStatus::Expired)
    }
}

#[derive(Clone, Copy, Debug, Default)]
pub struct ContractState {
    // TODO: like upgrade state
}

#[allow(dead_code)]
pub fn sign_contract(game_state: &mut GameState, contract: Contract) {
    contract.on_sign_effects().iter().for_each(|effect| {
        run_effect(game_state, effect);
    });

    game_state.contracts.push(contract);
}

#[derive(Clone, Debug)]
pub struct ContractEvent {
    pub contract_id: ContractId,
    pub effect: Effect,
    pub should_remove: bool,
}
